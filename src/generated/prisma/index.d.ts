
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserSubscription
 * 
 */
export type UserSubscription = $Result.DefaultSelection<Prisma.$UserSubscriptionPayload>
/**
 * Model SubscriptionFeatures
 * 
 */
export type SubscriptionFeatures = $Result.DefaultSelection<Prisma.$SubscriptionFeaturesPayload>
/**
 * Model SubscriptionUsage
 * 
 */
export type SubscriptionUsage = $Result.DefaultSelection<Prisma.$SubscriptionUsagePayload>
/**
 * Model Card
 * 
 */
export type Card = $Result.DefaultSelection<Prisma.$CardPayload>
/**
 * Model MarketplaceListing
 * 
 */
export type MarketplaceListing = $Result.DefaultSelection<Prisma.$MarketplaceListingPayload>
/**
 * Model Bid
 * 
 */
export type Bid = $Result.DefaultSelection<Prisma.$BidPayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model CryptoWallet
 * 
 */
export type CryptoWallet = $Result.DefaultSelection<Prisma.$CryptoWalletPayload>
/**
 * Model PhysicalCard
 * 
 */
export type PhysicalCard = $Result.DefaultSelection<Prisma.$PhysicalCardPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model SocialFeed
 * 
 */
export type SocialFeed = $Result.DefaultSelection<Prisma.$SocialFeedPayload>
/**
 * Model Follow
 * 
 */
export type Follow = $Result.DefaultSelection<Prisma.$FollowPayload>
/**
 * Model AppOrder
 * 
 */
export type AppOrder = $Result.DefaultSelection<Prisma.$AppOrderPayload>
/**
 * Model OrderRevision
 * 
 */
export type OrderRevision = $Result.DefaultSelection<Prisma.$OrderRevisionPayload>
/**
 * Model OrderCommunication
 * 
 */
export type OrderCommunication = $Result.DefaultSelection<Prisma.$OrderCommunicationPayload>
/**
 * Model OrderDeliverable
 * 
 */
export type OrderDeliverable = $Result.DefaultSelection<Prisma.$OrderDeliverablePayload>
/**
 * Model BettingMarket
 * 
 */
export type BettingMarket = $Result.DefaultSelection<Prisma.$BettingMarketPayload>
/**
 * Model BettingPosition
 * 
 */
export type BettingPosition = $Result.DefaultSelection<Prisma.$BettingPositionPayload>
/**
 * Model MarketMetrics
 * 
 */
export type MarketMetrics = $Result.DefaultSelection<Prisma.$MarketMetricsPayload>
/**
 * Model BettingPayout
 * 
 */
export type BettingPayout = $Result.DefaultSelection<Prisma.$BettingPayoutPayload>
/**
 * Model CardAuction
 * 
 */
export type CardAuction = $Result.DefaultSelection<Prisma.$CardAuctionPayload>
/**
 * Model AuctionConditions
 * 
 */
export type AuctionConditions = $Result.DefaultSelection<Prisma.$AuctionConditionsPayload>
/**
 * Model AuctionBid
 * 
 */
export type AuctionBid = $Result.DefaultSelection<Prisma.$AuctionBidPayload>
/**
 * Model AuctionWatcher
 * 
 */
export type AuctionWatcher = $Result.DefaultSelection<Prisma.$AuctionWatcherPayload>
/**
 * Model AuctionHistory
 * 
 */
export type AuctionHistory = $Result.DefaultSelection<Prisma.$AuctionHistoryPayload>
/**
 * Model MABattle
 * 
 */
export type MABattle = $Result.DefaultSelection<Prisma.$MABattlePayload>
/**
 * Model BattleProposal
 * 
 */
export type BattleProposal = $Result.DefaultSelection<Prisma.$BattleProposalPayload>
/**
 * Model BattleVoting
 * 
 */
export type BattleVoting = $Result.DefaultSelection<Prisma.$BattleVotingPayload>
/**
 * Model BattleOutcome
 * 
 */
export type BattleOutcome = $Result.DefaultSelection<Prisma.$BattleOutcomePayload>
/**
 * Model StakingPool
 * 
 */
export type StakingPool = $Result.DefaultSelection<Prisma.$StakingPoolPayload>
/**
 * Model StakingPosition
 * 
 */
export type StakingPosition = $Result.DefaultSelection<Prisma.$StakingPositionPayload>
/**
 * Model StakingReward
 * 
 */
export type StakingReward = $Result.DefaultSelection<Prisma.$StakingRewardPayload>
/**
 * Model GovernanceProposal
 * 
 */
export type GovernanceProposal = $Result.DefaultSelection<Prisma.$GovernanceProposalPayload>
/**
 * Model GovernanceVote
 * 
 */
export type GovernanceVote = $Result.DefaultSelection<Prisma.$GovernanceVotePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const MarketMetricType: {
  REVENUE_GROWTH: 'REVENUE_GROWTH',
  USER_GROWTH: 'USER_GROWTH',
  VALUATION_CHANGE: 'VALUATION_CHANGE',
  MARKET_CAP: 'MARKET_CAP',
  QUARTERLY_PERFORMANCE: 'QUARTERLY_PERFORMANCE',
  PRODUCT_LAUNCH_SUCCESS: 'PRODUCT_LAUNCH_SUCCESS',
  COMPETITIVE_POSITION: 'COMPETITIVE_POSITION',
  SOCIAL_SENTIMENT: 'SOCIAL_SENTIMENT',
  TECHNOLOGY_ADOPTION: 'TECHNOLOGY_ADOPTION',
  REGULATORY_IMPACT: 'REGULATORY_IMPACT'
};

export type MarketMetricType = (typeof MarketMetricType)[keyof typeof MarketMetricType]


export const PredictionDirection: {
  UP: 'UP',
  DOWN: 'DOWN'
};

export type PredictionDirection = (typeof PredictionDirection)[keyof typeof PredictionDirection]


export const MarketStatus: {
  ACTIVE: 'ACTIVE',
  SUSPENDED: 'SUSPENDED',
  SETTLED: 'SETTLED',
  CANCELLED: 'CANCELLED'
};

export type MarketStatus = (typeof MarketStatus)[keyof typeof MarketStatus]


export const PositionStatus: {
  ACTIVE: 'ACTIVE',
  SETTLED: 'SETTLED',
  CANCELLED: 'CANCELLED',
  EXPIRED: 'EXPIRED'
};

export type PositionStatus = (typeof PositionStatus)[keyof typeof PositionStatus]


export const PayoutStatus: {
  PENDING: 'PENDING',
  PROCESSING: 'PROCESSING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED'
};

export type PayoutStatus = (typeof PayoutStatus)[keyof typeof PayoutStatus]


export const AuctionStatus: {
  PENDING: 'PENDING',
  ACTIVE: 'ACTIVE',
  ENDING_SOON: 'ENDING_SOON',
  ENDED: 'ENDED',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type AuctionStatus = (typeof AuctionStatus)[keyof typeof AuctionStatus]


export const BidType: {
  MANUAL: 'MANUAL',
  AUTO_BID: 'AUTO_BID',
  PROXY_BID: 'PROXY_BID'
};

export type BidType = (typeof BidType)[keyof typeof BidType]


export const AuctionBidStatus: {
  ACTIVE: 'ACTIVE',
  OUTBID: 'OUTBID',
  WINNING: 'WINNING',
  WON: 'WON',
  LOST: 'LOST',
  CANCELLED: 'CANCELLED'
};

export type AuctionBidStatus = (typeof AuctionBidStatus)[keyof typeof AuctionBidStatus]


export const SaleType: {
  AUCTION: 'AUCTION',
  FIXED_PRICE: 'FIXED_PRICE',
  PRIVATE_SALE: 'PRIVATE_SALE',
  TRADE: 'TRADE'
};

export type SaleType = (typeof SaleType)[keyof typeof SaleType]


export const BattleType: {
  MERGER: 'MERGER',
  ACQUISITION: 'ACQUISITION',
  STRATEGIC_ALLIANCE: 'STRATEGIC_ALLIANCE',
  COMPETITIVE_CHALLENGE: 'COMPETITIVE_CHALLENGE',
  MARKET_DOMINATION: 'MARKET_DOMINATION'
};

export type BattleType = (typeof BattleType)[keyof typeof BattleType]


export const BattleStatus: {
  PENDING: 'PENDING',
  ACTIVE: 'ACTIVE',
  VOTING: 'VOTING',
  RESOLVING: 'RESOLVING',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type BattleStatus = (typeof BattleStatus)[keyof typeof BattleStatus]


export const ProposalType: {
  MERGER_PROPOSAL: 'MERGER_PROPOSAL',
  ACQUISITION_OFFER: 'ACQUISITION_OFFER',
  ALLIANCE_TERMS: 'ALLIANCE_TERMS',
  CHALLENGE_TERMS: 'CHALLENGE_TERMS'
};

export type ProposalType = (typeof ProposalType)[keyof typeof ProposalType]


export const ProposalStatus: {
  PENDING: 'PENDING',
  UNDER_REVIEW: 'UNDER_REVIEW',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  WITHDRAWN: 'WITHDRAWN'
};

export type ProposalStatus = (typeof ProposalStatus)[keyof typeof ProposalStatus]


export const VoteDirection: {
  APPROVE: 'APPROVE',
  REJECT: 'REJECT',
  ABSTAIN: 'ABSTAIN'
};

export type VoteDirection = (typeof VoteDirection)[keyof typeof VoteDirection]


export const BattleWinner: {
  INITIATOR: 'INITIATOR',
  TARGET: 'TARGET',
  MUTUAL_BENEFIT: 'MUTUAL_BENEFIT',
  NO_WINNER: 'NO_WINNER'
};

export type BattleWinner = (typeof BattleWinner)[keyof typeof BattleWinner]


export const ProjectType: {
  SAAS_DASHBOARD: 'SAAS_DASHBOARD',
  PORTFOLIO_SITE: 'PORTFOLIO_SITE',
  ECOMMERCE_STORE: 'ECOMMERCE_STORE',
  LANDING_PAGE: 'LANDING_PAGE',
  MOBILE_APP: 'MOBILE_APP',
  WEB_APP: 'WEB_APP',
  CUSTOM: 'CUSTOM'
};

export type ProjectType = (typeof ProjectType)[keyof typeof ProjectType]


export const OrderTimeline: {
  RUSH_2_WEEKS: 'RUSH_2_WEEKS',
  STANDARD_1_MONTH: 'STANDARD_1_MONTH'
};

export type OrderTimeline = (typeof OrderTimeline)[keyof typeof OrderTimeline]


export const OrderStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  IN_PROGRESS: 'IN_PROGRESS',
  REVIEW: 'REVIEW',
  REVISION_REQUESTED: 'REVISION_REQUESTED',
  COMPLETED: 'COMPLETED',
  DELIVERED: 'DELIVERED',
  CANCELLED: 'CANCELLED'
};

export type OrderStatus = (typeof OrderStatus)[keyof typeof OrderStatus]


export const OrderPriority: {
  STANDARD: 'STANDARD',
  HIGH: 'HIGH',
  URGENT: 'URGENT'
};

export type OrderPriority = (typeof OrderPriority)[keyof typeof OrderPriority]


export const RevisionStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  COMPLETED: 'COMPLETED'
};

export type RevisionStatus = (typeof RevisionStatus)[keyof typeof RevisionStatus]


export const CommunicationType: {
  MESSAGE: 'MESSAGE',
  PROGRESS_UPDATE: 'PROGRESS_UPDATE',
  REVISION_REQUEST: 'REVISION_REQUEST',
  DELIVERY_NOTIFICATION: 'DELIVERY_NOTIFICATION',
  SYSTEM_ALERT: 'SYSTEM_ALERT'
};

export type CommunicationType = (typeof CommunicationType)[keyof typeof CommunicationType]


export const DeliverableType: {
  GITHUB_REPO: 'GITHUB_REPO',
  VERCEL_DEPLOYMENT: 'VERCEL_DEPLOYMENT',
  ZIP_DOWNLOAD: 'ZIP_DOWNLOAD',
  DOCUMENTATION: 'DOCUMENTATION',
  ASSETS: 'ASSETS',
  APP_CARD: 'APP_CARD'
};

export type DeliverableType = (typeof DeliverableType)[keyof typeof DeliverableType]


export const DeliverableStatus: {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  DELIVERED: 'DELIVERED'
};

export type DeliverableStatus = (typeof DeliverableStatus)[keyof typeof DeliverableStatus]


export const SubscriptionPlan: {
  FREE: 'FREE',
  PRO: 'PRO',
  ENTERPRISE: 'ENTERPRISE'
};

export type SubscriptionPlan = (typeof SubscriptionPlan)[keyof typeof SubscriptionPlan]


export const SubscriptionStatus: {
  ACTIVE: 'ACTIVE',
  CANCELED: 'CANCELED',
  PAST_DUE: 'PAST_DUE',
  UNPAID: 'UNPAID'
};

export type SubscriptionStatus = (typeof SubscriptionStatus)[keyof typeof SubscriptionStatus]


export const CardCategory: {
  AUTOMOTIVE: 'AUTOMOTIVE',
  TECHNOLOGY: 'TECHNOLOGY',
  REAL_ESTATE: 'REAL_ESTATE',
  LUXURY: 'LUXURY',
  COLLECTIBLES: 'COLLECTIBLES',
  GAMING: 'GAMING',
  SPORTS: 'SPORTS',
  ENTERTAINMENT: 'ENTERTAINMENT'
};

export type CardCategory = (typeof CardCategory)[keyof typeof CardCategory]


export const CardRarity: {
  COMMON: 'COMMON',
  RARE: 'RARE',
  EPIC: 'EPIC',
  LEGENDARY: 'LEGENDARY',
  MYTHIC: 'MYTHIC'
};

export type CardRarity = (typeof CardRarity)[keyof typeof CardRarity]


export const ListingType: {
  FIXED_PRICE: 'FIXED_PRICE',
  AUCTION: 'AUCTION',
  DUTCH_AUCTION: 'DUTCH_AUCTION'
};

export type ListingType = (typeof ListingType)[keyof typeof ListingType]


export const ListingStatus: {
  ACTIVE: 'ACTIVE',
  SOLD: 'SOLD',
  EXPIRED: 'EXPIRED',
  CANCELED: 'CANCELED'
};

export type ListingStatus = (typeof ListingStatus)[keyof typeof ListingStatus]


export const BidStatus: {
  PENDING: 'PENDING',
  ACCEPTED: 'ACCEPTED',
  REJECTED: 'REJECTED',
  EXPIRED: 'EXPIRED'
};

export type BidStatus = (typeof BidStatus)[keyof typeof BidStatus]


export const TransactionType: {
  DEPOSIT: 'DEPOSIT',
  WITHDRAWAL: 'WITHDRAWAL',
  PURCHASE: 'PURCHASE',
  SALE: 'SALE',
  TRADE: 'TRADE',
  REWARD: 'REWARD',
  REFUND: 'REFUND'
};

export type TransactionType = (typeof TransactionType)[keyof typeof TransactionType]


export const TransactionStatus: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  CANCELED: 'CANCELED',
  REFUNDED: 'REFUNDED'
};

export type TransactionStatus = (typeof TransactionStatus)[keyof typeof TransactionStatus]


export const PhysicalCardStatus: {
  ACTIVE: 'ACTIVE',
  BLOCKED: 'BLOCKED',
  EXPIRED: 'EXPIRED',
  REQUESTED: 'REQUESTED'
};

export type PhysicalCardStatus = (typeof PhysicalCardStatus)[keyof typeof PhysicalCardStatus]


export const NotificationType: {
  MARKET: 'MARKET',
  SOCIAL: 'SOCIAL',
  TRADING: 'TRADING',
  IPO: 'IPO',
  PRICE_ALERT: 'PRICE_ALERT',
  SYSTEM: 'SYSTEM'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const NotificationPriority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  URGENT: 'URGENT'
};

export type NotificationPriority = (typeof NotificationPriority)[keyof typeof NotificationPriority]


export const SocialFeedType: {
  TRADE: 'TRADE',
  PURCHASE: 'PURCHASE',
  ACHIEVEMENT: 'ACHIEVEMENT',
  POST: 'POST',
  SHARE: 'SHARE'
};

export type SocialFeedType = (typeof SocialFeedType)[keyof typeof SocialFeedType]


export const SocialVisibility: {
  PUBLIC: 'PUBLIC',
  FRIENDS: 'FRIENDS',
  PRIVATE: 'PRIVATE'
};

export type SocialVisibility = (typeof SocialVisibility)[keyof typeof SocialVisibility]


export const StakingPoolType: {
  MARKETPLACE_REWARDS: 'MARKETPLACE_REWARDS',
  GOVERNANCE_PARTICIPATION: 'GOVERNANCE_PARTICIPATION',
  LIQUIDITY_PROVISION: 'LIQUIDITY_PROVISION',
  TRADING_BONUSES: 'TRADING_BONUSES'
};

export type StakingPoolType = (typeof StakingPoolType)[keyof typeof StakingPoolType]


export const StakingRewardType: {
  TRADING_FEES: 'TRADING_FEES',
  MARKETPLACE_PROFITS: 'MARKETPLACE_PROFITS',
  GOVERNANCE_REWARDS: 'GOVERNANCE_REWARDS',
  LIQUIDITY_REWARDS: 'LIQUIDITY_REWARDS'
};

export type StakingRewardType = (typeof StakingRewardType)[keyof typeof StakingRewardType]


export const GovernanceStatus: {
  DRAFT: 'DRAFT',
  ACTIVE: 'ACTIVE',
  PASSED: 'PASSED',
  REJECTED: 'REJECTED',
  EXECUTED: 'EXECUTED',
  EXPIRED: 'EXPIRED'
};

export type GovernanceStatus = (typeof GovernanceStatus)[keyof typeof GovernanceStatus]


export const VoteChoice: {
  YES: 'YES',
  NO: 'NO',
  ABSTAIN: 'ABSTAIN'
};

export type VoteChoice = (typeof VoteChoice)[keyof typeof VoteChoice]

}

export type MarketMetricType = $Enums.MarketMetricType

export const MarketMetricType: typeof $Enums.MarketMetricType

export type PredictionDirection = $Enums.PredictionDirection

export const PredictionDirection: typeof $Enums.PredictionDirection

export type MarketStatus = $Enums.MarketStatus

export const MarketStatus: typeof $Enums.MarketStatus

export type PositionStatus = $Enums.PositionStatus

export const PositionStatus: typeof $Enums.PositionStatus

export type PayoutStatus = $Enums.PayoutStatus

export const PayoutStatus: typeof $Enums.PayoutStatus

export type AuctionStatus = $Enums.AuctionStatus

export const AuctionStatus: typeof $Enums.AuctionStatus

export type BidType = $Enums.BidType

export const BidType: typeof $Enums.BidType

export type AuctionBidStatus = $Enums.AuctionBidStatus

export const AuctionBidStatus: typeof $Enums.AuctionBidStatus

export type SaleType = $Enums.SaleType

export const SaleType: typeof $Enums.SaleType

export type BattleType = $Enums.BattleType

export const BattleType: typeof $Enums.BattleType

export type BattleStatus = $Enums.BattleStatus

export const BattleStatus: typeof $Enums.BattleStatus

export type ProposalType = $Enums.ProposalType

export const ProposalType: typeof $Enums.ProposalType

export type ProposalStatus = $Enums.ProposalStatus

export const ProposalStatus: typeof $Enums.ProposalStatus

export type VoteDirection = $Enums.VoteDirection

export const VoteDirection: typeof $Enums.VoteDirection

export type BattleWinner = $Enums.BattleWinner

export const BattleWinner: typeof $Enums.BattleWinner

export type ProjectType = $Enums.ProjectType

export const ProjectType: typeof $Enums.ProjectType

export type OrderTimeline = $Enums.OrderTimeline

export const OrderTimeline: typeof $Enums.OrderTimeline

export type OrderStatus = $Enums.OrderStatus

export const OrderStatus: typeof $Enums.OrderStatus

export type OrderPriority = $Enums.OrderPriority

export const OrderPriority: typeof $Enums.OrderPriority

export type RevisionStatus = $Enums.RevisionStatus

export const RevisionStatus: typeof $Enums.RevisionStatus

export type CommunicationType = $Enums.CommunicationType

export const CommunicationType: typeof $Enums.CommunicationType

export type DeliverableType = $Enums.DeliverableType

export const DeliverableType: typeof $Enums.DeliverableType

export type DeliverableStatus = $Enums.DeliverableStatus

export const DeliverableStatus: typeof $Enums.DeliverableStatus

export type SubscriptionPlan = $Enums.SubscriptionPlan

export const SubscriptionPlan: typeof $Enums.SubscriptionPlan

export type SubscriptionStatus = $Enums.SubscriptionStatus

export const SubscriptionStatus: typeof $Enums.SubscriptionStatus

export type CardCategory = $Enums.CardCategory

export const CardCategory: typeof $Enums.CardCategory

export type CardRarity = $Enums.CardRarity

export const CardRarity: typeof $Enums.CardRarity

export type ListingType = $Enums.ListingType

export const ListingType: typeof $Enums.ListingType

export type ListingStatus = $Enums.ListingStatus

export const ListingStatus: typeof $Enums.ListingStatus

export type BidStatus = $Enums.BidStatus

export const BidStatus: typeof $Enums.BidStatus

export type TransactionType = $Enums.TransactionType

export const TransactionType: typeof $Enums.TransactionType

export type TransactionStatus = $Enums.TransactionStatus

export const TransactionStatus: typeof $Enums.TransactionStatus

export type PhysicalCardStatus = $Enums.PhysicalCardStatus

export const PhysicalCardStatus: typeof $Enums.PhysicalCardStatus

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type NotificationPriority = $Enums.NotificationPriority

export const NotificationPriority: typeof $Enums.NotificationPriority

export type SocialFeedType = $Enums.SocialFeedType

export const SocialFeedType: typeof $Enums.SocialFeedType

export type SocialVisibility = $Enums.SocialVisibility

export const SocialVisibility: typeof $Enums.SocialVisibility

export type StakingPoolType = $Enums.StakingPoolType

export const StakingPoolType: typeof $Enums.StakingPoolType

export type StakingRewardType = $Enums.StakingRewardType

export const StakingRewardType: typeof $Enums.StakingRewardType

export type GovernanceStatus = $Enums.GovernanceStatus

export const GovernanceStatus: typeof $Enums.GovernanceStatus

export type VoteChoice = $Enums.VoteChoice

export const VoteChoice: typeof $Enums.VoteChoice

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userSubscription`: Exposes CRUD operations for the **UserSubscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSubscriptions
    * const userSubscriptions = await prisma.userSubscription.findMany()
    * ```
    */
  get userSubscription(): Prisma.UserSubscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscriptionFeatures`: Exposes CRUD operations for the **SubscriptionFeatures** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubscriptionFeatures
    * const subscriptionFeatures = await prisma.subscriptionFeatures.findMany()
    * ```
    */
  get subscriptionFeatures(): Prisma.SubscriptionFeaturesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscriptionUsage`: Exposes CRUD operations for the **SubscriptionUsage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubscriptionUsages
    * const subscriptionUsages = await prisma.subscriptionUsage.findMany()
    * ```
    */
  get subscriptionUsage(): Prisma.SubscriptionUsageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.card`: Exposes CRUD operations for the **Card** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cards
    * const cards = await prisma.card.findMany()
    * ```
    */
  get card(): Prisma.CardDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.marketplaceListing`: Exposes CRUD operations for the **MarketplaceListing** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MarketplaceListings
    * const marketplaceListings = await prisma.marketplaceListing.findMany()
    * ```
    */
  get marketplaceListing(): Prisma.MarketplaceListingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bid`: Exposes CRUD operations for the **Bid** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bids
    * const bids = await prisma.bid.findMany()
    * ```
    */
  get bid(): Prisma.BidDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cryptoWallet`: Exposes CRUD operations for the **CryptoWallet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CryptoWallets
    * const cryptoWallets = await prisma.cryptoWallet.findMany()
    * ```
    */
  get cryptoWallet(): Prisma.CryptoWalletDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.physicalCard`: Exposes CRUD operations for the **PhysicalCard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PhysicalCards
    * const physicalCards = await prisma.physicalCard.findMany()
    * ```
    */
  get physicalCard(): Prisma.PhysicalCardDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.socialFeed`: Exposes CRUD operations for the **SocialFeed** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SocialFeeds
    * const socialFeeds = await prisma.socialFeed.findMany()
    * ```
    */
  get socialFeed(): Prisma.SocialFeedDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.follow`: Exposes CRUD operations for the **Follow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Follows
    * const follows = await prisma.follow.findMany()
    * ```
    */
  get follow(): Prisma.FollowDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.appOrder`: Exposes CRUD operations for the **AppOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AppOrders
    * const appOrders = await prisma.appOrder.findMany()
    * ```
    */
  get appOrder(): Prisma.AppOrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderRevision`: Exposes CRUD operations for the **OrderRevision** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderRevisions
    * const orderRevisions = await prisma.orderRevision.findMany()
    * ```
    */
  get orderRevision(): Prisma.OrderRevisionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderCommunication`: Exposes CRUD operations for the **OrderCommunication** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderCommunications
    * const orderCommunications = await prisma.orderCommunication.findMany()
    * ```
    */
  get orderCommunication(): Prisma.OrderCommunicationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderDeliverable`: Exposes CRUD operations for the **OrderDeliverable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderDeliverables
    * const orderDeliverables = await prisma.orderDeliverable.findMany()
    * ```
    */
  get orderDeliverable(): Prisma.OrderDeliverableDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bettingMarket`: Exposes CRUD operations for the **BettingMarket** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BettingMarkets
    * const bettingMarkets = await prisma.bettingMarket.findMany()
    * ```
    */
  get bettingMarket(): Prisma.BettingMarketDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bettingPosition`: Exposes CRUD operations for the **BettingPosition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BettingPositions
    * const bettingPositions = await prisma.bettingPosition.findMany()
    * ```
    */
  get bettingPosition(): Prisma.BettingPositionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.marketMetrics`: Exposes CRUD operations for the **MarketMetrics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MarketMetrics
    * const marketMetrics = await prisma.marketMetrics.findMany()
    * ```
    */
  get marketMetrics(): Prisma.MarketMetricsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bettingPayout`: Exposes CRUD operations for the **BettingPayout** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BettingPayouts
    * const bettingPayouts = await prisma.bettingPayout.findMany()
    * ```
    */
  get bettingPayout(): Prisma.BettingPayoutDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cardAuction`: Exposes CRUD operations for the **CardAuction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CardAuctions
    * const cardAuctions = await prisma.cardAuction.findMany()
    * ```
    */
  get cardAuction(): Prisma.CardAuctionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auctionConditions`: Exposes CRUD operations for the **AuctionConditions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuctionConditions
    * const auctionConditions = await prisma.auctionConditions.findMany()
    * ```
    */
  get auctionConditions(): Prisma.AuctionConditionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auctionBid`: Exposes CRUD operations for the **AuctionBid** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuctionBids
    * const auctionBids = await prisma.auctionBid.findMany()
    * ```
    */
  get auctionBid(): Prisma.AuctionBidDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auctionWatcher`: Exposes CRUD operations for the **AuctionWatcher** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuctionWatchers
    * const auctionWatchers = await prisma.auctionWatcher.findMany()
    * ```
    */
  get auctionWatcher(): Prisma.AuctionWatcherDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auctionHistory`: Exposes CRUD operations for the **AuctionHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuctionHistories
    * const auctionHistories = await prisma.auctionHistory.findMany()
    * ```
    */
  get auctionHistory(): Prisma.AuctionHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mABattle`: Exposes CRUD operations for the **MABattle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MABattles
    * const mABattles = await prisma.mABattle.findMany()
    * ```
    */
  get mABattle(): Prisma.MABattleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.battleProposal`: Exposes CRUD operations for the **BattleProposal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BattleProposals
    * const battleProposals = await prisma.battleProposal.findMany()
    * ```
    */
  get battleProposal(): Prisma.BattleProposalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.battleVoting`: Exposes CRUD operations for the **BattleVoting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BattleVotings
    * const battleVotings = await prisma.battleVoting.findMany()
    * ```
    */
  get battleVoting(): Prisma.BattleVotingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.battleOutcome`: Exposes CRUD operations for the **BattleOutcome** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BattleOutcomes
    * const battleOutcomes = await prisma.battleOutcome.findMany()
    * ```
    */
  get battleOutcome(): Prisma.BattleOutcomeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stakingPool`: Exposes CRUD operations for the **StakingPool** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StakingPools
    * const stakingPools = await prisma.stakingPool.findMany()
    * ```
    */
  get stakingPool(): Prisma.StakingPoolDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stakingPosition`: Exposes CRUD operations for the **StakingPosition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StakingPositions
    * const stakingPositions = await prisma.stakingPosition.findMany()
    * ```
    */
  get stakingPosition(): Prisma.StakingPositionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stakingReward`: Exposes CRUD operations for the **StakingReward** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StakingRewards
    * const stakingRewards = await prisma.stakingReward.findMany()
    * ```
    */
  get stakingReward(): Prisma.StakingRewardDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.governanceProposal`: Exposes CRUD operations for the **GovernanceProposal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GovernanceProposals
    * const governanceProposals = await prisma.governanceProposal.findMany()
    * ```
    */
  get governanceProposal(): Prisma.GovernanceProposalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.governanceVote`: Exposes CRUD operations for the **GovernanceVote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GovernanceVotes
    * const governanceVotes = await prisma.governanceVote.findMany()
    * ```
    */
  get governanceVote(): Prisma.GovernanceVoteDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.11.1
   * Query Engine version: f40f79ec31188888a2e33acda0ecc8fd10a853a9
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    UserSubscription: 'UserSubscription',
    SubscriptionFeatures: 'SubscriptionFeatures',
    SubscriptionUsage: 'SubscriptionUsage',
    Card: 'Card',
    MarketplaceListing: 'MarketplaceListing',
    Bid: 'Bid',
    Transaction: 'Transaction',
    CryptoWallet: 'CryptoWallet',
    PhysicalCard: 'PhysicalCard',
    Notification: 'Notification',
    SocialFeed: 'SocialFeed',
    Follow: 'Follow',
    AppOrder: 'AppOrder',
    OrderRevision: 'OrderRevision',
    OrderCommunication: 'OrderCommunication',
    OrderDeliverable: 'OrderDeliverable',
    BettingMarket: 'BettingMarket',
    BettingPosition: 'BettingPosition',
    MarketMetrics: 'MarketMetrics',
    BettingPayout: 'BettingPayout',
    CardAuction: 'CardAuction',
    AuctionConditions: 'AuctionConditions',
    AuctionBid: 'AuctionBid',
    AuctionWatcher: 'AuctionWatcher',
    AuctionHistory: 'AuctionHistory',
    MABattle: 'MABattle',
    BattleProposal: 'BattleProposal',
    BattleVoting: 'BattleVoting',
    BattleOutcome: 'BattleOutcome',
    StakingPool: 'StakingPool',
    StakingPosition: 'StakingPosition',
    StakingReward: 'StakingReward',
    GovernanceProposal: 'GovernanceProposal',
    GovernanceVote: 'GovernanceVote'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "userSubscription" | "subscriptionFeatures" | "subscriptionUsage" | "card" | "marketplaceListing" | "bid" | "transaction" | "cryptoWallet" | "physicalCard" | "notification" | "socialFeed" | "follow" | "appOrder" | "orderRevision" | "orderCommunication" | "orderDeliverable" | "bettingMarket" | "bettingPosition" | "marketMetrics" | "bettingPayout" | "cardAuction" | "auctionConditions" | "auctionBid" | "auctionWatcher" | "auctionHistory" | "mABattle" | "battleProposal" | "battleVoting" | "battleOutcome" | "stakingPool" | "stakingPosition" | "stakingReward" | "governanceProposal" | "governanceVote"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserSubscription: {
        payload: Prisma.$UserSubscriptionPayload<ExtArgs>
        fields: Prisma.UserSubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>
          }
          findFirst: {
            args: Prisma.UserSubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>
          }
          findMany: {
            args: Prisma.UserSubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>[]
          }
          create: {
            args: Prisma.UserSubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>
          }
          createMany: {
            args: Prisma.UserSubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>[]
          }
          delete: {
            args: Prisma.UserSubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>
          }
          update: {
            args: Prisma.UserSubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.UserSubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserSubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.UserSubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>
          }
          aggregate: {
            args: Prisma.UserSubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSubscription>
          }
          groupBy: {
            args: Prisma.UserSubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<UserSubscriptionCountAggregateOutputType> | number
          }
        }
      }
      SubscriptionFeatures: {
        payload: Prisma.$SubscriptionFeaturesPayload<ExtArgs>
        fields: Prisma.SubscriptionFeaturesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionFeaturesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionFeaturesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionFeaturesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionFeaturesPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionFeaturesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionFeaturesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionFeaturesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionFeaturesPayload>
          }
          findMany: {
            args: Prisma.SubscriptionFeaturesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionFeaturesPayload>[]
          }
          create: {
            args: Prisma.SubscriptionFeaturesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionFeaturesPayload>
          }
          createMany: {
            args: Prisma.SubscriptionFeaturesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionFeaturesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionFeaturesPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionFeaturesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionFeaturesPayload>
          }
          update: {
            args: Prisma.SubscriptionFeaturesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionFeaturesPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionFeaturesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionFeaturesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubscriptionFeaturesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionFeaturesPayload>[]
          }
          upsert: {
            args: Prisma.SubscriptionFeaturesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionFeaturesPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionFeaturesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscriptionFeatures>
          }
          groupBy: {
            args: Prisma.SubscriptionFeaturesGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionFeaturesGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionFeaturesCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionFeaturesCountAggregateOutputType> | number
          }
        }
      }
      SubscriptionUsage: {
        payload: Prisma.$SubscriptionUsagePayload<ExtArgs>
        fields: Prisma.SubscriptionUsageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionUsageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionUsagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionUsageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionUsagePayload>
          }
          findFirst: {
            args: Prisma.SubscriptionUsageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionUsagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionUsageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionUsagePayload>
          }
          findMany: {
            args: Prisma.SubscriptionUsageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionUsagePayload>[]
          }
          create: {
            args: Prisma.SubscriptionUsageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionUsagePayload>
          }
          createMany: {
            args: Prisma.SubscriptionUsageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionUsageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionUsagePayload>[]
          }
          delete: {
            args: Prisma.SubscriptionUsageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionUsagePayload>
          }
          update: {
            args: Prisma.SubscriptionUsageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionUsagePayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionUsageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionUsageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubscriptionUsageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionUsagePayload>[]
          }
          upsert: {
            args: Prisma.SubscriptionUsageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionUsagePayload>
          }
          aggregate: {
            args: Prisma.SubscriptionUsageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscriptionUsage>
          }
          groupBy: {
            args: Prisma.SubscriptionUsageGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionUsageGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionUsageCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionUsageCountAggregateOutputType> | number
          }
        }
      }
      Card: {
        payload: Prisma.$CardPayload<ExtArgs>
        fields: Prisma.CardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload>
          }
          findFirst: {
            args: Prisma.CardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload>
          }
          findMany: {
            args: Prisma.CardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload>[]
          }
          create: {
            args: Prisma.CardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload>
          }
          createMany: {
            args: Prisma.CardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload>[]
          }
          delete: {
            args: Prisma.CardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload>
          }
          update: {
            args: Prisma.CardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload>
          }
          deleteMany: {
            args: Prisma.CardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CardUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload>[]
          }
          upsert: {
            args: Prisma.CardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload>
          }
          aggregate: {
            args: Prisma.CardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCard>
          }
          groupBy: {
            args: Prisma.CardGroupByArgs<ExtArgs>
            result: $Utils.Optional<CardGroupByOutputType>[]
          }
          count: {
            args: Prisma.CardCountArgs<ExtArgs>
            result: $Utils.Optional<CardCountAggregateOutputType> | number
          }
        }
      }
      MarketplaceListing: {
        payload: Prisma.$MarketplaceListingPayload<ExtArgs>
        fields: Prisma.MarketplaceListingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MarketplaceListingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceListingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MarketplaceListingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceListingPayload>
          }
          findFirst: {
            args: Prisma.MarketplaceListingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceListingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MarketplaceListingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceListingPayload>
          }
          findMany: {
            args: Prisma.MarketplaceListingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceListingPayload>[]
          }
          create: {
            args: Prisma.MarketplaceListingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceListingPayload>
          }
          createMany: {
            args: Prisma.MarketplaceListingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MarketplaceListingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceListingPayload>[]
          }
          delete: {
            args: Prisma.MarketplaceListingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceListingPayload>
          }
          update: {
            args: Prisma.MarketplaceListingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceListingPayload>
          }
          deleteMany: {
            args: Prisma.MarketplaceListingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MarketplaceListingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MarketplaceListingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceListingPayload>[]
          }
          upsert: {
            args: Prisma.MarketplaceListingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceListingPayload>
          }
          aggregate: {
            args: Prisma.MarketplaceListingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMarketplaceListing>
          }
          groupBy: {
            args: Prisma.MarketplaceListingGroupByArgs<ExtArgs>
            result: $Utils.Optional<MarketplaceListingGroupByOutputType>[]
          }
          count: {
            args: Prisma.MarketplaceListingCountArgs<ExtArgs>
            result: $Utils.Optional<MarketplaceListingCountAggregateOutputType> | number
          }
        }
      }
      Bid: {
        payload: Prisma.$BidPayload<ExtArgs>
        fields: Prisma.BidFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BidFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BidFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidPayload>
          }
          findFirst: {
            args: Prisma.BidFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BidFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidPayload>
          }
          findMany: {
            args: Prisma.BidFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidPayload>[]
          }
          create: {
            args: Prisma.BidCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidPayload>
          }
          createMany: {
            args: Prisma.BidCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BidCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidPayload>[]
          }
          delete: {
            args: Prisma.BidDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidPayload>
          }
          update: {
            args: Prisma.BidUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidPayload>
          }
          deleteMany: {
            args: Prisma.BidDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BidUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BidUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidPayload>[]
          }
          upsert: {
            args: Prisma.BidUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidPayload>
          }
          aggregate: {
            args: Prisma.BidAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBid>
          }
          groupBy: {
            args: Prisma.BidGroupByArgs<ExtArgs>
            result: $Utils.Optional<BidGroupByOutputType>[]
          }
          count: {
            args: Prisma.BidCountArgs<ExtArgs>
            result: $Utils.Optional<BidCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      CryptoWallet: {
        payload: Prisma.$CryptoWalletPayload<ExtArgs>
        fields: Prisma.CryptoWalletFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CryptoWalletFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoWalletPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CryptoWalletFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoWalletPayload>
          }
          findFirst: {
            args: Prisma.CryptoWalletFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoWalletPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CryptoWalletFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoWalletPayload>
          }
          findMany: {
            args: Prisma.CryptoWalletFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoWalletPayload>[]
          }
          create: {
            args: Prisma.CryptoWalletCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoWalletPayload>
          }
          createMany: {
            args: Prisma.CryptoWalletCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CryptoWalletCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoWalletPayload>[]
          }
          delete: {
            args: Prisma.CryptoWalletDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoWalletPayload>
          }
          update: {
            args: Prisma.CryptoWalletUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoWalletPayload>
          }
          deleteMany: {
            args: Prisma.CryptoWalletDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CryptoWalletUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CryptoWalletUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoWalletPayload>[]
          }
          upsert: {
            args: Prisma.CryptoWalletUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoWalletPayload>
          }
          aggregate: {
            args: Prisma.CryptoWalletAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCryptoWallet>
          }
          groupBy: {
            args: Prisma.CryptoWalletGroupByArgs<ExtArgs>
            result: $Utils.Optional<CryptoWalletGroupByOutputType>[]
          }
          count: {
            args: Prisma.CryptoWalletCountArgs<ExtArgs>
            result: $Utils.Optional<CryptoWalletCountAggregateOutputType> | number
          }
        }
      }
      PhysicalCard: {
        payload: Prisma.$PhysicalCardPayload<ExtArgs>
        fields: Prisma.PhysicalCardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PhysicalCardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhysicalCardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PhysicalCardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhysicalCardPayload>
          }
          findFirst: {
            args: Prisma.PhysicalCardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhysicalCardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PhysicalCardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhysicalCardPayload>
          }
          findMany: {
            args: Prisma.PhysicalCardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhysicalCardPayload>[]
          }
          create: {
            args: Prisma.PhysicalCardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhysicalCardPayload>
          }
          createMany: {
            args: Prisma.PhysicalCardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PhysicalCardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhysicalCardPayload>[]
          }
          delete: {
            args: Prisma.PhysicalCardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhysicalCardPayload>
          }
          update: {
            args: Prisma.PhysicalCardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhysicalCardPayload>
          }
          deleteMany: {
            args: Prisma.PhysicalCardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PhysicalCardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PhysicalCardUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhysicalCardPayload>[]
          }
          upsert: {
            args: Prisma.PhysicalCardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhysicalCardPayload>
          }
          aggregate: {
            args: Prisma.PhysicalCardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePhysicalCard>
          }
          groupBy: {
            args: Prisma.PhysicalCardGroupByArgs<ExtArgs>
            result: $Utils.Optional<PhysicalCardGroupByOutputType>[]
          }
          count: {
            args: Prisma.PhysicalCardCountArgs<ExtArgs>
            result: $Utils.Optional<PhysicalCardCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      SocialFeed: {
        payload: Prisma.$SocialFeedPayload<ExtArgs>
        fields: Prisma.SocialFeedFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SocialFeedFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialFeedPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SocialFeedFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialFeedPayload>
          }
          findFirst: {
            args: Prisma.SocialFeedFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialFeedPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SocialFeedFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialFeedPayload>
          }
          findMany: {
            args: Prisma.SocialFeedFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialFeedPayload>[]
          }
          create: {
            args: Prisma.SocialFeedCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialFeedPayload>
          }
          createMany: {
            args: Prisma.SocialFeedCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SocialFeedCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialFeedPayload>[]
          }
          delete: {
            args: Prisma.SocialFeedDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialFeedPayload>
          }
          update: {
            args: Prisma.SocialFeedUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialFeedPayload>
          }
          deleteMany: {
            args: Prisma.SocialFeedDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SocialFeedUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SocialFeedUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialFeedPayload>[]
          }
          upsert: {
            args: Prisma.SocialFeedUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialFeedPayload>
          }
          aggregate: {
            args: Prisma.SocialFeedAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSocialFeed>
          }
          groupBy: {
            args: Prisma.SocialFeedGroupByArgs<ExtArgs>
            result: $Utils.Optional<SocialFeedGroupByOutputType>[]
          }
          count: {
            args: Prisma.SocialFeedCountArgs<ExtArgs>
            result: $Utils.Optional<SocialFeedCountAggregateOutputType> | number
          }
        }
      }
      Follow: {
        payload: Prisma.$FollowPayload<ExtArgs>
        fields: Prisma.FollowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FollowFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FollowFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          findFirst: {
            args: Prisma.FollowFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FollowFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          findMany: {
            args: Prisma.FollowFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>[]
          }
          create: {
            args: Prisma.FollowCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          createMany: {
            args: Prisma.FollowCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FollowCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>[]
          }
          delete: {
            args: Prisma.FollowDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          update: {
            args: Prisma.FollowUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          deleteMany: {
            args: Prisma.FollowDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FollowUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FollowUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>[]
          }
          upsert: {
            args: Prisma.FollowUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          aggregate: {
            args: Prisma.FollowAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFollow>
          }
          groupBy: {
            args: Prisma.FollowGroupByArgs<ExtArgs>
            result: $Utils.Optional<FollowGroupByOutputType>[]
          }
          count: {
            args: Prisma.FollowCountArgs<ExtArgs>
            result: $Utils.Optional<FollowCountAggregateOutputType> | number
          }
        }
      }
      AppOrder: {
        payload: Prisma.$AppOrderPayload<ExtArgs>
        fields: Prisma.AppOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AppOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AppOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppOrderPayload>
          }
          findFirst: {
            args: Prisma.AppOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AppOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppOrderPayload>
          }
          findMany: {
            args: Prisma.AppOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppOrderPayload>[]
          }
          create: {
            args: Prisma.AppOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppOrderPayload>
          }
          createMany: {
            args: Prisma.AppOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AppOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppOrderPayload>[]
          }
          delete: {
            args: Prisma.AppOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppOrderPayload>
          }
          update: {
            args: Prisma.AppOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppOrderPayload>
          }
          deleteMany: {
            args: Prisma.AppOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AppOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AppOrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppOrderPayload>[]
          }
          upsert: {
            args: Prisma.AppOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppOrderPayload>
          }
          aggregate: {
            args: Prisma.AppOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAppOrder>
          }
          groupBy: {
            args: Prisma.AppOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<AppOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.AppOrderCountArgs<ExtArgs>
            result: $Utils.Optional<AppOrderCountAggregateOutputType> | number
          }
        }
      }
      OrderRevision: {
        payload: Prisma.$OrderRevisionPayload<ExtArgs>
        fields: Prisma.OrderRevisionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderRevisionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderRevisionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderRevisionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderRevisionPayload>
          }
          findFirst: {
            args: Prisma.OrderRevisionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderRevisionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderRevisionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderRevisionPayload>
          }
          findMany: {
            args: Prisma.OrderRevisionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderRevisionPayload>[]
          }
          create: {
            args: Prisma.OrderRevisionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderRevisionPayload>
          }
          createMany: {
            args: Prisma.OrderRevisionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderRevisionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderRevisionPayload>[]
          }
          delete: {
            args: Prisma.OrderRevisionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderRevisionPayload>
          }
          update: {
            args: Prisma.OrderRevisionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderRevisionPayload>
          }
          deleteMany: {
            args: Prisma.OrderRevisionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderRevisionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderRevisionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderRevisionPayload>[]
          }
          upsert: {
            args: Prisma.OrderRevisionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderRevisionPayload>
          }
          aggregate: {
            args: Prisma.OrderRevisionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderRevision>
          }
          groupBy: {
            args: Prisma.OrderRevisionGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderRevisionGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderRevisionCountArgs<ExtArgs>
            result: $Utils.Optional<OrderRevisionCountAggregateOutputType> | number
          }
        }
      }
      OrderCommunication: {
        payload: Prisma.$OrderCommunicationPayload<ExtArgs>
        fields: Prisma.OrderCommunicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderCommunicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderCommunicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderCommunicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderCommunicationPayload>
          }
          findFirst: {
            args: Prisma.OrderCommunicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderCommunicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderCommunicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderCommunicationPayload>
          }
          findMany: {
            args: Prisma.OrderCommunicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderCommunicationPayload>[]
          }
          create: {
            args: Prisma.OrderCommunicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderCommunicationPayload>
          }
          createMany: {
            args: Prisma.OrderCommunicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderCommunicationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderCommunicationPayload>[]
          }
          delete: {
            args: Prisma.OrderCommunicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderCommunicationPayload>
          }
          update: {
            args: Prisma.OrderCommunicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderCommunicationPayload>
          }
          deleteMany: {
            args: Prisma.OrderCommunicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderCommunicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderCommunicationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderCommunicationPayload>[]
          }
          upsert: {
            args: Prisma.OrderCommunicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderCommunicationPayload>
          }
          aggregate: {
            args: Prisma.OrderCommunicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderCommunication>
          }
          groupBy: {
            args: Prisma.OrderCommunicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderCommunicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCommunicationCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCommunicationCountAggregateOutputType> | number
          }
        }
      }
      OrderDeliverable: {
        payload: Prisma.$OrderDeliverablePayload<ExtArgs>
        fields: Prisma.OrderDeliverableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderDeliverableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderDeliverablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderDeliverableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderDeliverablePayload>
          }
          findFirst: {
            args: Prisma.OrderDeliverableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderDeliverablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderDeliverableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderDeliverablePayload>
          }
          findMany: {
            args: Prisma.OrderDeliverableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderDeliverablePayload>[]
          }
          create: {
            args: Prisma.OrderDeliverableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderDeliverablePayload>
          }
          createMany: {
            args: Prisma.OrderDeliverableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderDeliverableCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderDeliverablePayload>[]
          }
          delete: {
            args: Prisma.OrderDeliverableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderDeliverablePayload>
          }
          update: {
            args: Prisma.OrderDeliverableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderDeliverablePayload>
          }
          deleteMany: {
            args: Prisma.OrderDeliverableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderDeliverableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderDeliverableUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderDeliverablePayload>[]
          }
          upsert: {
            args: Prisma.OrderDeliverableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderDeliverablePayload>
          }
          aggregate: {
            args: Prisma.OrderDeliverableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderDeliverable>
          }
          groupBy: {
            args: Prisma.OrderDeliverableGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderDeliverableGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderDeliverableCountArgs<ExtArgs>
            result: $Utils.Optional<OrderDeliverableCountAggregateOutputType> | number
          }
        }
      }
      BettingMarket: {
        payload: Prisma.$BettingMarketPayload<ExtArgs>
        fields: Prisma.BettingMarketFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BettingMarketFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BettingMarketPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BettingMarketFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BettingMarketPayload>
          }
          findFirst: {
            args: Prisma.BettingMarketFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BettingMarketPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BettingMarketFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BettingMarketPayload>
          }
          findMany: {
            args: Prisma.BettingMarketFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BettingMarketPayload>[]
          }
          create: {
            args: Prisma.BettingMarketCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BettingMarketPayload>
          }
          createMany: {
            args: Prisma.BettingMarketCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BettingMarketCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BettingMarketPayload>[]
          }
          delete: {
            args: Prisma.BettingMarketDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BettingMarketPayload>
          }
          update: {
            args: Prisma.BettingMarketUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BettingMarketPayload>
          }
          deleteMany: {
            args: Prisma.BettingMarketDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BettingMarketUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BettingMarketUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BettingMarketPayload>[]
          }
          upsert: {
            args: Prisma.BettingMarketUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BettingMarketPayload>
          }
          aggregate: {
            args: Prisma.BettingMarketAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBettingMarket>
          }
          groupBy: {
            args: Prisma.BettingMarketGroupByArgs<ExtArgs>
            result: $Utils.Optional<BettingMarketGroupByOutputType>[]
          }
          count: {
            args: Prisma.BettingMarketCountArgs<ExtArgs>
            result: $Utils.Optional<BettingMarketCountAggregateOutputType> | number
          }
        }
      }
      BettingPosition: {
        payload: Prisma.$BettingPositionPayload<ExtArgs>
        fields: Prisma.BettingPositionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BettingPositionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BettingPositionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BettingPositionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BettingPositionPayload>
          }
          findFirst: {
            args: Prisma.BettingPositionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BettingPositionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BettingPositionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BettingPositionPayload>
          }
          findMany: {
            args: Prisma.BettingPositionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BettingPositionPayload>[]
          }
          create: {
            args: Prisma.BettingPositionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BettingPositionPayload>
          }
          createMany: {
            args: Prisma.BettingPositionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BettingPositionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BettingPositionPayload>[]
          }
          delete: {
            args: Prisma.BettingPositionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BettingPositionPayload>
          }
          update: {
            args: Prisma.BettingPositionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BettingPositionPayload>
          }
          deleteMany: {
            args: Prisma.BettingPositionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BettingPositionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BettingPositionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BettingPositionPayload>[]
          }
          upsert: {
            args: Prisma.BettingPositionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BettingPositionPayload>
          }
          aggregate: {
            args: Prisma.BettingPositionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBettingPosition>
          }
          groupBy: {
            args: Prisma.BettingPositionGroupByArgs<ExtArgs>
            result: $Utils.Optional<BettingPositionGroupByOutputType>[]
          }
          count: {
            args: Prisma.BettingPositionCountArgs<ExtArgs>
            result: $Utils.Optional<BettingPositionCountAggregateOutputType> | number
          }
        }
      }
      MarketMetrics: {
        payload: Prisma.$MarketMetricsPayload<ExtArgs>
        fields: Prisma.MarketMetricsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MarketMetricsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketMetricsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MarketMetricsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketMetricsPayload>
          }
          findFirst: {
            args: Prisma.MarketMetricsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketMetricsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MarketMetricsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketMetricsPayload>
          }
          findMany: {
            args: Prisma.MarketMetricsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketMetricsPayload>[]
          }
          create: {
            args: Prisma.MarketMetricsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketMetricsPayload>
          }
          createMany: {
            args: Prisma.MarketMetricsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MarketMetricsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketMetricsPayload>[]
          }
          delete: {
            args: Prisma.MarketMetricsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketMetricsPayload>
          }
          update: {
            args: Prisma.MarketMetricsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketMetricsPayload>
          }
          deleteMany: {
            args: Prisma.MarketMetricsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MarketMetricsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MarketMetricsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketMetricsPayload>[]
          }
          upsert: {
            args: Prisma.MarketMetricsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketMetricsPayload>
          }
          aggregate: {
            args: Prisma.MarketMetricsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMarketMetrics>
          }
          groupBy: {
            args: Prisma.MarketMetricsGroupByArgs<ExtArgs>
            result: $Utils.Optional<MarketMetricsGroupByOutputType>[]
          }
          count: {
            args: Prisma.MarketMetricsCountArgs<ExtArgs>
            result: $Utils.Optional<MarketMetricsCountAggregateOutputType> | number
          }
        }
      }
      BettingPayout: {
        payload: Prisma.$BettingPayoutPayload<ExtArgs>
        fields: Prisma.BettingPayoutFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BettingPayoutFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BettingPayoutPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BettingPayoutFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BettingPayoutPayload>
          }
          findFirst: {
            args: Prisma.BettingPayoutFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BettingPayoutPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BettingPayoutFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BettingPayoutPayload>
          }
          findMany: {
            args: Prisma.BettingPayoutFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BettingPayoutPayload>[]
          }
          create: {
            args: Prisma.BettingPayoutCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BettingPayoutPayload>
          }
          createMany: {
            args: Prisma.BettingPayoutCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BettingPayoutCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BettingPayoutPayload>[]
          }
          delete: {
            args: Prisma.BettingPayoutDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BettingPayoutPayload>
          }
          update: {
            args: Prisma.BettingPayoutUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BettingPayoutPayload>
          }
          deleteMany: {
            args: Prisma.BettingPayoutDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BettingPayoutUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BettingPayoutUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BettingPayoutPayload>[]
          }
          upsert: {
            args: Prisma.BettingPayoutUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BettingPayoutPayload>
          }
          aggregate: {
            args: Prisma.BettingPayoutAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBettingPayout>
          }
          groupBy: {
            args: Prisma.BettingPayoutGroupByArgs<ExtArgs>
            result: $Utils.Optional<BettingPayoutGroupByOutputType>[]
          }
          count: {
            args: Prisma.BettingPayoutCountArgs<ExtArgs>
            result: $Utils.Optional<BettingPayoutCountAggregateOutputType> | number
          }
        }
      }
      CardAuction: {
        payload: Prisma.$CardAuctionPayload<ExtArgs>
        fields: Prisma.CardAuctionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CardAuctionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardAuctionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CardAuctionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardAuctionPayload>
          }
          findFirst: {
            args: Prisma.CardAuctionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardAuctionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CardAuctionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardAuctionPayload>
          }
          findMany: {
            args: Prisma.CardAuctionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardAuctionPayload>[]
          }
          create: {
            args: Prisma.CardAuctionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardAuctionPayload>
          }
          createMany: {
            args: Prisma.CardAuctionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CardAuctionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardAuctionPayload>[]
          }
          delete: {
            args: Prisma.CardAuctionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardAuctionPayload>
          }
          update: {
            args: Prisma.CardAuctionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardAuctionPayload>
          }
          deleteMany: {
            args: Prisma.CardAuctionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CardAuctionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CardAuctionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardAuctionPayload>[]
          }
          upsert: {
            args: Prisma.CardAuctionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardAuctionPayload>
          }
          aggregate: {
            args: Prisma.CardAuctionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCardAuction>
          }
          groupBy: {
            args: Prisma.CardAuctionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CardAuctionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CardAuctionCountArgs<ExtArgs>
            result: $Utils.Optional<CardAuctionCountAggregateOutputType> | number
          }
        }
      }
      AuctionConditions: {
        payload: Prisma.$AuctionConditionsPayload<ExtArgs>
        fields: Prisma.AuctionConditionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuctionConditionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionConditionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuctionConditionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionConditionsPayload>
          }
          findFirst: {
            args: Prisma.AuctionConditionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionConditionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuctionConditionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionConditionsPayload>
          }
          findMany: {
            args: Prisma.AuctionConditionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionConditionsPayload>[]
          }
          create: {
            args: Prisma.AuctionConditionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionConditionsPayload>
          }
          createMany: {
            args: Prisma.AuctionConditionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuctionConditionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionConditionsPayload>[]
          }
          delete: {
            args: Prisma.AuctionConditionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionConditionsPayload>
          }
          update: {
            args: Prisma.AuctionConditionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionConditionsPayload>
          }
          deleteMany: {
            args: Prisma.AuctionConditionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuctionConditionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuctionConditionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionConditionsPayload>[]
          }
          upsert: {
            args: Prisma.AuctionConditionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionConditionsPayload>
          }
          aggregate: {
            args: Prisma.AuctionConditionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuctionConditions>
          }
          groupBy: {
            args: Prisma.AuctionConditionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuctionConditionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuctionConditionsCountArgs<ExtArgs>
            result: $Utils.Optional<AuctionConditionsCountAggregateOutputType> | number
          }
        }
      }
      AuctionBid: {
        payload: Prisma.$AuctionBidPayload<ExtArgs>
        fields: Prisma.AuctionBidFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuctionBidFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionBidPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuctionBidFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionBidPayload>
          }
          findFirst: {
            args: Prisma.AuctionBidFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionBidPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuctionBidFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionBidPayload>
          }
          findMany: {
            args: Prisma.AuctionBidFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionBidPayload>[]
          }
          create: {
            args: Prisma.AuctionBidCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionBidPayload>
          }
          createMany: {
            args: Prisma.AuctionBidCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuctionBidCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionBidPayload>[]
          }
          delete: {
            args: Prisma.AuctionBidDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionBidPayload>
          }
          update: {
            args: Prisma.AuctionBidUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionBidPayload>
          }
          deleteMany: {
            args: Prisma.AuctionBidDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuctionBidUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuctionBidUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionBidPayload>[]
          }
          upsert: {
            args: Prisma.AuctionBidUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionBidPayload>
          }
          aggregate: {
            args: Prisma.AuctionBidAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuctionBid>
          }
          groupBy: {
            args: Prisma.AuctionBidGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuctionBidGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuctionBidCountArgs<ExtArgs>
            result: $Utils.Optional<AuctionBidCountAggregateOutputType> | number
          }
        }
      }
      AuctionWatcher: {
        payload: Prisma.$AuctionWatcherPayload<ExtArgs>
        fields: Prisma.AuctionWatcherFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuctionWatcherFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionWatcherPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuctionWatcherFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionWatcherPayload>
          }
          findFirst: {
            args: Prisma.AuctionWatcherFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionWatcherPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuctionWatcherFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionWatcherPayload>
          }
          findMany: {
            args: Prisma.AuctionWatcherFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionWatcherPayload>[]
          }
          create: {
            args: Prisma.AuctionWatcherCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionWatcherPayload>
          }
          createMany: {
            args: Prisma.AuctionWatcherCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuctionWatcherCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionWatcherPayload>[]
          }
          delete: {
            args: Prisma.AuctionWatcherDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionWatcherPayload>
          }
          update: {
            args: Prisma.AuctionWatcherUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionWatcherPayload>
          }
          deleteMany: {
            args: Prisma.AuctionWatcherDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuctionWatcherUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuctionWatcherUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionWatcherPayload>[]
          }
          upsert: {
            args: Prisma.AuctionWatcherUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionWatcherPayload>
          }
          aggregate: {
            args: Prisma.AuctionWatcherAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuctionWatcher>
          }
          groupBy: {
            args: Prisma.AuctionWatcherGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuctionWatcherGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuctionWatcherCountArgs<ExtArgs>
            result: $Utils.Optional<AuctionWatcherCountAggregateOutputType> | number
          }
        }
      }
      AuctionHistory: {
        payload: Prisma.$AuctionHistoryPayload<ExtArgs>
        fields: Prisma.AuctionHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuctionHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuctionHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionHistoryPayload>
          }
          findFirst: {
            args: Prisma.AuctionHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuctionHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionHistoryPayload>
          }
          findMany: {
            args: Prisma.AuctionHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionHistoryPayload>[]
          }
          create: {
            args: Prisma.AuctionHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionHistoryPayload>
          }
          createMany: {
            args: Prisma.AuctionHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuctionHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionHistoryPayload>[]
          }
          delete: {
            args: Prisma.AuctionHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionHistoryPayload>
          }
          update: {
            args: Prisma.AuctionHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionHistoryPayload>
          }
          deleteMany: {
            args: Prisma.AuctionHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuctionHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuctionHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionHistoryPayload>[]
          }
          upsert: {
            args: Prisma.AuctionHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionHistoryPayload>
          }
          aggregate: {
            args: Prisma.AuctionHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuctionHistory>
          }
          groupBy: {
            args: Prisma.AuctionHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuctionHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuctionHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<AuctionHistoryCountAggregateOutputType> | number
          }
        }
      }
      MABattle: {
        payload: Prisma.$MABattlePayload<ExtArgs>
        fields: Prisma.MABattleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MABattleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MABattlePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MABattleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MABattlePayload>
          }
          findFirst: {
            args: Prisma.MABattleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MABattlePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MABattleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MABattlePayload>
          }
          findMany: {
            args: Prisma.MABattleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MABattlePayload>[]
          }
          create: {
            args: Prisma.MABattleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MABattlePayload>
          }
          createMany: {
            args: Prisma.MABattleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MABattleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MABattlePayload>[]
          }
          delete: {
            args: Prisma.MABattleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MABattlePayload>
          }
          update: {
            args: Prisma.MABattleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MABattlePayload>
          }
          deleteMany: {
            args: Prisma.MABattleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MABattleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MABattleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MABattlePayload>[]
          }
          upsert: {
            args: Prisma.MABattleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MABattlePayload>
          }
          aggregate: {
            args: Prisma.MABattleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMABattle>
          }
          groupBy: {
            args: Prisma.MABattleGroupByArgs<ExtArgs>
            result: $Utils.Optional<MABattleGroupByOutputType>[]
          }
          count: {
            args: Prisma.MABattleCountArgs<ExtArgs>
            result: $Utils.Optional<MABattleCountAggregateOutputType> | number
          }
        }
      }
      BattleProposal: {
        payload: Prisma.$BattleProposalPayload<ExtArgs>
        fields: Prisma.BattleProposalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BattleProposalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattleProposalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BattleProposalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattleProposalPayload>
          }
          findFirst: {
            args: Prisma.BattleProposalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattleProposalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BattleProposalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattleProposalPayload>
          }
          findMany: {
            args: Prisma.BattleProposalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattleProposalPayload>[]
          }
          create: {
            args: Prisma.BattleProposalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattleProposalPayload>
          }
          createMany: {
            args: Prisma.BattleProposalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BattleProposalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattleProposalPayload>[]
          }
          delete: {
            args: Prisma.BattleProposalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattleProposalPayload>
          }
          update: {
            args: Prisma.BattleProposalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattleProposalPayload>
          }
          deleteMany: {
            args: Prisma.BattleProposalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BattleProposalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BattleProposalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattleProposalPayload>[]
          }
          upsert: {
            args: Prisma.BattleProposalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattleProposalPayload>
          }
          aggregate: {
            args: Prisma.BattleProposalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBattleProposal>
          }
          groupBy: {
            args: Prisma.BattleProposalGroupByArgs<ExtArgs>
            result: $Utils.Optional<BattleProposalGroupByOutputType>[]
          }
          count: {
            args: Prisma.BattleProposalCountArgs<ExtArgs>
            result: $Utils.Optional<BattleProposalCountAggregateOutputType> | number
          }
        }
      }
      BattleVoting: {
        payload: Prisma.$BattleVotingPayload<ExtArgs>
        fields: Prisma.BattleVotingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BattleVotingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattleVotingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BattleVotingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattleVotingPayload>
          }
          findFirst: {
            args: Prisma.BattleVotingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattleVotingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BattleVotingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattleVotingPayload>
          }
          findMany: {
            args: Prisma.BattleVotingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattleVotingPayload>[]
          }
          create: {
            args: Prisma.BattleVotingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattleVotingPayload>
          }
          createMany: {
            args: Prisma.BattleVotingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BattleVotingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattleVotingPayload>[]
          }
          delete: {
            args: Prisma.BattleVotingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattleVotingPayload>
          }
          update: {
            args: Prisma.BattleVotingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattleVotingPayload>
          }
          deleteMany: {
            args: Prisma.BattleVotingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BattleVotingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BattleVotingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattleVotingPayload>[]
          }
          upsert: {
            args: Prisma.BattleVotingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattleVotingPayload>
          }
          aggregate: {
            args: Prisma.BattleVotingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBattleVoting>
          }
          groupBy: {
            args: Prisma.BattleVotingGroupByArgs<ExtArgs>
            result: $Utils.Optional<BattleVotingGroupByOutputType>[]
          }
          count: {
            args: Prisma.BattleVotingCountArgs<ExtArgs>
            result: $Utils.Optional<BattleVotingCountAggregateOutputType> | number
          }
        }
      }
      BattleOutcome: {
        payload: Prisma.$BattleOutcomePayload<ExtArgs>
        fields: Prisma.BattleOutcomeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BattleOutcomeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattleOutcomePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BattleOutcomeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattleOutcomePayload>
          }
          findFirst: {
            args: Prisma.BattleOutcomeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattleOutcomePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BattleOutcomeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattleOutcomePayload>
          }
          findMany: {
            args: Prisma.BattleOutcomeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattleOutcomePayload>[]
          }
          create: {
            args: Prisma.BattleOutcomeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattleOutcomePayload>
          }
          createMany: {
            args: Prisma.BattleOutcomeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BattleOutcomeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattleOutcomePayload>[]
          }
          delete: {
            args: Prisma.BattleOutcomeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattleOutcomePayload>
          }
          update: {
            args: Prisma.BattleOutcomeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattleOutcomePayload>
          }
          deleteMany: {
            args: Prisma.BattleOutcomeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BattleOutcomeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BattleOutcomeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattleOutcomePayload>[]
          }
          upsert: {
            args: Prisma.BattleOutcomeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattleOutcomePayload>
          }
          aggregate: {
            args: Prisma.BattleOutcomeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBattleOutcome>
          }
          groupBy: {
            args: Prisma.BattleOutcomeGroupByArgs<ExtArgs>
            result: $Utils.Optional<BattleOutcomeGroupByOutputType>[]
          }
          count: {
            args: Prisma.BattleOutcomeCountArgs<ExtArgs>
            result: $Utils.Optional<BattleOutcomeCountAggregateOutputType> | number
          }
        }
      }
      StakingPool: {
        payload: Prisma.$StakingPoolPayload<ExtArgs>
        fields: Prisma.StakingPoolFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StakingPoolFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakingPoolPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StakingPoolFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakingPoolPayload>
          }
          findFirst: {
            args: Prisma.StakingPoolFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakingPoolPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StakingPoolFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakingPoolPayload>
          }
          findMany: {
            args: Prisma.StakingPoolFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakingPoolPayload>[]
          }
          create: {
            args: Prisma.StakingPoolCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakingPoolPayload>
          }
          createMany: {
            args: Prisma.StakingPoolCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StakingPoolCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakingPoolPayload>[]
          }
          delete: {
            args: Prisma.StakingPoolDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakingPoolPayload>
          }
          update: {
            args: Prisma.StakingPoolUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakingPoolPayload>
          }
          deleteMany: {
            args: Prisma.StakingPoolDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StakingPoolUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StakingPoolUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakingPoolPayload>[]
          }
          upsert: {
            args: Prisma.StakingPoolUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakingPoolPayload>
          }
          aggregate: {
            args: Prisma.StakingPoolAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStakingPool>
          }
          groupBy: {
            args: Prisma.StakingPoolGroupByArgs<ExtArgs>
            result: $Utils.Optional<StakingPoolGroupByOutputType>[]
          }
          count: {
            args: Prisma.StakingPoolCountArgs<ExtArgs>
            result: $Utils.Optional<StakingPoolCountAggregateOutputType> | number
          }
        }
      }
      StakingPosition: {
        payload: Prisma.$StakingPositionPayload<ExtArgs>
        fields: Prisma.StakingPositionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StakingPositionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakingPositionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StakingPositionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakingPositionPayload>
          }
          findFirst: {
            args: Prisma.StakingPositionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakingPositionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StakingPositionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakingPositionPayload>
          }
          findMany: {
            args: Prisma.StakingPositionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakingPositionPayload>[]
          }
          create: {
            args: Prisma.StakingPositionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakingPositionPayload>
          }
          createMany: {
            args: Prisma.StakingPositionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StakingPositionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakingPositionPayload>[]
          }
          delete: {
            args: Prisma.StakingPositionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakingPositionPayload>
          }
          update: {
            args: Prisma.StakingPositionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakingPositionPayload>
          }
          deleteMany: {
            args: Prisma.StakingPositionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StakingPositionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StakingPositionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakingPositionPayload>[]
          }
          upsert: {
            args: Prisma.StakingPositionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakingPositionPayload>
          }
          aggregate: {
            args: Prisma.StakingPositionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStakingPosition>
          }
          groupBy: {
            args: Prisma.StakingPositionGroupByArgs<ExtArgs>
            result: $Utils.Optional<StakingPositionGroupByOutputType>[]
          }
          count: {
            args: Prisma.StakingPositionCountArgs<ExtArgs>
            result: $Utils.Optional<StakingPositionCountAggregateOutputType> | number
          }
        }
      }
      StakingReward: {
        payload: Prisma.$StakingRewardPayload<ExtArgs>
        fields: Prisma.StakingRewardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StakingRewardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakingRewardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StakingRewardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakingRewardPayload>
          }
          findFirst: {
            args: Prisma.StakingRewardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakingRewardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StakingRewardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakingRewardPayload>
          }
          findMany: {
            args: Prisma.StakingRewardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakingRewardPayload>[]
          }
          create: {
            args: Prisma.StakingRewardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakingRewardPayload>
          }
          createMany: {
            args: Prisma.StakingRewardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StakingRewardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakingRewardPayload>[]
          }
          delete: {
            args: Prisma.StakingRewardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakingRewardPayload>
          }
          update: {
            args: Prisma.StakingRewardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakingRewardPayload>
          }
          deleteMany: {
            args: Prisma.StakingRewardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StakingRewardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StakingRewardUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakingRewardPayload>[]
          }
          upsert: {
            args: Prisma.StakingRewardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakingRewardPayload>
          }
          aggregate: {
            args: Prisma.StakingRewardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStakingReward>
          }
          groupBy: {
            args: Prisma.StakingRewardGroupByArgs<ExtArgs>
            result: $Utils.Optional<StakingRewardGroupByOutputType>[]
          }
          count: {
            args: Prisma.StakingRewardCountArgs<ExtArgs>
            result: $Utils.Optional<StakingRewardCountAggregateOutputType> | number
          }
        }
      }
      GovernanceProposal: {
        payload: Prisma.$GovernanceProposalPayload<ExtArgs>
        fields: Prisma.GovernanceProposalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GovernanceProposalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GovernanceProposalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GovernanceProposalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GovernanceProposalPayload>
          }
          findFirst: {
            args: Prisma.GovernanceProposalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GovernanceProposalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GovernanceProposalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GovernanceProposalPayload>
          }
          findMany: {
            args: Prisma.GovernanceProposalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GovernanceProposalPayload>[]
          }
          create: {
            args: Prisma.GovernanceProposalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GovernanceProposalPayload>
          }
          createMany: {
            args: Prisma.GovernanceProposalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GovernanceProposalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GovernanceProposalPayload>[]
          }
          delete: {
            args: Prisma.GovernanceProposalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GovernanceProposalPayload>
          }
          update: {
            args: Prisma.GovernanceProposalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GovernanceProposalPayload>
          }
          deleteMany: {
            args: Prisma.GovernanceProposalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GovernanceProposalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GovernanceProposalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GovernanceProposalPayload>[]
          }
          upsert: {
            args: Prisma.GovernanceProposalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GovernanceProposalPayload>
          }
          aggregate: {
            args: Prisma.GovernanceProposalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGovernanceProposal>
          }
          groupBy: {
            args: Prisma.GovernanceProposalGroupByArgs<ExtArgs>
            result: $Utils.Optional<GovernanceProposalGroupByOutputType>[]
          }
          count: {
            args: Prisma.GovernanceProposalCountArgs<ExtArgs>
            result: $Utils.Optional<GovernanceProposalCountAggregateOutputType> | number
          }
        }
      }
      GovernanceVote: {
        payload: Prisma.$GovernanceVotePayload<ExtArgs>
        fields: Prisma.GovernanceVoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GovernanceVoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GovernanceVotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GovernanceVoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GovernanceVotePayload>
          }
          findFirst: {
            args: Prisma.GovernanceVoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GovernanceVotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GovernanceVoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GovernanceVotePayload>
          }
          findMany: {
            args: Prisma.GovernanceVoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GovernanceVotePayload>[]
          }
          create: {
            args: Prisma.GovernanceVoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GovernanceVotePayload>
          }
          createMany: {
            args: Prisma.GovernanceVoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GovernanceVoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GovernanceVotePayload>[]
          }
          delete: {
            args: Prisma.GovernanceVoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GovernanceVotePayload>
          }
          update: {
            args: Prisma.GovernanceVoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GovernanceVotePayload>
          }
          deleteMany: {
            args: Prisma.GovernanceVoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GovernanceVoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GovernanceVoteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GovernanceVotePayload>[]
          }
          upsert: {
            args: Prisma.GovernanceVoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GovernanceVotePayload>
          }
          aggregate: {
            args: Prisma.GovernanceVoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGovernanceVote>
          }
          groupBy: {
            args: Prisma.GovernanceVoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<GovernanceVoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.GovernanceVoteCountArgs<ExtArgs>
            result: $Utils.Optional<GovernanceVoteCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    userSubscription?: UserSubscriptionOmit
    subscriptionFeatures?: SubscriptionFeaturesOmit
    subscriptionUsage?: SubscriptionUsageOmit
    card?: CardOmit
    marketplaceListing?: MarketplaceListingOmit
    bid?: BidOmit
    transaction?: TransactionOmit
    cryptoWallet?: CryptoWalletOmit
    physicalCard?: PhysicalCardOmit
    notification?: NotificationOmit
    socialFeed?: SocialFeedOmit
    follow?: FollowOmit
    appOrder?: AppOrderOmit
    orderRevision?: OrderRevisionOmit
    orderCommunication?: OrderCommunicationOmit
    orderDeliverable?: OrderDeliverableOmit
    bettingMarket?: BettingMarketOmit
    bettingPosition?: BettingPositionOmit
    marketMetrics?: MarketMetricsOmit
    bettingPayout?: BettingPayoutOmit
    cardAuction?: CardAuctionOmit
    auctionConditions?: AuctionConditionsOmit
    auctionBid?: AuctionBidOmit
    auctionWatcher?: AuctionWatcherOmit
    auctionHistory?: AuctionHistoryOmit
    mABattle?: MABattleOmit
    battleProposal?: BattleProposalOmit
    battleVoting?: BattleVotingOmit
    battleOutcome?: BattleOutcomeOmit
    stakingPool?: StakingPoolOmit
    stakingPosition?: StakingPositionOmit
    stakingReward?: StakingRewardOmit
    governanceProposal?: GovernanceProposalOmit
    governanceVote?: GovernanceVoteOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    cryptoWallets: number
    ownedCards: number
    tradingHistory: number
    bids: number
    listings: number
    appOrders: number
    orderRevisions: number
    orderCommunications: number
    bettingPositions: number
    bettingPayouts: number
    ownedAuctions: number
    wonAuctions: number
    placedAuctionBids: number
    watchedAuctions: number
    initiatedMABattles: number
    targetedMABattles: number
    battleProposals: number
    battleVotes: number
    stakingPositions: number
    stakingRewards: number
    governanceProposals: number
    governanceVotes: number
    notifications: number
    socialFeeds: number
    followers: number
    following: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cryptoWallets?: boolean | UserCountOutputTypeCountCryptoWalletsArgs
    ownedCards?: boolean | UserCountOutputTypeCountOwnedCardsArgs
    tradingHistory?: boolean | UserCountOutputTypeCountTradingHistoryArgs
    bids?: boolean | UserCountOutputTypeCountBidsArgs
    listings?: boolean | UserCountOutputTypeCountListingsArgs
    appOrders?: boolean | UserCountOutputTypeCountAppOrdersArgs
    orderRevisions?: boolean | UserCountOutputTypeCountOrderRevisionsArgs
    orderCommunications?: boolean | UserCountOutputTypeCountOrderCommunicationsArgs
    bettingPositions?: boolean | UserCountOutputTypeCountBettingPositionsArgs
    bettingPayouts?: boolean | UserCountOutputTypeCountBettingPayoutsArgs
    ownedAuctions?: boolean | UserCountOutputTypeCountOwnedAuctionsArgs
    wonAuctions?: boolean | UserCountOutputTypeCountWonAuctionsArgs
    placedAuctionBids?: boolean | UserCountOutputTypeCountPlacedAuctionBidsArgs
    watchedAuctions?: boolean | UserCountOutputTypeCountWatchedAuctionsArgs
    initiatedMABattles?: boolean | UserCountOutputTypeCountInitiatedMABattlesArgs
    targetedMABattles?: boolean | UserCountOutputTypeCountTargetedMABattlesArgs
    battleProposals?: boolean | UserCountOutputTypeCountBattleProposalsArgs
    battleVotes?: boolean | UserCountOutputTypeCountBattleVotesArgs
    stakingPositions?: boolean | UserCountOutputTypeCountStakingPositionsArgs
    stakingRewards?: boolean | UserCountOutputTypeCountStakingRewardsArgs
    governanceProposals?: boolean | UserCountOutputTypeCountGovernanceProposalsArgs
    governanceVotes?: boolean | UserCountOutputTypeCountGovernanceVotesArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    socialFeeds?: boolean | UserCountOutputTypeCountSocialFeedsArgs
    followers?: boolean | UserCountOutputTypeCountFollowersArgs
    following?: boolean | UserCountOutputTypeCountFollowingArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCryptoWalletsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CryptoWalletWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOwnedCardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CardWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTradingHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBidsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BidWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountListingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketplaceListingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAppOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppOrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrderRevisionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderRevisionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrderCommunicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderCommunicationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBettingPositionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BettingPositionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBettingPayoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BettingPayoutWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOwnedAuctionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CardAuctionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWonAuctionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CardAuctionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPlacedAuctionBidsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuctionBidWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWatchedAuctionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuctionWatcherWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInitiatedMABattlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MABattleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTargetedMABattlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MABattleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBattleProposalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BattleProposalWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBattleVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BattleVotingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStakingPositionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StakingPositionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStakingRewardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StakingRewardWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGovernanceProposalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GovernanceProposalWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGovernanceVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GovernanceVoteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSocialFeedsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SocialFeedWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFollowersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFollowingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowWhereInput
  }


  /**
   * Count Type CardCountOutputType
   */

  export type CardCountOutputType = {
    bids: number
    transactions: number
    bettingMarkets: number
    marketMetrics: number
    auctionHistory: number
    initiatedBattles: number
    targetedBattles: number
  }

  export type CardCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bids?: boolean | CardCountOutputTypeCountBidsArgs
    transactions?: boolean | CardCountOutputTypeCountTransactionsArgs
    bettingMarkets?: boolean | CardCountOutputTypeCountBettingMarketsArgs
    marketMetrics?: boolean | CardCountOutputTypeCountMarketMetricsArgs
    auctionHistory?: boolean | CardCountOutputTypeCountAuctionHistoryArgs
    initiatedBattles?: boolean | CardCountOutputTypeCountInitiatedBattlesArgs
    targetedBattles?: boolean | CardCountOutputTypeCountTargetedBattlesArgs
  }

  // Custom InputTypes
  /**
   * CardCountOutputType without action
   */
  export type CardCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardCountOutputType
     */
    select?: CardCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CardCountOutputType without action
   */
  export type CardCountOutputTypeCountBidsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BidWhereInput
  }

  /**
   * CardCountOutputType without action
   */
  export type CardCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * CardCountOutputType without action
   */
  export type CardCountOutputTypeCountBettingMarketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BettingMarketWhereInput
  }

  /**
   * CardCountOutputType without action
   */
  export type CardCountOutputTypeCountMarketMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketMetricsWhereInput
  }

  /**
   * CardCountOutputType without action
   */
  export type CardCountOutputTypeCountAuctionHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuctionHistoryWhereInput
  }

  /**
   * CardCountOutputType without action
   */
  export type CardCountOutputTypeCountInitiatedBattlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MABattleWhereInput
  }

  /**
   * CardCountOutputType without action
   */
  export type CardCountOutputTypeCountTargetedBattlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MABattleWhereInput
  }


  /**
   * Count Type MarketplaceListingCountOutputType
   */

  export type MarketplaceListingCountOutputType = {
    bids: number
  }

  export type MarketplaceListingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bids?: boolean | MarketplaceListingCountOutputTypeCountBidsArgs
  }

  // Custom InputTypes
  /**
   * MarketplaceListingCountOutputType without action
   */
  export type MarketplaceListingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceListingCountOutputType
     */
    select?: MarketplaceListingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MarketplaceListingCountOutputType without action
   */
  export type MarketplaceListingCountOutputTypeCountBidsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BidWhereInput
  }


  /**
   * Count Type AppOrderCountOutputType
   */

  export type AppOrderCountOutputType = {
    revisions: number
    communications: number
    deliverables: number
  }

  export type AppOrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    revisions?: boolean | AppOrderCountOutputTypeCountRevisionsArgs
    communications?: boolean | AppOrderCountOutputTypeCountCommunicationsArgs
    deliverables?: boolean | AppOrderCountOutputTypeCountDeliverablesArgs
  }

  // Custom InputTypes
  /**
   * AppOrderCountOutputType without action
   */
  export type AppOrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppOrderCountOutputType
     */
    select?: AppOrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AppOrderCountOutputType without action
   */
  export type AppOrderCountOutputTypeCountRevisionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderRevisionWhereInput
  }

  /**
   * AppOrderCountOutputType without action
   */
  export type AppOrderCountOutputTypeCountCommunicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderCommunicationWhereInput
  }

  /**
   * AppOrderCountOutputType without action
   */
  export type AppOrderCountOutputTypeCountDeliverablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderDeliverableWhereInput
  }


  /**
   * Count Type BettingMarketCountOutputType
   */

  export type BettingMarketCountOutputType = {
    positions: number
    payouts: number
    metrics: number
  }

  export type BettingMarketCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    positions?: boolean | BettingMarketCountOutputTypeCountPositionsArgs
    payouts?: boolean | BettingMarketCountOutputTypeCountPayoutsArgs
    metrics?: boolean | BettingMarketCountOutputTypeCountMetricsArgs
  }

  // Custom InputTypes
  /**
   * BettingMarketCountOutputType without action
   */
  export type BettingMarketCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BettingMarketCountOutputType
     */
    select?: BettingMarketCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BettingMarketCountOutputType without action
   */
  export type BettingMarketCountOutputTypeCountPositionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BettingPositionWhereInput
  }

  /**
   * BettingMarketCountOutputType without action
   */
  export type BettingMarketCountOutputTypeCountPayoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BettingPayoutWhereInput
  }

  /**
   * BettingMarketCountOutputType without action
   */
  export type BettingMarketCountOutputTypeCountMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketMetricsWhereInput
  }


  /**
   * Count Type CardAuctionCountOutputType
   */

  export type CardAuctionCountOutputType = {
    bids: number
    watchers: number
    history: number
  }

  export type CardAuctionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bids?: boolean | CardAuctionCountOutputTypeCountBidsArgs
    watchers?: boolean | CardAuctionCountOutputTypeCountWatchersArgs
    history?: boolean | CardAuctionCountOutputTypeCountHistoryArgs
  }

  // Custom InputTypes
  /**
   * CardAuctionCountOutputType without action
   */
  export type CardAuctionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardAuctionCountOutputType
     */
    select?: CardAuctionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CardAuctionCountOutputType without action
   */
  export type CardAuctionCountOutputTypeCountBidsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuctionBidWhereInput
  }

  /**
   * CardAuctionCountOutputType without action
   */
  export type CardAuctionCountOutputTypeCountWatchersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuctionWatcherWhereInput
  }

  /**
   * CardAuctionCountOutputType without action
   */
  export type CardAuctionCountOutputTypeCountHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuctionHistoryWhereInput
  }


  /**
   * Count Type MABattleCountOutputType
   */

  export type MABattleCountOutputType = {
    proposals: number
    votes: number
    outcomes: number
  }

  export type MABattleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proposals?: boolean | MABattleCountOutputTypeCountProposalsArgs
    votes?: boolean | MABattleCountOutputTypeCountVotesArgs
    outcomes?: boolean | MABattleCountOutputTypeCountOutcomesArgs
  }

  // Custom InputTypes
  /**
   * MABattleCountOutputType without action
   */
  export type MABattleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MABattleCountOutputType
     */
    select?: MABattleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MABattleCountOutputType without action
   */
  export type MABattleCountOutputTypeCountProposalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BattleProposalWhereInput
  }

  /**
   * MABattleCountOutputType without action
   */
  export type MABattleCountOutputTypeCountVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BattleVotingWhereInput
  }

  /**
   * MABattleCountOutputType without action
   */
  export type MABattleCountOutputTypeCountOutcomesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BattleOutcomeWhereInput
  }


  /**
   * Count Type BattleProposalCountOutputType
   */

  export type BattleProposalCountOutputType = {
    votes: number
  }

  export type BattleProposalCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    votes?: boolean | BattleProposalCountOutputTypeCountVotesArgs
  }

  // Custom InputTypes
  /**
   * BattleProposalCountOutputType without action
   */
  export type BattleProposalCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BattleProposalCountOutputType
     */
    select?: BattleProposalCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BattleProposalCountOutputType without action
   */
  export type BattleProposalCountOutputTypeCountVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BattleVotingWhereInput
  }


  /**
   * Count Type StakingPoolCountOutputType
   */

  export type StakingPoolCountOutputType = {
    stakes: number
    rewards: number
  }

  export type StakingPoolCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stakes?: boolean | StakingPoolCountOutputTypeCountStakesArgs
    rewards?: boolean | StakingPoolCountOutputTypeCountRewardsArgs
  }

  // Custom InputTypes
  /**
   * StakingPoolCountOutputType without action
   */
  export type StakingPoolCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakingPoolCountOutputType
     */
    select?: StakingPoolCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StakingPoolCountOutputType without action
   */
  export type StakingPoolCountOutputTypeCountStakesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StakingPositionWhereInput
  }

  /**
   * StakingPoolCountOutputType without action
   */
  export type StakingPoolCountOutputTypeCountRewardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StakingRewardWhereInput
  }


  /**
   * Count Type StakingPositionCountOutputType
   */

  export type StakingPositionCountOutputType = {
    rewards: number
  }

  export type StakingPositionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rewards?: boolean | StakingPositionCountOutputTypeCountRewardsArgs
  }

  // Custom InputTypes
  /**
   * StakingPositionCountOutputType without action
   */
  export type StakingPositionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakingPositionCountOutputType
     */
    select?: StakingPositionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StakingPositionCountOutputType without action
   */
  export type StakingPositionCountOutputTypeCountRewardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StakingRewardWhereInput
  }


  /**
   * Count Type GovernanceProposalCountOutputType
   */

  export type GovernanceProposalCountOutputType = {
    votes: number
  }

  export type GovernanceProposalCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    votes?: boolean | GovernanceProposalCountOutputTypeCountVotesArgs
  }

  // Custom InputTypes
  /**
   * GovernanceProposalCountOutputType without action
   */
  export type GovernanceProposalCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GovernanceProposalCountOutputType
     */
    select?: GovernanceProposalCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GovernanceProposalCountOutputType without action
   */
  export type GovernanceProposalCountOutputTypeCountVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GovernanceVoteWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    eceBalance: number | null
  }

  export type UserSumAggregateOutputType = {
    eceBalance: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    firstName: string | null
    lastName: string | null
    avatar: string | null
    passwordHash: string | null
    emailVerified: Date | null
    eceBalance: number | null
    createdAt: Date | null
    updatedAt: Date | null
    lastActive: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    firstName: string | null
    lastName: string | null
    avatar: string | null
    passwordHash: string | null
    emailVerified: Date | null
    eceBalance: number | null
    createdAt: Date | null
    updatedAt: Date | null
    lastActive: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    username: number
    firstName: number
    lastName: number
    avatar: number
    passwordHash: number
    emailVerified: number
    eceBalance: number
    createdAt: number
    updatedAt: number
    lastActive: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    eceBalance?: true
  }

  export type UserSumAggregateInputType = {
    eceBalance?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    username?: true
    firstName?: true
    lastName?: true
    avatar?: true
    passwordHash?: true
    emailVerified?: true
    eceBalance?: true
    createdAt?: true
    updatedAt?: true
    lastActive?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    username?: true
    firstName?: true
    lastName?: true
    avatar?: true
    passwordHash?: true
    emailVerified?: true
    eceBalance?: true
    createdAt?: true
    updatedAt?: true
    lastActive?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    username?: true
    firstName?: true
    lastName?: true
    avatar?: true
    passwordHash?: true
    emailVerified?: true
    eceBalance?: true
    createdAt?: true
    updatedAt?: true
    lastActive?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    username: string
    firstName: string | null
    lastName: string | null
    avatar: string | null
    passwordHash: string | null
    emailVerified: Date | null
    eceBalance: number
    createdAt: Date
    updatedAt: Date
    lastActive: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    firstName?: boolean
    lastName?: boolean
    avatar?: boolean
    passwordHash?: boolean
    emailVerified?: boolean
    eceBalance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastActive?: boolean
    subscription?: boolean | User$subscriptionArgs<ExtArgs>
    cryptoWallets?: boolean | User$cryptoWalletsArgs<ExtArgs>
    physicalCard?: boolean | User$physicalCardArgs<ExtArgs>
    ownedCards?: boolean | User$ownedCardsArgs<ExtArgs>
    tradingHistory?: boolean | User$tradingHistoryArgs<ExtArgs>
    bids?: boolean | User$bidsArgs<ExtArgs>
    listings?: boolean | User$listingsArgs<ExtArgs>
    appOrders?: boolean | User$appOrdersArgs<ExtArgs>
    orderRevisions?: boolean | User$orderRevisionsArgs<ExtArgs>
    orderCommunications?: boolean | User$orderCommunicationsArgs<ExtArgs>
    bettingPositions?: boolean | User$bettingPositionsArgs<ExtArgs>
    bettingPayouts?: boolean | User$bettingPayoutsArgs<ExtArgs>
    ownedAuctions?: boolean | User$ownedAuctionsArgs<ExtArgs>
    wonAuctions?: boolean | User$wonAuctionsArgs<ExtArgs>
    placedAuctionBids?: boolean | User$placedAuctionBidsArgs<ExtArgs>
    watchedAuctions?: boolean | User$watchedAuctionsArgs<ExtArgs>
    initiatedMABattles?: boolean | User$initiatedMABattlesArgs<ExtArgs>
    targetedMABattles?: boolean | User$targetedMABattlesArgs<ExtArgs>
    battleProposals?: boolean | User$battleProposalsArgs<ExtArgs>
    battleVotes?: boolean | User$battleVotesArgs<ExtArgs>
    stakingPositions?: boolean | User$stakingPositionsArgs<ExtArgs>
    stakingRewards?: boolean | User$stakingRewardsArgs<ExtArgs>
    governanceProposals?: boolean | User$governanceProposalsArgs<ExtArgs>
    governanceVotes?: boolean | User$governanceVotesArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    socialFeeds?: boolean | User$socialFeedsArgs<ExtArgs>
    followers?: boolean | User$followersArgs<ExtArgs>
    following?: boolean | User$followingArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    firstName?: boolean
    lastName?: boolean
    avatar?: boolean
    passwordHash?: boolean
    emailVerified?: boolean
    eceBalance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastActive?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    firstName?: boolean
    lastName?: boolean
    avatar?: boolean
    passwordHash?: boolean
    emailVerified?: boolean
    eceBalance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastActive?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    username?: boolean
    firstName?: boolean
    lastName?: boolean
    avatar?: boolean
    passwordHash?: boolean
    emailVerified?: boolean
    eceBalance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastActive?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "username" | "firstName" | "lastName" | "avatar" | "passwordHash" | "emailVerified" | "eceBalance" | "createdAt" | "updatedAt" | "lastActive", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | User$subscriptionArgs<ExtArgs>
    cryptoWallets?: boolean | User$cryptoWalletsArgs<ExtArgs>
    physicalCard?: boolean | User$physicalCardArgs<ExtArgs>
    ownedCards?: boolean | User$ownedCardsArgs<ExtArgs>
    tradingHistory?: boolean | User$tradingHistoryArgs<ExtArgs>
    bids?: boolean | User$bidsArgs<ExtArgs>
    listings?: boolean | User$listingsArgs<ExtArgs>
    appOrders?: boolean | User$appOrdersArgs<ExtArgs>
    orderRevisions?: boolean | User$orderRevisionsArgs<ExtArgs>
    orderCommunications?: boolean | User$orderCommunicationsArgs<ExtArgs>
    bettingPositions?: boolean | User$bettingPositionsArgs<ExtArgs>
    bettingPayouts?: boolean | User$bettingPayoutsArgs<ExtArgs>
    ownedAuctions?: boolean | User$ownedAuctionsArgs<ExtArgs>
    wonAuctions?: boolean | User$wonAuctionsArgs<ExtArgs>
    placedAuctionBids?: boolean | User$placedAuctionBidsArgs<ExtArgs>
    watchedAuctions?: boolean | User$watchedAuctionsArgs<ExtArgs>
    initiatedMABattles?: boolean | User$initiatedMABattlesArgs<ExtArgs>
    targetedMABattles?: boolean | User$targetedMABattlesArgs<ExtArgs>
    battleProposals?: boolean | User$battleProposalsArgs<ExtArgs>
    battleVotes?: boolean | User$battleVotesArgs<ExtArgs>
    stakingPositions?: boolean | User$stakingPositionsArgs<ExtArgs>
    stakingRewards?: boolean | User$stakingRewardsArgs<ExtArgs>
    governanceProposals?: boolean | User$governanceProposalsArgs<ExtArgs>
    governanceVotes?: boolean | User$governanceVotesArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    socialFeeds?: boolean | User$socialFeedsArgs<ExtArgs>
    followers?: boolean | User$followersArgs<ExtArgs>
    following?: boolean | User$followingArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      subscription: Prisma.$UserSubscriptionPayload<ExtArgs> | null
      cryptoWallets: Prisma.$CryptoWalletPayload<ExtArgs>[]
      physicalCard: Prisma.$PhysicalCardPayload<ExtArgs> | null
      ownedCards: Prisma.$CardPayload<ExtArgs>[]
      tradingHistory: Prisma.$TransactionPayload<ExtArgs>[]
      bids: Prisma.$BidPayload<ExtArgs>[]
      listings: Prisma.$MarketplaceListingPayload<ExtArgs>[]
      appOrders: Prisma.$AppOrderPayload<ExtArgs>[]
      orderRevisions: Prisma.$OrderRevisionPayload<ExtArgs>[]
      orderCommunications: Prisma.$OrderCommunicationPayload<ExtArgs>[]
      bettingPositions: Prisma.$BettingPositionPayload<ExtArgs>[]
      bettingPayouts: Prisma.$BettingPayoutPayload<ExtArgs>[]
      ownedAuctions: Prisma.$CardAuctionPayload<ExtArgs>[]
      wonAuctions: Prisma.$CardAuctionPayload<ExtArgs>[]
      placedAuctionBids: Prisma.$AuctionBidPayload<ExtArgs>[]
      watchedAuctions: Prisma.$AuctionWatcherPayload<ExtArgs>[]
      initiatedMABattles: Prisma.$MABattlePayload<ExtArgs>[]
      targetedMABattles: Prisma.$MABattlePayload<ExtArgs>[]
      battleProposals: Prisma.$BattleProposalPayload<ExtArgs>[]
      battleVotes: Prisma.$BattleVotingPayload<ExtArgs>[]
      stakingPositions: Prisma.$StakingPositionPayload<ExtArgs>[]
      stakingRewards: Prisma.$StakingRewardPayload<ExtArgs>[]
      governanceProposals: Prisma.$GovernanceProposalPayload<ExtArgs>[]
      governanceVotes: Prisma.$GovernanceVotePayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      socialFeeds: Prisma.$SocialFeedPayload<ExtArgs>[]
      followers: Prisma.$FollowPayload<ExtArgs>[]
      following: Prisma.$FollowPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      username: string
      firstName: string | null
      lastName: string | null
      avatar: string | null
      passwordHash: string | null
      emailVerified: Date | null
      eceBalance: number
      createdAt: Date
      updatedAt: Date
      lastActive: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscription<T extends User$subscriptionArgs<ExtArgs> = {}>(args?: Subset<T, User$subscriptionArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    cryptoWallets<T extends User$cryptoWalletsArgs<ExtArgs> = {}>(args?: Subset<T, User$cryptoWalletsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CryptoWalletPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    physicalCard<T extends User$physicalCardArgs<ExtArgs> = {}>(args?: Subset<T, User$physicalCardArgs<ExtArgs>>): Prisma__PhysicalCardClient<$Result.GetResult<Prisma.$PhysicalCardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    ownedCards<T extends User$ownedCardsArgs<ExtArgs> = {}>(args?: Subset<T, User$ownedCardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tradingHistory<T extends User$tradingHistoryArgs<ExtArgs> = {}>(args?: Subset<T, User$tradingHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bids<T extends User$bidsArgs<ExtArgs> = {}>(args?: Subset<T, User$bidsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    listings<T extends User$listingsArgs<ExtArgs> = {}>(args?: Subset<T, User$listingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketplaceListingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    appOrders<T extends User$appOrdersArgs<ExtArgs> = {}>(args?: Subset<T, User$appOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orderRevisions<T extends User$orderRevisionsArgs<ExtArgs> = {}>(args?: Subset<T, User$orderRevisionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderRevisionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orderCommunications<T extends User$orderCommunicationsArgs<ExtArgs> = {}>(args?: Subset<T, User$orderCommunicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderCommunicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bettingPositions<T extends User$bettingPositionsArgs<ExtArgs> = {}>(args?: Subset<T, User$bettingPositionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BettingPositionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bettingPayouts<T extends User$bettingPayoutsArgs<ExtArgs> = {}>(args?: Subset<T, User$bettingPayoutsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BettingPayoutPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ownedAuctions<T extends User$ownedAuctionsArgs<ExtArgs> = {}>(args?: Subset<T, User$ownedAuctionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CardAuctionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    wonAuctions<T extends User$wonAuctionsArgs<ExtArgs> = {}>(args?: Subset<T, User$wonAuctionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CardAuctionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    placedAuctionBids<T extends User$placedAuctionBidsArgs<ExtArgs> = {}>(args?: Subset<T, User$placedAuctionBidsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuctionBidPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    watchedAuctions<T extends User$watchedAuctionsArgs<ExtArgs> = {}>(args?: Subset<T, User$watchedAuctionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuctionWatcherPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    initiatedMABattles<T extends User$initiatedMABattlesArgs<ExtArgs> = {}>(args?: Subset<T, User$initiatedMABattlesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MABattlePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    targetedMABattles<T extends User$targetedMABattlesArgs<ExtArgs> = {}>(args?: Subset<T, User$targetedMABattlesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MABattlePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    battleProposals<T extends User$battleProposalsArgs<ExtArgs> = {}>(args?: Subset<T, User$battleProposalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BattleProposalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    battleVotes<T extends User$battleVotesArgs<ExtArgs> = {}>(args?: Subset<T, User$battleVotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BattleVotingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stakingPositions<T extends User$stakingPositionsArgs<ExtArgs> = {}>(args?: Subset<T, User$stakingPositionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StakingPositionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stakingRewards<T extends User$stakingRewardsArgs<ExtArgs> = {}>(args?: Subset<T, User$stakingRewardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StakingRewardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    governanceProposals<T extends User$governanceProposalsArgs<ExtArgs> = {}>(args?: Subset<T, User$governanceProposalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GovernanceProposalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    governanceVotes<T extends User$governanceVotesArgs<ExtArgs> = {}>(args?: Subset<T, User$governanceVotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GovernanceVotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    socialFeeds<T extends User$socialFeedsArgs<ExtArgs> = {}>(args?: Subset<T, User$socialFeedsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialFeedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    followers<T extends User$followersArgs<ExtArgs> = {}>(args?: Subset<T, User$followersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    following<T extends User$followingArgs<ExtArgs> = {}>(args?: Subset<T, User$followingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly eceBalance: FieldRef<"User", 'Float'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly lastActive: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.subscription
   */
  export type User$subscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    where?: UserSubscriptionWhereInput
  }

  /**
   * User.cryptoWallets
   */
  export type User$cryptoWalletsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoWallet
     */
    select?: CryptoWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoWallet
     */
    omit?: CryptoWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoWalletInclude<ExtArgs> | null
    where?: CryptoWalletWhereInput
    orderBy?: CryptoWalletOrderByWithRelationInput | CryptoWalletOrderByWithRelationInput[]
    cursor?: CryptoWalletWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CryptoWalletScalarFieldEnum | CryptoWalletScalarFieldEnum[]
  }

  /**
   * User.physicalCard
   */
  export type User$physicalCardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhysicalCard
     */
    select?: PhysicalCardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhysicalCard
     */
    omit?: PhysicalCardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhysicalCardInclude<ExtArgs> | null
    where?: PhysicalCardWhereInput
  }

  /**
   * User.ownedCards
   */
  export type User$ownedCardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Card
     */
    omit?: CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardInclude<ExtArgs> | null
    where?: CardWhereInput
    orderBy?: CardOrderByWithRelationInput | CardOrderByWithRelationInput[]
    cursor?: CardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CardScalarFieldEnum | CardScalarFieldEnum[]
  }

  /**
   * User.tradingHistory
   */
  export type User$tradingHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * User.bids
   */
  export type User$bidsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bid
     */
    omit?: BidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
    where?: BidWhereInput
    orderBy?: BidOrderByWithRelationInput | BidOrderByWithRelationInput[]
    cursor?: BidWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BidScalarFieldEnum | BidScalarFieldEnum[]
  }

  /**
   * User.listings
   */
  export type User$listingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceListing
     */
    select?: MarketplaceListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceListing
     */
    omit?: MarketplaceListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceListingInclude<ExtArgs> | null
    where?: MarketplaceListingWhereInput
    orderBy?: MarketplaceListingOrderByWithRelationInput | MarketplaceListingOrderByWithRelationInput[]
    cursor?: MarketplaceListingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MarketplaceListingScalarFieldEnum | MarketplaceListingScalarFieldEnum[]
  }

  /**
   * User.appOrders
   */
  export type User$appOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppOrder
     */
    select?: AppOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppOrder
     */
    omit?: AppOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppOrderInclude<ExtArgs> | null
    where?: AppOrderWhereInput
    orderBy?: AppOrderOrderByWithRelationInput | AppOrderOrderByWithRelationInput[]
    cursor?: AppOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppOrderScalarFieldEnum | AppOrderScalarFieldEnum[]
  }

  /**
   * User.orderRevisions
   */
  export type User$orderRevisionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderRevision
     */
    select?: OrderRevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderRevision
     */
    omit?: OrderRevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderRevisionInclude<ExtArgs> | null
    where?: OrderRevisionWhereInput
    orderBy?: OrderRevisionOrderByWithRelationInput | OrderRevisionOrderByWithRelationInput[]
    cursor?: OrderRevisionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderRevisionScalarFieldEnum | OrderRevisionScalarFieldEnum[]
  }

  /**
   * User.orderCommunications
   */
  export type User$orderCommunicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCommunication
     */
    select?: OrderCommunicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderCommunication
     */
    omit?: OrderCommunicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderCommunicationInclude<ExtArgs> | null
    where?: OrderCommunicationWhereInput
    orderBy?: OrderCommunicationOrderByWithRelationInput | OrderCommunicationOrderByWithRelationInput[]
    cursor?: OrderCommunicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderCommunicationScalarFieldEnum | OrderCommunicationScalarFieldEnum[]
  }

  /**
   * User.bettingPositions
   */
  export type User$bettingPositionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BettingPosition
     */
    select?: BettingPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BettingPosition
     */
    omit?: BettingPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BettingPositionInclude<ExtArgs> | null
    where?: BettingPositionWhereInput
    orderBy?: BettingPositionOrderByWithRelationInput | BettingPositionOrderByWithRelationInput[]
    cursor?: BettingPositionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BettingPositionScalarFieldEnum | BettingPositionScalarFieldEnum[]
  }

  /**
   * User.bettingPayouts
   */
  export type User$bettingPayoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BettingPayout
     */
    select?: BettingPayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BettingPayout
     */
    omit?: BettingPayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BettingPayoutInclude<ExtArgs> | null
    where?: BettingPayoutWhereInput
    orderBy?: BettingPayoutOrderByWithRelationInput | BettingPayoutOrderByWithRelationInput[]
    cursor?: BettingPayoutWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BettingPayoutScalarFieldEnum | BettingPayoutScalarFieldEnum[]
  }

  /**
   * User.ownedAuctions
   */
  export type User$ownedAuctionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardAuction
     */
    select?: CardAuctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardAuction
     */
    omit?: CardAuctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardAuctionInclude<ExtArgs> | null
    where?: CardAuctionWhereInput
    orderBy?: CardAuctionOrderByWithRelationInput | CardAuctionOrderByWithRelationInput[]
    cursor?: CardAuctionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CardAuctionScalarFieldEnum | CardAuctionScalarFieldEnum[]
  }

  /**
   * User.wonAuctions
   */
  export type User$wonAuctionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardAuction
     */
    select?: CardAuctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardAuction
     */
    omit?: CardAuctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardAuctionInclude<ExtArgs> | null
    where?: CardAuctionWhereInput
    orderBy?: CardAuctionOrderByWithRelationInput | CardAuctionOrderByWithRelationInput[]
    cursor?: CardAuctionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CardAuctionScalarFieldEnum | CardAuctionScalarFieldEnum[]
  }

  /**
   * User.placedAuctionBids
   */
  export type User$placedAuctionBidsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionBid
     */
    select?: AuctionBidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionBid
     */
    omit?: AuctionBidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionBidInclude<ExtArgs> | null
    where?: AuctionBidWhereInput
    orderBy?: AuctionBidOrderByWithRelationInput | AuctionBidOrderByWithRelationInput[]
    cursor?: AuctionBidWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuctionBidScalarFieldEnum | AuctionBidScalarFieldEnum[]
  }

  /**
   * User.watchedAuctions
   */
  export type User$watchedAuctionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionWatcher
     */
    select?: AuctionWatcherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionWatcher
     */
    omit?: AuctionWatcherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionWatcherInclude<ExtArgs> | null
    where?: AuctionWatcherWhereInput
    orderBy?: AuctionWatcherOrderByWithRelationInput | AuctionWatcherOrderByWithRelationInput[]
    cursor?: AuctionWatcherWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuctionWatcherScalarFieldEnum | AuctionWatcherScalarFieldEnum[]
  }

  /**
   * User.initiatedMABattles
   */
  export type User$initiatedMABattlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MABattle
     */
    select?: MABattleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MABattle
     */
    omit?: MABattleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MABattleInclude<ExtArgs> | null
    where?: MABattleWhereInput
    orderBy?: MABattleOrderByWithRelationInput | MABattleOrderByWithRelationInput[]
    cursor?: MABattleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MABattleScalarFieldEnum | MABattleScalarFieldEnum[]
  }

  /**
   * User.targetedMABattles
   */
  export type User$targetedMABattlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MABattle
     */
    select?: MABattleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MABattle
     */
    omit?: MABattleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MABattleInclude<ExtArgs> | null
    where?: MABattleWhereInput
    orderBy?: MABattleOrderByWithRelationInput | MABattleOrderByWithRelationInput[]
    cursor?: MABattleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MABattleScalarFieldEnum | MABattleScalarFieldEnum[]
  }

  /**
   * User.battleProposals
   */
  export type User$battleProposalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BattleProposal
     */
    select?: BattleProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BattleProposal
     */
    omit?: BattleProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleProposalInclude<ExtArgs> | null
    where?: BattleProposalWhereInput
    orderBy?: BattleProposalOrderByWithRelationInput | BattleProposalOrderByWithRelationInput[]
    cursor?: BattleProposalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BattleProposalScalarFieldEnum | BattleProposalScalarFieldEnum[]
  }

  /**
   * User.battleVotes
   */
  export type User$battleVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BattleVoting
     */
    select?: BattleVotingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BattleVoting
     */
    omit?: BattleVotingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleVotingInclude<ExtArgs> | null
    where?: BattleVotingWhereInput
    orderBy?: BattleVotingOrderByWithRelationInput | BattleVotingOrderByWithRelationInput[]
    cursor?: BattleVotingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BattleVotingScalarFieldEnum | BattleVotingScalarFieldEnum[]
  }

  /**
   * User.stakingPositions
   */
  export type User$stakingPositionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakingPosition
     */
    select?: StakingPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakingPosition
     */
    omit?: StakingPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakingPositionInclude<ExtArgs> | null
    where?: StakingPositionWhereInput
    orderBy?: StakingPositionOrderByWithRelationInput | StakingPositionOrderByWithRelationInput[]
    cursor?: StakingPositionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StakingPositionScalarFieldEnum | StakingPositionScalarFieldEnum[]
  }

  /**
   * User.stakingRewards
   */
  export type User$stakingRewardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakingReward
     */
    select?: StakingRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakingReward
     */
    omit?: StakingRewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakingRewardInclude<ExtArgs> | null
    where?: StakingRewardWhereInput
    orderBy?: StakingRewardOrderByWithRelationInput | StakingRewardOrderByWithRelationInput[]
    cursor?: StakingRewardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StakingRewardScalarFieldEnum | StakingRewardScalarFieldEnum[]
  }

  /**
   * User.governanceProposals
   */
  export type User$governanceProposalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GovernanceProposal
     */
    select?: GovernanceProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GovernanceProposal
     */
    omit?: GovernanceProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GovernanceProposalInclude<ExtArgs> | null
    where?: GovernanceProposalWhereInput
    orderBy?: GovernanceProposalOrderByWithRelationInput | GovernanceProposalOrderByWithRelationInput[]
    cursor?: GovernanceProposalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GovernanceProposalScalarFieldEnum | GovernanceProposalScalarFieldEnum[]
  }

  /**
   * User.governanceVotes
   */
  export type User$governanceVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GovernanceVote
     */
    select?: GovernanceVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GovernanceVote
     */
    omit?: GovernanceVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GovernanceVoteInclude<ExtArgs> | null
    where?: GovernanceVoteWhereInput
    orderBy?: GovernanceVoteOrderByWithRelationInput | GovernanceVoteOrderByWithRelationInput[]
    cursor?: GovernanceVoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GovernanceVoteScalarFieldEnum | GovernanceVoteScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.socialFeeds
   */
  export type User$socialFeedsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialFeed
     */
    select?: SocialFeedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialFeed
     */
    omit?: SocialFeedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialFeedInclude<ExtArgs> | null
    where?: SocialFeedWhereInput
    orderBy?: SocialFeedOrderByWithRelationInput | SocialFeedOrderByWithRelationInput[]
    cursor?: SocialFeedWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SocialFeedScalarFieldEnum | SocialFeedScalarFieldEnum[]
  }

  /**
   * User.followers
   */
  export type User$followersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    where?: FollowWhereInput
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    cursor?: FollowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * User.following
   */
  export type User$followingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    where?: FollowWhereInput
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    cursor?: FollowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserSubscription
   */

  export type AggregateUserSubscription = {
    _count: UserSubscriptionCountAggregateOutputType | null
    _min: UserSubscriptionMinAggregateOutputType | null
    _max: UserSubscriptionMaxAggregateOutputType | null
  }

  export type UserSubscriptionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    plan: $Enums.SubscriptionPlan | null
    status: $Enums.SubscriptionStatus | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    cancelAtPeriodEnd: boolean | null
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserSubscriptionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    plan: $Enums.SubscriptionPlan | null
    status: $Enums.SubscriptionStatus | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    cancelAtPeriodEnd: boolean | null
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserSubscriptionCountAggregateOutputType = {
    id: number
    userId: number
    plan: number
    status: number
    currentPeriodStart: number
    currentPeriodEnd: number
    cancelAtPeriodEnd: number
    stripeCustomerId: number
    stripeSubscriptionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserSubscriptionMinAggregateInputType = {
    id?: true
    userId?: true
    plan?: true
    status?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelAtPeriodEnd?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserSubscriptionMaxAggregateInputType = {
    id?: true
    userId?: true
    plan?: true
    status?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelAtPeriodEnd?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserSubscriptionCountAggregateInputType = {
    id?: true
    userId?: true
    plan?: true
    status?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelAtPeriodEnd?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserSubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSubscription to aggregate.
     */
    where?: UserSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSubscriptions to fetch.
     */
    orderBy?: UserSubscriptionOrderByWithRelationInput | UserSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSubscriptions
    **/
    _count?: true | UserSubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSubscriptionMaxAggregateInputType
  }

  export type GetUserSubscriptionAggregateType<T extends UserSubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSubscription[P]>
      : GetScalarType<T[P], AggregateUserSubscription[P]>
  }




  export type UserSubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSubscriptionWhereInput
    orderBy?: UserSubscriptionOrderByWithAggregationInput | UserSubscriptionOrderByWithAggregationInput[]
    by: UserSubscriptionScalarFieldEnum[] | UserSubscriptionScalarFieldEnum
    having?: UserSubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSubscriptionCountAggregateInputType | true
    _min?: UserSubscriptionMinAggregateInputType
    _max?: UserSubscriptionMaxAggregateInputType
  }

  export type UserSubscriptionGroupByOutputType = {
    id: string
    userId: string
    plan: $Enums.SubscriptionPlan
    status: $Enums.SubscriptionStatus
    currentPeriodStart: Date
    currentPeriodEnd: Date
    cancelAtPeriodEnd: boolean
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserSubscriptionCountAggregateOutputType | null
    _min: UserSubscriptionMinAggregateOutputType | null
    _max: UserSubscriptionMaxAggregateOutputType | null
  }

  type GetUserSubscriptionGroupByPayload<T extends UserSubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], UserSubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type UserSubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    plan?: boolean
    status?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    features?: boolean | UserSubscription$featuresArgs<ExtArgs>
    usage?: boolean | UserSubscription$usageArgs<ExtArgs>
  }, ExtArgs["result"]["userSubscription"]>

  export type UserSubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    plan?: boolean
    status?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSubscription"]>

  export type UserSubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    plan?: boolean
    status?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSubscription"]>

  export type UserSubscriptionSelectScalar = {
    id?: boolean
    userId?: boolean
    plan?: boolean
    status?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserSubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "plan" | "status" | "currentPeriodStart" | "currentPeriodEnd" | "cancelAtPeriodEnd" | "stripeCustomerId" | "stripeSubscriptionId" | "createdAt" | "updatedAt", ExtArgs["result"]["userSubscription"]>
  export type UserSubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    features?: boolean | UserSubscription$featuresArgs<ExtArgs>
    usage?: boolean | UserSubscription$usageArgs<ExtArgs>
  }
  export type UserSubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSubscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserSubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSubscription"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      features: Prisma.$SubscriptionFeaturesPayload<ExtArgs> | null
      usage: Prisma.$SubscriptionUsagePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      plan: $Enums.SubscriptionPlan
      status: $Enums.SubscriptionStatus
      currentPeriodStart: Date
      currentPeriodEnd: Date
      cancelAtPeriodEnd: boolean
      stripeCustomerId: string | null
      stripeSubscriptionId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userSubscription"]>
    composites: {}
  }

  type UserSubscriptionGetPayload<S extends boolean | null | undefined | UserSubscriptionDefaultArgs> = $Result.GetResult<Prisma.$UserSubscriptionPayload, S>

  type UserSubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserSubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserSubscriptionCountAggregateInputType | true
    }

  export interface UserSubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSubscription'], meta: { name: 'UserSubscription' } }
    /**
     * Find zero or one UserSubscription that matches the filter.
     * @param {UserSubscriptionFindUniqueArgs} args - Arguments to find a UserSubscription
     * @example
     * // Get one UserSubscription
     * const userSubscription = await prisma.userSubscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSubscriptionFindUniqueArgs>(args: SelectSubset<T, UserSubscriptionFindUniqueArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserSubscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserSubscriptionFindUniqueOrThrowArgs} args - Arguments to find a UserSubscription
     * @example
     * // Get one UserSubscription
     * const userSubscription = await prisma.userSubscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSubscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionFindFirstArgs} args - Arguments to find a UserSubscription
     * @example
     * // Get one UserSubscription
     * const userSubscription = await prisma.userSubscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSubscriptionFindFirstArgs>(args?: SelectSubset<T, UserSubscriptionFindFirstArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSubscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionFindFirstOrThrowArgs} args - Arguments to find a UserSubscription
     * @example
     * // Get one UserSubscription
     * const userSubscription = await prisma.userSubscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserSubscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSubscriptions
     * const userSubscriptions = await prisma.userSubscription.findMany()
     * 
     * // Get first 10 UserSubscriptions
     * const userSubscriptions = await prisma.userSubscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSubscriptionWithIdOnly = await prisma.userSubscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserSubscriptionFindManyArgs>(args?: SelectSubset<T, UserSubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserSubscription.
     * @param {UserSubscriptionCreateArgs} args - Arguments to create a UserSubscription.
     * @example
     * // Create one UserSubscription
     * const UserSubscription = await prisma.userSubscription.create({
     *   data: {
     *     // ... data to create a UserSubscription
     *   }
     * })
     * 
     */
    create<T extends UserSubscriptionCreateArgs>(args: SelectSubset<T, UserSubscriptionCreateArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserSubscriptions.
     * @param {UserSubscriptionCreateManyArgs} args - Arguments to create many UserSubscriptions.
     * @example
     * // Create many UserSubscriptions
     * const userSubscription = await prisma.userSubscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSubscriptionCreateManyArgs>(args?: SelectSubset<T, UserSubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSubscriptions and returns the data saved in the database.
     * @param {UserSubscriptionCreateManyAndReturnArgs} args - Arguments to create many UserSubscriptions.
     * @example
     * // Create many UserSubscriptions
     * const userSubscription = await prisma.userSubscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSubscriptions and only return the `id`
     * const userSubscriptionWithIdOnly = await prisma.userSubscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserSubscription.
     * @param {UserSubscriptionDeleteArgs} args - Arguments to delete one UserSubscription.
     * @example
     * // Delete one UserSubscription
     * const UserSubscription = await prisma.userSubscription.delete({
     *   where: {
     *     // ... filter to delete one UserSubscription
     *   }
     * })
     * 
     */
    delete<T extends UserSubscriptionDeleteArgs>(args: SelectSubset<T, UserSubscriptionDeleteArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserSubscription.
     * @param {UserSubscriptionUpdateArgs} args - Arguments to update one UserSubscription.
     * @example
     * // Update one UserSubscription
     * const userSubscription = await prisma.userSubscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSubscriptionUpdateArgs>(args: SelectSubset<T, UserSubscriptionUpdateArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserSubscriptions.
     * @param {UserSubscriptionDeleteManyArgs} args - Arguments to filter UserSubscriptions to delete.
     * @example
     * // Delete a few UserSubscriptions
     * const { count } = await prisma.userSubscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSubscriptionDeleteManyArgs>(args?: SelectSubset<T, UserSubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSubscriptions
     * const userSubscription = await prisma.userSubscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSubscriptionUpdateManyArgs>(args: SelectSubset<T, UserSubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSubscriptions and returns the data updated in the database.
     * @param {UserSubscriptionUpdateManyAndReturnArgs} args - Arguments to update many UserSubscriptions.
     * @example
     * // Update many UserSubscriptions
     * const userSubscription = await prisma.userSubscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserSubscriptions and only return the `id`
     * const userSubscriptionWithIdOnly = await prisma.userSubscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserSubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, UserSubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserSubscription.
     * @param {UserSubscriptionUpsertArgs} args - Arguments to update or create a UserSubscription.
     * @example
     * // Update or create a UserSubscription
     * const userSubscription = await prisma.userSubscription.upsert({
     *   create: {
     *     // ... data to create a UserSubscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSubscription we want to update
     *   }
     * })
     */
    upsert<T extends UserSubscriptionUpsertArgs>(args: SelectSubset<T, UserSubscriptionUpsertArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionCountArgs} args - Arguments to filter UserSubscriptions to count.
     * @example
     * // Count the number of UserSubscriptions
     * const count = await prisma.userSubscription.count({
     *   where: {
     *     // ... the filter for the UserSubscriptions we want to count
     *   }
     * })
    **/
    count<T extends UserSubscriptionCountArgs>(
      args?: Subset<T, UserSubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSubscriptionAggregateArgs>(args: Subset<T, UserSubscriptionAggregateArgs>): Prisma.PrismaPromise<GetUserSubscriptionAggregateType<T>>

    /**
     * Group by UserSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: UserSubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSubscription model
   */
  readonly fields: UserSubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSubscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    features<T extends UserSubscription$featuresArgs<ExtArgs> = {}>(args?: Subset<T, UserSubscription$featuresArgs<ExtArgs>>): Prisma__SubscriptionFeaturesClient<$Result.GetResult<Prisma.$SubscriptionFeaturesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    usage<T extends UserSubscription$usageArgs<ExtArgs> = {}>(args?: Subset<T, UserSubscription$usageArgs<ExtArgs>>): Prisma__SubscriptionUsageClient<$Result.GetResult<Prisma.$SubscriptionUsagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSubscription model
   */
  interface UserSubscriptionFieldRefs {
    readonly id: FieldRef<"UserSubscription", 'String'>
    readonly userId: FieldRef<"UserSubscription", 'String'>
    readonly plan: FieldRef<"UserSubscription", 'SubscriptionPlan'>
    readonly status: FieldRef<"UserSubscription", 'SubscriptionStatus'>
    readonly currentPeriodStart: FieldRef<"UserSubscription", 'DateTime'>
    readonly currentPeriodEnd: FieldRef<"UserSubscription", 'DateTime'>
    readonly cancelAtPeriodEnd: FieldRef<"UserSubscription", 'Boolean'>
    readonly stripeCustomerId: FieldRef<"UserSubscription", 'String'>
    readonly stripeSubscriptionId: FieldRef<"UserSubscription", 'String'>
    readonly createdAt: FieldRef<"UserSubscription", 'DateTime'>
    readonly updatedAt: FieldRef<"UserSubscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserSubscription findUnique
   */
  export type UserSubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which UserSubscription to fetch.
     */
    where: UserSubscriptionWhereUniqueInput
  }

  /**
   * UserSubscription findUniqueOrThrow
   */
  export type UserSubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which UserSubscription to fetch.
     */
    where: UserSubscriptionWhereUniqueInput
  }

  /**
   * UserSubscription findFirst
   */
  export type UserSubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which UserSubscription to fetch.
     */
    where?: UserSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSubscriptions to fetch.
     */
    orderBy?: UserSubscriptionOrderByWithRelationInput | UserSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSubscriptions.
     */
    cursor?: UserSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSubscriptions.
     */
    distinct?: UserSubscriptionScalarFieldEnum | UserSubscriptionScalarFieldEnum[]
  }

  /**
   * UserSubscription findFirstOrThrow
   */
  export type UserSubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which UserSubscription to fetch.
     */
    where?: UserSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSubscriptions to fetch.
     */
    orderBy?: UserSubscriptionOrderByWithRelationInput | UserSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSubscriptions.
     */
    cursor?: UserSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSubscriptions.
     */
    distinct?: UserSubscriptionScalarFieldEnum | UserSubscriptionScalarFieldEnum[]
  }

  /**
   * UserSubscription findMany
   */
  export type UserSubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which UserSubscriptions to fetch.
     */
    where?: UserSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSubscriptions to fetch.
     */
    orderBy?: UserSubscriptionOrderByWithRelationInput | UserSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSubscriptions.
     */
    cursor?: UserSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSubscriptions.
     */
    skip?: number
    distinct?: UserSubscriptionScalarFieldEnum | UserSubscriptionScalarFieldEnum[]
  }

  /**
   * UserSubscription create
   */
  export type UserSubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSubscription.
     */
    data: XOR<UserSubscriptionCreateInput, UserSubscriptionUncheckedCreateInput>
  }

  /**
   * UserSubscription createMany
   */
  export type UserSubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSubscriptions.
     */
    data: UserSubscriptionCreateManyInput | UserSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSubscription createManyAndReturn
   */
  export type UserSubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many UserSubscriptions.
     */
    data: UserSubscriptionCreateManyInput | UserSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSubscription update
   */
  export type UserSubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSubscription.
     */
    data: XOR<UserSubscriptionUpdateInput, UserSubscriptionUncheckedUpdateInput>
    /**
     * Choose, which UserSubscription to update.
     */
    where: UserSubscriptionWhereUniqueInput
  }

  /**
   * UserSubscription updateMany
   */
  export type UserSubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSubscriptions.
     */
    data: XOR<UserSubscriptionUpdateManyMutationInput, UserSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which UserSubscriptions to update
     */
    where?: UserSubscriptionWhereInput
    /**
     * Limit how many UserSubscriptions to update.
     */
    limit?: number
  }

  /**
   * UserSubscription updateManyAndReturn
   */
  export type UserSubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update UserSubscriptions.
     */
    data: XOR<UserSubscriptionUpdateManyMutationInput, UserSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which UserSubscriptions to update
     */
    where?: UserSubscriptionWhereInput
    /**
     * Limit how many UserSubscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSubscription upsert
   */
  export type UserSubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSubscription to update in case it exists.
     */
    where: UserSubscriptionWhereUniqueInput
    /**
     * In case the UserSubscription found by the `where` argument doesn't exist, create a new UserSubscription with this data.
     */
    create: XOR<UserSubscriptionCreateInput, UserSubscriptionUncheckedCreateInput>
    /**
     * In case the UserSubscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSubscriptionUpdateInput, UserSubscriptionUncheckedUpdateInput>
  }

  /**
   * UserSubscription delete
   */
  export type UserSubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * Filter which UserSubscription to delete.
     */
    where: UserSubscriptionWhereUniqueInput
  }

  /**
   * UserSubscription deleteMany
   */
  export type UserSubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSubscriptions to delete
     */
    where?: UserSubscriptionWhereInput
    /**
     * Limit how many UserSubscriptions to delete.
     */
    limit?: number
  }

  /**
   * UserSubscription.features
   */
  export type UserSubscription$featuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionFeatures
     */
    select?: SubscriptionFeaturesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionFeatures
     */
    omit?: SubscriptionFeaturesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionFeaturesInclude<ExtArgs> | null
    where?: SubscriptionFeaturesWhereInput
  }

  /**
   * UserSubscription.usage
   */
  export type UserSubscription$usageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionUsage
     */
    select?: SubscriptionUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionUsage
     */
    omit?: SubscriptionUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionUsageInclude<ExtArgs> | null
    where?: SubscriptionUsageWhereInput
  }

  /**
   * UserSubscription without action
   */
  export type UserSubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model SubscriptionFeatures
   */

  export type AggregateSubscriptionFeatures = {
    _count: SubscriptionFeaturesCountAggregateOutputType | null
    _avg: SubscriptionFeaturesAvgAggregateOutputType | null
    _sum: SubscriptionFeaturesSumAggregateOutputType | null
    _min: SubscriptionFeaturesMinAggregateOutputType | null
    _max: SubscriptionFeaturesMaxAggregateOutputType | null
  }

  export type SubscriptionFeaturesAvgAggregateOutputType = {
    maxTrades: number | null
    businessStipend: number | null
    withdrawalLimit: number | null
  }

  export type SubscriptionFeaturesSumAggregateOutputType = {
    maxTrades: number | null
    businessStipend: number | null
    withdrawalLimit: number | null
  }

  export type SubscriptionFeaturesMinAggregateOutputType = {
    id: string | null
    subscriptionId: string | null
    maxTrades: number | null
    advancedAnalytics: boolean | null
    prioritySupport: boolean | null
    marketplaceAccess: boolean | null
    premiumListings: boolean | null
    bulkOperations: boolean | null
    cryptoPayments: boolean | null
    physicalCard: boolean | null
    businessStipend: number | null
    withdrawalLimit: number | null
  }

  export type SubscriptionFeaturesMaxAggregateOutputType = {
    id: string | null
    subscriptionId: string | null
    maxTrades: number | null
    advancedAnalytics: boolean | null
    prioritySupport: boolean | null
    marketplaceAccess: boolean | null
    premiumListings: boolean | null
    bulkOperations: boolean | null
    cryptoPayments: boolean | null
    physicalCard: boolean | null
    businessStipend: number | null
    withdrawalLimit: number | null
  }

  export type SubscriptionFeaturesCountAggregateOutputType = {
    id: number
    subscriptionId: number
    maxTrades: number
    advancedAnalytics: number
    prioritySupport: number
    marketplaceAccess: number
    premiumListings: number
    bulkOperations: number
    cryptoPayments: number
    physicalCard: number
    businessStipend: number
    withdrawalLimit: number
    _all: number
  }


  export type SubscriptionFeaturesAvgAggregateInputType = {
    maxTrades?: true
    businessStipend?: true
    withdrawalLimit?: true
  }

  export type SubscriptionFeaturesSumAggregateInputType = {
    maxTrades?: true
    businessStipend?: true
    withdrawalLimit?: true
  }

  export type SubscriptionFeaturesMinAggregateInputType = {
    id?: true
    subscriptionId?: true
    maxTrades?: true
    advancedAnalytics?: true
    prioritySupport?: true
    marketplaceAccess?: true
    premiumListings?: true
    bulkOperations?: true
    cryptoPayments?: true
    physicalCard?: true
    businessStipend?: true
    withdrawalLimit?: true
  }

  export type SubscriptionFeaturesMaxAggregateInputType = {
    id?: true
    subscriptionId?: true
    maxTrades?: true
    advancedAnalytics?: true
    prioritySupport?: true
    marketplaceAccess?: true
    premiumListings?: true
    bulkOperations?: true
    cryptoPayments?: true
    physicalCard?: true
    businessStipend?: true
    withdrawalLimit?: true
  }

  export type SubscriptionFeaturesCountAggregateInputType = {
    id?: true
    subscriptionId?: true
    maxTrades?: true
    advancedAnalytics?: true
    prioritySupport?: true
    marketplaceAccess?: true
    premiumListings?: true
    bulkOperations?: true
    cryptoPayments?: true
    physicalCard?: true
    businessStipend?: true
    withdrawalLimit?: true
    _all?: true
  }

  export type SubscriptionFeaturesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubscriptionFeatures to aggregate.
     */
    where?: SubscriptionFeaturesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionFeatures to fetch.
     */
    orderBy?: SubscriptionFeaturesOrderByWithRelationInput | SubscriptionFeaturesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionFeaturesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubscriptionFeatures
    **/
    _count?: true | SubscriptionFeaturesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionFeaturesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionFeaturesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionFeaturesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionFeaturesMaxAggregateInputType
  }

  export type GetSubscriptionFeaturesAggregateType<T extends SubscriptionFeaturesAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscriptionFeatures]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscriptionFeatures[P]>
      : GetScalarType<T[P], AggregateSubscriptionFeatures[P]>
  }




  export type SubscriptionFeaturesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionFeaturesWhereInput
    orderBy?: SubscriptionFeaturesOrderByWithAggregationInput | SubscriptionFeaturesOrderByWithAggregationInput[]
    by: SubscriptionFeaturesScalarFieldEnum[] | SubscriptionFeaturesScalarFieldEnum
    having?: SubscriptionFeaturesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionFeaturesCountAggregateInputType | true
    _avg?: SubscriptionFeaturesAvgAggregateInputType
    _sum?: SubscriptionFeaturesSumAggregateInputType
    _min?: SubscriptionFeaturesMinAggregateInputType
    _max?: SubscriptionFeaturesMaxAggregateInputType
  }

  export type SubscriptionFeaturesGroupByOutputType = {
    id: string
    subscriptionId: string
    maxTrades: number
    advancedAnalytics: boolean
    prioritySupport: boolean
    marketplaceAccess: boolean
    premiumListings: boolean
    bulkOperations: boolean
    cryptoPayments: boolean
    physicalCard: boolean
    businessStipend: number
    withdrawalLimit: number
    _count: SubscriptionFeaturesCountAggregateOutputType | null
    _avg: SubscriptionFeaturesAvgAggregateOutputType | null
    _sum: SubscriptionFeaturesSumAggregateOutputType | null
    _min: SubscriptionFeaturesMinAggregateOutputType | null
    _max: SubscriptionFeaturesMaxAggregateOutputType | null
  }

  type GetSubscriptionFeaturesGroupByPayload<T extends SubscriptionFeaturesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionFeaturesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionFeaturesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionFeaturesGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionFeaturesGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionFeaturesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    maxTrades?: boolean
    advancedAnalytics?: boolean
    prioritySupport?: boolean
    marketplaceAccess?: boolean
    premiumListings?: boolean
    bulkOperations?: boolean
    cryptoPayments?: boolean
    physicalCard?: boolean
    businessStipend?: boolean
    withdrawalLimit?: boolean
    subscription?: boolean | UserSubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptionFeatures"]>

  export type SubscriptionFeaturesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    maxTrades?: boolean
    advancedAnalytics?: boolean
    prioritySupport?: boolean
    marketplaceAccess?: boolean
    premiumListings?: boolean
    bulkOperations?: boolean
    cryptoPayments?: boolean
    physicalCard?: boolean
    businessStipend?: boolean
    withdrawalLimit?: boolean
    subscription?: boolean | UserSubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptionFeatures"]>

  export type SubscriptionFeaturesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    maxTrades?: boolean
    advancedAnalytics?: boolean
    prioritySupport?: boolean
    marketplaceAccess?: boolean
    premiumListings?: boolean
    bulkOperations?: boolean
    cryptoPayments?: boolean
    physicalCard?: boolean
    businessStipend?: boolean
    withdrawalLimit?: boolean
    subscription?: boolean | UserSubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptionFeatures"]>

  export type SubscriptionFeaturesSelectScalar = {
    id?: boolean
    subscriptionId?: boolean
    maxTrades?: boolean
    advancedAnalytics?: boolean
    prioritySupport?: boolean
    marketplaceAccess?: boolean
    premiumListings?: boolean
    bulkOperations?: boolean
    cryptoPayments?: boolean
    physicalCard?: boolean
    businessStipend?: boolean
    withdrawalLimit?: boolean
  }

  export type SubscriptionFeaturesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "subscriptionId" | "maxTrades" | "advancedAnalytics" | "prioritySupport" | "marketplaceAccess" | "premiumListings" | "bulkOperations" | "cryptoPayments" | "physicalCard" | "businessStipend" | "withdrawalLimit", ExtArgs["result"]["subscriptionFeatures"]>
  export type SubscriptionFeaturesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | UserSubscriptionDefaultArgs<ExtArgs>
  }
  export type SubscriptionFeaturesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | UserSubscriptionDefaultArgs<ExtArgs>
  }
  export type SubscriptionFeaturesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | UserSubscriptionDefaultArgs<ExtArgs>
  }

  export type $SubscriptionFeaturesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubscriptionFeatures"
    objects: {
      subscription: Prisma.$UserSubscriptionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      subscriptionId: string
      maxTrades: number
      advancedAnalytics: boolean
      prioritySupport: boolean
      marketplaceAccess: boolean
      premiumListings: boolean
      bulkOperations: boolean
      cryptoPayments: boolean
      physicalCard: boolean
      businessStipend: number
      withdrawalLimit: number
    }, ExtArgs["result"]["subscriptionFeatures"]>
    composites: {}
  }

  type SubscriptionFeaturesGetPayload<S extends boolean | null | undefined | SubscriptionFeaturesDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionFeaturesPayload, S>

  type SubscriptionFeaturesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubscriptionFeaturesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionFeaturesCountAggregateInputType | true
    }

  export interface SubscriptionFeaturesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubscriptionFeatures'], meta: { name: 'SubscriptionFeatures' } }
    /**
     * Find zero or one SubscriptionFeatures that matches the filter.
     * @param {SubscriptionFeaturesFindUniqueArgs} args - Arguments to find a SubscriptionFeatures
     * @example
     * // Get one SubscriptionFeatures
     * const subscriptionFeatures = await prisma.subscriptionFeatures.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionFeaturesFindUniqueArgs>(args: SelectSubset<T, SubscriptionFeaturesFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionFeaturesClient<$Result.GetResult<Prisma.$SubscriptionFeaturesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SubscriptionFeatures that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscriptionFeaturesFindUniqueOrThrowArgs} args - Arguments to find a SubscriptionFeatures
     * @example
     * // Get one SubscriptionFeatures
     * const subscriptionFeatures = await prisma.subscriptionFeatures.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionFeaturesFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionFeaturesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionFeaturesClient<$Result.GetResult<Prisma.$SubscriptionFeaturesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubscriptionFeatures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFeaturesFindFirstArgs} args - Arguments to find a SubscriptionFeatures
     * @example
     * // Get one SubscriptionFeatures
     * const subscriptionFeatures = await prisma.subscriptionFeatures.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionFeaturesFindFirstArgs>(args?: SelectSubset<T, SubscriptionFeaturesFindFirstArgs<ExtArgs>>): Prisma__SubscriptionFeaturesClient<$Result.GetResult<Prisma.$SubscriptionFeaturesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubscriptionFeatures that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFeaturesFindFirstOrThrowArgs} args - Arguments to find a SubscriptionFeatures
     * @example
     * // Get one SubscriptionFeatures
     * const subscriptionFeatures = await prisma.subscriptionFeatures.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionFeaturesFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionFeaturesFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionFeaturesClient<$Result.GetResult<Prisma.$SubscriptionFeaturesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SubscriptionFeatures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFeaturesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubscriptionFeatures
     * const subscriptionFeatures = await prisma.subscriptionFeatures.findMany()
     * 
     * // Get first 10 SubscriptionFeatures
     * const subscriptionFeatures = await prisma.subscriptionFeatures.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionFeaturesWithIdOnly = await prisma.subscriptionFeatures.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionFeaturesFindManyArgs>(args?: SelectSubset<T, SubscriptionFeaturesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionFeaturesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SubscriptionFeatures.
     * @param {SubscriptionFeaturesCreateArgs} args - Arguments to create a SubscriptionFeatures.
     * @example
     * // Create one SubscriptionFeatures
     * const SubscriptionFeatures = await prisma.subscriptionFeatures.create({
     *   data: {
     *     // ... data to create a SubscriptionFeatures
     *   }
     * })
     * 
     */
    create<T extends SubscriptionFeaturesCreateArgs>(args: SelectSubset<T, SubscriptionFeaturesCreateArgs<ExtArgs>>): Prisma__SubscriptionFeaturesClient<$Result.GetResult<Prisma.$SubscriptionFeaturesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SubscriptionFeatures.
     * @param {SubscriptionFeaturesCreateManyArgs} args - Arguments to create many SubscriptionFeatures.
     * @example
     * // Create many SubscriptionFeatures
     * const subscriptionFeatures = await prisma.subscriptionFeatures.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionFeaturesCreateManyArgs>(args?: SelectSubset<T, SubscriptionFeaturesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubscriptionFeatures and returns the data saved in the database.
     * @param {SubscriptionFeaturesCreateManyAndReturnArgs} args - Arguments to create many SubscriptionFeatures.
     * @example
     * // Create many SubscriptionFeatures
     * const subscriptionFeatures = await prisma.subscriptionFeatures.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubscriptionFeatures and only return the `id`
     * const subscriptionFeaturesWithIdOnly = await prisma.subscriptionFeatures.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionFeaturesCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionFeaturesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionFeaturesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SubscriptionFeatures.
     * @param {SubscriptionFeaturesDeleteArgs} args - Arguments to delete one SubscriptionFeatures.
     * @example
     * // Delete one SubscriptionFeatures
     * const SubscriptionFeatures = await prisma.subscriptionFeatures.delete({
     *   where: {
     *     // ... filter to delete one SubscriptionFeatures
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionFeaturesDeleteArgs>(args: SelectSubset<T, SubscriptionFeaturesDeleteArgs<ExtArgs>>): Prisma__SubscriptionFeaturesClient<$Result.GetResult<Prisma.$SubscriptionFeaturesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SubscriptionFeatures.
     * @param {SubscriptionFeaturesUpdateArgs} args - Arguments to update one SubscriptionFeatures.
     * @example
     * // Update one SubscriptionFeatures
     * const subscriptionFeatures = await prisma.subscriptionFeatures.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionFeaturesUpdateArgs>(args: SelectSubset<T, SubscriptionFeaturesUpdateArgs<ExtArgs>>): Prisma__SubscriptionFeaturesClient<$Result.GetResult<Prisma.$SubscriptionFeaturesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SubscriptionFeatures.
     * @param {SubscriptionFeaturesDeleteManyArgs} args - Arguments to filter SubscriptionFeatures to delete.
     * @example
     * // Delete a few SubscriptionFeatures
     * const { count } = await prisma.subscriptionFeatures.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionFeaturesDeleteManyArgs>(args?: SelectSubset<T, SubscriptionFeaturesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubscriptionFeatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFeaturesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubscriptionFeatures
     * const subscriptionFeatures = await prisma.subscriptionFeatures.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionFeaturesUpdateManyArgs>(args: SelectSubset<T, SubscriptionFeaturesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubscriptionFeatures and returns the data updated in the database.
     * @param {SubscriptionFeaturesUpdateManyAndReturnArgs} args - Arguments to update many SubscriptionFeatures.
     * @example
     * // Update many SubscriptionFeatures
     * const subscriptionFeatures = await prisma.subscriptionFeatures.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SubscriptionFeatures and only return the `id`
     * const subscriptionFeaturesWithIdOnly = await prisma.subscriptionFeatures.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubscriptionFeaturesUpdateManyAndReturnArgs>(args: SelectSubset<T, SubscriptionFeaturesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionFeaturesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SubscriptionFeatures.
     * @param {SubscriptionFeaturesUpsertArgs} args - Arguments to update or create a SubscriptionFeatures.
     * @example
     * // Update or create a SubscriptionFeatures
     * const subscriptionFeatures = await prisma.subscriptionFeatures.upsert({
     *   create: {
     *     // ... data to create a SubscriptionFeatures
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubscriptionFeatures we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionFeaturesUpsertArgs>(args: SelectSubset<T, SubscriptionFeaturesUpsertArgs<ExtArgs>>): Prisma__SubscriptionFeaturesClient<$Result.GetResult<Prisma.$SubscriptionFeaturesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SubscriptionFeatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFeaturesCountArgs} args - Arguments to filter SubscriptionFeatures to count.
     * @example
     * // Count the number of SubscriptionFeatures
     * const count = await prisma.subscriptionFeatures.count({
     *   where: {
     *     // ... the filter for the SubscriptionFeatures we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionFeaturesCountArgs>(
      args?: Subset<T, SubscriptionFeaturesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionFeaturesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubscriptionFeatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFeaturesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionFeaturesAggregateArgs>(args: Subset<T, SubscriptionFeaturesAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionFeaturesAggregateType<T>>

    /**
     * Group by SubscriptionFeatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFeaturesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionFeaturesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionFeaturesGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionFeaturesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionFeaturesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionFeaturesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubscriptionFeatures model
   */
  readonly fields: SubscriptionFeaturesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubscriptionFeatures.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionFeaturesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscription<T extends UserSubscriptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserSubscriptionDefaultArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubscriptionFeatures model
   */
  interface SubscriptionFeaturesFieldRefs {
    readonly id: FieldRef<"SubscriptionFeatures", 'String'>
    readonly subscriptionId: FieldRef<"SubscriptionFeatures", 'String'>
    readonly maxTrades: FieldRef<"SubscriptionFeatures", 'Int'>
    readonly advancedAnalytics: FieldRef<"SubscriptionFeatures", 'Boolean'>
    readonly prioritySupport: FieldRef<"SubscriptionFeatures", 'Boolean'>
    readonly marketplaceAccess: FieldRef<"SubscriptionFeatures", 'Boolean'>
    readonly premiumListings: FieldRef<"SubscriptionFeatures", 'Boolean'>
    readonly bulkOperations: FieldRef<"SubscriptionFeatures", 'Boolean'>
    readonly cryptoPayments: FieldRef<"SubscriptionFeatures", 'Boolean'>
    readonly physicalCard: FieldRef<"SubscriptionFeatures", 'Boolean'>
    readonly businessStipend: FieldRef<"SubscriptionFeatures", 'Float'>
    readonly withdrawalLimit: FieldRef<"SubscriptionFeatures", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * SubscriptionFeatures findUnique
   */
  export type SubscriptionFeaturesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionFeatures
     */
    select?: SubscriptionFeaturesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionFeatures
     */
    omit?: SubscriptionFeaturesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionFeaturesInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionFeatures to fetch.
     */
    where: SubscriptionFeaturesWhereUniqueInput
  }

  /**
   * SubscriptionFeatures findUniqueOrThrow
   */
  export type SubscriptionFeaturesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionFeatures
     */
    select?: SubscriptionFeaturesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionFeatures
     */
    omit?: SubscriptionFeaturesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionFeaturesInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionFeatures to fetch.
     */
    where: SubscriptionFeaturesWhereUniqueInput
  }

  /**
   * SubscriptionFeatures findFirst
   */
  export type SubscriptionFeaturesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionFeatures
     */
    select?: SubscriptionFeaturesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionFeatures
     */
    omit?: SubscriptionFeaturesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionFeaturesInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionFeatures to fetch.
     */
    where?: SubscriptionFeaturesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionFeatures to fetch.
     */
    orderBy?: SubscriptionFeaturesOrderByWithRelationInput | SubscriptionFeaturesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubscriptionFeatures.
     */
    cursor?: SubscriptionFeaturesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubscriptionFeatures.
     */
    distinct?: SubscriptionFeaturesScalarFieldEnum | SubscriptionFeaturesScalarFieldEnum[]
  }

  /**
   * SubscriptionFeatures findFirstOrThrow
   */
  export type SubscriptionFeaturesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionFeatures
     */
    select?: SubscriptionFeaturesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionFeatures
     */
    omit?: SubscriptionFeaturesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionFeaturesInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionFeatures to fetch.
     */
    where?: SubscriptionFeaturesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionFeatures to fetch.
     */
    orderBy?: SubscriptionFeaturesOrderByWithRelationInput | SubscriptionFeaturesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubscriptionFeatures.
     */
    cursor?: SubscriptionFeaturesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubscriptionFeatures.
     */
    distinct?: SubscriptionFeaturesScalarFieldEnum | SubscriptionFeaturesScalarFieldEnum[]
  }

  /**
   * SubscriptionFeatures findMany
   */
  export type SubscriptionFeaturesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionFeatures
     */
    select?: SubscriptionFeaturesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionFeatures
     */
    omit?: SubscriptionFeaturesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionFeaturesInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionFeatures to fetch.
     */
    where?: SubscriptionFeaturesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionFeatures to fetch.
     */
    orderBy?: SubscriptionFeaturesOrderByWithRelationInput | SubscriptionFeaturesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubscriptionFeatures.
     */
    cursor?: SubscriptionFeaturesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionFeatures.
     */
    skip?: number
    distinct?: SubscriptionFeaturesScalarFieldEnum | SubscriptionFeaturesScalarFieldEnum[]
  }

  /**
   * SubscriptionFeatures create
   */
  export type SubscriptionFeaturesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionFeatures
     */
    select?: SubscriptionFeaturesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionFeatures
     */
    omit?: SubscriptionFeaturesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionFeaturesInclude<ExtArgs> | null
    /**
     * The data needed to create a SubscriptionFeatures.
     */
    data: XOR<SubscriptionFeaturesCreateInput, SubscriptionFeaturesUncheckedCreateInput>
  }

  /**
   * SubscriptionFeatures createMany
   */
  export type SubscriptionFeaturesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubscriptionFeatures.
     */
    data: SubscriptionFeaturesCreateManyInput | SubscriptionFeaturesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubscriptionFeatures createManyAndReturn
   */
  export type SubscriptionFeaturesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionFeatures
     */
    select?: SubscriptionFeaturesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionFeatures
     */
    omit?: SubscriptionFeaturesOmit<ExtArgs> | null
    /**
     * The data used to create many SubscriptionFeatures.
     */
    data: SubscriptionFeaturesCreateManyInput | SubscriptionFeaturesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionFeaturesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubscriptionFeatures update
   */
  export type SubscriptionFeaturesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionFeatures
     */
    select?: SubscriptionFeaturesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionFeatures
     */
    omit?: SubscriptionFeaturesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionFeaturesInclude<ExtArgs> | null
    /**
     * The data needed to update a SubscriptionFeatures.
     */
    data: XOR<SubscriptionFeaturesUpdateInput, SubscriptionFeaturesUncheckedUpdateInput>
    /**
     * Choose, which SubscriptionFeatures to update.
     */
    where: SubscriptionFeaturesWhereUniqueInput
  }

  /**
   * SubscriptionFeatures updateMany
   */
  export type SubscriptionFeaturesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubscriptionFeatures.
     */
    data: XOR<SubscriptionFeaturesUpdateManyMutationInput, SubscriptionFeaturesUncheckedUpdateManyInput>
    /**
     * Filter which SubscriptionFeatures to update
     */
    where?: SubscriptionFeaturesWhereInput
    /**
     * Limit how many SubscriptionFeatures to update.
     */
    limit?: number
  }

  /**
   * SubscriptionFeatures updateManyAndReturn
   */
  export type SubscriptionFeaturesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionFeatures
     */
    select?: SubscriptionFeaturesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionFeatures
     */
    omit?: SubscriptionFeaturesOmit<ExtArgs> | null
    /**
     * The data used to update SubscriptionFeatures.
     */
    data: XOR<SubscriptionFeaturesUpdateManyMutationInput, SubscriptionFeaturesUncheckedUpdateManyInput>
    /**
     * Filter which SubscriptionFeatures to update
     */
    where?: SubscriptionFeaturesWhereInput
    /**
     * Limit how many SubscriptionFeatures to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionFeaturesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubscriptionFeatures upsert
   */
  export type SubscriptionFeaturesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionFeatures
     */
    select?: SubscriptionFeaturesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionFeatures
     */
    omit?: SubscriptionFeaturesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionFeaturesInclude<ExtArgs> | null
    /**
     * The filter to search for the SubscriptionFeatures to update in case it exists.
     */
    where: SubscriptionFeaturesWhereUniqueInput
    /**
     * In case the SubscriptionFeatures found by the `where` argument doesn't exist, create a new SubscriptionFeatures with this data.
     */
    create: XOR<SubscriptionFeaturesCreateInput, SubscriptionFeaturesUncheckedCreateInput>
    /**
     * In case the SubscriptionFeatures was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionFeaturesUpdateInput, SubscriptionFeaturesUncheckedUpdateInput>
  }

  /**
   * SubscriptionFeatures delete
   */
  export type SubscriptionFeaturesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionFeatures
     */
    select?: SubscriptionFeaturesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionFeatures
     */
    omit?: SubscriptionFeaturesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionFeaturesInclude<ExtArgs> | null
    /**
     * Filter which SubscriptionFeatures to delete.
     */
    where: SubscriptionFeaturesWhereUniqueInput
  }

  /**
   * SubscriptionFeatures deleteMany
   */
  export type SubscriptionFeaturesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubscriptionFeatures to delete
     */
    where?: SubscriptionFeaturesWhereInput
    /**
     * Limit how many SubscriptionFeatures to delete.
     */
    limit?: number
  }

  /**
   * SubscriptionFeatures without action
   */
  export type SubscriptionFeaturesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionFeatures
     */
    select?: SubscriptionFeaturesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionFeatures
     */
    omit?: SubscriptionFeaturesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionFeaturesInclude<ExtArgs> | null
  }


  /**
   * Model SubscriptionUsage
   */

  export type AggregateSubscriptionUsage = {
    _count: SubscriptionUsageCountAggregateOutputType | null
    _avg: SubscriptionUsageAvgAggregateOutputType | null
    _sum: SubscriptionUsageSumAggregateOutputType | null
    _min: SubscriptionUsageMinAggregateOutputType | null
    _max: SubscriptionUsageMaxAggregateOutputType | null
  }

  export type SubscriptionUsageAvgAggregateOutputType = {
    tradesThisMonth: number | null
    listingsThisMonth: number | null
    stipendUsed: number | null
  }

  export type SubscriptionUsageSumAggregateOutputType = {
    tradesThisMonth: number | null
    listingsThisMonth: number | null
    stipendUsed: number | null
  }

  export type SubscriptionUsageMinAggregateOutputType = {
    id: string | null
    subscriptionId: string | null
    tradesThisMonth: number | null
    listingsThisMonth: number | null
    stipendUsed: number | null
    lastResetAt: Date | null
  }

  export type SubscriptionUsageMaxAggregateOutputType = {
    id: string | null
    subscriptionId: string | null
    tradesThisMonth: number | null
    listingsThisMonth: number | null
    stipendUsed: number | null
    lastResetAt: Date | null
  }

  export type SubscriptionUsageCountAggregateOutputType = {
    id: number
    subscriptionId: number
    tradesThisMonth: number
    listingsThisMonth: number
    stipendUsed: number
    lastResetAt: number
    _all: number
  }


  export type SubscriptionUsageAvgAggregateInputType = {
    tradesThisMonth?: true
    listingsThisMonth?: true
    stipendUsed?: true
  }

  export type SubscriptionUsageSumAggregateInputType = {
    tradesThisMonth?: true
    listingsThisMonth?: true
    stipendUsed?: true
  }

  export type SubscriptionUsageMinAggregateInputType = {
    id?: true
    subscriptionId?: true
    tradesThisMonth?: true
    listingsThisMonth?: true
    stipendUsed?: true
    lastResetAt?: true
  }

  export type SubscriptionUsageMaxAggregateInputType = {
    id?: true
    subscriptionId?: true
    tradesThisMonth?: true
    listingsThisMonth?: true
    stipendUsed?: true
    lastResetAt?: true
  }

  export type SubscriptionUsageCountAggregateInputType = {
    id?: true
    subscriptionId?: true
    tradesThisMonth?: true
    listingsThisMonth?: true
    stipendUsed?: true
    lastResetAt?: true
    _all?: true
  }

  export type SubscriptionUsageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubscriptionUsage to aggregate.
     */
    where?: SubscriptionUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionUsages to fetch.
     */
    orderBy?: SubscriptionUsageOrderByWithRelationInput | SubscriptionUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubscriptionUsages
    **/
    _count?: true | SubscriptionUsageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionUsageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionUsageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionUsageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionUsageMaxAggregateInputType
  }

  export type GetSubscriptionUsageAggregateType<T extends SubscriptionUsageAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscriptionUsage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscriptionUsage[P]>
      : GetScalarType<T[P], AggregateSubscriptionUsage[P]>
  }




  export type SubscriptionUsageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionUsageWhereInput
    orderBy?: SubscriptionUsageOrderByWithAggregationInput | SubscriptionUsageOrderByWithAggregationInput[]
    by: SubscriptionUsageScalarFieldEnum[] | SubscriptionUsageScalarFieldEnum
    having?: SubscriptionUsageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionUsageCountAggregateInputType | true
    _avg?: SubscriptionUsageAvgAggregateInputType
    _sum?: SubscriptionUsageSumAggregateInputType
    _min?: SubscriptionUsageMinAggregateInputType
    _max?: SubscriptionUsageMaxAggregateInputType
  }

  export type SubscriptionUsageGroupByOutputType = {
    id: string
    subscriptionId: string
    tradesThisMonth: number
    listingsThisMonth: number
    stipendUsed: number
    lastResetAt: Date
    _count: SubscriptionUsageCountAggregateOutputType | null
    _avg: SubscriptionUsageAvgAggregateOutputType | null
    _sum: SubscriptionUsageSumAggregateOutputType | null
    _min: SubscriptionUsageMinAggregateOutputType | null
    _max: SubscriptionUsageMaxAggregateOutputType | null
  }

  type GetSubscriptionUsageGroupByPayload<T extends SubscriptionUsageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionUsageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionUsageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionUsageGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionUsageGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionUsageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    tradesThisMonth?: boolean
    listingsThisMonth?: boolean
    stipendUsed?: boolean
    lastResetAt?: boolean
    subscription?: boolean | UserSubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptionUsage"]>

  export type SubscriptionUsageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    tradesThisMonth?: boolean
    listingsThisMonth?: boolean
    stipendUsed?: boolean
    lastResetAt?: boolean
    subscription?: boolean | UserSubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptionUsage"]>

  export type SubscriptionUsageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    tradesThisMonth?: boolean
    listingsThisMonth?: boolean
    stipendUsed?: boolean
    lastResetAt?: boolean
    subscription?: boolean | UserSubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptionUsage"]>

  export type SubscriptionUsageSelectScalar = {
    id?: boolean
    subscriptionId?: boolean
    tradesThisMonth?: boolean
    listingsThisMonth?: boolean
    stipendUsed?: boolean
    lastResetAt?: boolean
  }

  export type SubscriptionUsageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "subscriptionId" | "tradesThisMonth" | "listingsThisMonth" | "stipendUsed" | "lastResetAt", ExtArgs["result"]["subscriptionUsage"]>
  export type SubscriptionUsageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | UserSubscriptionDefaultArgs<ExtArgs>
  }
  export type SubscriptionUsageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | UserSubscriptionDefaultArgs<ExtArgs>
  }
  export type SubscriptionUsageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | UserSubscriptionDefaultArgs<ExtArgs>
  }

  export type $SubscriptionUsagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubscriptionUsage"
    objects: {
      subscription: Prisma.$UserSubscriptionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      subscriptionId: string
      tradesThisMonth: number
      listingsThisMonth: number
      stipendUsed: number
      lastResetAt: Date
    }, ExtArgs["result"]["subscriptionUsage"]>
    composites: {}
  }

  type SubscriptionUsageGetPayload<S extends boolean | null | undefined | SubscriptionUsageDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionUsagePayload, S>

  type SubscriptionUsageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubscriptionUsageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionUsageCountAggregateInputType | true
    }

  export interface SubscriptionUsageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubscriptionUsage'], meta: { name: 'SubscriptionUsage' } }
    /**
     * Find zero or one SubscriptionUsage that matches the filter.
     * @param {SubscriptionUsageFindUniqueArgs} args - Arguments to find a SubscriptionUsage
     * @example
     * // Get one SubscriptionUsage
     * const subscriptionUsage = await prisma.subscriptionUsage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionUsageFindUniqueArgs>(args: SelectSubset<T, SubscriptionUsageFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionUsageClient<$Result.GetResult<Prisma.$SubscriptionUsagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SubscriptionUsage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscriptionUsageFindUniqueOrThrowArgs} args - Arguments to find a SubscriptionUsage
     * @example
     * // Get one SubscriptionUsage
     * const subscriptionUsage = await prisma.subscriptionUsage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionUsageFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionUsageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionUsageClient<$Result.GetResult<Prisma.$SubscriptionUsagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubscriptionUsage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUsageFindFirstArgs} args - Arguments to find a SubscriptionUsage
     * @example
     * // Get one SubscriptionUsage
     * const subscriptionUsage = await prisma.subscriptionUsage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionUsageFindFirstArgs>(args?: SelectSubset<T, SubscriptionUsageFindFirstArgs<ExtArgs>>): Prisma__SubscriptionUsageClient<$Result.GetResult<Prisma.$SubscriptionUsagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubscriptionUsage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUsageFindFirstOrThrowArgs} args - Arguments to find a SubscriptionUsage
     * @example
     * // Get one SubscriptionUsage
     * const subscriptionUsage = await prisma.subscriptionUsage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionUsageFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionUsageFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionUsageClient<$Result.GetResult<Prisma.$SubscriptionUsagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SubscriptionUsages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUsageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubscriptionUsages
     * const subscriptionUsages = await prisma.subscriptionUsage.findMany()
     * 
     * // Get first 10 SubscriptionUsages
     * const subscriptionUsages = await prisma.subscriptionUsage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionUsageWithIdOnly = await prisma.subscriptionUsage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionUsageFindManyArgs>(args?: SelectSubset<T, SubscriptionUsageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SubscriptionUsage.
     * @param {SubscriptionUsageCreateArgs} args - Arguments to create a SubscriptionUsage.
     * @example
     * // Create one SubscriptionUsage
     * const SubscriptionUsage = await prisma.subscriptionUsage.create({
     *   data: {
     *     // ... data to create a SubscriptionUsage
     *   }
     * })
     * 
     */
    create<T extends SubscriptionUsageCreateArgs>(args: SelectSubset<T, SubscriptionUsageCreateArgs<ExtArgs>>): Prisma__SubscriptionUsageClient<$Result.GetResult<Prisma.$SubscriptionUsagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SubscriptionUsages.
     * @param {SubscriptionUsageCreateManyArgs} args - Arguments to create many SubscriptionUsages.
     * @example
     * // Create many SubscriptionUsages
     * const subscriptionUsage = await prisma.subscriptionUsage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionUsageCreateManyArgs>(args?: SelectSubset<T, SubscriptionUsageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubscriptionUsages and returns the data saved in the database.
     * @param {SubscriptionUsageCreateManyAndReturnArgs} args - Arguments to create many SubscriptionUsages.
     * @example
     * // Create many SubscriptionUsages
     * const subscriptionUsage = await prisma.subscriptionUsage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubscriptionUsages and only return the `id`
     * const subscriptionUsageWithIdOnly = await prisma.subscriptionUsage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionUsageCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionUsageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionUsagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SubscriptionUsage.
     * @param {SubscriptionUsageDeleteArgs} args - Arguments to delete one SubscriptionUsage.
     * @example
     * // Delete one SubscriptionUsage
     * const SubscriptionUsage = await prisma.subscriptionUsage.delete({
     *   where: {
     *     // ... filter to delete one SubscriptionUsage
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionUsageDeleteArgs>(args: SelectSubset<T, SubscriptionUsageDeleteArgs<ExtArgs>>): Prisma__SubscriptionUsageClient<$Result.GetResult<Prisma.$SubscriptionUsagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SubscriptionUsage.
     * @param {SubscriptionUsageUpdateArgs} args - Arguments to update one SubscriptionUsage.
     * @example
     * // Update one SubscriptionUsage
     * const subscriptionUsage = await prisma.subscriptionUsage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionUsageUpdateArgs>(args: SelectSubset<T, SubscriptionUsageUpdateArgs<ExtArgs>>): Prisma__SubscriptionUsageClient<$Result.GetResult<Prisma.$SubscriptionUsagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SubscriptionUsages.
     * @param {SubscriptionUsageDeleteManyArgs} args - Arguments to filter SubscriptionUsages to delete.
     * @example
     * // Delete a few SubscriptionUsages
     * const { count } = await prisma.subscriptionUsage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionUsageDeleteManyArgs>(args?: SelectSubset<T, SubscriptionUsageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubscriptionUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUsageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubscriptionUsages
     * const subscriptionUsage = await prisma.subscriptionUsage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionUsageUpdateManyArgs>(args: SelectSubset<T, SubscriptionUsageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubscriptionUsages and returns the data updated in the database.
     * @param {SubscriptionUsageUpdateManyAndReturnArgs} args - Arguments to update many SubscriptionUsages.
     * @example
     * // Update many SubscriptionUsages
     * const subscriptionUsage = await prisma.subscriptionUsage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SubscriptionUsages and only return the `id`
     * const subscriptionUsageWithIdOnly = await prisma.subscriptionUsage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubscriptionUsageUpdateManyAndReturnArgs>(args: SelectSubset<T, SubscriptionUsageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionUsagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SubscriptionUsage.
     * @param {SubscriptionUsageUpsertArgs} args - Arguments to update or create a SubscriptionUsage.
     * @example
     * // Update or create a SubscriptionUsage
     * const subscriptionUsage = await prisma.subscriptionUsage.upsert({
     *   create: {
     *     // ... data to create a SubscriptionUsage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubscriptionUsage we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionUsageUpsertArgs>(args: SelectSubset<T, SubscriptionUsageUpsertArgs<ExtArgs>>): Prisma__SubscriptionUsageClient<$Result.GetResult<Prisma.$SubscriptionUsagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SubscriptionUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUsageCountArgs} args - Arguments to filter SubscriptionUsages to count.
     * @example
     * // Count the number of SubscriptionUsages
     * const count = await prisma.subscriptionUsage.count({
     *   where: {
     *     // ... the filter for the SubscriptionUsages we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionUsageCountArgs>(
      args?: Subset<T, SubscriptionUsageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionUsageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubscriptionUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUsageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionUsageAggregateArgs>(args: Subset<T, SubscriptionUsageAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionUsageAggregateType<T>>

    /**
     * Group by SubscriptionUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUsageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionUsageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionUsageGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionUsageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionUsageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionUsageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubscriptionUsage model
   */
  readonly fields: SubscriptionUsageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubscriptionUsage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionUsageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscription<T extends UserSubscriptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserSubscriptionDefaultArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubscriptionUsage model
   */
  interface SubscriptionUsageFieldRefs {
    readonly id: FieldRef<"SubscriptionUsage", 'String'>
    readonly subscriptionId: FieldRef<"SubscriptionUsage", 'String'>
    readonly tradesThisMonth: FieldRef<"SubscriptionUsage", 'Int'>
    readonly listingsThisMonth: FieldRef<"SubscriptionUsage", 'Int'>
    readonly stipendUsed: FieldRef<"SubscriptionUsage", 'Float'>
    readonly lastResetAt: FieldRef<"SubscriptionUsage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SubscriptionUsage findUnique
   */
  export type SubscriptionUsageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionUsage
     */
    select?: SubscriptionUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionUsage
     */
    omit?: SubscriptionUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionUsageInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionUsage to fetch.
     */
    where: SubscriptionUsageWhereUniqueInput
  }

  /**
   * SubscriptionUsage findUniqueOrThrow
   */
  export type SubscriptionUsageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionUsage
     */
    select?: SubscriptionUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionUsage
     */
    omit?: SubscriptionUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionUsageInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionUsage to fetch.
     */
    where: SubscriptionUsageWhereUniqueInput
  }

  /**
   * SubscriptionUsage findFirst
   */
  export type SubscriptionUsageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionUsage
     */
    select?: SubscriptionUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionUsage
     */
    omit?: SubscriptionUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionUsageInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionUsage to fetch.
     */
    where?: SubscriptionUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionUsages to fetch.
     */
    orderBy?: SubscriptionUsageOrderByWithRelationInput | SubscriptionUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubscriptionUsages.
     */
    cursor?: SubscriptionUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubscriptionUsages.
     */
    distinct?: SubscriptionUsageScalarFieldEnum | SubscriptionUsageScalarFieldEnum[]
  }

  /**
   * SubscriptionUsage findFirstOrThrow
   */
  export type SubscriptionUsageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionUsage
     */
    select?: SubscriptionUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionUsage
     */
    omit?: SubscriptionUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionUsageInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionUsage to fetch.
     */
    where?: SubscriptionUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionUsages to fetch.
     */
    orderBy?: SubscriptionUsageOrderByWithRelationInput | SubscriptionUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubscriptionUsages.
     */
    cursor?: SubscriptionUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubscriptionUsages.
     */
    distinct?: SubscriptionUsageScalarFieldEnum | SubscriptionUsageScalarFieldEnum[]
  }

  /**
   * SubscriptionUsage findMany
   */
  export type SubscriptionUsageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionUsage
     */
    select?: SubscriptionUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionUsage
     */
    omit?: SubscriptionUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionUsageInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionUsages to fetch.
     */
    where?: SubscriptionUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionUsages to fetch.
     */
    orderBy?: SubscriptionUsageOrderByWithRelationInput | SubscriptionUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubscriptionUsages.
     */
    cursor?: SubscriptionUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionUsages.
     */
    skip?: number
    distinct?: SubscriptionUsageScalarFieldEnum | SubscriptionUsageScalarFieldEnum[]
  }

  /**
   * SubscriptionUsage create
   */
  export type SubscriptionUsageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionUsage
     */
    select?: SubscriptionUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionUsage
     */
    omit?: SubscriptionUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionUsageInclude<ExtArgs> | null
    /**
     * The data needed to create a SubscriptionUsage.
     */
    data: XOR<SubscriptionUsageCreateInput, SubscriptionUsageUncheckedCreateInput>
  }

  /**
   * SubscriptionUsage createMany
   */
  export type SubscriptionUsageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubscriptionUsages.
     */
    data: SubscriptionUsageCreateManyInput | SubscriptionUsageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubscriptionUsage createManyAndReturn
   */
  export type SubscriptionUsageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionUsage
     */
    select?: SubscriptionUsageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionUsage
     */
    omit?: SubscriptionUsageOmit<ExtArgs> | null
    /**
     * The data used to create many SubscriptionUsages.
     */
    data: SubscriptionUsageCreateManyInput | SubscriptionUsageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionUsageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubscriptionUsage update
   */
  export type SubscriptionUsageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionUsage
     */
    select?: SubscriptionUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionUsage
     */
    omit?: SubscriptionUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionUsageInclude<ExtArgs> | null
    /**
     * The data needed to update a SubscriptionUsage.
     */
    data: XOR<SubscriptionUsageUpdateInput, SubscriptionUsageUncheckedUpdateInput>
    /**
     * Choose, which SubscriptionUsage to update.
     */
    where: SubscriptionUsageWhereUniqueInput
  }

  /**
   * SubscriptionUsage updateMany
   */
  export type SubscriptionUsageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubscriptionUsages.
     */
    data: XOR<SubscriptionUsageUpdateManyMutationInput, SubscriptionUsageUncheckedUpdateManyInput>
    /**
     * Filter which SubscriptionUsages to update
     */
    where?: SubscriptionUsageWhereInput
    /**
     * Limit how many SubscriptionUsages to update.
     */
    limit?: number
  }

  /**
   * SubscriptionUsage updateManyAndReturn
   */
  export type SubscriptionUsageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionUsage
     */
    select?: SubscriptionUsageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionUsage
     */
    omit?: SubscriptionUsageOmit<ExtArgs> | null
    /**
     * The data used to update SubscriptionUsages.
     */
    data: XOR<SubscriptionUsageUpdateManyMutationInput, SubscriptionUsageUncheckedUpdateManyInput>
    /**
     * Filter which SubscriptionUsages to update
     */
    where?: SubscriptionUsageWhereInput
    /**
     * Limit how many SubscriptionUsages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionUsageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubscriptionUsage upsert
   */
  export type SubscriptionUsageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionUsage
     */
    select?: SubscriptionUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionUsage
     */
    omit?: SubscriptionUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionUsageInclude<ExtArgs> | null
    /**
     * The filter to search for the SubscriptionUsage to update in case it exists.
     */
    where: SubscriptionUsageWhereUniqueInput
    /**
     * In case the SubscriptionUsage found by the `where` argument doesn't exist, create a new SubscriptionUsage with this data.
     */
    create: XOR<SubscriptionUsageCreateInput, SubscriptionUsageUncheckedCreateInput>
    /**
     * In case the SubscriptionUsage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUsageUpdateInput, SubscriptionUsageUncheckedUpdateInput>
  }

  /**
   * SubscriptionUsage delete
   */
  export type SubscriptionUsageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionUsage
     */
    select?: SubscriptionUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionUsage
     */
    omit?: SubscriptionUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionUsageInclude<ExtArgs> | null
    /**
     * Filter which SubscriptionUsage to delete.
     */
    where: SubscriptionUsageWhereUniqueInput
  }

  /**
   * SubscriptionUsage deleteMany
   */
  export type SubscriptionUsageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubscriptionUsages to delete
     */
    where?: SubscriptionUsageWhereInput
    /**
     * Limit how many SubscriptionUsages to delete.
     */
    limit?: number
  }

  /**
   * SubscriptionUsage without action
   */
  export type SubscriptionUsageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionUsage
     */
    select?: SubscriptionUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionUsage
     */
    omit?: SubscriptionUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionUsageInclude<ExtArgs> | null
  }


  /**
   * Model Card
   */

  export type AggregateCard = {
    _count: CardCountAggregateOutputType | null
    _avg: CardAvgAggregateOutputType | null
    _sum: CardSumAggregateOutputType | null
    _min: CardMinAggregateOutputType | null
    _max: CardMaxAggregateOutputType | null
  }

  export type CardAvgAggregateOutputType = {
    currentPrice: number | null
  }

  export type CardSumAggregateOutputType = {
    currentPrice: number | null
  }

  export type CardMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    category: $Enums.CardCategory | null
    rarity: $Enums.CardRarity | null
    company: string | null
    currentPrice: number | null
    imageUrl: string | null
    ownerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CardMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    category: $Enums.CardCategory | null
    rarity: $Enums.CardRarity | null
    company: string | null
    currentPrice: number | null
    imageUrl: string | null
    ownerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CardCountAggregateOutputType = {
    id: number
    name: number
    description: number
    category: number
    rarity: number
    company: number
    currentPrice: number
    historicalPrices: number
    imageUrl: number
    metadata: number
    stats: number
    ownerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CardAvgAggregateInputType = {
    currentPrice?: true
  }

  export type CardSumAggregateInputType = {
    currentPrice?: true
  }

  export type CardMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    rarity?: true
    company?: true
    currentPrice?: true
    imageUrl?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CardMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    rarity?: true
    company?: true
    currentPrice?: true
    imageUrl?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CardCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    rarity?: true
    company?: true
    currentPrice?: true
    historicalPrices?: true
    imageUrl?: true
    metadata?: true
    stats?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Card to aggregate.
     */
    where?: CardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cards to fetch.
     */
    orderBy?: CardOrderByWithRelationInput | CardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cards
    **/
    _count?: true | CardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CardMaxAggregateInputType
  }

  export type GetCardAggregateType<T extends CardAggregateArgs> = {
        [P in keyof T & keyof AggregateCard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCard[P]>
      : GetScalarType<T[P], AggregateCard[P]>
  }




  export type CardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CardWhereInput
    orderBy?: CardOrderByWithAggregationInput | CardOrderByWithAggregationInput[]
    by: CardScalarFieldEnum[] | CardScalarFieldEnum
    having?: CardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CardCountAggregateInputType | true
    _avg?: CardAvgAggregateInputType
    _sum?: CardSumAggregateInputType
    _min?: CardMinAggregateInputType
    _max?: CardMaxAggregateInputType
  }

  export type CardGroupByOutputType = {
    id: string
    name: string
    description: string | null
    category: $Enums.CardCategory
    rarity: $Enums.CardRarity
    company: string | null
    currentPrice: number
    historicalPrices: JsonValue | null
    imageUrl: string | null
    metadata: JsonValue | null
    stats: JsonValue | null
    ownerId: string
    createdAt: Date
    updatedAt: Date
    _count: CardCountAggregateOutputType | null
    _avg: CardAvgAggregateOutputType | null
    _sum: CardSumAggregateOutputType | null
    _min: CardMinAggregateOutputType | null
    _max: CardMaxAggregateOutputType | null
  }

  type GetCardGroupByPayload<T extends CardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CardGroupByOutputType[P]>
            : GetScalarType<T[P], CardGroupByOutputType[P]>
        }
      >
    >


  export type CardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    rarity?: boolean
    company?: boolean
    currentPrice?: boolean
    historicalPrices?: boolean
    imageUrl?: boolean
    metadata?: boolean
    stats?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    listing?: boolean | Card$listingArgs<ExtArgs>
    bids?: boolean | Card$bidsArgs<ExtArgs>
    transactions?: boolean | Card$transactionsArgs<ExtArgs>
    bettingMarkets?: boolean | Card$bettingMarketsArgs<ExtArgs>
    marketMetrics?: boolean | Card$marketMetricsArgs<ExtArgs>
    auction?: boolean | Card$auctionArgs<ExtArgs>
    auctionHistory?: boolean | Card$auctionHistoryArgs<ExtArgs>
    initiatedBattles?: boolean | Card$initiatedBattlesArgs<ExtArgs>
    targetedBattles?: boolean | Card$targetedBattlesArgs<ExtArgs>
    _count?: boolean | CardCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["card"]>

  export type CardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    rarity?: boolean
    company?: boolean
    currentPrice?: boolean
    historicalPrices?: boolean
    imageUrl?: boolean
    metadata?: boolean
    stats?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["card"]>

  export type CardSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    rarity?: boolean
    company?: boolean
    currentPrice?: boolean
    historicalPrices?: boolean
    imageUrl?: boolean
    metadata?: boolean
    stats?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["card"]>

  export type CardSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    rarity?: boolean
    company?: boolean
    currentPrice?: boolean
    historicalPrices?: boolean
    imageUrl?: boolean
    metadata?: boolean
    stats?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "category" | "rarity" | "company" | "currentPrice" | "historicalPrices" | "imageUrl" | "metadata" | "stats" | "ownerId" | "createdAt" | "updatedAt", ExtArgs["result"]["card"]>
  export type CardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    listing?: boolean | Card$listingArgs<ExtArgs>
    bids?: boolean | Card$bidsArgs<ExtArgs>
    transactions?: boolean | Card$transactionsArgs<ExtArgs>
    bettingMarkets?: boolean | Card$bettingMarketsArgs<ExtArgs>
    marketMetrics?: boolean | Card$marketMetricsArgs<ExtArgs>
    auction?: boolean | Card$auctionArgs<ExtArgs>
    auctionHistory?: boolean | Card$auctionHistoryArgs<ExtArgs>
    initiatedBattles?: boolean | Card$initiatedBattlesArgs<ExtArgs>
    targetedBattles?: boolean | Card$targetedBattlesArgs<ExtArgs>
    _count?: boolean | CardCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CardIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Card"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs>
      listing: Prisma.$MarketplaceListingPayload<ExtArgs> | null
      bids: Prisma.$BidPayload<ExtArgs>[]
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      bettingMarkets: Prisma.$BettingMarketPayload<ExtArgs>[]
      marketMetrics: Prisma.$MarketMetricsPayload<ExtArgs>[]
      auction: Prisma.$CardAuctionPayload<ExtArgs> | null
      auctionHistory: Prisma.$AuctionHistoryPayload<ExtArgs>[]
      initiatedBattles: Prisma.$MABattlePayload<ExtArgs>[]
      targetedBattles: Prisma.$MABattlePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      category: $Enums.CardCategory
      rarity: $Enums.CardRarity
      company: string | null
      currentPrice: number
      historicalPrices: Prisma.JsonValue | null
      imageUrl: string | null
      metadata: Prisma.JsonValue | null
      stats: Prisma.JsonValue | null
      ownerId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["card"]>
    composites: {}
  }

  type CardGetPayload<S extends boolean | null | undefined | CardDefaultArgs> = $Result.GetResult<Prisma.$CardPayload, S>

  type CardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CardFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CardCountAggregateInputType | true
    }

  export interface CardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Card'], meta: { name: 'Card' } }
    /**
     * Find zero or one Card that matches the filter.
     * @param {CardFindUniqueArgs} args - Arguments to find a Card
     * @example
     * // Get one Card
     * const card = await prisma.card.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CardFindUniqueArgs>(args: SelectSubset<T, CardFindUniqueArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Card that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CardFindUniqueOrThrowArgs} args - Arguments to find a Card
     * @example
     * // Get one Card
     * const card = await prisma.card.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CardFindUniqueOrThrowArgs>(args: SelectSubset<T, CardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Card that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardFindFirstArgs} args - Arguments to find a Card
     * @example
     * // Get one Card
     * const card = await prisma.card.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CardFindFirstArgs>(args?: SelectSubset<T, CardFindFirstArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Card that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardFindFirstOrThrowArgs} args - Arguments to find a Card
     * @example
     * // Get one Card
     * const card = await prisma.card.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CardFindFirstOrThrowArgs>(args?: SelectSubset<T, CardFindFirstOrThrowArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cards
     * const cards = await prisma.card.findMany()
     * 
     * // Get first 10 Cards
     * const cards = await prisma.card.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cardWithIdOnly = await prisma.card.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CardFindManyArgs>(args?: SelectSubset<T, CardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Card.
     * @param {CardCreateArgs} args - Arguments to create a Card.
     * @example
     * // Create one Card
     * const Card = await prisma.card.create({
     *   data: {
     *     // ... data to create a Card
     *   }
     * })
     * 
     */
    create<T extends CardCreateArgs>(args: SelectSubset<T, CardCreateArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cards.
     * @param {CardCreateManyArgs} args - Arguments to create many Cards.
     * @example
     * // Create many Cards
     * const card = await prisma.card.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CardCreateManyArgs>(args?: SelectSubset<T, CardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cards and returns the data saved in the database.
     * @param {CardCreateManyAndReturnArgs} args - Arguments to create many Cards.
     * @example
     * // Create many Cards
     * const card = await prisma.card.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cards and only return the `id`
     * const cardWithIdOnly = await prisma.card.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CardCreateManyAndReturnArgs>(args?: SelectSubset<T, CardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Card.
     * @param {CardDeleteArgs} args - Arguments to delete one Card.
     * @example
     * // Delete one Card
     * const Card = await prisma.card.delete({
     *   where: {
     *     // ... filter to delete one Card
     *   }
     * })
     * 
     */
    delete<T extends CardDeleteArgs>(args: SelectSubset<T, CardDeleteArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Card.
     * @param {CardUpdateArgs} args - Arguments to update one Card.
     * @example
     * // Update one Card
     * const card = await prisma.card.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CardUpdateArgs>(args: SelectSubset<T, CardUpdateArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cards.
     * @param {CardDeleteManyArgs} args - Arguments to filter Cards to delete.
     * @example
     * // Delete a few Cards
     * const { count } = await prisma.card.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CardDeleteManyArgs>(args?: SelectSubset<T, CardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cards
     * const card = await prisma.card.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CardUpdateManyArgs>(args: SelectSubset<T, CardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cards and returns the data updated in the database.
     * @param {CardUpdateManyAndReturnArgs} args - Arguments to update many Cards.
     * @example
     * // Update many Cards
     * const card = await prisma.card.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Cards and only return the `id`
     * const cardWithIdOnly = await prisma.card.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CardUpdateManyAndReturnArgs>(args: SelectSubset<T, CardUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Card.
     * @param {CardUpsertArgs} args - Arguments to update or create a Card.
     * @example
     * // Update or create a Card
     * const card = await prisma.card.upsert({
     *   create: {
     *     // ... data to create a Card
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Card we want to update
     *   }
     * })
     */
    upsert<T extends CardUpsertArgs>(args: SelectSubset<T, CardUpsertArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardCountArgs} args - Arguments to filter Cards to count.
     * @example
     * // Count the number of Cards
     * const count = await prisma.card.count({
     *   where: {
     *     // ... the filter for the Cards we want to count
     *   }
     * })
    **/
    count<T extends CardCountArgs>(
      args?: Subset<T, CardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Card.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CardAggregateArgs>(args: Subset<T, CardAggregateArgs>): Prisma.PrismaPromise<GetCardAggregateType<T>>

    /**
     * Group by Card.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CardGroupByArgs['orderBy'] }
        : { orderBy?: CardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Card model
   */
  readonly fields: CardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Card.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    listing<T extends Card$listingArgs<ExtArgs> = {}>(args?: Subset<T, Card$listingArgs<ExtArgs>>): Prisma__MarketplaceListingClient<$Result.GetResult<Prisma.$MarketplaceListingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    bids<T extends Card$bidsArgs<ExtArgs> = {}>(args?: Subset<T, Card$bidsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactions<T extends Card$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Card$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bettingMarkets<T extends Card$bettingMarketsArgs<ExtArgs> = {}>(args?: Subset<T, Card$bettingMarketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BettingMarketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    marketMetrics<T extends Card$marketMetricsArgs<ExtArgs> = {}>(args?: Subset<T, Card$marketMetricsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketMetricsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auction<T extends Card$auctionArgs<ExtArgs> = {}>(args?: Subset<T, Card$auctionArgs<ExtArgs>>): Prisma__CardAuctionClient<$Result.GetResult<Prisma.$CardAuctionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    auctionHistory<T extends Card$auctionHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Card$auctionHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuctionHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    initiatedBattles<T extends Card$initiatedBattlesArgs<ExtArgs> = {}>(args?: Subset<T, Card$initiatedBattlesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MABattlePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    targetedBattles<T extends Card$targetedBattlesArgs<ExtArgs> = {}>(args?: Subset<T, Card$targetedBattlesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MABattlePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Card model
   */
  interface CardFieldRefs {
    readonly id: FieldRef<"Card", 'String'>
    readonly name: FieldRef<"Card", 'String'>
    readonly description: FieldRef<"Card", 'String'>
    readonly category: FieldRef<"Card", 'CardCategory'>
    readonly rarity: FieldRef<"Card", 'CardRarity'>
    readonly company: FieldRef<"Card", 'String'>
    readonly currentPrice: FieldRef<"Card", 'Float'>
    readonly historicalPrices: FieldRef<"Card", 'Json'>
    readonly imageUrl: FieldRef<"Card", 'String'>
    readonly metadata: FieldRef<"Card", 'Json'>
    readonly stats: FieldRef<"Card", 'Json'>
    readonly ownerId: FieldRef<"Card", 'String'>
    readonly createdAt: FieldRef<"Card", 'DateTime'>
    readonly updatedAt: FieldRef<"Card", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Card findUnique
   */
  export type CardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Card
     */
    omit?: CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardInclude<ExtArgs> | null
    /**
     * Filter, which Card to fetch.
     */
    where: CardWhereUniqueInput
  }

  /**
   * Card findUniqueOrThrow
   */
  export type CardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Card
     */
    omit?: CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardInclude<ExtArgs> | null
    /**
     * Filter, which Card to fetch.
     */
    where: CardWhereUniqueInput
  }

  /**
   * Card findFirst
   */
  export type CardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Card
     */
    omit?: CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardInclude<ExtArgs> | null
    /**
     * Filter, which Card to fetch.
     */
    where?: CardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cards to fetch.
     */
    orderBy?: CardOrderByWithRelationInput | CardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cards.
     */
    cursor?: CardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cards.
     */
    distinct?: CardScalarFieldEnum | CardScalarFieldEnum[]
  }

  /**
   * Card findFirstOrThrow
   */
  export type CardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Card
     */
    omit?: CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardInclude<ExtArgs> | null
    /**
     * Filter, which Card to fetch.
     */
    where?: CardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cards to fetch.
     */
    orderBy?: CardOrderByWithRelationInput | CardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cards.
     */
    cursor?: CardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cards.
     */
    distinct?: CardScalarFieldEnum | CardScalarFieldEnum[]
  }

  /**
   * Card findMany
   */
  export type CardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Card
     */
    omit?: CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardInclude<ExtArgs> | null
    /**
     * Filter, which Cards to fetch.
     */
    where?: CardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cards to fetch.
     */
    orderBy?: CardOrderByWithRelationInput | CardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cards.
     */
    cursor?: CardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cards.
     */
    skip?: number
    distinct?: CardScalarFieldEnum | CardScalarFieldEnum[]
  }

  /**
   * Card create
   */
  export type CardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Card
     */
    omit?: CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardInclude<ExtArgs> | null
    /**
     * The data needed to create a Card.
     */
    data: XOR<CardCreateInput, CardUncheckedCreateInput>
  }

  /**
   * Card createMany
   */
  export type CardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cards.
     */
    data: CardCreateManyInput | CardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Card createManyAndReturn
   */
  export type CardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Card
     */
    omit?: CardOmit<ExtArgs> | null
    /**
     * The data used to create many Cards.
     */
    data: CardCreateManyInput | CardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Card update
   */
  export type CardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Card
     */
    omit?: CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardInclude<ExtArgs> | null
    /**
     * The data needed to update a Card.
     */
    data: XOR<CardUpdateInput, CardUncheckedUpdateInput>
    /**
     * Choose, which Card to update.
     */
    where: CardWhereUniqueInput
  }

  /**
   * Card updateMany
   */
  export type CardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cards.
     */
    data: XOR<CardUpdateManyMutationInput, CardUncheckedUpdateManyInput>
    /**
     * Filter which Cards to update
     */
    where?: CardWhereInput
    /**
     * Limit how many Cards to update.
     */
    limit?: number
  }

  /**
   * Card updateManyAndReturn
   */
  export type CardUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Card
     */
    omit?: CardOmit<ExtArgs> | null
    /**
     * The data used to update Cards.
     */
    data: XOR<CardUpdateManyMutationInput, CardUncheckedUpdateManyInput>
    /**
     * Filter which Cards to update
     */
    where?: CardWhereInput
    /**
     * Limit how many Cards to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Card upsert
   */
  export type CardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Card
     */
    omit?: CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardInclude<ExtArgs> | null
    /**
     * The filter to search for the Card to update in case it exists.
     */
    where: CardWhereUniqueInput
    /**
     * In case the Card found by the `where` argument doesn't exist, create a new Card with this data.
     */
    create: XOR<CardCreateInput, CardUncheckedCreateInput>
    /**
     * In case the Card was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CardUpdateInput, CardUncheckedUpdateInput>
  }

  /**
   * Card delete
   */
  export type CardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Card
     */
    omit?: CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardInclude<ExtArgs> | null
    /**
     * Filter which Card to delete.
     */
    where: CardWhereUniqueInput
  }

  /**
   * Card deleteMany
   */
  export type CardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cards to delete
     */
    where?: CardWhereInput
    /**
     * Limit how many Cards to delete.
     */
    limit?: number
  }

  /**
   * Card.listing
   */
  export type Card$listingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceListing
     */
    select?: MarketplaceListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceListing
     */
    omit?: MarketplaceListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceListingInclude<ExtArgs> | null
    where?: MarketplaceListingWhereInput
  }

  /**
   * Card.bids
   */
  export type Card$bidsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bid
     */
    omit?: BidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
    where?: BidWhereInput
    orderBy?: BidOrderByWithRelationInput | BidOrderByWithRelationInput[]
    cursor?: BidWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BidScalarFieldEnum | BidScalarFieldEnum[]
  }

  /**
   * Card.transactions
   */
  export type Card$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Card.bettingMarkets
   */
  export type Card$bettingMarketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BettingMarket
     */
    select?: BettingMarketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BettingMarket
     */
    omit?: BettingMarketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BettingMarketInclude<ExtArgs> | null
    where?: BettingMarketWhereInput
    orderBy?: BettingMarketOrderByWithRelationInput | BettingMarketOrderByWithRelationInput[]
    cursor?: BettingMarketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BettingMarketScalarFieldEnum | BettingMarketScalarFieldEnum[]
  }

  /**
   * Card.marketMetrics
   */
  export type Card$marketMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketMetrics
     */
    select?: MarketMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketMetrics
     */
    omit?: MarketMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketMetricsInclude<ExtArgs> | null
    where?: MarketMetricsWhereInput
    orderBy?: MarketMetricsOrderByWithRelationInput | MarketMetricsOrderByWithRelationInput[]
    cursor?: MarketMetricsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MarketMetricsScalarFieldEnum | MarketMetricsScalarFieldEnum[]
  }

  /**
   * Card.auction
   */
  export type Card$auctionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardAuction
     */
    select?: CardAuctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardAuction
     */
    omit?: CardAuctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardAuctionInclude<ExtArgs> | null
    where?: CardAuctionWhereInput
  }

  /**
   * Card.auctionHistory
   */
  export type Card$auctionHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionHistory
     */
    select?: AuctionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionHistory
     */
    omit?: AuctionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionHistoryInclude<ExtArgs> | null
    where?: AuctionHistoryWhereInput
    orderBy?: AuctionHistoryOrderByWithRelationInput | AuctionHistoryOrderByWithRelationInput[]
    cursor?: AuctionHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuctionHistoryScalarFieldEnum | AuctionHistoryScalarFieldEnum[]
  }

  /**
   * Card.initiatedBattles
   */
  export type Card$initiatedBattlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MABattle
     */
    select?: MABattleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MABattle
     */
    omit?: MABattleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MABattleInclude<ExtArgs> | null
    where?: MABattleWhereInput
    orderBy?: MABattleOrderByWithRelationInput | MABattleOrderByWithRelationInput[]
    cursor?: MABattleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MABattleScalarFieldEnum | MABattleScalarFieldEnum[]
  }

  /**
   * Card.targetedBattles
   */
  export type Card$targetedBattlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MABattle
     */
    select?: MABattleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MABattle
     */
    omit?: MABattleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MABattleInclude<ExtArgs> | null
    where?: MABattleWhereInput
    orderBy?: MABattleOrderByWithRelationInput | MABattleOrderByWithRelationInput[]
    cursor?: MABattleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MABattleScalarFieldEnum | MABattleScalarFieldEnum[]
  }

  /**
   * Card without action
   */
  export type CardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Card
     */
    omit?: CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardInclude<ExtArgs> | null
  }


  /**
   * Model MarketplaceListing
   */

  export type AggregateMarketplaceListing = {
    _count: MarketplaceListingCountAggregateOutputType | null
    _avg: MarketplaceListingAvgAggregateOutputType | null
    _sum: MarketplaceListingSumAggregateOutputType | null
    _min: MarketplaceListingMinAggregateOutputType | null
    _max: MarketplaceListingMaxAggregateOutputType | null
  }

  export type MarketplaceListingAvgAggregateOutputType = {
    price: number | null
  }

  export type MarketplaceListingSumAggregateOutputType = {
    price: number | null
  }

  export type MarketplaceListingMinAggregateOutputType = {
    id: string | null
    cardId: string | null
    sellerId: string | null
    price: number | null
    listingType: $Enums.ListingType | null
    auctionEnd: Date | null
    status: $Enums.ListingStatus | null
    featured: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MarketplaceListingMaxAggregateOutputType = {
    id: string | null
    cardId: string | null
    sellerId: string | null
    price: number | null
    listingType: $Enums.ListingType | null
    auctionEnd: Date | null
    status: $Enums.ListingStatus | null
    featured: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MarketplaceListingCountAggregateOutputType = {
    id: number
    cardId: number
    sellerId: number
    price: number
    listingType: number
    auctionEnd: number
    status: number
    featured: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MarketplaceListingAvgAggregateInputType = {
    price?: true
  }

  export type MarketplaceListingSumAggregateInputType = {
    price?: true
  }

  export type MarketplaceListingMinAggregateInputType = {
    id?: true
    cardId?: true
    sellerId?: true
    price?: true
    listingType?: true
    auctionEnd?: true
    status?: true
    featured?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MarketplaceListingMaxAggregateInputType = {
    id?: true
    cardId?: true
    sellerId?: true
    price?: true
    listingType?: true
    auctionEnd?: true
    status?: true
    featured?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MarketplaceListingCountAggregateInputType = {
    id?: true
    cardId?: true
    sellerId?: true
    price?: true
    listingType?: true
    auctionEnd?: true
    status?: true
    featured?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MarketplaceListingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketplaceListing to aggregate.
     */
    where?: MarketplaceListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketplaceListings to fetch.
     */
    orderBy?: MarketplaceListingOrderByWithRelationInput | MarketplaceListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MarketplaceListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketplaceListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketplaceListings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MarketplaceListings
    **/
    _count?: true | MarketplaceListingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MarketplaceListingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MarketplaceListingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MarketplaceListingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MarketplaceListingMaxAggregateInputType
  }

  export type GetMarketplaceListingAggregateType<T extends MarketplaceListingAggregateArgs> = {
        [P in keyof T & keyof AggregateMarketplaceListing]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarketplaceListing[P]>
      : GetScalarType<T[P], AggregateMarketplaceListing[P]>
  }




  export type MarketplaceListingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketplaceListingWhereInput
    orderBy?: MarketplaceListingOrderByWithAggregationInput | MarketplaceListingOrderByWithAggregationInput[]
    by: MarketplaceListingScalarFieldEnum[] | MarketplaceListingScalarFieldEnum
    having?: MarketplaceListingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MarketplaceListingCountAggregateInputType | true
    _avg?: MarketplaceListingAvgAggregateInputType
    _sum?: MarketplaceListingSumAggregateInputType
    _min?: MarketplaceListingMinAggregateInputType
    _max?: MarketplaceListingMaxAggregateInputType
  }

  export type MarketplaceListingGroupByOutputType = {
    id: string
    cardId: string
    sellerId: string
    price: number
    listingType: $Enums.ListingType
    auctionEnd: Date | null
    status: $Enums.ListingStatus
    featured: boolean
    createdAt: Date
    updatedAt: Date
    _count: MarketplaceListingCountAggregateOutputType | null
    _avg: MarketplaceListingAvgAggregateOutputType | null
    _sum: MarketplaceListingSumAggregateOutputType | null
    _min: MarketplaceListingMinAggregateOutputType | null
    _max: MarketplaceListingMaxAggregateOutputType | null
  }

  type GetMarketplaceListingGroupByPayload<T extends MarketplaceListingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MarketplaceListingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MarketplaceListingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarketplaceListingGroupByOutputType[P]>
            : GetScalarType<T[P], MarketplaceListingGroupByOutputType[P]>
        }
      >
    >


  export type MarketplaceListingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cardId?: boolean
    sellerId?: boolean
    price?: boolean
    listingType?: boolean
    auctionEnd?: boolean
    status?: boolean
    featured?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    card?: boolean | CardDefaultArgs<ExtArgs>
    seller?: boolean | UserDefaultArgs<ExtArgs>
    bids?: boolean | MarketplaceListing$bidsArgs<ExtArgs>
    _count?: boolean | MarketplaceListingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["marketplaceListing"]>

  export type MarketplaceListingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cardId?: boolean
    sellerId?: boolean
    price?: boolean
    listingType?: boolean
    auctionEnd?: boolean
    status?: boolean
    featured?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    card?: boolean | CardDefaultArgs<ExtArgs>
    seller?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["marketplaceListing"]>

  export type MarketplaceListingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cardId?: boolean
    sellerId?: boolean
    price?: boolean
    listingType?: boolean
    auctionEnd?: boolean
    status?: boolean
    featured?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    card?: boolean | CardDefaultArgs<ExtArgs>
    seller?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["marketplaceListing"]>

  export type MarketplaceListingSelectScalar = {
    id?: boolean
    cardId?: boolean
    sellerId?: boolean
    price?: boolean
    listingType?: boolean
    auctionEnd?: boolean
    status?: boolean
    featured?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MarketplaceListingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cardId" | "sellerId" | "price" | "listingType" | "auctionEnd" | "status" | "featured" | "createdAt" | "updatedAt", ExtArgs["result"]["marketplaceListing"]>
  export type MarketplaceListingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    card?: boolean | CardDefaultArgs<ExtArgs>
    seller?: boolean | UserDefaultArgs<ExtArgs>
    bids?: boolean | MarketplaceListing$bidsArgs<ExtArgs>
    _count?: boolean | MarketplaceListingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MarketplaceListingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    card?: boolean | CardDefaultArgs<ExtArgs>
    seller?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MarketplaceListingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    card?: boolean | CardDefaultArgs<ExtArgs>
    seller?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MarketplaceListingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MarketplaceListing"
    objects: {
      card: Prisma.$CardPayload<ExtArgs>
      seller: Prisma.$UserPayload<ExtArgs>
      bids: Prisma.$BidPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cardId: string
      sellerId: string
      price: number
      listingType: $Enums.ListingType
      auctionEnd: Date | null
      status: $Enums.ListingStatus
      featured: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["marketplaceListing"]>
    composites: {}
  }

  type MarketplaceListingGetPayload<S extends boolean | null | undefined | MarketplaceListingDefaultArgs> = $Result.GetResult<Prisma.$MarketplaceListingPayload, S>

  type MarketplaceListingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MarketplaceListingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MarketplaceListingCountAggregateInputType | true
    }

  export interface MarketplaceListingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MarketplaceListing'], meta: { name: 'MarketplaceListing' } }
    /**
     * Find zero or one MarketplaceListing that matches the filter.
     * @param {MarketplaceListingFindUniqueArgs} args - Arguments to find a MarketplaceListing
     * @example
     * // Get one MarketplaceListing
     * const marketplaceListing = await prisma.marketplaceListing.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MarketplaceListingFindUniqueArgs>(args: SelectSubset<T, MarketplaceListingFindUniqueArgs<ExtArgs>>): Prisma__MarketplaceListingClient<$Result.GetResult<Prisma.$MarketplaceListingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MarketplaceListing that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MarketplaceListingFindUniqueOrThrowArgs} args - Arguments to find a MarketplaceListing
     * @example
     * // Get one MarketplaceListing
     * const marketplaceListing = await prisma.marketplaceListing.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MarketplaceListingFindUniqueOrThrowArgs>(args: SelectSubset<T, MarketplaceListingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MarketplaceListingClient<$Result.GetResult<Prisma.$MarketplaceListingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MarketplaceListing that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceListingFindFirstArgs} args - Arguments to find a MarketplaceListing
     * @example
     * // Get one MarketplaceListing
     * const marketplaceListing = await prisma.marketplaceListing.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MarketplaceListingFindFirstArgs>(args?: SelectSubset<T, MarketplaceListingFindFirstArgs<ExtArgs>>): Prisma__MarketplaceListingClient<$Result.GetResult<Prisma.$MarketplaceListingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MarketplaceListing that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceListingFindFirstOrThrowArgs} args - Arguments to find a MarketplaceListing
     * @example
     * // Get one MarketplaceListing
     * const marketplaceListing = await prisma.marketplaceListing.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MarketplaceListingFindFirstOrThrowArgs>(args?: SelectSubset<T, MarketplaceListingFindFirstOrThrowArgs<ExtArgs>>): Prisma__MarketplaceListingClient<$Result.GetResult<Prisma.$MarketplaceListingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MarketplaceListings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceListingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MarketplaceListings
     * const marketplaceListings = await prisma.marketplaceListing.findMany()
     * 
     * // Get first 10 MarketplaceListings
     * const marketplaceListings = await prisma.marketplaceListing.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const marketplaceListingWithIdOnly = await prisma.marketplaceListing.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MarketplaceListingFindManyArgs>(args?: SelectSubset<T, MarketplaceListingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketplaceListingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MarketplaceListing.
     * @param {MarketplaceListingCreateArgs} args - Arguments to create a MarketplaceListing.
     * @example
     * // Create one MarketplaceListing
     * const MarketplaceListing = await prisma.marketplaceListing.create({
     *   data: {
     *     // ... data to create a MarketplaceListing
     *   }
     * })
     * 
     */
    create<T extends MarketplaceListingCreateArgs>(args: SelectSubset<T, MarketplaceListingCreateArgs<ExtArgs>>): Prisma__MarketplaceListingClient<$Result.GetResult<Prisma.$MarketplaceListingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MarketplaceListings.
     * @param {MarketplaceListingCreateManyArgs} args - Arguments to create many MarketplaceListings.
     * @example
     * // Create many MarketplaceListings
     * const marketplaceListing = await prisma.marketplaceListing.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MarketplaceListingCreateManyArgs>(args?: SelectSubset<T, MarketplaceListingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MarketplaceListings and returns the data saved in the database.
     * @param {MarketplaceListingCreateManyAndReturnArgs} args - Arguments to create many MarketplaceListings.
     * @example
     * // Create many MarketplaceListings
     * const marketplaceListing = await prisma.marketplaceListing.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MarketplaceListings and only return the `id`
     * const marketplaceListingWithIdOnly = await prisma.marketplaceListing.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MarketplaceListingCreateManyAndReturnArgs>(args?: SelectSubset<T, MarketplaceListingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketplaceListingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MarketplaceListing.
     * @param {MarketplaceListingDeleteArgs} args - Arguments to delete one MarketplaceListing.
     * @example
     * // Delete one MarketplaceListing
     * const MarketplaceListing = await prisma.marketplaceListing.delete({
     *   where: {
     *     // ... filter to delete one MarketplaceListing
     *   }
     * })
     * 
     */
    delete<T extends MarketplaceListingDeleteArgs>(args: SelectSubset<T, MarketplaceListingDeleteArgs<ExtArgs>>): Prisma__MarketplaceListingClient<$Result.GetResult<Prisma.$MarketplaceListingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MarketplaceListing.
     * @param {MarketplaceListingUpdateArgs} args - Arguments to update one MarketplaceListing.
     * @example
     * // Update one MarketplaceListing
     * const marketplaceListing = await prisma.marketplaceListing.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MarketplaceListingUpdateArgs>(args: SelectSubset<T, MarketplaceListingUpdateArgs<ExtArgs>>): Prisma__MarketplaceListingClient<$Result.GetResult<Prisma.$MarketplaceListingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MarketplaceListings.
     * @param {MarketplaceListingDeleteManyArgs} args - Arguments to filter MarketplaceListings to delete.
     * @example
     * // Delete a few MarketplaceListings
     * const { count } = await prisma.marketplaceListing.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MarketplaceListingDeleteManyArgs>(args?: SelectSubset<T, MarketplaceListingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarketplaceListings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceListingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MarketplaceListings
     * const marketplaceListing = await prisma.marketplaceListing.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MarketplaceListingUpdateManyArgs>(args: SelectSubset<T, MarketplaceListingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarketplaceListings and returns the data updated in the database.
     * @param {MarketplaceListingUpdateManyAndReturnArgs} args - Arguments to update many MarketplaceListings.
     * @example
     * // Update many MarketplaceListings
     * const marketplaceListing = await prisma.marketplaceListing.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MarketplaceListings and only return the `id`
     * const marketplaceListingWithIdOnly = await prisma.marketplaceListing.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MarketplaceListingUpdateManyAndReturnArgs>(args: SelectSubset<T, MarketplaceListingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketplaceListingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MarketplaceListing.
     * @param {MarketplaceListingUpsertArgs} args - Arguments to update or create a MarketplaceListing.
     * @example
     * // Update or create a MarketplaceListing
     * const marketplaceListing = await prisma.marketplaceListing.upsert({
     *   create: {
     *     // ... data to create a MarketplaceListing
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MarketplaceListing we want to update
     *   }
     * })
     */
    upsert<T extends MarketplaceListingUpsertArgs>(args: SelectSubset<T, MarketplaceListingUpsertArgs<ExtArgs>>): Prisma__MarketplaceListingClient<$Result.GetResult<Prisma.$MarketplaceListingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MarketplaceListings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceListingCountArgs} args - Arguments to filter MarketplaceListings to count.
     * @example
     * // Count the number of MarketplaceListings
     * const count = await prisma.marketplaceListing.count({
     *   where: {
     *     // ... the filter for the MarketplaceListings we want to count
     *   }
     * })
    **/
    count<T extends MarketplaceListingCountArgs>(
      args?: Subset<T, MarketplaceListingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarketplaceListingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MarketplaceListing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceListingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MarketplaceListingAggregateArgs>(args: Subset<T, MarketplaceListingAggregateArgs>): Prisma.PrismaPromise<GetMarketplaceListingAggregateType<T>>

    /**
     * Group by MarketplaceListing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceListingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MarketplaceListingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MarketplaceListingGroupByArgs['orderBy'] }
        : { orderBy?: MarketplaceListingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MarketplaceListingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarketplaceListingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MarketplaceListing model
   */
  readonly fields: MarketplaceListingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MarketplaceListing.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MarketplaceListingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    card<T extends CardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CardDefaultArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    seller<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bids<T extends MarketplaceListing$bidsArgs<ExtArgs> = {}>(args?: Subset<T, MarketplaceListing$bidsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MarketplaceListing model
   */
  interface MarketplaceListingFieldRefs {
    readonly id: FieldRef<"MarketplaceListing", 'String'>
    readonly cardId: FieldRef<"MarketplaceListing", 'String'>
    readonly sellerId: FieldRef<"MarketplaceListing", 'String'>
    readonly price: FieldRef<"MarketplaceListing", 'Float'>
    readonly listingType: FieldRef<"MarketplaceListing", 'ListingType'>
    readonly auctionEnd: FieldRef<"MarketplaceListing", 'DateTime'>
    readonly status: FieldRef<"MarketplaceListing", 'ListingStatus'>
    readonly featured: FieldRef<"MarketplaceListing", 'Boolean'>
    readonly createdAt: FieldRef<"MarketplaceListing", 'DateTime'>
    readonly updatedAt: FieldRef<"MarketplaceListing", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MarketplaceListing findUnique
   */
  export type MarketplaceListingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceListing
     */
    select?: MarketplaceListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceListing
     */
    omit?: MarketplaceListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceListingInclude<ExtArgs> | null
    /**
     * Filter, which MarketplaceListing to fetch.
     */
    where: MarketplaceListingWhereUniqueInput
  }

  /**
   * MarketplaceListing findUniqueOrThrow
   */
  export type MarketplaceListingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceListing
     */
    select?: MarketplaceListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceListing
     */
    omit?: MarketplaceListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceListingInclude<ExtArgs> | null
    /**
     * Filter, which MarketplaceListing to fetch.
     */
    where: MarketplaceListingWhereUniqueInput
  }

  /**
   * MarketplaceListing findFirst
   */
  export type MarketplaceListingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceListing
     */
    select?: MarketplaceListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceListing
     */
    omit?: MarketplaceListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceListingInclude<ExtArgs> | null
    /**
     * Filter, which MarketplaceListing to fetch.
     */
    where?: MarketplaceListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketplaceListings to fetch.
     */
    orderBy?: MarketplaceListingOrderByWithRelationInput | MarketplaceListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketplaceListings.
     */
    cursor?: MarketplaceListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketplaceListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketplaceListings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketplaceListings.
     */
    distinct?: MarketplaceListingScalarFieldEnum | MarketplaceListingScalarFieldEnum[]
  }

  /**
   * MarketplaceListing findFirstOrThrow
   */
  export type MarketplaceListingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceListing
     */
    select?: MarketplaceListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceListing
     */
    omit?: MarketplaceListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceListingInclude<ExtArgs> | null
    /**
     * Filter, which MarketplaceListing to fetch.
     */
    where?: MarketplaceListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketplaceListings to fetch.
     */
    orderBy?: MarketplaceListingOrderByWithRelationInput | MarketplaceListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketplaceListings.
     */
    cursor?: MarketplaceListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketplaceListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketplaceListings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketplaceListings.
     */
    distinct?: MarketplaceListingScalarFieldEnum | MarketplaceListingScalarFieldEnum[]
  }

  /**
   * MarketplaceListing findMany
   */
  export type MarketplaceListingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceListing
     */
    select?: MarketplaceListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceListing
     */
    omit?: MarketplaceListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceListingInclude<ExtArgs> | null
    /**
     * Filter, which MarketplaceListings to fetch.
     */
    where?: MarketplaceListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketplaceListings to fetch.
     */
    orderBy?: MarketplaceListingOrderByWithRelationInput | MarketplaceListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MarketplaceListings.
     */
    cursor?: MarketplaceListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketplaceListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketplaceListings.
     */
    skip?: number
    distinct?: MarketplaceListingScalarFieldEnum | MarketplaceListingScalarFieldEnum[]
  }

  /**
   * MarketplaceListing create
   */
  export type MarketplaceListingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceListing
     */
    select?: MarketplaceListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceListing
     */
    omit?: MarketplaceListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceListingInclude<ExtArgs> | null
    /**
     * The data needed to create a MarketplaceListing.
     */
    data: XOR<MarketplaceListingCreateInput, MarketplaceListingUncheckedCreateInput>
  }

  /**
   * MarketplaceListing createMany
   */
  export type MarketplaceListingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MarketplaceListings.
     */
    data: MarketplaceListingCreateManyInput | MarketplaceListingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MarketplaceListing createManyAndReturn
   */
  export type MarketplaceListingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceListing
     */
    select?: MarketplaceListingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceListing
     */
    omit?: MarketplaceListingOmit<ExtArgs> | null
    /**
     * The data used to create many MarketplaceListings.
     */
    data: MarketplaceListingCreateManyInput | MarketplaceListingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceListingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MarketplaceListing update
   */
  export type MarketplaceListingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceListing
     */
    select?: MarketplaceListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceListing
     */
    omit?: MarketplaceListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceListingInclude<ExtArgs> | null
    /**
     * The data needed to update a MarketplaceListing.
     */
    data: XOR<MarketplaceListingUpdateInput, MarketplaceListingUncheckedUpdateInput>
    /**
     * Choose, which MarketplaceListing to update.
     */
    where: MarketplaceListingWhereUniqueInput
  }

  /**
   * MarketplaceListing updateMany
   */
  export type MarketplaceListingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MarketplaceListings.
     */
    data: XOR<MarketplaceListingUpdateManyMutationInput, MarketplaceListingUncheckedUpdateManyInput>
    /**
     * Filter which MarketplaceListings to update
     */
    where?: MarketplaceListingWhereInput
    /**
     * Limit how many MarketplaceListings to update.
     */
    limit?: number
  }

  /**
   * MarketplaceListing updateManyAndReturn
   */
  export type MarketplaceListingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceListing
     */
    select?: MarketplaceListingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceListing
     */
    omit?: MarketplaceListingOmit<ExtArgs> | null
    /**
     * The data used to update MarketplaceListings.
     */
    data: XOR<MarketplaceListingUpdateManyMutationInput, MarketplaceListingUncheckedUpdateManyInput>
    /**
     * Filter which MarketplaceListings to update
     */
    where?: MarketplaceListingWhereInput
    /**
     * Limit how many MarketplaceListings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceListingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MarketplaceListing upsert
   */
  export type MarketplaceListingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceListing
     */
    select?: MarketplaceListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceListing
     */
    omit?: MarketplaceListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceListingInclude<ExtArgs> | null
    /**
     * The filter to search for the MarketplaceListing to update in case it exists.
     */
    where: MarketplaceListingWhereUniqueInput
    /**
     * In case the MarketplaceListing found by the `where` argument doesn't exist, create a new MarketplaceListing with this data.
     */
    create: XOR<MarketplaceListingCreateInput, MarketplaceListingUncheckedCreateInput>
    /**
     * In case the MarketplaceListing was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MarketplaceListingUpdateInput, MarketplaceListingUncheckedUpdateInput>
  }

  /**
   * MarketplaceListing delete
   */
  export type MarketplaceListingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceListing
     */
    select?: MarketplaceListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceListing
     */
    omit?: MarketplaceListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceListingInclude<ExtArgs> | null
    /**
     * Filter which MarketplaceListing to delete.
     */
    where: MarketplaceListingWhereUniqueInput
  }

  /**
   * MarketplaceListing deleteMany
   */
  export type MarketplaceListingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketplaceListings to delete
     */
    where?: MarketplaceListingWhereInput
    /**
     * Limit how many MarketplaceListings to delete.
     */
    limit?: number
  }

  /**
   * MarketplaceListing.bids
   */
  export type MarketplaceListing$bidsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bid
     */
    omit?: BidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
    where?: BidWhereInput
    orderBy?: BidOrderByWithRelationInput | BidOrderByWithRelationInput[]
    cursor?: BidWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BidScalarFieldEnum | BidScalarFieldEnum[]
  }

  /**
   * MarketplaceListing without action
   */
  export type MarketplaceListingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceListing
     */
    select?: MarketplaceListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceListing
     */
    omit?: MarketplaceListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceListingInclude<ExtArgs> | null
  }


  /**
   * Model Bid
   */

  export type AggregateBid = {
    _count: BidCountAggregateOutputType | null
    _avg: BidAvgAggregateOutputType | null
    _sum: BidSumAggregateOutputType | null
    _min: BidMinAggregateOutputType | null
    _max: BidMaxAggregateOutputType | null
  }

  export type BidAvgAggregateOutputType = {
    amount: number | null
  }

  export type BidSumAggregateOutputType = {
    amount: number | null
  }

  export type BidMinAggregateOutputType = {
    id: string | null
    listingId: string | null
    bidderId: string | null
    cardId: string | null
    amount: number | null
    status: $Enums.BidStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BidMaxAggregateOutputType = {
    id: string | null
    listingId: string | null
    bidderId: string | null
    cardId: string | null
    amount: number | null
    status: $Enums.BidStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BidCountAggregateOutputType = {
    id: number
    listingId: number
    bidderId: number
    cardId: number
    amount: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BidAvgAggregateInputType = {
    amount?: true
  }

  export type BidSumAggregateInputType = {
    amount?: true
  }

  export type BidMinAggregateInputType = {
    id?: true
    listingId?: true
    bidderId?: true
    cardId?: true
    amount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BidMaxAggregateInputType = {
    id?: true
    listingId?: true
    bidderId?: true
    cardId?: true
    amount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BidCountAggregateInputType = {
    id?: true
    listingId?: true
    bidderId?: true
    cardId?: true
    amount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BidAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bid to aggregate.
     */
    where?: BidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bids to fetch.
     */
    orderBy?: BidOrderByWithRelationInput | BidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bids.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bids
    **/
    _count?: true | BidCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BidAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BidSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BidMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BidMaxAggregateInputType
  }

  export type GetBidAggregateType<T extends BidAggregateArgs> = {
        [P in keyof T & keyof AggregateBid]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBid[P]>
      : GetScalarType<T[P], AggregateBid[P]>
  }




  export type BidGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BidWhereInput
    orderBy?: BidOrderByWithAggregationInput | BidOrderByWithAggregationInput[]
    by: BidScalarFieldEnum[] | BidScalarFieldEnum
    having?: BidScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BidCountAggregateInputType | true
    _avg?: BidAvgAggregateInputType
    _sum?: BidSumAggregateInputType
    _min?: BidMinAggregateInputType
    _max?: BidMaxAggregateInputType
  }

  export type BidGroupByOutputType = {
    id: string
    listingId: string
    bidderId: string
    cardId: string
    amount: number
    status: $Enums.BidStatus
    createdAt: Date
    updatedAt: Date
    _count: BidCountAggregateOutputType | null
    _avg: BidAvgAggregateOutputType | null
    _sum: BidSumAggregateOutputType | null
    _min: BidMinAggregateOutputType | null
    _max: BidMaxAggregateOutputType | null
  }

  type GetBidGroupByPayload<T extends BidGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BidGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BidGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BidGroupByOutputType[P]>
            : GetScalarType<T[P], BidGroupByOutputType[P]>
        }
      >
    >


  export type BidSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    listingId?: boolean
    bidderId?: boolean
    cardId?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    listing?: boolean | MarketplaceListingDefaultArgs<ExtArgs>
    bidder?: boolean | UserDefaultArgs<ExtArgs>
    card?: boolean | CardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bid"]>

  export type BidSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    listingId?: boolean
    bidderId?: boolean
    cardId?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    listing?: boolean | MarketplaceListingDefaultArgs<ExtArgs>
    bidder?: boolean | UserDefaultArgs<ExtArgs>
    card?: boolean | CardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bid"]>

  export type BidSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    listingId?: boolean
    bidderId?: boolean
    cardId?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    listing?: boolean | MarketplaceListingDefaultArgs<ExtArgs>
    bidder?: boolean | UserDefaultArgs<ExtArgs>
    card?: boolean | CardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bid"]>

  export type BidSelectScalar = {
    id?: boolean
    listingId?: boolean
    bidderId?: boolean
    cardId?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BidOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "listingId" | "bidderId" | "cardId" | "amount" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["bid"]>
  export type BidInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    listing?: boolean | MarketplaceListingDefaultArgs<ExtArgs>
    bidder?: boolean | UserDefaultArgs<ExtArgs>
    card?: boolean | CardDefaultArgs<ExtArgs>
  }
  export type BidIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    listing?: boolean | MarketplaceListingDefaultArgs<ExtArgs>
    bidder?: boolean | UserDefaultArgs<ExtArgs>
    card?: boolean | CardDefaultArgs<ExtArgs>
  }
  export type BidIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    listing?: boolean | MarketplaceListingDefaultArgs<ExtArgs>
    bidder?: boolean | UserDefaultArgs<ExtArgs>
    card?: boolean | CardDefaultArgs<ExtArgs>
  }

  export type $BidPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bid"
    objects: {
      listing: Prisma.$MarketplaceListingPayload<ExtArgs>
      bidder: Prisma.$UserPayload<ExtArgs>
      card: Prisma.$CardPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      listingId: string
      bidderId: string
      cardId: string
      amount: number
      status: $Enums.BidStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bid"]>
    composites: {}
  }

  type BidGetPayload<S extends boolean | null | undefined | BidDefaultArgs> = $Result.GetResult<Prisma.$BidPayload, S>

  type BidCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BidFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BidCountAggregateInputType | true
    }

  export interface BidDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bid'], meta: { name: 'Bid' } }
    /**
     * Find zero or one Bid that matches the filter.
     * @param {BidFindUniqueArgs} args - Arguments to find a Bid
     * @example
     * // Get one Bid
     * const bid = await prisma.bid.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BidFindUniqueArgs>(args: SelectSubset<T, BidFindUniqueArgs<ExtArgs>>): Prisma__BidClient<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Bid that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BidFindUniqueOrThrowArgs} args - Arguments to find a Bid
     * @example
     * // Get one Bid
     * const bid = await prisma.bid.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BidFindUniqueOrThrowArgs>(args: SelectSubset<T, BidFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BidClient<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bid that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidFindFirstArgs} args - Arguments to find a Bid
     * @example
     * // Get one Bid
     * const bid = await prisma.bid.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BidFindFirstArgs>(args?: SelectSubset<T, BidFindFirstArgs<ExtArgs>>): Prisma__BidClient<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bid that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidFindFirstOrThrowArgs} args - Arguments to find a Bid
     * @example
     * // Get one Bid
     * const bid = await prisma.bid.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BidFindFirstOrThrowArgs>(args?: SelectSubset<T, BidFindFirstOrThrowArgs<ExtArgs>>): Prisma__BidClient<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bids that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bids
     * const bids = await prisma.bid.findMany()
     * 
     * // Get first 10 Bids
     * const bids = await prisma.bid.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bidWithIdOnly = await prisma.bid.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BidFindManyArgs>(args?: SelectSubset<T, BidFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Bid.
     * @param {BidCreateArgs} args - Arguments to create a Bid.
     * @example
     * // Create one Bid
     * const Bid = await prisma.bid.create({
     *   data: {
     *     // ... data to create a Bid
     *   }
     * })
     * 
     */
    create<T extends BidCreateArgs>(args: SelectSubset<T, BidCreateArgs<ExtArgs>>): Prisma__BidClient<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bids.
     * @param {BidCreateManyArgs} args - Arguments to create many Bids.
     * @example
     * // Create many Bids
     * const bid = await prisma.bid.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BidCreateManyArgs>(args?: SelectSubset<T, BidCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bids and returns the data saved in the database.
     * @param {BidCreateManyAndReturnArgs} args - Arguments to create many Bids.
     * @example
     * // Create many Bids
     * const bid = await prisma.bid.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bids and only return the `id`
     * const bidWithIdOnly = await prisma.bid.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BidCreateManyAndReturnArgs>(args?: SelectSubset<T, BidCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Bid.
     * @param {BidDeleteArgs} args - Arguments to delete one Bid.
     * @example
     * // Delete one Bid
     * const Bid = await prisma.bid.delete({
     *   where: {
     *     // ... filter to delete one Bid
     *   }
     * })
     * 
     */
    delete<T extends BidDeleteArgs>(args: SelectSubset<T, BidDeleteArgs<ExtArgs>>): Prisma__BidClient<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Bid.
     * @param {BidUpdateArgs} args - Arguments to update one Bid.
     * @example
     * // Update one Bid
     * const bid = await prisma.bid.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BidUpdateArgs>(args: SelectSubset<T, BidUpdateArgs<ExtArgs>>): Prisma__BidClient<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bids.
     * @param {BidDeleteManyArgs} args - Arguments to filter Bids to delete.
     * @example
     * // Delete a few Bids
     * const { count } = await prisma.bid.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BidDeleteManyArgs>(args?: SelectSubset<T, BidDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bids.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bids
     * const bid = await prisma.bid.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BidUpdateManyArgs>(args: SelectSubset<T, BidUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bids and returns the data updated in the database.
     * @param {BidUpdateManyAndReturnArgs} args - Arguments to update many Bids.
     * @example
     * // Update many Bids
     * const bid = await prisma.bid.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Bids and only return the `id`
     * const bidWithIdOnly = await prisma.bid.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BidUpdateManyAndReturnArgs>(args: SelectSubset<T, BidUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Bid.
     * @param {BidUpsertArgs} args - Arguments to update or create a Bid.
     * @example
     * // Update or create a Bid
     * const bid = await prisma.bid.upsert({
     *   create: {
     *     // ... data to create a Bid
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bid we want to update
     *   }
     * })
     */
    upsert<T extends BidUpsertArgs>(args: SelectSubset<T, BidUpsertArgs<ExtArgs>>): Prisma__BidClient<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bids.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidCountArgs} args - Arguments to filter Bids to count.
     * @example
     * // Count the number of Bids
     * const count = await prisma.bid.count({
     *   where: {
     *     // ... the filter for the Bids we want to count
     *   }
     * })
    **/
    count<T extends BidCountArgs>(
      args?: Subset<T, BidCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BidCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bid.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BidAggregateArgs>(args: Subset<T, BidAggregateArgs>): Prisma.PrismaPromise<GetBidAggregateType<T>>

    /**
     * Group by Bid.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BidGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BidGroupByArgs['orderBy'] }
        : { orderBy?: BidGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BidGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBidGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bid model
   */
  readonly fields: BidFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bid.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BidClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    listing<T extends MarketplaceListingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MarketplaceListingDefaultArgs<ExtArgs>>): Prisma__MarketplaceListingClient<$Result.GetResult<Prisma.$MarketplaceListingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bidder<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    card<T extends CardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CardDefaultArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Bid model
   */
  interface BidFieldRefs {
    readonly id: FieldRef<"Bid", 'String'>
    readonly listingId: FieldRef<"Bid", 'String'>
    readonly bidderId: FieldRef<"Bid", 'String'>
    readonly cardId: FieldRef<"Bid", 'String'>
    readonly amount: FieldRef<"Bid", 'Float'>
    readonly status: FieldRef<"Bid", 'BidStatus'>
    readonly createdAt: FieldRef<"Bid", 'DateTime'>
    readonly updatedAt: FieldRef<"Bid", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Bid findUnique
   */
  export type BidFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bid
     */
    omit?: BidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
    /**
     * Filter, which Bid to fetch.
     */
    where: BidWhereUniqueInput
  }

  /**
   * Bid findUniqueOrThrow
   */
  export type BidFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bid
     */
    omit?: BidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
    /**
     * Filter, which Bid to fetch.
     */
    where: BidWhereUniqueInput
  }

  /**
   * Bid findFirst
   */
  export type BidFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bid
     */
    omit?: BidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
    /**
     * Filter, which Bid to fetch.
     */
    where?: BidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bids to fetch.
     */
    orderBy?: BidOrderByWithRelationInput | BidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bids.
     */
    cursor?: BidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bids.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bids.
     */
    distinct?: BidScalarFieldEnum | BidScalarFieldEnum[]
  }

  /**
   * Bid findFirstOrThrow
   */
  export type BidFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bid
     */
    omit?: BidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
    /**
     * Filter, which Bid to fetch.
     */
    where?: BidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bids to fetch.
     */
    orderBy?: BidOrderByWithRelationInput | BidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bids.
     */
    cursor?: BidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bids.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bids.
     */
    distinct?: BidScalarFieldEnum | BidScalarFieldEnum[]
  }

  /**
   * Bid findMany
   */
  export type BidFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bid
     */
    omit?: BidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
    /**
     * Filter, which Bids to fetch.
     */
    where?: BidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bids to fetch.
     */
    orderBy?: BidOrderByWithRelationInput | BidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bids.
     */
    cursor?: BidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bids.
     */
    skip?: number
    distinct?: BidScalarFieldEnum | BidScalarFieldEnum[]
  }

  /**
   * Bid create
   */
  export type BidCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bid
     */
    omit?: BidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
    /**
     * The data needed to create a Bid.
     */
    data: XOR<BidCreateInput, BidUncheckedCreateInput>
  }

  /**
   * Bid createMany
   */
  export type BidCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bids.
     */
    data: BidCreateManyInput | BidCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bid createManyAndReturn
   */
  export type BidCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Bid
     */
    omit?: BidOmit<ExtArgs> | null
    /**
     * The data used to create many Bids.
     */
    data: BidCreateManyInput | BidCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bid update
   */
  export type BidUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bid
     */
    omit?: BidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
    /**
     * The data needed to update a Bid.
     */
    data: XOR<BidUpdateInput, BidUncheckedUpdateInput>
    /**
     * Choose, which Bid to update.
     */
    where: BidWhereUniqueInput
  }

  /**
   * Bid updateMany
   */
  export type BidUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bids.
     */
    data: XOR<BidUpdateManyMutationInput, BidUncheckedUpdateManyInput>
    /**
     * Filter which Bids to update
     */
    where?: BidWhereInput
    /**
     * Limit how many Bids to update.
     */
    limit?: number
  }

  /**
   * Bid updateManyAndReturn
   */
  export type BidUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Bid
     */
    omit?: BidOmit<ExtArgs> | null
    /**
     * The data used to update Bids.
     */
    data: XOR<BidUpdateManyMutationInput, BidUncheckedUpdateManyInput>
    /**
     * Filter which Bids to update
     */
    where?: BidWhereInput
    /**
     * Limit how many Bids to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bid upsert
   */
  export type BidUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bid
     */
    omit?: BidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
    /**
     * The filter to search for the Bid to update in case it exists.
     */
    where: BidWhereUniqueInput
    /**
     * In case the Bid found by the `where` argument doesn't exist, create a new Bid with this data.
     */
    create: XOR<BidCreateInput, BidUncheckedCreateInput>
    /**
     * In case the Bid was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BidUpdateInput, BidUncheckedUpdateInput>
  }

  /**
   * Bid delete
   */
  export type BidDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bid
     */
    omit?: BidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
    /**
     * Filter which Bid to delete.
     */
    where: BidWhereUniqueInput
  }

  /**
   * Bid deleteMany
   */
  export type BidDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bids to delete
     */
    where?: BidWhereInput
    /**
     * Limit how many Bids to delete.
     */
    limit?: number
  }

  /**
   * Bid without action
   */
  export type BidDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bid
     */
    omit?: BidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    amount: number | null
  }

  export type TransactionSumAggregateOutputType = {
    amount: number | null
  }

  export type TransactionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    cardId: string | null
    type: $Enums.TransactionType | null
    amount: number | null
    currency: string | null
    status: $Enums.TransactionStatus | null
    description: string | null
    paymentMethod: string | null
    paymentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    cardId: string | null
    type: $Enums.TransactionType | null
    amount: number | null
    currency: string | null
    status: $Enums.TransactionStatus | null
    description: string | null
    paymentMethod: string | null
    paymentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    userId: number
    cardId: number
    type: number
    amount: number
    currency: number
    status: number
    description: number
    metadata: number
    paymentMethod: number
    paymentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    amount?: true
  }

  export type TransactionSumAggregateInputType = {
    amount?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    userId?: true
    cardId?: true
    type?: true
    amount?: true
    currency?: true
    status?: true
    description?: true
    paymentMethod?: true
    paymentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    userId?: true
    cardId?: true
    type?: true
    amount?: true
    currency?: true
    status?: true
    description?: true
    paymentMethod?: true
    paymentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    userId?: true
    cardId?: true
    type?: true
    amount?: true
    currency?: true
    status?: true
    description?: true
    metadata?: true
    paymentMethod?: true
    paymentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: string
    userId: string
    cardId: string | null
    type: $Enums.TransactionType
    amount: number
    currency: string
    status: $Enums.TransactionStatus
    description: string | null
    metadata: JsonValue | null
    paymentMethod: string | null
    paymentId: string | null
    createdAt: Date
    updatedAt: Date
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    cardId?: boolean
    type?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    description?: boolean
    metadata?: boolean
    paymentMethod?: boolean
    paymentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    card?: boolean | Transaction$cardArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    cardId?: boolean
    type?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    description?: boolean
    metadata?: boolean
    paymentMethod?: boolean
    paymentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    card?: boolean | Transaction$cardArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    cardId?: boolean
    type?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    description?: boolean
    metadata?: boolean
    paymentMethod?: boolean
    paymentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    card?: boolean | Transaction$cardArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectScalar = {
    id?: boolean
    userId?: boolean
    cardId?: boolean
    type?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    description?: boolean
    metadata?: boolean
    paymentMethod?: boolean
    paymentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "cardId" | "type" | "amount" | "currency" | "status" | "description" | "metadata" | "paymentMethod" | "paymentId" | "createdAt" | "updatedAt", ExtArgs["result"]["transaction"]>
  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    card?: boolean | Transaction$cardArgs<ExtArgs>
  }
  export type TransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    card?: boolean | Transaction$cardArgs<ExtArgs>
  }
  export type TransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    card?: boolean | Transaction$cardArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      card: Prisma.$CardPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      cardId: string | null
      type: $Enums.TransactionType
      amount: number
      currency: string
      status: $Enums.TransactionStatus
      description: string | null
      metadata: Prisma.JsonValue | null
      paymentMethod: string | null
      paymentId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions and returns the data updated in the database.
     * @param {TransactionUpdateManyAndReturnArgs} args - Arguments to update many Transactions.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    card<T extends Transaction$cardArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$cardArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'String'>
    readonly userId: FieldRef<"Transaction", 'String'>
    readonly cardId: FieldRef<"Transaction", 'String'>
    readonly type: FieldRef<"Transaction", 'TransactionType'>
    readonly amount: FieldRef<"Transaction", 'Float'>
    readonly currency: FieldRef<"Transaction", 'String'>
    readonly status: FieldRef<"Transaction", 'TransactionStatus'>
    readonly description: FieldRef<"Transaction", 'String'>
    readonly metadata: FieldRef<"Transaction", 'Json'>
    readonly paymentMethod: FieldRef<"Transaction", 'String'>
    readonly paymentId: FieldRef<"Transaction", 'String'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
    readonly updatedAt: FieldRef<"Transaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction createManyAndReturn
   */
  export type TransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
  }

  /**
   * Transaction updateManyAndReturn
   */
  export type TransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to delete.
     */
    limit?: number
  }

  /**
   * Transaction.card
   */
  export type Transaction$cardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Card
     */
    omit?: CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardInclude<ExtArgs> | null
    where?: CardWhereInput
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model CryptoWallet
   */

  export type AggregateCryptoWallet = {
    _count: CryptoWalletCountAggregateOutputType | null
    _avg: CryptoWalletAvgAggregateOutputType | null
    _sum: CryptoWalletSumAggregateOutputType | null
    _min: CryptoWalletMinAggregateOutputType | null
    _max: CryptoWalletMaxAggregateOutputType | null
  }

  export type CryptoWalletAvgAggregateOutputType = {
    balance: number | null
  }

  export type CryptoWalletSumAggregateOutputType = {
    balance: number | null
  }

  export type CryptoWalletMinAggregateOutputType = {
    id: string | null
    userId: string | null
    currency: string | null
    address: string | null
    balance: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CryptoWalletMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    currency: string | null
    address: string | null
    balance: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CryptoWalletCountAggregateOutputType = {
    id: number
    userId: number
    currency: number
    address: number
    balance: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CryptoWalletAvgAggregateInputType = {
    balance?: true
  }

  export type CryptoWalletSumAggregateInputType = {
    balance?: true
  }

  export type CryptoWalletMinAggregateInputType = {
    id?: true
    userId?: true
    currency?: true
    address?: true
    balance?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CryptoWalletMaxAggregateInputType = {
    id?: true
    userId?: true
    currency?: true
    address?: true
    balance?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CryptoWalletCountAggregateInputType = {
    id?: true
    userId?: true
    currency?: true
    address?: true
    balance?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CryptoWalletAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CryptoWallet to aggregate.
     */
    where?: CryptoWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CryptoWallets to fetch.
     */
    orderBy?: CryptoWalletOrderByWithRelationInput | CryptoWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CryptoWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CryptoWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CryptoWallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CryptoWallets
    **/
    _count?: true | CryptoWalletCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CryptoWalletAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CryptoWalletSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CryptoWalletMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CryptoWalletMaxAggregateInputType
  }

  export type GetCryptoWalletAggregateType<T extends CryptoWalletAggregateArgs> = {
        [P in keyof T & keyof AggregateCryptoWallet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCryptoWallet[P]>
      : GetScalarType<T[P], AggregateCryptoWallet[P]>
  }




  export type CryptoWalletGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CryptoWalletWhereInput
    orderBy?: CryptoWalletOrderByWithAggregationInput | CryptoWalletOrderByWithAggregationInput[]
    by: CryptoWalletScalarFieldEnum[] | CryptoWalletScalarFieldEnum
    having?: CryptoWalletScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CryptoWalletCountAggregateInputType | true
    _avg?: CryptoWalletAvgAggregateInputType
    _sum?: CryptoWalletSumAggregateInputType
    _min?: CryptoWalletMinAggregateInputType
    _max?: CryptoWalletMaxAggregateInputType
  }

  export type CryptoWalletGroupByOutputType = {
    id: string
    userId: string
    currency: string
    address: string
    balance: number
    createdAt: Date
    updatedAt: Date
    _count: CryptoWalletCountAggregateOutputType | null
    _avg: CryptoWalletAvgAggregateOutputType | null
    _sum: CryptoWalletSumAggregateOutputType | null
    _min: CryptoWalletMinAggregateOutputType | null
    _max: CryptoWalletMaxAggregateOutputType | null
  }

  type GetCryptoWalletGroupByPayload<T extends CryptoWalletGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CryptoWalletGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CryptoWalletGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CryptoWalletGroupByOutputType[P]>
            : GetScalarType<T[P], CryptoWalletGroupByOutputType[P]>
        }
      >
    >


  export type CryptoWalletSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    currency?: boolean
    address?: boolean
    balance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cryptoWallet"]>

  export type CryptoWalletSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    currency?: boolean
    address?: boolean
    balance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cryptoWallet"]>

  export type CryptoWalletSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    currency?: boolean
    address?: boolean
    balance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cryptoWallet"]>

  export type CryptoWalletSelectScalar = {
    id?: boolean
    userId?: boolean
    currency?: boolean
    address?: boolean
    balance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CryptoWalletOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "currency" | "address" | "balance" | "createdAt" | "updatedAt", ExtArgs["result"]["cryptoWallet"]>
  export type CryptoWalletInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CryptoWalletIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CryptoWalletIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CryptoWalletPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CryptoWallet"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      currency: string
      address: string
      balance: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cryptoWallet"]>
    composites: {}
  }

  type CryptoWalletGetPayload<S extends boolean | null | undefined | CryptoWalletDefaultArgs> = $Result.GetResult<Prisma.$CryptoWalletPayload, S>

  type CryptoWalletCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CryptoWalletFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CryptoWalletCountAggregateInputType | true
    }

  export interface CryptoWalletDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CryptoWallet'], meta: { name: 'CryptoWallet' } }
    /**
     * Find zero or one CryptoWallet that matches the filter.
     * @param {CryptoWalletFindUniqueArgs} args - Arguments to find a CryptoWallet
     * @example
     * // Get one CryptoWallet
     * const cryptoWallet = await prisma.cryptoWallet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CryptoWalletFindUniqueArgs>(args: SelectSubset<T, CryptoWalletFindUniqueArgs<ExtArgs>>): Prisma__CryptoWalletClient<$Result.GetResult<Prisma.$CryptoWalletPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CryptoWallet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CryptoWalletFindUniqueOrThrowArgs} args - Arguments to find a CryptoWallet
     * @example
     * // Get one CryptoWallet
     * const cryptoWallet = await prisma.cryptoWallet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CryptoWalletFindUniqueOrThrowArgs>(args: SelectSubset<T, CryptoWalletFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CryptoWalletClient<$Result.GetResult<Prisma.$CryptoWalletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CryptoWallet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoWalletFindFirstArgs} args - Arguments to find a CryptoWallet
     * @example
     * // Get one CryptoWallet
     * const cryptoWallet = await prisma.cryptoWallet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CryptoWalletFindFirstArgs>(args?: SelectSubset<T, CryptoWalletFindFirstArgs<ExtArgs>>): Prisma__CryptoWalletClient<$Result.GetResult<Prisma.$CryptoWalletPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CryptoWallet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoWalletFindFirstOrThrowArgs} args - Arguments to find a CryptoWallet
     * @example
     * // Get one CryptoWallet
     * const cryptoWallet = await prisma.cryptoWallet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CryptoWalletFindFirstOrThrowArgs>(args?: SelectSubset<T, CryptoWalletFindFirstOrThrowArgs<ExtArgs>>): Prisma__CryptoWalletClient<$Result.GetResult<Prisma.$CryptoWalletPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CryptoWallets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoWalletFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CryptoWallets
     * const cryptoWallets = await prisma.cryptoWallet.findMany()
     * 
     * // Get first 10 CryptoWallets
     * const cryptoWallets = await prisma.cryptoWallet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cryptoWalletWithIdOnly = await prisma.cryptoWallet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CryptoWalletFindManyArgs>(args?: SelectSubset<T, CryptoWalletFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CryptoWalletPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CryptoWallet.
     * @param {CryptoWalletCreateArgs} args - Arguments to create a CryptoWallet.
     * @example
     * // Create one CryptoWallet
     * const CryptoWallet = await prisma.cryptoWallet.create({
     *   data: {
     *     // ... data to create a CryptoWallet
     *   }
     * })
     * 
     */
    create<T extends CryptoWalletCreateArgs>(args: SelectSubset<T, CryptoWalletCreateArgs<ExtArgs>>): Prisma__CryptoWalletClient<$Result.GetResult<Prisma.$CryptoWalletPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CryptoWallets.
     * @param {CryptoWalletCreateManyArgs} args - Arguments to create many CryptoWallets.
     * @example
     * // Create many CryptoWallets
     * const cryptoWallet = await prisma.cryptoWallet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CryptoWalletCreateManyArgs>(args?: SelectSubset<T, CryptoWalletCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CryptoWallets and returns the data saved in the database.
     * @param {CryptoWalletCreateManyAndReturnArgs} args - Arguments to create many CryptoWallets.
     * @example
     * // Create many CryptoWallets
     * const cryptoWallet = await prisma.cryptoWallet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CryptoWallets and only return the `id`
     * const cryptoWalletWithIdOnly = await prisma.cryptoWallet.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CryptoWalletCreateManyAndReturnArgs>(args?: SelectSubset<T, CryptoWalletCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CryptoWalletPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CryptoWallet.
     * @param {CryptoWalletDeleteArgs} args - Arguments to delete one CryptoWallet.
     * @example
     * // Delete one CryptoWallet
     * const CryptoWallet = await prisma.cryptoWallet.delete({
     *   where: {
     *     // ... filter to delete one CryptoWallet
     *   }
     * })
     * 
     */
    delete<T extends CryptoWalletDeleteArgs>(args: SelectSubset<T, CryptoWalletDeleteArgs<ExtArgs>>): Prisma__CryptoWalletClient<$Result.GetResult<Prisma.$CryptoWalletPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CryptoWallet.
     * @param {CryptoWalletUpdateArgs} args - Arguments to update one CryptoWallet.
     * @example
     * // Update one CryptoWallet
     * const cryptoWallet = await prisma.cryptoWallet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CryptoWalletUpdateArgs>(args: SelectSubset<T, CryptoWalletUpdateArgs<ExtArgs>>): Prisma__CryptoWalletClient<$Result.GetResult<Prisma.$CryptoWalletPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CryptoWallets.
     * @param {CryptoWalletDeleteManyArgs} args - Arguments to filter CryptoWallets to delete.
     * @example
     * // Delete a few CryptoWallets
     * const { count } = await prisma.cryptoWallet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CryptoWalletDeleteManyArgs>(args?: SelectSubset<T, CryptoWalletDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CryptoWallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoWalletUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CryptoWallets
     * const cryptoWallet = await prisma.cryptoWallet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CryptoWalletUpdateManyArgs>(args: SelectSubset<T, CryptoWalletUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CryptoWallets and returns the data updated in the database.
     * @param {CryptoWalletUpdateManyAndReturnArgs} args - Arguments to update many CryptoWallets.
     * @example
     * // Update many CryptoWallets
     * const cryptoWallet = await prisma.cryptoWallet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CryptoWallets and only return the `id`
     * const cryptoWalletWithIdOnly = await prisma.cryptoWallet.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CryptoWalletUpdateManyAndReturnArgs>(args: SelectSubset<T, CryptoWalletUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CryptoWalletPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CryptoWallet.
     * @param {CryptoWalletUpsertArgs} args - Arguments to update or create a CryptoWallet.
     * @example
     * // Update or create a CryptoWallet
     * const cryptoWallet = await prisma.cryptoWallet.upsert({
     *   create: {
     *     // ... data to create a CryptoWallet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CryptoWallet we want to update
     *   }
     * })
     */
    upsert<T extends CryptoWalletUpsertArgs>(args: SelectSubset<T, CryptoWalletUpsertArgs<ExtArgs>>): Prisma__CryptoWalletClient<$Result.GetResult<Prisma.$CryptoWalletPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CryptoWallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoWalletCountArgs} args - Arguments to filter CryptoWallets to count.
     * @example
     * // Count the number of CryptoWallets
     * const count = await prisma.cryptoWallet.count({
     *   where: {
     *     // ... the filter for the CryptoWallets we want to count
     *   }
     * })
    **/
    count<T extends CryptoWalletCountArgs>(
      args?: Subset<T, CryptoWalletCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CryptoWalletCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CryptoWallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoWalletAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CryptoWalletAggregateArgs>(args: Subset<T, CryptoWalletAggregateArgs>): Prisma.PrismaPromise<GetCryptoWalletAggregateType<T>>

    /**
     * Group by CryptoWallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoWalletGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CryptoWalletGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CryptoWalletGroupByArgs['orderBy'] }
        : { orderBy?: CryptoWalletGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CryptoWalletGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCryptoWalletGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CryptoWallet model
   */
  readonly fields: CryptoWalletFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CryptoWallet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CryptoWalletClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CryptoWallet model
   */
  interface CryptoWalletFieldRefs {
    readonly id: FieldRef<"CryptoWallet", 'String'>
    readonly userId: FieldRef<"CryptoWallet", 'String'>
    readonly currency: FieldRef<"CryptoWallet", 'String'>
    readonly address: FieldRef<"CryptoWallet", 'String'>
    readonly balance: FieldRef<"CryptoWallet", 'Float'>
    readonly createdAt: FieldRef<"CryptoWallet", 'DateTime'>
    readonly updatedAt: FieldRef<"CryptoWallet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CryptoWallet findUnique
   */
  export type CryptoWalletFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoWallet
     */
    select?: CryptoWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoWallet
     */
    omit?: CryptoWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoWalletInclude<ExtArgs> | null
    /**
     * Filter, which CryptoWallet to fetch.
     */
    where: CryptoWalletWhereUniqueInput
  }

  /**
   * CryptoWallet findUniqueOrThrow
   */
  export type CryptoWalletFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoWallet
     */
    select?: CryptoWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoWallet
     */
    omit?: CryptoWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoWalletInclude<ExtArgs> | null
    /**
     * Filter, which CryptoWallet to fetch.
     */
    where: CryptoWalletWhereUniqueInput
  }

  /**
   * CryptoWallet findFirst
   */
  export type CryptoWalletFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoWallet
     */
    select?: CryptoWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoWallet
     */
    omit?: CryptoWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoWalletInclude<ExtArgs> | null
    /**
     * Filter, which CryptoWallet to fetch.
     */
    where?: CryptoWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CryptoWallets to fetch.
     */
    orderBy?: CryptoWalletOrderByWithRelationInput | CryptoWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CryptoWallets.
     */
    cursor?: CryptoWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CryptoWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CryptoWallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CryptoWallets.
     */
    distinct?: CryptoWalletScalarFieldEnum | CryptoWalletScalarFieldEnum[]
  }

  /**
   * CryptoWallet findFirstOrThrow
   */
  export type CryptoWalletFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoWallet
     */
    select?: CryptoWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoWallet
     */
    omit?: CryptoWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoWalletInclude<ExtArgs> | null
    /**
     * Filter, which CryptoWallet to fetch.
     */
    where?: CryptoWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CryptoWallets to fetch.
     */
    orderBy?: CryptoWalletOrderByWithRelationInput | CryptoWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CryptoWallets.
     */
    cursor?: CryptoWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CryptoWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CryptoWallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CryptoWallets.
     */
    distinct?: CryptoWalletScalarFieldEnum | CryptoWalletScalarFieldEnum[]
  }

  /**
   * CryptoWallet findMany
   */
  export type CryptoWalletFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoWallet
     */
    select?: CryptoWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoWallet
     */
    omit?: CryptoWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoWalletInclude<ExtArgs> | null
    /**
     * Filter, which CryptoWallets to fetch.
     */
    where?: CryptoWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CryptoWallets to fetch.
     */
    orderBy?: CryptoWalletOrderByWithRelationInput | CryptoWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CryptoWallets.
     */
    cursor?: CryptoWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CryptoWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CryptoWallets.
     */
    skip?: number
    distinct?: CryptoWalletScalarFieldEnum | CryptoWalletScalarFieldEnum[]
  }

  /**
   * CryptoWallet create
   */
  export type CryptoWalletCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoWallet
     */
    select?: CryptoWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoWallet
     */
    omit?: CryptoWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoWalletInclude<ExtArgs> | null
    /**
     * The data needed to create a CryptoWallet.
     */
    data: XOR<CryptoWalletCreateInput, CryptoWalletUncheckedCreateInput>
  }

  /**
   * CryptoWallet createMany
   */
  export type CryptoWalletCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CryptoWallets.
     */
    data: CryptoWalletCreateManyInput | CryptoWalletCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CryptoWallet createManyAndReturn
   */
  export type CryptoWalletCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoWallet
     */
    select?: CryptoWalletSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoWallet
     */
    omit?: CryptoWalletOmit<ExtArgs> | null
    /**
     * The data used to create many CryptoWallets.
     */
    data: CryptoWalletCreateManyInput | CryptoWalletCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoWalletIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CryptoWallet update
   */
  export type CryptoWalletUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoWallet
     */
    select?: CryptoWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoWallet
     */
    omit?: CryptoWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoWalletInclude<ExtArgs> | null
    /**
     * The data needed to update a CryptoWallet.
     */
    data: XOR<CryptoWalletUpdateInput, CryptoWalletUncheckedUpdateInput>
    /**
     * Choose, which CryptoWallet to update.
     */
    where: CryptoWalletWhereUniqueInput
  }

  /**
   * CryptoWallet updateMany
   */
  export type CryptoWalletUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CryptoWallets.
     */
    data: XOR<CryptoWalletUpdateManyMutationInput, CryptoWalletUncheckedUpdateManyInput>
    /**
     * Filter which CryptoWallets to update
     */
    where?: CryptoWalletWhereInput
    /**
     * Limit how many CryptoWallets to update.
     */
    limit?: number
  }

  /**
   * CryptoWallet updateManyAndReturn
   */
  export type CryptoWalletUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoWallet
     */
    select?: CryptoWalletSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoWallet
     */
    omit?: CryptoWalletOmit<ExtArgs> | null
    /**
     * The data used to update CryptoWallets.
     */
    data: XOR<CryptoWalletUpdateManyMutationInput, CryptoWalletUncheckedUpdateManyInput>
    /**
     * Filter which CryptoWallets to update
     */
    where?: CryptoWalletWhereInput
    /**
     * Limit how many CryptoWallets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoWalletIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CryptoWallet upsert
   */
  export type CryptoWalletUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoWallet
     */
    select?: CryptoWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoWallet
     */
    omit?: CryptoWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoWalletInclude<ExtArgs> | null
    /**
     * The filter to search for the CryptoWallet to update in case it exists.
     */
    where: CryptoWalletWhereUniqueInput
    /**
     * In case the CryptoWallet found by the `where` argument doesn't exist, create a new CryptoWallet with this data.
     */
    create: XOR<CryptoWalletCreateInput, CryptoWalletUncheckedCreateInput>
    /**
     * In case the CryptoWallet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CryptoWalletUpdateInput, CryptoWalletUncheckedUpdateInput>
  }

  /**
   * CryptoWallet delete
   */
  export type CryptoWalletDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoWallet
     */
    select?: CryptoWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoWallet
     */
    omit?: CryptoWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoWalletInclude<ExtArgs> | null
    /**
     * Filter which CryptoWallet to delete.
     */
    where: CryptoWalletWhereUniqueInput
  }

  /**
   * CryptoWallet deleteMany
   */
  export type CryptoWalletDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CryptoWallets to delete
     */
    where?: CryptoWalletWhereInput
    /**
     * Limit how many CryptoWallets to delete.
     */
    limit?: number
  }

  /**
   * CryptoWallet without action
   */
  export type CryptoWalletDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoWallet
     */
    select?: CryptoWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoWallet
     */
    omit?: CryptoWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoWalletInclude<ExtArgs> | null
  }


  /**
   * Model PhysicalCard
   */

  export type AggregatePhysicalCard = {
    _count: PhysicalCardCountAggregateOutputType | null
    _min: PhysicalCardMinAggregateOutputType | null
    _max: PhysicalCardMaxAggregateOutputType | null
  }

  export type PhysicalCardMinAggregateOutputType = {
    id: string | null
    userId: string | null
    cardNumber: string | null
    expiryDate: string | null
    cvv: string | null
    status: $Enums.PhysicalCardStatus | null
    appleWalletPassId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PhysicalCardMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    cardNumber: string | null
    expiryDate: string | null
    cvv: string | null
    status: $Enums.PhysicalCardStatus | null
    appleWalletPassId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PhysicalCardCountAggregateOutputType = {
    id: number
    userId: number
    cardNumber: number
    expiryDate: number
    cvv: number
    status: number
    appleWalletPassId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PhysicalCardMinAggregateInputType = {
    id?: true
    userId?: true
    cardNumber?: true
    expiryDate?: true
    cvv?: true
    status?: true
    appleWalletPassId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PhysicalCardMaxAggregateInputType = {
    id?: true
    userId?: true
    cardNumber?: true
    expiryDate?: true
    cvv?: true
    status?: true
    appleWalletPassId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PhysicalCardCountAggregateInputType = {
    id?: true
    userId?: true
    cardNumber?: true
    expiryDate?: true
    cvv?: true
    status?: true
    appleWalletPassId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PhysicalCardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PhysicalCard to aggregate.
     */
    where?: PhysicalCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhysicalCards to fetch.
     */
    orderBy?: PhysicalCardOrderByWithRelationInput | PhysicalCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PhysicalCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhysicalCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhysicalCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PhysicalCards
    **/
    _count?: true | PhysicalCardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PhysicalCardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PhysicalCardMaxAggregateInputType
  }

  export type GetPhysicalCardAggregateType<T extends PhysicalCardAggregateArgs> = {
        [P in keyof T & keyof AggregatePhysicalCard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhysicalCard[P]>
      : GetScalarType<T[P], AggregatePhysicalCard[P]>
  }




  export type PhysicalCardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhysicalCardWhereInput
    orderBy?: PhysicalCardOrderByWithAggregationInput | PhysicalCardOrderByWithAggregationInput[]
    by: PhysicalCardScalarFieldEnum[] | PhysicalCardScalarFieldEnum
    having?: PhysicalCardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PhysicalCardCountAggregateInputType | true
    _min?: PhysicalCardMinAggregateInputType
    _max?: PhysicalCardMaxAggregateInputType
  }

  export type PhysicalCardGroupByOutputType = {
    id: string
    userId: string
    cardNumber: string
    expiryDate: string
    cvv: string
    status: $Enums.PhysicalCardStatus
    appleWalletPassId: string | null
    createdAt: Date
    updatedAt: Date
    _count: PhysicalCardCountAggregateOutputType | null
    _min: PhysicalCardMinAggregateOutputType | null
    _max: PhysicalCardMaxAggregateOutputType | null
  }

  type GetPhysicalCardGroupByPayload<T extends PhysicalCardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PhysicalCardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PhysicalCardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PhysicalCardGroupByOutputType[P]>
            : GetScalarType<T[P], PhysicalCardGroupByOutputType[P]>
        }
      >
    >


  export type PhysicalCardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    cardNumber?: boolean
    expiryDate?: boolean
    cvv?: boolean
    status?: boolean
    appleWalletPassId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["physicalCard"]>

  export type PhysicalCardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    cardNumber?: boolean
    expiryDate?: boolean
    cvv?: boolean
    status?: boolean
    appleWalletPassId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["physicalCard"]>

  export type PhysicalCardSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    cardNumber?: boolean
    expiryDate?: boolean
    cvv?: boolean
    status?: boolean
    appleWalletPassId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["physicalCard"]>

  export type PhysicalCardSelectScalar = {
    id?: boolean
    userId?: boolean
    cardNumber?: boolean
    expiryDate?: boolean
    cvv?: boolean
    status?: boolean
    appleWalletPassId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PhysicalCardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "cardNumber" | "expiryDate" | "cvv" | "status" | "appleWalletPassId" | "createdAt" | "updatedAt", ExtArgs["result"]["physicalCard"]>
  export type PhysicalCardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PhysicalCardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PhysicalCardIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PhysicalCardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PhysicalCard"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      cardNumber: string
      expiryDate: string
      cvv: string
      status: $Enums.PhysicalCardStatus
      appleWalletPassId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["physicalCard"]>
    composites: {}
  }

  type PhysicalCardGetPayload<S extends boolean | null | undefined | PhysicalCardDefaultArgs> = $Result.GetResult<Prisma.$PhysicalCardPayload, S>

  type PhysicalCardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PhysicalCardFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PhysicalCardCountAggregateInputType | true
    }

  export interface PhysicalCardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PhysicalCard'], meta: { name: 'PhysicalCard' } }
    /**
     * Find zero or one PhysicalCard that matches the filter.
     * @param {PhysicalCardFindUniqueArgs} args - Arguments to find a PhysicalCard
     * @example
     * // Get one PhysicalCard
     * const physicalCard = await prisma.physicalCard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PhysicalCardFindUniqueArgs>(args: SelectSubset<T, PhysicalCardFindUniqueArgs<ExtArgs>>): Prisma__PhysicalCardClient<$Result.GetResult<Prisma.$PhysicalCardPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PhysicalCard that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PhysicalCardFindUniqueOrThrowArgs} args - Arguments to find a PhysicalCard
     * @example
     * // Get one PhysicalCard
     * const physicalCard = await prisma.physicalCard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PhysicalCardFindUniqueOrThrowArgs>(args: SelectSubset<T, PhysicalCardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PhysicalCardClient<$Result.GetResult<Prisma.$PhysicalCardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PhysicalCard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhysicalCardFindFirstArgs} args - Arguments to find a PhysicalCard
     * @example
     * // Get one PhysicalCard
     * const physicalCard = await prisma.physicalCard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PhysicalCardFindFirstArgs>(args?: SelectSubset<T, PhysicalCardFindFirstArgs<ExtArgs>>): Prisma__PhysicalCardClient<$Result.GetResult<Prisma.$PhysicalCardPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PhysicalCard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhysicalCardFindFirstOrThrowArgs} args - Arguments to find a PhysicalCard
     * @example
     * // Get one PhysicalCard
     * const physicalCard = await prisma.physicalCard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PhysicalCardFindFirstOrThrowArgs>(args?: SelectSubset<T, PhysicalCardFindFirstOrThrowArgs<ExtArgs>>): Prisma__PhysicalCardClient<$Result.GetResult<Prisma.$PhysicalCardPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PhysicalCards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhysicalCardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PhysicalCards
     * const physicalCards = await prisma.physicalCard.findMany()
     * 
     * // Get first 10 PhysicalCards
     * const physicalCards = await prisma.physicalCard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const physicalCardWithIdOnly = await prisma.physicalCard.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PhysicalCardFindManyArgs>(args?: SelectSubset<T, PhysicalCardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhysicalCardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PhysicalCard.
     * @param {PhysicalCardCreateArgs} args - Arguments to create a PhysicalCard.
     * @example
     * // Create one PhysicalCard
     * const PhysicalCard = await prisma.physicalCard.create({
     *   data: {
     *     // ... data to create a PhysicalCard
     *   }
     * })
     * 
     */
    create<T extends PhysicalCardCreateArgs>(args: SelectSubset<T, PhysicalCardCreateArgs<ExtArgs>>): Prisma__PhysicalCardClient<$Result.GetResult<Prisma.$PhysicalCardPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PhysicalCards.
     * @param {PhysicalCardCreateManyArgs} args - Arguments to create many PhysicalCards.
     * @example
     * // Create many PhysicalCards
     * const physicalCard = await prisma.physicalCard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PhysicalCardCreateManyArgs>(args?: SelectSubset<T, PhysicalCardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PhysicalCards and returns the data saved in the database.
     * @param {PhysicalCardCreateManyAndReturnArgs} args - Arguments to create many PhysicalCards.
     * @example
     * // Create many PhysicalCards
     * const physicalCard = await prisma.physicalCard.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PhysicalCards and only return the `id`
     * const physicalCardWithIdOnly = await prisma.physicalCard.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PhysicalCardCreateManyAndReturnArgs>(args?: SelectSubset<T, PhysicalCardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhysicalCardPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PhysicalCard.
     * @param {PhysicalCardDeleteArgs} args - Arguments to delete one PhysicalCard.
     * @example
     * // Delete one PhysicalCard
     * const PhysicalCard = await prisma.physicalCard.delete({
     *   where: {
     *     // ... filter to delete one PhysicalCard
     *   }
     * })
     * 
     */
    delete<T extends PhysicalCardDeleteArgs>(args: SelectSubset<T, PhysicalCardDeleteArgs<ExtArgs>>): Prisma__PhysicalCardClient<$Result.GetResult<Prisma.$PhysicalCardPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PhysicalCard.
     * @param {PhysicalCardUpdateArgs} args - Arguments to update one PhysicalCard.
     * @example
     * // Update one PhysicalCard
     * const physicalCard = await prisma.physicalCard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PhysicalCardUpdateArgs>(args: SelectSubset<T, PhysicalCardUpdateArgs<ExtArgs>>): Prisma__PhysicalCardClient<$Result.GetResult<Prisma.$PhysicalCardPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PhysicalCards.
     * @param {PhysicalCardDeleteManyArgs} args - Arguments to filter PhysicalCards to delete.
     * @example
     * // Delete a few PhysicalCards
     * const { count } = await prisma.physicalCard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PhysicalCardDeleteManyArgs>(args?: SelectSubset<T, PhysicalCardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PhysicalCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhysicalCardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PhysicalCards
     * const physicalCard = await prisma.physicalCard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PhysicalCardUpdateManyArgs>(args: SelectSubset<T, PhysicalCardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PhysicalCards and returns the data updated in the database.
     * @param {PhysicalCardUpdateManyAndReturnArgs} args - Arguments to update many PhysicalCards.
     * @example
     * // Update many PhysicalCards
     * const physicalCard = await prisma.physicalCard.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PhysicalCards and only return the `id`
     * const physicalCardWithIdOnly = await prisma.physicalCard.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PhysicalCardUpdateManyAndReturnArgs>(args: SelectSubset<T, PhysicalCardUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhysicalCardPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PhysicalCard.
     * @param {PhysicalCardUpsertArgs} args - Arguments to update or create a PhysicalCard.
     * @example
     * // Update or create a PhysicalCard
     * const physicalCard = await prisma.physicalCard.upsert({
     *   create: {
     *     // ... data to create a PhysicalCard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PhysicalCard we want to update
     *   }
     * })
     */
    upsert<T extends PhysicalCardUpsertArgs>(args: SelectSubset<T, PhysicalCardUpsertArgs<ExtArgs>>): Prisma__PhysicalCardClient<$Result.GetResult<Prisma.$PhysicalCardPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PhysicalCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhysicalCardCountArgs} args - Arguments to filter PhysicalCards to count.
     * @example
     * // Count the number of PhysicalCards
     * const count = await prisma.physicalCard.count({
     *   where: {
     *     // ... the filter for the PhysicalCards we want to count
     *   }
     * })
    **/
    count<T extends PhysicalCardCountArgs>(
      args?: Subset<T, PhysicalCardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PhysicalCardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PhysicalCard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhysicalCardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PhysicalCardAggregateArgs>(args: Subset<T, PhysicalCardAggregateArgs>): Prisma.PrismaPromise<GetPhysicalCardAggregateType<T>>

    /**
     * Group by PhysicalCard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhysicalCardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PhysicalCardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PhysicalCardGroupByArgs['orderBy'] }
        : { orderBy?: PhysicalCardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PhysicalCardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhysicalCardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PhysicalCard model
   */
  readonly fields: PhysicalCardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PhysicalCard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PhysicalCardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PhysicalCard model
   */
  interface PhysicalCardFieldRefs {
    readonly id: FieldRef<"PhysicalCard", 'String'>
    readonly userId: FieldRef<"PhysicalCard", 'String'>
    readonly cardNumber: FieldRef<"PhysicalCard", 'String'>
    readonly expiryDate: FieldRef<"PhysicalCard", 'String'>
    readonly cvv: FieldRef<"PhysicalCard", 'String'>
    readonly status: FieldRef<"PhysicalCard", 'PhysicalCardStatus'>
    readonly appleWalletPassId: FieldRef<"PhysicalCard", 'String'>
    readonly createdAt: FieldRef<"PhysicalCard", 'DateTime'>
    readonly updatedAt: FieldRef<"PhysicalCard", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PhysicalCard findUnique
   */
  export type PhysicalCardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhysicalCard
     */
    select?: PhysicalCardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhysicalCard
     */
    omit?: PhysicalCardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhysicalCardInclude<ExtArgs> | null
    /**
     * Filter, which PhysicalCard to fetch.
     */
    where: PhysicalCardWhereUniqueInput
  }

  /**
   * PhysicalCard findUniqueOrThrow
   */
  export type PhysicalCardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhysicalCard
     */
    select?: PhysicalCardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhysicalCard
     */
    omit?: PhysicalCardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhysicalCardInclude<ExtArgs> | null
    /**
     * Filter, which PhysicalCard to fetch.
     */
    where: PhysicalCardWhereUniqueInput
  }

  /**
   * PhysicalCard findFirst
   */
  export type PhysicalCardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhysicalCard
     */
    select?: PhysicalCardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhysicalCard
     */
    omit?: PhysicalCardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhysicalCardInclude<ExtArgs> | null
    /**
     * Filter, which PhysicalCard to fetch.
     */
    where?: PhysicalCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhysicalCards to fetch.
     */
    orderBy?: PhysicalCardOrderByWithRelationInput | PhysicalCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PhysicalCards.
     */
    cursor?: PhysicalCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhysicalCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhysicalCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PhysicalCards.
     */
    distinct?: PhysicalCardScalarFieldEnum | PhysicalCardScalarFieldEnum[]
  }

  /**
   * PhysicalCard findFirstOrThrow
   */
  export type PhysicalCardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhysicalCard
     */
    select?: PhysicalCardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhysicalCard
     */
    omit?: PhysicalCardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhysicalCardInclude<ExtArgs> | null
    /**
     * Filter, which PhysicalCard to fetch.
     */
    where?: PhysicalCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhysicalCards to fetch.
     */
    orderBy?: PhysicalCardOrderByWithRelationInput | PhysicalCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PhysicalCards.
     */
    cursor?: PhysicalCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhysicalCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhysicalCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PhysicalCards.
     */
    distinct?: PhysicalCardScalarFieldEnum | PhysicalCardScalarFieldEnum[]
  }

  /**
   * PhysicalCard findMany
   */
  export type PhysicalCardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhysicalCard
     */
    select?: PhysicalCardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhysicalCard
     */
    omit?: PhysicalCardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhysicalCardInclude<ExtArgs> | null
    /**
     * Filter, which PhysicalCards to fetch.
     */
    where?: PhysicalCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhysicalCards to fetch.
     */
    orderBy?: PhysicalCardOrderByWithRelationInput | PhysicalCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PhysicalCards.
     */
    cursor?: PhysicalCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhysicalCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhysicalCards.
     */
    skip?: number
    distinct?: PhysicalCardScalarFieldEnum | PhysicalCardScalarFieldEnum[]
  }

  /**
   * PhysicalCard create
   */
  export type PhysicalCardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhysicalCard
     */
    select?: PhysicalCardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhysicalCard
     */
    omit?: PhysicalCardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhysicalCardInclude<ExtArgs> | null
    /**
     * The data needed to create a PhysicalCard.
     */
    data: XOR<PhysicalCardCreateInput, PhysicalCardUncheckedCreateInput>
  }

  /**
   * PhysicalCard createMany
   */
  export type PhysicalCardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PhysicalCards.
     */
    data: PhysicalCardCreateManyInput | PhysicalCardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PhysicalCard createManyAndReturn
   */
  export type PhysicalCardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhysicalCard
     */
    select?: PhysicalCardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PhysicalCard
     */
    omit?: PhysicalCardOmit<ExtArgs> | null
    /**
     * The data used to create many PhysicalCards.
     */
    data: PhysicalCardCreateManyInput | PhysicalCardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhysicalCardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PhysicalCard update
   */
  export type PhysicalCardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhysicalCard
     */
    select?: PhysicalCardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhysicalCard
     */
    omit?: PhysicalCardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhysicalCardInclude<ExtArgs> | null
    /**
     * The data needed to update a PhysicalCard.
     */
    data: XOR<PhysicalCardUpdateInput, PhysicalCardUncheckedUpdateInput>
    /**
     * Choose, which PhysicalCard to update.
     */
    where: PhysicalCardWhereUniqueInput
  }

  /**
   * PhysicalCard updateMany
   */
  export type PhysicalCardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PhysicalCards.
     */
    data: XOR<PhysicalCardUpdateManyMutationInput, PhysicalCardUncheckedUpdateManyInput>
    /**
     * Filter which PhysicalCards to update
     */
    where?: PhysicalCardWhereInput
    /**
     * Limit how many PhysicalCards to update.
     */
    limit?: number
  }

  /**
   * PhysicalCard updateManyAndReturn
   */
  export type PhysicalCardUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhysicalCard
     */
    select?: PhysicalCardSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PhysicalCard
     */
    omit?: PhysicalCardOmit<ExtArgs> | null
    /**
     * The data used to update PhysicalCards.
     */
    data: XOR<PhysicalCardUpdateManyMutationInput, PhysicalCardUncheckedUpdateManyInput>
    /**
     * Filter which PhysicalCards to update
     */
    where?: PhysicalCardWhereInput
    /**
     * Limit how many PhysicalCards to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhysicalCardIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PhysicalCard upsert
   */
  export type PhysicalCardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhysicalCard
     */
    select?: PhysicalCardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhysicalCard
     */
    omit?: PhysicalCardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhysicalCardInclude<ExtArgs> | null
    /**
     * The filter to search for the PhysicalCard to update in case it exists.
     */
    where: PhysicalCardWhereUniqueInput
    /**
     * In case the PhysicalCard found by the `where` argument doesn't exist, create a new PhysicalCard with this data.
     */
    create: XOR<PhysicalCardCreateInput, PhysicalCardUncheckedCreateInput>
    /**
     * In case the PhysicalCard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PhysicalCardUpdateInput, PhysicalCardUncheckedUpdateInput>
  }

  /**
   * PhysicalCard delete
   */
  export type PhysicalCardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhysicalCard
     */
    select?: PhysicalCardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhysicalCard
     */
    omit?: PhysicalCardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhysicalCardInclude<ExtArgs> | null
    /**
     * Filter which PhysicalCard to delete.
     */
    where: PhysicalCardWhereUniqueInput
  }

  /**
   * PhysicalCard deleteMany
   */
  export type PhysicalCardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PhysicalCards to delete
     */
    where?: PhysicalCardWhereInput
    /**
     * Limit how many PhysicalCards to delete.
     */
    limit?: number
  }

  /**
   * PhysicalCard without action
   */
  export type PhysicalCardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhysicalCard
     */
    select?: PhysicalCardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhysicalCard
     */
    omit?: PhysicalCardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhysicalCardInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    read: boolean | null
    priority: $Enums.NotificationPriority | null
    requiresSubscription: $Enums.SubscriptionPlan | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    read: boolean | null
    priority: $Enums.NotificationPriority | null
    requiresSubscription: $Enums.SubscriptionPlan | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    title: number
    message: number
    data: number
    read: number
    priority: number
    requiresSubscription: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    read?: true
    priority?: true
    requiresSubscription?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    read?: true
    priority?: true
    requiresSubscription?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    data?: true
    read?: true
    priority?: true
    requiresSubscription?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    type: $Enums.NotificationType
    title: string
    message: string
    data: JsonValue | null
    read: boolean
    priority: $Enums.NotificationPriority
    requiresSubscription: $Enums.SubscriptionPlan | null
    createdAt: Date
    updatedAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    data?: boolean
    read?: boolean
    priority?: boolean
    requiresSubscription?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    data?: boolean
    read?: boolean
    priority?: boolean
    requiresSubscription?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    data?: boolean
    read?: boolean
    priority?: boolean
    requiresSubscription?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    data?: boolean
    read?: boolean
    priority?: boolean
    requiresSubscription?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "title" | "message" | "data" | "read" | "priority" | "requiresSubscription" | "createdAt" | "updatedAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: $Enums.NotificationType
      title: string
      message: string
      data: Prisma.JsonValue | null
      read: boolean
      priority: $Enums.NotificationPriority
      requiresSubscription: $Enums.SubscriptionPlan | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly data: FieldRef<"Notification", 'Json'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly priority: FieldRef<"Notification", 'NotificationPriority'>
    readonly requiresSubscription: FieldRef<"Notification", 'SubscriptionPlan'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly updatedAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model SocialFeed
   */

  export type AggregateSocialFeed = {
    _count: SocialFeedCountAggregateOutputType | null
    _avg: SocialFeedAvgAggregateOutputType | null
    _sum: SocialFeedSumAggregateOutputType | null
    _min: SocialFeedMinAggregateOutputType | null
    _max: SocialFeedMaxAggregateOutputType | null
  }

  export type SocialFeedAvgAggregateOutputType = {
    likes: number | null
    comments: number | null
    shares: number | null
  }

  export type SocialFeedSumAggregateOutputType = {
    likes: number | null
    comments: number | null
    shares: number | null
  }

  export type SocialFeedMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.SocialFeedType | null
    content: string | null
    likes: number | null
    comments: number | null
    shares: number | null
    visibility: $Enums.SocialVisibility | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SocialFeedMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.SocialFeedType | null
    content: string | null
    likes: number | null
    comments: number | null
    shares: number | null
    visibility: $Enums.SocialVisibility | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SocialFeedCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    content: number
    data: number
    likes: number
    comments: number
    shares: number
    visibility: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SocialFeedAvgAggregateInputType = {
    likes?: true
    comments?: true
    shares?: true
  }

  export type SocialFeedSumAggregateInputType = {
    likes?: true
    comments?: true
    shares?: true
  }

  export type SocialFeedMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    content?: true
    likes?: true
    comments?: true
    shares?: true
    visibility?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SocialFeedMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    content?: true
    likes?: true
    comments?: true
    shares?: true
    visibility?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SocialFeedCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    content?: true
    data?: true
    likes?: true
    comments?: true
    shares?: true
    visibility?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SocialFeedAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SocialFeed to aggregate.
     */
    where?: SocialFeedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialFeeds to fetch.
     */
    orderBy?: SocialFeedOrderByWithRelationInput | SocialFeedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SocialFeedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialFeeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialFeeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SocialFeeds
    **/
    _count?: true | SocialFeedCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SocialFeedAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SocialFeedSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SocialFeedMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SocialFeedMaxAggregateInputType
  }

  export type GetSocialFeedAggregateType<T extends SocialFeedAggregateArgs> = {
        [P in keyof T & keyof AggregateSocialFeed]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSocialFeed[P]>
      : GetScalarType<T[P], AggregateSocialFeed[P]>
  }




  export type SocialFeedGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SocialFeedWhereInput
    orderBy?: SocialFeedOrderByWithAggregationInput | SocialFeedOrderByWithAggregationInput[]
    by: SocialFeedScalarFieldEnum[] | SocialFeedScalarFieldEnum
    having?: SocialFeedScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SocialFeedCountAggregateInputType | true
    _avg?: SocialFeedAvgAggregateInputType
    _sum?: SocialFeedSumAggregateInputType
    _min?: SocialFeedMinAggregateInputType
    _max?: SocialFeedMaxAggregateInputType
  }

  export type SocialFeedGroupByOutputType = {
    id: string
    userId: string
    type: $Enums.SocialFeedType
    content: string
    data: JsonValue | null
    likes: number
    comments: number
    shares: number
    visibility: $Enums.SocialVisibility
    createdAt: Date
    updatedAt: Date
    _count: SocialFeedCountAggregateOutputType | null
    _avg: SocialFeedAvgAggregateOutputType | null
    _sum: SocialFeedSumAggregateOutputType | null
    _min: SocialFeedMinAggregateOutputType | null
    _max: SocialFeedMaxAggregateOutputType | null
  }

  type GetSocialFeedGroupByPayload<T extends SocialFeedGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SocialFeedGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SocialFeedGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SocialFeedGroupByOutputType[P]>
            : GetScalarType<T[P], SocialFeedGroupByOutputType[P]>
        }
      >
    >


  export type SocialFeedSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    content?: boolean
    data?: boolean
    likes?: boolean
    comments?: boolean
    shares?: boolean
    visibility?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["socialFeed"]>

  export type SocialFeedSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    content?: boolean
    data?: boolean
    likes?: boolean
    comments?: boolean
    shares?: boolean
    visibility?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["socialFeed"]>

  export type SocialFeedSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    content?: boolean
    data?: boolean
    likes?: boolean
    comments?: boolean
    shares?: boolean
    visibility?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["socialFeed"]>

  export type SocialFeedSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    content?: boolean
    data?: boolean
    likes?: boolean
    comments?: boolean
    shares?: boolean
    visibility?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SocialFeedOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "content" | "data" | "likes" | "comments" | "shares" | "visibility" | "createdAt" | "updatedAt", ExtArgs["result"]["socialFeed"]>
  export type SocialFeedInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SocialFeedIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SocialFeedIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SocialFeedPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SocialFeed"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: $Enums.SocialFeedType
      content: string
      data: Prisma.JsonValue | null
      likes: number
      comments: number
      shares: number
      visibility: $Enums.SocialVisibility
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["socialFeed"]>
    composites: {}
  }

  type SocialFeedGetPayload<S extends boolean | null | undefined | SocialFeedDefaultArgs> = $Result.GetResult<Prisma.$SocialFeedPayload, S>

  type SocialFeedCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SocialFeedFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SocialFeedCountAggregateInputType | true
    }

  export interface SocialFeedDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SocialFeed'], meta: { name: 'SocialFeed' } }
    /**
     * Find zero or one SocialFeed that matches the filter.
     * @param {SocialFeedFindUniqueArgs} args - Arguments to find a SocialFeed
     * @example
     * // Get one SocialFeed
     * const socialFeed = await prisma.socialFeed.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SocialFeedFindUniqueArgs>(args: SelectSubset<T, SocialFeedFindUniqueArgs<ExtArgs>>): Prisma__SocialFeedClient<$Result.GetResult<Prisma.$SocialFeedPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SocialFeed that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SocialFeedFindUniqueOrThrowArgs} args - Arguments to find a SocialFeed
     * @example
     * // Get one SocialFeed
     * const socialFeed = await prisma.socialFeed.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SocialFeedFindUniqueOrThrowArgs>(args: SelectSubset<T, SocialFeedFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SocialFeedClient<$Result.GetResult<Prisma.$SocialFeedPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SocialFeed that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialFeedFindFirstArgs} args - Arguments to find a SocialFeed
     * @example
     * // Get one SocialFeed
     * const socialFeed = await prisma.socialFeed.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SocialFeedFindFirstArgs>(args?: SelectSubset<T, SocialFeedFindFirstArgs<ExtArgs>>): Prisma__SocialFeedClient<$Result.GetResult<Prisma.$SocialFeedPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SocialFeed that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialFeedFindFirstOrThrowArgs} args - Arguments to find a SocialFeed
     * @example
     * // Get one SocialFeed
     * const socialFeed = await prisma.socialFeed.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SocialFeedFindFirstOrThrowArgs>(args?: SelectSubset<T, SocialFeedFindFirstOrThrowArgs<ExtArgs>>): Prisma__SocialFeedClient<$Result.GetResult<Prisma.$SocialFeedPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SocialFeeds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialFeedFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SocialFeeds
     * const socialFeeds = await prisma.socialFeed.findMany()
     * 
     * // Get first 10 SocialFeeds
     * const socialFeeds = await prisma.socialFeed.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const socialFeedWithIdOnly = await prisma.socialFeed.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SocialFeedFindManyArgs>(args?: SelectSubset<T, SocialFeedFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialFeedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SocialFeed.
     * @param {SocialFeedCreateArgs} args - Arguments to create a SocialFeed.
     * @example
     * // Create one SocialFeed
     * const SocialFeed = await prisma.socialFeed.create({
     *   data: {
     *     // ... data to create a SocialFeed
     *   }
     * })
     * 
     */
    create<T extends SocialFeedCreateArgs>(args: SelectSubset<T, SocialFeedCreateArgs<ExtArgs>>): Prisma__SocialFeedClient<$Result.GetResult<Prisma.$SocialFeedPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SocialFeeds.
     * @param {SocialFeedCreateManyArgs} args - Arguments to create many SocialFeeds.
     * @example
     * // Create many SocialFeeds
     * const socialFeed = await prisma.socialFeed.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SocialFeedCreateManyArgs>(args?: SelectSubset<T, SocialFeedCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SocialFeeds and returns the data saved in the database.
     * @param {SocialFeedCreateManyAndReturnArgs} args - Arguments to create many SocialFeeds.
     * @example
     * // Create many SocialFeeds
     * const socialFeed = await prisma.socialFeed.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SocialFeeds and only return the `id`
     * const socialFeedWithIdOnly = await prisma.socialFeed.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SocialFeedCreateManyAndReturnArgs>(args?: SelectSubset<T, SocialFeedCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialFeedPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SocialFeed.
     * @param {SocialFeedDeleteArgs} args - Arguments to delete one SocialFeed.
     * @example
     * // Delete one SocialFeed
     * const SocialFeed = await prisma.socialFeed.delete({
     *   where: {
     *     // ... filter to delete one SocialFeed
     *   }
     * })
     * 
     */
    delete<T extends SocialFeedDeleteArgs>(args: SelectSubset<T, SocialFeedDeleteArgs<ExtArgs>>): Prisma__SocialFeedClient<$Result.GetResult<Prisma.$SocialFeedPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SocialFeed.
     * @param {SocialFeedUpdateArgs} args - Arguments to update one SocialFeed.
     * @example
     * // Update one SocialFeed
     * const socialFeed = await prisma.socialFeed.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SocialFeedUpdateArgs>(args: SelectSubset<T, SocialFeedUpdateArgs<ExtArgs>>): Prisma__SocialFeedClient<$Result.GetResult<Prisma.$SocialFeedPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SocialFeeds.
     * @param {SocialFeedDeleteManyArgs} args - Arguments to filter SocialFeeds to delete.
     * @example
     * // Delete a few SocialFeeds
     * const { count } = await prisma.socialFeed.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SocialFeedDeleteManyArgs>(args?: SelectSubset<T, SocialFeedDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SocialFeeds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialFeedUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SocialFeeds
     * const socialFeed = await prisma.socialFeed.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SocialFeedUpdateManyArgs>(args: SelectSubset<T, SocialFeedUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SocialFeeds and returns the data updated in the database.
     * @param {SocialFeedUpdateManyAndReturnArgs} args - Arguments to update many SocialFeeds.
     * @example
     * // Update many SocialFeeds
     * const socialFeed = await prisma.socialFeed.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SocialFeeds and only return the `id`
     * const socialFeedWithIdOnly = await prisma.socialFeed.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SocialFeedUpdateManyAndReturnArgs>(args: SelectSubset<T, SocialFeedUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialFeedPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SocialFeed.
     * @param {SocialFeedUpsertArgs} args - Arguments to update or create a SocialFeed.
     * @example
     * // Update or create a SocialFeed
     * const socialFeed = await prisma.socialFeed.upsert({
     *   create: {
     *     // ... data to create a SocialFeed
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SocialFeed we want to update
     *   }
     * })
     */
    upsert<T extends SocialFeedUpsertArgs>(args: SelectSubset<T, SocialFeedUpsertArgs<ExtArgs>>): Prisma__SocialFeedClient<$Result.GetResult<Prisma.$SocialFeedPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SocialFeeds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialFeedCountArgs} args - Arguments to filter SocialFeeds to count.
     * @example
     * // Count the number of SocialFeeds
     * const count = await prisma.socialFeed.count({
     *   where: {
     *     // ... the filter for the SocialFeeds we want to count
     *   }
     * })
    **/
    count<T extends SocialFeedCountArgs>(
      args?: Subset<T, SocialFeedCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SocialFeedCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SocialFeed.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialFeedAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SocialFeedAggregateArgs>(args: Subset<T, SocialFeedAggregateArgs>): Prisma.PrismaPromise<GetSocialFeedAggregateType<T>>

    /**
     * Group by SocialFeed.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialFeedGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SocialFeedGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SocialFeedGroupByArgs['orderBy'] }
        : { orderBy?: SocialFeedGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SocialFeedGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSocialFeedGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SocialFeed model
   */
  readonly fields: SocialFeedFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SocialFeed.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SocialFeedClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SocialFeed model
   */
  interface SocialFeedFieldRefs {
    readonly id: FieldRef<"SocialFeed", 'String'>
    readonly userId: FieldRef<"SocialFeed", 'String'>
    readonly type: FieldRef<"SocialFeed", 'SocialFeedType'>
    readonly content: FieldRef<"SocialFeed", 'String'>
    readonly data: FieldRef<"SocialFeed", 'Json'>
    readonly likes: FieldRef<"SocialFeed", 'Int'>
    readonly comments: FieldRef<"SocialFeed", 'Int'>
    readonly shares: FieldRef<"SocialFeed", 'Int'>
    readonly visibility: FieldRef<"SocialFeed", 'SocialVisibility'>
    readonly createdAt: FieldRef<"SocialFeed", 'DateTime'>
    readonly updatedAt: FieldRef<"SocialFeed", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SocialFeed findUnique
   */
  export type SocialFeedFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialFeed
     */
    select?: SocialFeedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialFeed
     */
    omit?: SocialFeedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialFeedInclude<ExtArgs> | null
    /**
     * Filter, which SocialFeed to fetch.
     */
    where: SocialFeedWhereUniqueInput
  }

  /**
   * SocialFeed findUniqueOrThrow
   */
  export type SocialFeedFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialFeed
     */
    select?: SocialFeedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialFeed
     */
    omit?: SocialFeedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialFeedInclude<ExtArgs> | null
    /**
     * Filter, which SocialFeed to fetch.
     */
    where: SocialFeedWhereUniqueInput
  }

  /**
   * SocialFeed findFirst
   */
  export type SocialFeedFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialFeed
     */
    select?: SocialFeedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialFeed
     */
    omit?: SocialFeedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialFeedInclude<ExtArgs> | null
    /**
     * Filter, which SocialFeed to fetch.
     */
    where?: SocialFeedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialFeeds to fetch.
     */
    orderBy?: SocialFeedOrderByWithRelationInput | SocialFeedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SocialFeeds.
     */
    cursor?: SocialFeedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialFeeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialFeeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SocialFeeds.
     */
    distinct?: SocialFeedScalarFieldEnum | SocialFeedScalarFieldEnum[]
  }

  /**
   * SocialFeed findFirstOrThrow
   */
  export type SocialFeedFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialFeed
     */
    select?: SocialFeedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialFeed
     */
    omit?: SocialFeedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialFeedInclude<ExtArgs> | null
    /**
     * Filter, which SocialFeed to fetch.
     */
    where?: SocialFeedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialFeeds to fetch.
     */
    orderBy?: SocialFeedOrderByWithRelationInput | SocialFeedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SocialFeeds.
     */
    cursor?: SocialFeedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialFeeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialFeeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SocialFeeds.
     */
    distinct?: SocialFeedScalarFieldEnum | SocialFeedScalarFieldEnum[]
  }

  /**
   * SocialFeed findMany
   */
  export type SocialFeedFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialFeed
     */
    select?: SocialFeedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialFeed
     */
    omit?: SocialFeedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialFeedInclude<ExtArgs> | null
    /**
     * Filter, which SocialFeeds to fetch.
     */
    where?: SocialFeedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialFeeds to fetch.
     */
    orderBy?: SocialFeedOrderByWithRelationInput | SocialFeedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SocialFeeds.
     */
    cursor?: SocialFeedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialFeeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialFeeds.
     */
    skip?: number
    distinct?: SocialFeedScalarFieldEnum | SocialFeedScalarFieldEnum[]
  }

  /**
   * SocialFeed create
   */
  export type SocialFeedCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialFeed
     */
    select?: SocialFeedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialFeed
     */
    omit?: SocialFeedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialFeedInclude<ExtArgs> | null
    /**
     * The data needed to create a SocialFeed.
     */
    data: XOR<SocialFeedCreateInput, SocialFeedUncheckedCreateInput>
  }

  /**
   * SocialFeed createMany
   */
  export type SocialFeedCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SocialFeeds.
     */
    data: SocialFeedCreateManyInput | SocialFeedCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SocialFeed createManyAndReturn
   */
  export type SocialFeedCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialFeed
     */
    select?: SocialFeedSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SocialFeed
     */
    omit?: SocialFeedOmit<ExtArgs> | null
    /**
     * The data used to create many SocialFeeds.
     */
    data: SocialFeedCreateManyInput | SocialFeedCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialFeedIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SocialFeed update
   */
  export type SocialFeedUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialFeed
     */
    select?: SocialFeedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialFeed
     */
    omit?: SocialFeedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialFeedInclude<ExtArgs> | null
    /**
     * The data needed to update a SocialFeed.
     */
    data: XOR<SocialFeedUpdateInput, SocialFeedUncheckedUpdateInput>
    /**
     * Choose, which SocialFeed to update.
     */
    where: SocialFeedWhereUniqueInput
  }

  /**
   * SocialFeed updateMany
   */
  export type SocialFeedUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SocialFeeds.
     */
    data: XOR<SocialFeedUpdateManyMutationInput, SocialFeedUncheckedUpdateManyInput>
    /**
     * Filter which SocialFeeds to update
     */
    where?: SocialFeedWhereInput
    /**
     * Limit how many SocialFeeds to update.
     */
    limit?: number
  }

  /**
   * SocialFeed updateManyAndReturn
   */
  export type SocialFeedUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialFeed
     */
    select?: SocialFeedSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SocialFeed
     */
    omit?: SocialFeedOmit<ExtArgs> | null
    /**
     * The data used to update SocialFeeds.
     */
    data: XOR<SocialFeedUpdateManyMutationInput, SocialFeedUncheckedUpdateManyInput>
    /**
     * Filter which SocialFeeds to update
     */
    where?: SocialFeedWhereInput
    /**
     * Limit how many SocialFeeds to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialFeedIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SocialFeed upsert
   */
  export type SocialFeedUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialFeed
     */
    select?: SocialFeedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialFeed
     */
    omit?: SocialFeedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialFeedInclude<ExtArgs> | null
    /**
     * The filter to search for the SocialFeed to update in case it exists.
     */
    where: SocialFeedWhereUniqueInput
    /**
     * In case the SocialFeed found by the `where` argument doesn't exist, create a new SocialFeed with this data.
     */
    create: XOR<SocialFeedCreateInput, SocialFeedUncheckedCreateInput>
    /**
     * In case the SocialFeed was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SocialFeedUpdateInput, SocialFeedUncheckedUpdateInput>
  }

  /**
   * SocialFeed delete
   */
  export type SocialFeedDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialFeed
     */
    select?: SocialFeedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialFeed
     */
    omit?: SocialFeedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialFeedInclude<ExtArgs> | null
    /**
     * Filter which SocialFeed to delete.
     */
    where: SocialFeedWhereUniqueInput
  }

  /**
   * SocialFeed deleteMany
   */
  export type SocialFeedDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SocialFeeds to delete
     */
    where?: SocialFeedWhereInput
    /**
     * Limit how many SocialFeeds to delete.
     */
    limit?: number
  }

  /**
   * SocialFeed without action
   */
  export type SocialFeedDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialFeed
     */
    select?: SocialFeedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialFeed
     */
    omit?: SocialFeedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialFeedInclude<ExtArgs> | null
  }


  /**
   * Model Follow
   */

  export type AggregateFollow = {
    _count: FollowCountAggregateOutputType | null
    _min: FollowMinAggregateOutputType | null
    _max: FollowMaxAggregateOutputType | null
  }

  export type FollowMinAggregateOutputType = {
    id: string | null
    followerId: string | null
    followingId: string | null
    createdAt: Date | null
  }

  export type FollowMaxAggregateOutputType = {
    id: string | null
    followerId: string | null
    followingId: string | null
    createdAt: Date | null
  }

  export type FollowCountAggregateOutputType = {
    id: number
    followerId: number
    followingId: number
    createdAt: number
    _all: number
  }


  export type FollowMinAggregateInputType = {
    id?: true
    followerId?: true
    followingId?: true
    createdAt?: true
  }

  export type FollowMaxAggregateInputType = {
    id?: true
    followerId?: true
    followingId?: true
    createdAt?: true
  }

  export type FollowCountAggregateInputType = {
    id?: true
    followerId?: true
    followingId?: true
    createdAt?: true
    _all?: true
  }

  export type FollowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Follow to aggregate.
     */
    where?: FollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Follows
    **/
    _count?: true | FollowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FollowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FollowMaxAggregateInputType
  }

  export type GetFollowAggregateType<T extends FollowAggregateArgs> = {
        [P in keyof T & keyof AggregateFollow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFollow[P]>
      : GetScalarType<T[P], AggregateFollow[P]>
  }




  export type FollowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowWhereInput
    orderBy?: FollowOrderByWithAggregationInput | FollowOrderByWithAggregationInput[]
    by: FollowScalarFieldEnum[] | FollowScalarFieldEnum
    having?: FollowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FollowCountAggregateInputType | true
    _min?: FollowMinAggregateInputType
    _max?: FollowMaxAggregateInputType
  }

  export type FollowGroupByOutputType = {
    id: string
    followerId: string
    followingId: string
    createdAt: Date
    _count: FollowCountAggregateOutputType | null
    _min: FollowMinAggregateOutputType | null
    _max: FollowMaxAggregateOutputType | null
  }

  type GetFollowGroupByPayload<T extends FollowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FollowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FollowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FollowGroupByOutputType[P]>
            : GetScalarType<T[P], FollowGroupByOutputType[P]>
        }
      >
    >


  export type FollowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    followerId?: boolean
    followingId?: boolean
    createdAt?: boolean
    follower?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["follow"]>

  export type FollowSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    followerId?: boolean
    followingId?: boolean
    createdAt?: boolean
    follower?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["follow"]>

  export type FollowSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    followerId?: boolean
    followingId?: boolean
    createdAt?: boolean
    follower?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["follow"]>

  export type FollowSelectScalar = {
    id?: boolean
    followerId?: boolean
    followingId?: boolean
    createdAt?: boolean
  }

  export type FollowOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "followerId" | "followingId" | "createdAt", ExtArgs["result"]["follow"]>
  export type FollowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    follower?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FollowIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    follower?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FollowIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    follower?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FollowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Follow"
    objects: {
      follower: Prisma.$UserPayload<ExtArgs>
      following: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      followerId: string
      followingId: string
      createdAt: Date
    }, ExtArgs["result"]["follow"]>
    composites: {}
  }

  type FollowGetPayload<S extends boolean | null | undefined | FollowDefaultArgs> = $Result.GetResult<Prisma.$FollowPayload, S>

  type FollowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FollowFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FollowCountAggregateInputType | true
    }

  export interface FollowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Follow'], meta: { name: 'Follow' } }
    /**
     * Find zero or one Follow that matches the filter.
     * @param {FollowFindUniqueArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FollowFindUniqueArgs>(args: SelectSubset<T, FollowFindUniqueArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Follow that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FollowFindUniqueOrThrowArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FollowFindUniqueOrThrowArgs>(args: SelectSubset<T, FollowFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Follow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowFindFirstArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FollowFindFirstArgs>(args?: SelectSubset<T, FollowFindFirstArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Follow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowFindFirstOrThrowArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FollowFindFirstOrThrowArgs>(args?: SelectSubset<T, FollowFindFirstOrThrowArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Follows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Follows
     * const follows = await prisma.follow.findMany()
     * 
     * // Get first 10 Follows
     * const follows = await prisma.follow.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const followWithIdOnly = await prisma.follow.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FollowFindManyArgs>(args?: SelectSubset<T, FollowFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Follow.
     * @param {FollowCreateArgs} args - Arguments to create a Follow.
     * @example
     * // Create one Follow
     * const Follow = await prisma.follow.create({
     *   data: {
     *     // ... data to create a Follow
     *   }
     * })
     * 
     */
    create<T extends FollowCreateArgs>(args: SelectSubset<T, FollowCreateArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Follows.
     * @param {FollowCreateManyArgs} args - Arguments to create many Follows.
     * @example
     * // Create many Follows
     * const follow = await prisma.follow.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FollowCreateManyArgs>(args?: SelectSubset<T, FollowCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Follows and returns the data saved in the database.
     * @param {FollowCreateManyAndReturnArgs} args - Arguments to create many Follows.
     * @example
     * // Create many Follows
     * const follow = await prisma.follow.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Follows and only return the `id`
     * const followWithIdOnly = await prisma.follow.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FollowCreateManyAndReturnArgs>(args?: SelectSubset<T, FollowCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Follow.
     * @param {FollowDeleteArgs} args - Arguments to delete one Follow.
     * @example
     * // Delete one Follow
     * const Follow = await prisma.follow.delete({
     *   where: {
     *     // ... filter to delete one Follow
     *   }
     * })
     * 
     */
    delete<T extends FollowDeleteArgs>(args: SelectSubset<T, FollowDeleteArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Follow.
     * @param {FollowUpdateArgs} args - Arguments to update one Follow.
     * @example
     * // Update one Follow
     * const follow = await prisma.follow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FollowUpdateArgs>(args: SelectSubset<T, FollowUpdateArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Follows.
     * @param {FollowDeleteManyArgs} args - Arguments to filter Follows to delete.
     * @example
     * // Delete a few Follows
     * const { count } = await prisma.follow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FollowDeleteManyArgs>(args?: SelectSubset<T, FollowDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Follows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Follows
     * const follow = await prisma.follow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FollowUpdateManyArgs>(args: SelectSubset<T, FollowUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Follows and returns the data updated in the database.
     * @param {FollowUpdateManyAndReturnArgs} args - Arguments to update many Follows.
     * @example
     * // Update many Follows
     * const follow = await prisma.follow.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Follows and only return the `id`
     * const followWithIdOnly = await prisma.follow.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FollowUpdateManyAndReturnArgs>(args: SelectSubset<T, FollowUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Follow.
     * @param {FollowUpsertArgs} args - Arguments to update or create a Follow.
     * @example
     * // Update or create a Follow
     * const follow = await prisma.follow.upsert({
     *   create: {
     *     // ... data to create a Follow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Follow we want to update
     *   }
     * })
     */
    upsert<T extends FollowUpsertArgs>(args: SelectSubset<T, FollowUpsertArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Follows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowCountArgs} args - Arguments to filter Follows to count.
     * @example
     * // Count the number of Follows
     * const count = await prisma.follow.count({
     *   where: {
     *     // ... the filter for the Follows we want to count
     *   }
     * })
    **/
    count<T extends FollowCountArgs>(
      args?: Subset<T, FollowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FollowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Follow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FollowAggregateArgs>(args: Subset<T, FollowAggregateArgs>): Prisma.PrismaPromise<GetFollowAggregateType<T>>

    /**
     * Group by Follow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FollowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FollowGroupByArgs['orderBy'] }
        : { orderBy?: FollowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FollowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFollowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Follow model
   */
  readonly fields: FollowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Follow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FollowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    follower<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    following<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Follow model
   */
  interface FollowFieldRefs {
    readonly id: FieldRef<"Follow", 'String'>
    readonly followerId: FieldRef<"Follow", 'String'>
    readonly followingId: FieldRef<"Follow", 'String'>
    readonly createdAt: FieldRef<"Follow", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Follow findUnique
   */
  export type FollowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follow to fetch.
     */
    where: FollowWhereUniqueInput
  }

  /**
   * Follow findUniqueOrThrow
   */
  export type FollowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follow to fetch.
     */
    where: FollowWhereUniqueInput
  }

  /**
   * Follow findFirst
   */
  export type FollowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follow to fetch.
     */
    where?: FollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Follows.
     */
    cursor?: FollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Follows.
     */
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * Follow findFirstOrThrow
   */
  export type FollowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follow to fetch.
     */
    where?: FollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Follows.
     */
    cursor?: FollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Follows.
     */
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * Follow findMany
   */
  export type FollowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follows to fetch.
     */
    where?: FollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Follows.
     */
    cursor?: FollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * Follow create
   */
  export type FollowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * The data needed to create a Follow.
     */
    data: XOR<FollowCreateInput, FollowUncheckedCreateInput>
  }

  /**
   * Follow createMany
   */
  export type FollowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Follows.
     */
    data: FollowCreateManyInput | FollowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Follow createManyAndReturn
   */
  export type FollowCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * The data used to create many Follows.
     */
    data: FollowCreateManyInput | FollowCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Follow update
   */
  export type FollowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * The data needed to update a Follow.
     */
    data: XOR<FollowUpdateInput, FollowUncheckedUpdateInput>
    /**
     * Choose, which Follow to update.
     */
    where: FollowWhereUniqueInput
  }

  /**
   * Follow updateMany
   */
  export type FollowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Follows.
     */
    data: XOR<FollowUpdateManyMutationInput, FollowUncheckedUpdateManyInput>
    /**
     * Filter which Follows to update
     */
    where?: FollowWhereInput
    /**
     * Limit how many Follows to update.
     */
    limit?: number
  }

  /**
   * Follow updateManyAndReturn
   */
  export type FollowUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * The data used to update Follows.
     */
    data: XOR<FollowUpdateManyMutationInput, FollowUncheckedUpdateManyInput>
    /**
     * Filter which Follows to update
     */
    where?: FollowWhereInput
    /**
     * Limit how many Follows to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Follow upsert
   */
  export type FollowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * The filter to search for the Follow to update in case it exists.
     */
    where: FollowWhereUniqueInput
    /**
     * In case the Follow found by the `where` argument doesn't exist, create a new Follow with this data.
     */
    create: XOR<FollowCreateInput, FollowUncheckedCreateInput>
    /**
     * In case the Follow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FollowUpdateInput, FollowUncheckedUpdateInput>
  }

  /**
   * Follow delete
   */
  export type FollowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter which Follow to delete.
     */
    where: FollowWhereUniqueInput
  }

  /**
   * Follow deleteMany
   */
  export type FollowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Follows to delete
     */
    where?: FollowWhereInput
    /**
     * Limit how many Follows to delete.
     */
    limit?: number
  }

  /**
   * Follow without action
   */
  export type FollowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
  }


  /**
   * Model AppOrder
   */

  export type AggregateAppOrder = {
    _count: AppOrderCountAggregateOutputType | null
    _avg: AppOrderAvgAggregateOutputType | null
    _sum: AppOrderSumAggregateOutputType | null
    _min: AppOrderMinAggregateOutputType | null
    _max: AppOrderMaxAggregateOutputType | null
  }

  export type AppOrderAvgAggregateOutputType = {
    estimatedCost: number | null
    actualCost: number | null
    progressPercentage: number | null
  }

  export type AppOrderSumAggregateOutputType = {
    estimatedCost: number | null
    actualCost: number | null
    progressPercentage: number | null
  }

  export type AppOrderMinAggregateOutputType = {
    id: string | null
    userId: string | null
    projectType: $Enums.ProjectType | null
    title: string | null
    description: string | null
    timeline: $Enums.OrderTimeline | null
    estimatedCost: number | null
    actualCost: number | null
    currency: string | null
    status: $Enums.OrderStatus | null
    priority: $Enums.OrderPriority | null
    deliveryDate: Date | null
    githubRepo: string | null
    vercelLink: string | null
    downloadLink: string | null
    progressPercentage: number | null
    currentMilestone: string | null
    assignedAdminId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AppOrderMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    projectType: $Enums.ProjectType | null
    title: string | null
    description: string | null
    timeline: $Enums.OrderTimeline | null
    estimatedCost: number | null
    actualCost: number | null
    currency: string | null
    status: $Enums.OrderStatus | null
    priority: $Enums.OrderPriority | null
    deliveryDate: Date | null
    githubRepo: string | null
    vercelLink: string | null
    downloadLink: string | null
    progressPercentage: number | null
    currentMilestone: string | null
    assignedAdminId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AppOrderCountAggregateOutputType = {
    id: number
    userId: number
    projectType: number
    title: number
    description: number
    requirements: number
    timeline: number
    estimatedCost: number
    actualCost: number
    currency: number
    status: number
    priority: number
    deliveryDate: number
    githubRepo: number
    vercelLink: number
    downloadLink: number
    progressPercentage: number
    currentMilestone: number
    assignedAdminId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AppOrderAvgAggregateInputType = {
    estimatedCost?: true
    actualCost?: true
    progressPercentage?: true
  }

  export type AppOrderSumAggregateInputType = {
    estimatedCost?: true
    actualCost?: true
    progressPercentage?: true
  }

  export type AppOrderMinAggregateInputType = {
    id?: true
    userId?: true
    projectType?: true
    title?: true
    description?: true
    timeline?: true
    estimatedCost?: true
    actualCost?: true
    currency?: true
    status?: true
    priority?: true
    deliveryDate?: true
    githubRepo?: true
    vercelLink?: true
    downloadLink?: true
    progressPercentage?: true
    currentMilestone?: true
    assignedAdminId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AppOrderMaxAggregateInputType = {
    id?: true
    userId?: true
    projectType?: true
    title?: true
    description?: true
    timeline?: true
    estimatedCost?: true
    actualCost?: true
    currency?: true
    status?: true
    priority?: true
    deliveryDate?: true
    githubRepo?: true
    vercelLink?: true
    downloadLink?: true
    progressPercentage?: true
    currentMilestone?: true
    assignedAdminId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AppOrderCountAggregateInputType = {
    id?: true
    userId?: true
    projectType?: true
    title?: true
    description?: true
    requirements?: true
    timeline?: true
    estimatedCost?: true
    actualCost?: true
    currency?: true
    status?: true
    priority?: true
    deliveryDate?: true
    githubRepo?: true
    vercelLink?: true
    downloadLink?: true
    progressPercentage?: true
    currentMilestone?: true
    assignedAdminId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AppOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AppOrder to aggregate.
     */
    where?: AppOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppOrders to fetch.
     */
    orderBy?: AppOrderOrderByWithRelationInput | AppOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AppOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AppOrders
    **/
    _count?: true | AppOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AppOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AppOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppOrderMaxAggregateInputType
  }

  export type GetAppOrderAggregateType<T extends AppOrderAggregateArgs> = {
        [P in keyof T & keyof AggregateAppOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppOrder[P]>
      : GetScalarType<T[P], AggregateAppOrder[P]>
  }




  export type AppOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppOrderWhereInput
    orderBy?: AppOrderOrderByWithAggregationInput | AppOrderOrderByWithAggregationInput[]
    by: AppOrderScalarFieldEnum[] | AppOrderScalarFieldEnum
    having?: AppOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppOrderCountAggregateInputType | true
    _avg?: AppOrderAvgAggregateInputType
    _sum?: AppOrderSumAggregateInputType
    _min?: AppOrderMinAggregateInputType
    _max?: AppOrderMaxAggregateInputType
  }

  export type AppOrderGroupByOutputType = {
    id: string
    userId: string
    projectType: $Enums.ProjectType
    title: string
    description: string
    requirements: JsonValue | null
    timeline: $Enums.OrderTimeline
    estimatedCost: number
    actualCost: number | null
    currency: string
    status: $Enums.OrderStatus
    priority: $Enums.OrderPriority
    deliveryDate: Date | null
    githubRepo: string | null
    vercelLink: string | null
    downloadLink: string | null
    progressPercentage: number
    currentMilestone: string | null
    assignedAdminId: string | null
    createdAt: Date
    updatedAt: Date
    _count: AppOrderCountAggregateOutputType | null
    _avg: AppOrderAvgAggregateOutputType | null
    _sum: AppOrderSumAggregateOutputType | null
    _min: AppOrderMinAggregateOutputType | null
    _max: AppOrderMaxAggregateOutputType | null
  }

  type GetAppOrderGroupByPayload<T extends AppOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppOrderGroupByOutputType[P]>
            : GetScalarType<T[P], AppOrderGroupByOutputType[P]>
        }
      >
    >


  export type AppOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    projectType?: boolean
    title?: boolean
    description?: boolean
    requirements?: boolean
    timeline?: boolean
    estimatedCost?: boolean
    actualCost?: boolean
    currency?: boolean
    status?: boolean
    priority?: boolean
    deliveryDate?: boolean
    githubRepo?: boolean
    vercelLink?: boolean
    downloadLink?: boolean
    progressPercentage?: boolean
    currentMilestone?: boolean
    assignedAdminId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    revisions?: boolean | AppOrder$revisionsArgs<ExtArgs>
    communications?: boolean | AppOrder$communicationsArgs<ExtArgs>
    deliverables?: boolean | AppOrder$deliverablesArgs<ExtArgs>
    _count?: boolean | AppOrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appOrder"]>

  export type AppOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    projectType?: boolean
    title?: boolean
    description?: boolean
    requirements?: boolean
    timeline?: boolean
    estimatedCost?: boolean
    actualCost?: boolean
    currency?: boolean
    status?: boolean
    priority?: boolean
    deliveryDate?: boolean
    githubRepo?: boolean
    vercelLink?: boolean
    downloadLink?: boolean
    progressPercentage?: boolean
    currentMilestone?: boolean
    assignedAdminId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appOrder"]>

  export type AppOrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    projectType?: boolean
    title?: boolean
    description?: boolean
    requirements?: boolean
    timeline?: boolean
    estimatedCost?: boolean
    actualCost?: boolean
    currency?: boolean
    status?: boolean
    priority?: boolean
    deliveryDate?: boolean
    githubRepo?: boolean
    vercelLink?: boolean
    downloadLink?: boolean
    progressPercentage?: boolean
    currentMilestone?: boolean
    assignedAdminId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appOrder"]>

  export type AppOrderSelectScalar = {
    id?: boolean
    userId?: boolean
    projectType?: boolean
    title?: boolean
    description?: boolean
    requirements?: boolean
    timeline?: boolean
    estimatedCost?: boolean
    actualCost?: boolean
    currency?: boolean
    status?: boolean
    priority?: boolean
    deliveryDate?: boolean
    githubRepo?: boolean
    vercelLink?: boolean
    downloadLink?: boolean
    progressPercentage?: boolean
    currentMilestone?: boolean
    assignedAdminId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AppOrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "projectType" | "title" | "description" | "requirements" | "timeline" | "estimatedCost" | "actualCost" | "currency" | "status" | "priority" | "deliveryDate" | "githubRepo" | "vercelLink" | "downloadLink" | "progressPercentage" | "currentMilestone" | "assignedAdminId" | "createdAt" | "updatedAt", ExtArgs["result"]["appOrder"]>
  export type AppOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    revisions?: boolean | AppOrder$revisionsArgs<ExtArgs>
    communications?: boolean | AppOrder$communicationsArgs<ExtArgs>
    deliverables?: boolean | AppOrder$deliverablesArgs<ExtArgs>
    _count?: boolean | AppOrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AppOrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AppOrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AppOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AppOrder"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      revisions: Prisma.$OrderRevisionPayload<ExtArgs>[]
      communications: Prisma.$OrderCommunicationPayload<ExtArgs>[]
      deliverables: Prisma.$OrderDeliverablePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      projectType: $Enums.ProjectType
      title: string
      description: string
      requirements: Prisma.JsonValue | null
      timeline: $Enums.OrderTimeline
      estimatedCost: number
      actualCost: number | null
      currency: string
      status: $Enums.OrderStatus
      priority: $Enums.OrderPriority
      deliveryDate: Date | null
      githubRepo: string | null
      vercelLink: string | null
      downloadLink: string | null
      progressPercentage: number
      currentMilestone: string | null
      assignedAdminId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["appOrder"]>
    composites: {}
  }

  type AppOrderGetPayload<S extends boolean | null | undefined | AppOrderDefaultArgs> = $Result.GetResult<Prisma.$AppOrderPayload, S>

  type AppOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AppOrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AppOrderCountAggregateInputType | true
    }

  export interface AppOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AppOrder'], meta: { name: 'AppOrder' } }
    /**
     * Find zero or one AppOrder that matches the filter.
     * @param {AppOrderFindUniqueArgs} args - Arguments to find a AppOrder
     * @example
     * // Get one AppOrder
     * const appOrder = await prisma.appOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AppOrderFindUniqueArgs>(args: SelectSubset<T, AppOrderFindUniqueArgs<ExtArgs>>): Prisma__AppOrderClient<$Result.GetResult<Prisma.$AppOrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AppOrder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AppOrderFindUniqueOrThrowArgs} args - Arguments to find a AppOrder
     * @example
     * // Get one AppOrder
     * const appOrder = await prisma.appOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AppOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, AppOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AppOrderClient<$Result.GetResult<Prisma.$AppOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AppOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppOrderFindFirstArgs} args - Arguments to find a AppOrder
     * @example
     * // Get one AppOrder
     * const appOrder = await prisma.appOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AppOrderFindFirstArgs>(args?: SelectSubset<T, AppOrderFindFirstArgs<ExtArgs>>): Prisma__AppOrderClient<$Result.GetResult<Prisma.$AppOrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AppOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppOrderFindFirstOrThrowArgs} args - Arguments to find a AppOrder
     * @example
     * // Get one AppOrder
     * const appOrder = await prisma.appOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AppOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, AppOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__AppOrderClient<$Result.GetResult<Prisma.$AppOrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AppOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AppOrders
     * const appOrders = await prisma.appOrder.findMany()
     * 
     * // Get first 10 AppOrders
     * const appOrders = await prisma.appOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appOrderWithIdOnly = await prisma.appOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AppOrderFindManyArgs>(args?: SelectSubset<T, AppOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AppOrder.
     * @param {AppOrderCreateArgs} args - Arguments to create a AppOrder.
     * @example
     * // Create one AppOrder
     * const AppOrder = await prisma.appOrder.create({
     *   data: {
     *     // ... data to create a AppOrder
     *   }
     * })
     * 
     */
    create<T extends AppOrderCreateArgs>(args: SelectSubset<T, AppOrderCreateArgs<ExtArgs>>): Prisma__AppOrderClient<$Result.GetResult<Prisma.$AppOrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AppOrders.
     * @param {AppOrderCreateManyArgs} args - Arguments to create many AppOrders.
     * @example
     * // Create many AppOrders
     * const appOrder = await prisma.appOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AppOrderCreateManyArgs>(args?: SelectSubset<T, AppOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AppOrders and returns the data saved in the database.
     * @param {AppOrderCreateManyAndReturnArgs} args - Arguments to create many AppOrders.
     * @example
     * // Create many AppOrders
     * const appOrder = await prisma.appOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AppOrders and only return the `id`
     * const appOrderWithIdOnly = await prisma.appOrder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AppOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, AppOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppOrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AppOrder.
     * @param {AppOrderDeleteArgs} args - Arguments to delete one AppOrder.
     * @example
     * // Delete one AppOrder
     * const AppOrder = await prisma.appOrder.delete({
     *   where: {
     *     // ... filter to delete one AppOrder
     *   }
     * })
     * 
     */
    delete<T extends AppOrderDeleteArgs>(args: SelectSubset<T, AppOrderDeleteArgs<ExtArgs>>): Prisma__AppOrderClient<$Result.GetResult<Prisma.$AppOrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AppOrder.
     * @param {AppOrderUpdateArgs} args - Arguments to update one AppOrder.
     * @example
     * // Update one AppOrder
     * const appOrder = await prisma.appOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AppOrderUpdateArgs>(args: SelectSubset<T, AppOrderUpdateArgs<ExtArgs>>): Prisma__AppOrderClient<$Result.GetResult<Prisma.$AppOrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AppOrders.
     * @param {AppOrderDeleteManyArgs} args - Arguments to filter AppOrders to delete.
     * @example
     * // Delete a few AppOrders
     * const { count } = await prisma.appOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AppOrderDeleteManyArgs>(args?: SelectSubset<T, AppOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AppOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AppOrders
     * const appOrder = await prisma.appOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AppOrderUpdateManyArgs>(args: SelectSubset<T, AppOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AppOrders and returns the data updated in the database.
     * @param {AppOrderUpdateManyAndReturnArgs} args - Arguments to update many AppOrders.
     * @example
     * // Update many AppOrders
     * const appOrder = await prisma.appOrder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AppOrders and only return the `id`
     * const appOrderWithIdOnly = await prisma.appOrder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AppOrderUpdateManyAndReturnArgs>(args: SelectSubset<T, AppOrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppOrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AppOrder.
     * @param {AppOrderUpsertArgs} args - Arguments to update or create a AppOrder.
     * @example
     * // Update or create a AppOrder
     * const appOrder = await prisma.appOrder.upsert({
     *   create: {
     *     // ... data to create a AppOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AppOrder we want to update
     *   }
     * })
     */
    upsert<T extends AppOrderUpsertArgs>(args: SelectSubset<T, AppOrderUpsertArgs<ExtArgs>>): Prisma__AppOrderClient<$Result.GetResult<Prisma.$AppOrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AppOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppOrderCountArgs} args - Arguments to filter AppOrders to count.
     * @example
     * // Count the number of AppOrders
     * const count = await prisma.appOrder.count({
     *   where: {
     *     // ... the filter for the AppOrders we want to count
     *   }
     * })
    **/
    count<T extends AppOrderCountArgs>(
      args?: Subset<T, AppOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AppOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppOrderAggregateArgs>(args: Subset<T, AppOrderAggregateArgs>): Prisma.PrismaPromise<GetAppOrderAggregateType<T>>

    /**
     * Group by AppOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppOrderGroupByArgs['orderBy'] }
        : { orderBy?: AppOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AppOrder model
   */
  readonly fields: AppOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AppOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AppOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    revisions<T extends AppOrder$revisionsArgs<ExtArgs> = {}>(args?: Subset<T, AppOrder$revisionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderRevisionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    communications<T extends AppOrder$communicationsArgs<ExtArgs> = {}>(args?: Subset<T, AppOrder$communicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderCommunicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deliverables<T extends AppOrder$deliverablesArgs<ExtArgs> = {}>(args?: Subset<T, AppOrder$deliverablesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderDeliverablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AppOrder model
   */
  interface AppOrderFieldRefs {
    readonly id: FieldRef<"AppOrder", 'String'>
    readonly userId: FieldRef<"AppOrder", 'String'>
    readonly projectType: FieldRef<"AppOrder", 'ProjectType'>
    readonly title: FieldRef<"AppOrder", 'String'>
    readonly description: FieldRef<"AppOrder", 'String'>
    readonly requirements: FieldRef<"AppOrder", 'Json'>
    readonly timeline: FieldRef<"AppOrder", 'OrderTimeline'>
    readonly estimatedCost: FieldRef<"AppOrder", 'Float'>
    readonly actualCost: FieldRef<"AppOrder", 'Float'>
    readonly currency: FieldRef<"AppOrder", 'String'>
    readonly status: FieldRef<"AppOrder", 'OrderStatus'>
    readonly priority: FieldRef<"AppOrder", 'OrderPriority'>
    readonly deliveryDate: FieldRef<"AppOrder", 'DateTime'>
    readonly githubRepo: FieldRef<"AppOrder", 'String'>
    readonly vercelLink: FieldRef<"AppOrder", 'String'>
    readonly downloadLink: FieldRef<"AppOrder", 'String'>
    readonly progressPercentage: FieldRef<"AppOrder", 'Int'>
    readonly currentMilestone: FieldRef<"AppOrder", 'String'>
    readonly assignedAdminId: FieldRef<"AppOrder", 'String'>
    readonly createdAt: FieldRef<"AppOrder", 'DateTime'>
    readonly updatedAt: FieldRef<"AppOrder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AppOrder findUnique
   */
  export type AppOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppOrder
     */
    select?: AppOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppOrder
     */
    omit?: AppOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppOrderInclude<ExtArgs> | null
    /**
     * Filter, which AppOrder to fetch.
     */
    where: AppOrderWhereUniqueInput
  }

  /**
   * AppOrder findUniqueOrThrow
   */
  export type AppOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppOrder
     */
    select?: AppOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppOrder
     */
    omit?: AppOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppOrderInclude<ExtArgs> | null
    /**
     * Filter, which AppOrder to fetch.
     */
    where: AppOrderWhereUniqueInput
  }

  /**
   * AppOrder findFirst
   */
  export type AppOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppOrder
     */
    select?: AppOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppOrder
     */
    omit?: AppOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppOrderInclude<ExtArgs> | null
    /**
     * Filter, which AppOrder to fetch.
     */
    where?: AppOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppOrders to fetch.
     */
    orderBy?: AppOrderOrderByWithRelationInput | AppOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AppOrders.
     */
    cursor?: AppOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AppOrders.
     */
    distinct?: AppOrderScalarFieldEnum | AppOrderScalarFieldEnum[]
  }

  /**
   * AppOrder findFirstOrThrow
   */
  export type AppOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppOrder
     */
    select?: AppOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppOrder
     */
    omit?: AppOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppOrderInclude<ExtArgs> | null
    /**
     * Filter, which AppOrder to fetch.
     */
    where?: AppOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppOrders to fetch.
     */
    orderBy?: AppOrderOrderByWithRelationInput | AppOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AppOrders.
     */
    cursor?: AppOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AppOrders.
     */
    distinct?: AppOrderScalarFieldEnum | AppOrderScalarFieldEnum[]
  }

  /**
   * AppOrder findMany
   */
  export type AppOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppOrder
     */
    select?: AppOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppOrder
     */
    omit?: AppOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppOrderInclude<ExtArgs> | null
    /**
     * Filter, which AppOrders to fetch.
     */
    where?: AppOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppOrders to fetch.
     */
    orderBy?: AppOrderOrderByWithRelationInput | AppOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AppOrders.
     */
    cursor?: AppOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppOrders.
     */
    skip?: number
    distinct?: AppOrderScalarFieldEnum | AppOrderScalarFieldEnum[]
  }

  /**
   * AppOrder create
   */
  export type AppOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppOrder
     */
    select?: AppOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppOrder
     */
    omit?: AppOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a AppOrder.
     */
    data: XOR<AppOrderCreateInput, AppOrderUncheckedCreateInput>
  }

  /**
   * AppOrder createMany
   */
  export type AppOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AppOrders.
     */
    data: AppOrderCreateManyInput | AppOrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AppOrder createManyAndReturn
   */
  export type AppOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppOrder
     */
    select?: AppOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AppOrder
     */
    omit?: AppOrderOmit<ExtArgs> | null
    /**
     * The data used to create many AppOrders.
     */
    data: AppOrderCreateManyInput | AppOrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppOrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AppOrder update
   */
  export type AppOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppOrder
     */
    select?: AppOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppOrder
     */
    omit?: AppOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a AppOrder.
     */
    data: XOR<AppOrderUpdateInput, AppOrderUncheckedUpdateInput>
    /**
     * Choose, which AppOrder to update.
     */
    where: AppOrderWhereUniqueInput
  }

  /**
   * AppOrder updateMany
   */
  export type AppOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AppOrders.
     */
    data: XOR<AppOrderUpdateManyMutationInput, AppOrderUncheckedUpdateManyInput>
    /**
     * Filter which AppOrders to update
     */
    where?: AppOrderWhereInput
    /**
     * Limit how many AppOrders to update.
     */
    limit?: number
  }

  /**
   * AppOrder updateManyAndReturn
   */
  export type AppOrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppOrder
     */
    select?: AppOrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AppOrder
     */
    omit?: AppOrderOmit<ExtArgs> | null
    /**
     * The data used to update AppOrders.
     */
    data: XOR<AppOrderUpdateManyMutationInput, AppOrderUncheckedUpdateManyInput>
    /**
     * Filter which AppOrders to update
     */
    where?: AppOrderWhereInput
    /**
     * Limit how many AppOrders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppOrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AppOrder upsert
   */
  export type AppOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppOrder
     */
    select?: AppOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppOrder
     */
    omit?: AppOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the AppOrder to update in case it exists.
     */
    where: AppOrderWhereUniqueInput
    /**
     * In case the AppOrder found by the `where` argument doesn't exist, create a new AppOrder with this data.
     */
    create: XOR<AppOrderCreateInput, AppOrderUncheckedCreateInput>
    /**
     * In case the AppOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppOrderUpdateInput, AppOrderUncheckedUpdateInput>
  }

  /**
   * AppOrder delete
   */
  export type AppOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppOrder
     */
    select?: AppOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppOrder
     */
    omit?: AppOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppOrderInclude<ExtArgs> | null
    /**
     * Filter which AppOrder to delete.
     */
    where: AppOrderWhereUniqueInput
  }

  /**
   * AppOrder deleteMany
   */
  export type AppOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AppOrders to delete
     */
    where?: AppOrderWhereInput
    /**
     * Limit how many AppOrders to delete.
     */
    limit?: number
  }

  /**
   * AppOrder.revisions
   */
  export type AppOrder$revisionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderRevision
     */
    select?: OrderRevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderRevision
     */
    omit?: OrderRevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderRevisionInclude<ExtArgs> | null
    where?: OrderRevisionWhereInput
    orderBy?: OrderRevisionOrderByWithRelationInput | OrderRevisionOrderByWithRelationInput[]
    cursor?: OrderRevisionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderRevisionScalarFieldEnum | OrderRevisionScalarFieldEnum[]
  }

  /**
   * AppOrder.communications
   */
  export type AppOrder$communicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCommunication
     */
    select?: OrderCommunicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderCommunication
     */
    omit?: OrderCommunicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderCommunicationInclude<ExtArgs> | null
    where?: OrderCommunicationWhereInput
    orderBy?: OrderCommunicationOrderByWithRelationInput | OrderCommunicationOrderByWithRelationInput[]
    cursor?: OrderCommunicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderCommunicationScalarFieldEnum | OrderCommunicationScalarFieldEnum[]
  }

  /**
   * AppOrder.deliverables
   */
  export type AppOrder$deliverablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDeliverable
     */
    select?: OrderDeliverableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderDeliverable
     */
    omit?: OrderDeliverableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDeliverableInclude<ExtArgs> | null
    where?: OrderDeliverableWhereInput
    orderBy?: OrderDeliverableOrderByWithRelationInput | OrderDeliverableOrderByWithRelationInput[]
    cursor?: OrderDeliverableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderDeliverableScalarFieldEnum | OrderDeliverableScalarFieldEnum[]
  }

  /**
   * AppOrder without action
   */
  export type AppOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppOrder
     */
    select?: AppOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppOrder
     */
    omit?: AppOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppOrderInclude<ExtArgs> | null
  }


  /**
   * Model OrderRevision
   */

  export type AggregateOrderRevision = {
    _count: OrderRevisionCountAggregateOutputType | null
    _avg: OrderRevisionAvgAggregateOutputType | null
    _sum: OrderRevisionSumAggregateOutputType | null
    _min: OrderRevisionMinAggregateOutputType | null
    _max: OrderRevisionMaxAggregateOutputType | null
  }

  export type OrderRevisionAvgAggregateOutputType = {
    revisionNumber: number | null
  }

  export type OrderRevisionSumAggregateOutputType = {
    revisionNumber: number | null
  }

  export type OrderRevisionMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    userId: string | null
    revisionNumber: number | null
    title: string | null
    description: string | null
    status: $Enums.RevisionStatus | null
    adminResponse: string | null
    adminId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderRevisionMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    userId: string | null
    revisionNumber: number | null
    title: string | null
    description: string | null
    status: $Enums.RevisionStatus | null
    adminResponse: string | null
    adminId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderRevisionCountAggregateOutputType = {
    id: number
    orderId: number
    userId: number
    revisionNumber: number
    title: number
    description: number
    status: number
    adminResponse: number
    adminId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrderRevisionAvgAggregateInputType = {
    revisionNumber?: true
  }

  export type OrderRevisionSumAggregateInputType = {
    revisionNumber?: true
  }

  export type OrderRevisionMinAggregateInputType = {
    id?: true
    orderId?: true
    userId?: true
    revisionNumber?: true
    title?: true
    description?: true
    status?: true
    adminResponse?: true
    adminId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderRevisionMaxAggregateInputType = {
    id?: true
    orderId?: true
    userId?: true
    revisionNumber?: true
    title?: true
    description?: true
    status?: true
    adminResponse?: true
    adminId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderRevisionCountAggregateInputType = {
    id?: true
    orderId?: true
    userId?: true
    revisionNumber?: true
    title?: true
    description?: true
    status?: true
    adminResponse?: true
    adminId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrderRevisionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderRevision to aggregate.
     */
    where?: OrderRevisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderRevisions to fetch.
     */
    orderBy?: OrderRevisionOrderByWithRelationInput | OrderRevisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderRevisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderRevisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderRevisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderRevisions
    **/
    _count?: true | OrderRevisionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderRevisionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderRevisionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderRevisionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderRevisionMaxAggregateInputType
  }

  export type GetOrderRevisionAggregateType<T extends OrderRevisionAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderRevision]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderRevision[P]>
      : GetScalarType<T[P], AggregateOrderRevision[P]>
  }




  export type OrderRevisionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderRevisionWhereInput
    orderBy?: OrderRevisionOrderByWithAggregationInput | OrderRevisionOrderByWithAggregationInput[]
    by: OrderRevisionScalarFieldEnum[] | OrderRevisionScalarFieldEnum
    having?: OrderRevisionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderRevisionCountAggregateInputType | true
    _avg?: OrderRevisionAvgAggregateInputType
    _sum?: OrderRevisionSumAggregateInputType
    _min?: OrderRevisionMinAggregateInputType
    _max?: OrderRevisionMaxAggregateInputType
  }

  export type OrderRevisionGroupByOutputType = {
    id: string
    orderId: string
    userId: string
    revisionNumber: number
    title: string
    description: string
    status: $Enums.RevisionStatus
    adminResponse: string | null
    adminId: string | null
    createdAt: Date
    updatedAt: Date
    _count: OrderRevisionCountAggregateOutputType | null
    _avg: OrderRevisionAvgAggregateOutputType | null
    _sum: OrderRevisionSumAggregateOutputType | null
    _min: OrderRevisionMinAggregateOutputType | null
    _max: OrderRevisionMaxAggregateOutputType | null
  }

  type GetOrderRevisionGroupByPayload<T extends OrderRevisionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderRevisionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderRevisionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderRevisionGroupByOutputType[P]>
            : GetScalarType<T[P], OrderRevisionGroupByOutputType[P]>
        }
      >
    >


  export type OrderRevisionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    userId?: boolean
    revisionNumber?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    adminResponse?: boolean
    adminId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | AppOrderDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderRevision"]>

  export type OrderRevisionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    userId?: boolean
    revisionNumber?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    adminResponse?: boolean
    adminId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | AppOrderDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderRevision"]>

  export type OrderRevisionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    userId?: boolean
    revisionNumber?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    adminResponse?: boolean
    adminId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | AppOrderDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderRevision"]>

  export type OrderRevisionSelectScalar = {
    id?: boolean
    orderId?: boolean
    userId?: boolean
    revisionNumber?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    adminResponse?: boolean
    adminId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrderRevisionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "userId" | "revisionNumber" | "title" | "description" | "status" | "adminResponse" | "adminId" | "createdAt" | "updatedAt", ExtArgs["result"]["orderRevision"]>
  export type OrderRevisionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | AppOrderDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type OrderRevisionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | AppOrderDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type OrderRevisionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | AppOrderDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OrderRevisionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderRevision"
    objects: {
      order: Prisma.$AppOrderPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      userId: string
      revisionNumber: number
      title: string
      description: string
      status: $Enums.RevisionStatus
      adminResponse: string | null
      adminId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["orderRevision"]>
    composites: {}
  }

  type OrderRevisionGetPayload<S extends boolean | null | undefined | OrderRevisionDefaultArgs> = $Result.GetResult<Prisma.$OrderRevisionPayload, S>

  type OrderRevisionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderRevisionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderRevisionCountAggregateInputType | true
    }

  export interface OrderRevisionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderRevision'], meta: { name: 'OrderRevision' } }
    /**
     * Find zero or one OrderRevision that matches the filter.
     * @param {OrderRevisionFindUniqueArgs} args - Arguments to find a OrderRevision
     * @example
     * // Get one OrderRevision
     * const orderRevision = await prisma.orderRevision.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderRevisionFindUniqueArgs>(args: SelectSubset<T, OrderRevisionFindUniqueArgs<ExtArgs>>): Prisma__OrderRevisionClient<$Result.GetResult<Prisma.$OrderRevisionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderRevision that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderRevisionFindUniqueOrThrowArgs} args - Arguments to find a OrderRevision
     * @example
     * // Get one OrderRevision
     * const orderRevision = await prisma.orderRevision.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderRevisionFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderRevisionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderRevisionClient<$Result.GetResult<Prisma.$OrderRevisionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderRevision that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderRevisionFindFirstArgs} args - Arguments to find a OrderRevision
     * @example
     * // Get one OrderRevision
     * const orderRevision = await prisma.orderRevision.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderRevisionFindFirstArgs>(args?: SelectSubset<T, OrderRevisionFindFirstArgs<ExtArgs>>): Prisma__OrderRevisionClient<$Result.GetResult<Prisma.$OrderRevisionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderRevision that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderRevisionFindFirstOrThrowArgs} args - Arguments to find a OrderRevision
     * @example
     * // Get one OrderRevision
     * const orderRevision = await prisma.orderRevision.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderRevisionFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderRevisionFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderRevisionClient<$Result.GetResult<Prisma.$OrderRevisionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderRevisions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderRevisionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderRevisions
     * const orderRevisions = await prisma.orderRevision.findMany()
     * 
     * // Get first 10 OrderRevisions
     * const orderRevisions = await prisma.orderRevision.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderRevisionWithIdOnly = await prisma.orderRevision.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderRevisionFindManyArgs>(args?: SelectSubset<T, OrderRevisionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderRevisionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderRevision.
     * @param {OrderRevisionCreateArgs} args - Arguments to create a OrderRevision.
     * @example
     * // Create one OrderRevision
     * const OrderRevision = await prisma.orderRevision.create({
     *   data: {
     *     // ... data to create a OrderRevision
     *   }
     * })
     * 
     */
    create<T extends OrderRevisionCreateArgs>(args: SelectSubset<T, OrderRevisionCreateArgs<ExtArgs>>): Prisma__OrderRevisionClient<$Result.GetResult<Prisma.$OrderRevisionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderRevisions.
     * @param {OrderRevisionCreateManyArgs} args - Arguments to create many OrderRevisions.
     * @example
     * // Create many OrderRevisions
     * const orderRevision = await prisma.orderRevision.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderRevisionCreateManyArgs>(args?: SelectSubset<T, OrderRevisionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderRevisions and returns the data saved in the database.
     * @param {OrderRevisionCreateManyAndReturnArgs} args - Arguments to create many OrderRevisions.
     * @example
     * // Create many OrderRevisions
     * const orderRevision = await prisma.orderRevision.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderRevisions and only return the `id`
     * const orderRevisionWithIdOnly = await prisma.orderRevision.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderRevisionCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderRevisionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderRevisionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrderRevision.
     * @param {OrderRevisionDeleteArgs} args - Arguments to delete one OrderRevision.
     * @example
     * // Delete one OrderRevision
     * const OrderRevision = await prisma.orderRevision.delete({
     *   where: {
     *     // ... filter to delete one OrderRevision
     *   }
     * })
     * 
     */
    delete<T extends OrderRevisionDeleteArgs>(args: SelectSubset<T, OrderRevisionDeleteArgs<ExtArgs>>): Prisma__OrderRevisionClient<$Result.GetResult<Prisma.$OrderRevisionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderRevision.
     * @param {OrderRevisionUpdateArgs} args - Arguments to update one OrderRevision.
     * @example
     * // Update one OrderRevision
     * const orderRevision = await prisma.orderRevision.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderRevisionUpdateArgs>(args: SelectSubset<T, OrderRevisionUpdateArgs<ExtArgs>>): Prisma__OrderRevisionClient<$Result.GetResult<Prisma.$OrderRevisionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderRevisions.
     * @param {OrderRevisionDeleteManyArgs} args - Arguments to filter OrderRevisions to delete.
     * @example
     * // Delete a few OrderRevisions
     * const { count } = await prisma.orderRevision.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderRevisionDeleteManyArgs>(args?: SelectSubset<T, OrderRevisionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderRevisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderRevisionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderRevisions
     * const orderRevision = await prisma.orderRevision.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderRevisionUpdateManyArgs>(args: SelectSubset<T, OrderRevisionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderRevisions and returns the data updated in the database.
     * @param {OrderRevisionUpdateManyAndReturnArgs} args - Arguments to update many OrderRevisions.
     * @example
     * // Update many OrderRevisions
     * const orderRevision = await prisma.orderRevision.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrderRevisions and only return the `id`
     * const orderRevisionWithIdOnly = await prisma.orderRevision.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderRevisionUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderRevisionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderRevisionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrderRevision.
     * @param {OrderRevisionUpsertArgs} args - Arguments to update or create a OrderRevision.
     * @example
     * // Update or create a OrderRevision
     * const orderRevision = await prisma.orderRevision.upsert({
     *   create: {
     *     // ... data to create a OrderRevision
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderRevision we want to update
     *   }
     * })
     */
    upsert<T extends OrderRevisionUpsertArgs>(args: SelectSubset<T, OrderRevisionUpsertArgs<ExtArgs>>): Prisma__OrderRevisionClient<$Result.GetResult<Prisma.$OrderRevisionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderRevisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderRevisionCountArgs} args - Arguments to filter OrderRevisions to count.
     * @example
     * // Count the number of OrderRevisions
     * const count = await prisma.orderRevision.count({
     *   where: {
     *     // ... the filter for the OrderRevisions we want to count
     *   }
     * })
    **/
    count<T extends OrderRevisionCountArgs>(
      args?: Subset<T, OrderRevisionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderRevisionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderRevision.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderRevisionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderRevisionAggregateArgs>(args: Subset<T, OrderRevisionAggregateArgs>): Prisma.PrismaPromise<GetOrderRevisionAggregateType<T>>

    /**
     * Group by OrderRevision.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderRevisionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderRevisionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderRevisionGroupByArgs['orderBy'] }
        : { orderBy?: OrderRevisionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderRevisionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderRevisionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderRevision model
   */
  readonly fields: OrderRevisionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderRevision.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderRevisionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends AppOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AppOrderDefaultArgs<ExtArgs>>): Prisma__AppOrderClient<$Result.GetResult<Prisma.$AppOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderRevision model
   */
  interface OrderRevisionFieldRefs {
    readonly id: FieldRef<"OrderRevision", 'String'>
    readonly orderId: FieldRef<"OrderRevision", 'String'>
    readonly userId: FieldRef<"OrderRevision", 'String'>
    readonly revisionNumber: FieldRef<"OrderRevision", 'Int'>
    readonly title: FieldRef<"OrderRevision", 'String'>
    readonly description: FieldRef<"OrderRevision", 'String'>
    readonly status: FieldRef<"OrderRevision", 'RevisionStatus'>
    readonly adminResponse: FieldRef<"OrderRevision", 'String'>
    readonly adminId: FieldRef<"OrderRevision", 'String'>
    readonly createdAt: FieldRef<"OrderRevision", 'DateTime'>
    readonly updatedAt: FieldRef<"OrderRevision", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrderRevision findUnique
   */
  export type OrderRevisionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderRevision
     */
    select?: OrderRevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderRevision
     */
    omit?: OrderRevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderRevisionInclude<ExtArgs> | null
    /**
     * Filter, which OrderRevision to fetch.
     */
    where: OrderRevisionWhereUniqueInput
  }

  /**
   * OrderRevision findUniqueOrThrow
   */
  export type OrderRevisionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderRevision
     */
    select?: OrderRevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderRevision
     */
    omit?: OrderRevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderRevisionInclude<ExtArgs> | null
    /**
     * Filter, which OrderRevision to fetch.
     */
    where: OrderRevisionWhereUniqueInput
  }

  /**
   * OrderRevision findFirst
   */
  export type OrderRevisionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderRevision
     */
    select?: OrderRevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderRevision
     */
    omit?: OrderRevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderRevisionInclude<ExtArgs> | null
    /**
     * Filter, which OrderRevision to fetch.
     */
    where?: OrderRevisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderRevisions to fetch.
     */
    orderBy?: OrderRevisionOrderByWithRelationInput | OrderRevisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderRevisions.
     */
    cursor?: OrderRevisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderRevisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderRevisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderRevisions.
     */
    distinct?: OrderRevisionScalarFieldEnum | OrderRevisionScalarFieldEnum[]
  }

  /**
   * OrderRevision findFirstOrThrow
   */
  export type OrderRevisionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderRevision
     */
    select?: OrderRevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderRevision
     */
    omit?: OrderRevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderRevisionInclude<ExtArgs> | null
    /**
     * Filter, which OrderRevision to fetch.
     */
    where?: OrderRevisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderRevisions to fetch.
     */
    orderBy?: OrderRevisionOrderByWithRelationInput | OrderRevisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderRevisions.
     */
    cursor?: OrderRevisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderRevisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderRevisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderRevisions.
     */
    distinct?: OrderRevisionScalarFieldEnum | OrderRevisionScalarFieldEnum[]
  }

  /**
   * OrderRevision findMany
   */
  export type OrderRevisionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderRevision
     */
    select?: OrderRevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderRevision
     */
    omit?: OrderRevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderRevisionInclude<ExtArgs> | null
    /**
     * Filter, which OrderRevisions to fetch.
     */
    where?: OrderRevisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderRevisions to fetch.
     */
    orderBy?: OrderRevisionOrderByWithRelationInput | OrderRevisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderRevisions.
     */
    cursor?: OrderRevisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderRevisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderRevisions.
     */
    skip?: number
    distinct?: OrderRevisionScalarFieldEnum | OrderRevisionScalarFieldEnum[]
  }

  /**
   * OrderRevision create
   */
  export type OrderRevisionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderRevision
     */
    select?: OrderRevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderRevision
     */
    omit?: OrderRevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderRevisionInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderRevision.
     */
    data: XOR<OrderRevisionCreateInput, OrderRevisionUncheckedCreateInput>
  }

  /**
   * OrderRevision createMany
   */
  export type OrderRevisionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderRevisions.
     */
    data: OrderRevisionCreateManyInput | OrderRevisionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderRevision createManyAndReturn
   */
  export type OrderRevisionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderRevision
     */
    select?: OrderRevisionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderRevision
     */
    omit?: OrderRevisionOmit<ExtArgs> | null
    /**
     * The data used to create many OrderRevisions.
     */
    data: OrderRevisionCreateManyInput | OrderRevisionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderRevisionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderRevision update
   */
  export type OrderRevisionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderRevision
     */
    select?: OrderRevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderRevision
     */
    omit?: OrderRevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderRevisionInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderRevision.
     */
    data: XOR<OrderRevisionUpdateInput, OrderRevisionUncheckedUpdateInput>
    /**
     * Choose, which OrderRevision to update.
     */
    where: OrderRevisionWhereUniqueInput
  }

  /**
   * OrderRevision updateMany
   */
  export type OrderRevisionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderRevisions.
     */
    data: XOR<OrderRevisionUpdateManyMutationInput, OrderRevisionUncheckedUpdateManyInput>
    /**
     * Filter which OrderRevisions to update
     */
    where?: OrderRevisionWhereInput
    /**
     * Limit how many OrderRevisions to update.
     */
    limit?: number
  }

  /**
   * OrderRevision updateManyAndReturn
   */
  export type OrderRevisionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderRevision
     */
    select?: OrderRevisionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderRevision
     */
    omit?: OrderRevisionOmit<ExtArgs> | null
    /**
     * The data used to update OrderRevisions.
     */
    data: XOR<OrderRevisionUpdateManyMutationInput, OrderRevisionUncheckedUpdateManyInput>
    /**
     * Filter which OrderRevisions to update
     */
    where?: OrderRevisionWhereInput
    /**
     * Limit how many OrderRevisions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderRevisionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderRevision upsert
   */
  export type OrderRevisionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderRevision
     */
    select?: OrderRevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderRevision
     */
    omit?: OrderRevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderRevisionInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderRevision to update in case it exists.
     */
    where: OrderRevisionWhereUniqueInput
    /**
     * In case the OrderRevision found by the `where` argument doesn't exist, create a new OrderRevision with this data.
     */
    create: XOR<OrderRevisionCreateInput, OrderRevisionUncheckedCreateInput>
    /**
     * In case the OrderRevision was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderRevisionUpdateInput, OrderRevisionUncheckedUpdateInput>
  }

  /**
   * OrderRevision delete
   */
  export type OrderRevisionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderRevision
     */
    select?: OrderRevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderRevision
     */
    omit?: OrderRevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderRevisionInclude<ExtArgs> | null
    /**
     * Filter which OrderRevision to delete.
     */
    where: OrderRevisionWhereUniqueInput
  }

  /**
   * OrderRevision deleteMany
   */
  export type OrderRevisionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderRevisions to delete
     */
    where?: OrderRevisionWhereInput
    /**
     * Limit how many OrderRevisions to delete.
     */
    limit?: number
  }

  /**
   * OrderRevision without action
   */
  export type OrderRevisionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderRevision
     */
    select?: OrderRevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderRevision
     */
    omit?: OrderRevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderRevisionInclude<ExtArgs> | null
  }


  /**
   * Model OrderCommunication
   */

  export type AggregateOrderCommunication = {
    _count: OrderCommunicationCountAggregateOutputType | null
    _min: OrderCommunicationMinAggregateOutputType | null
    _max: OrderCommunicationMaxAggregateOutputType | null
  }

  export type OrderCommunicationMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    userId: string | null
    messageType: $Enums.CommunicationType | null
    subject: string | null
    message: string | null
    isFromAdmin: boolean | null
    read: boolean | null
    important: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderCommunicationMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    userId: string | null
    messageType: $Enums.CommunicationType | null
    subject: string | null
    message: string | null
    isFromAdmin: boolean | null
    read: boolean | null
    important: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderCommunicationCountAggregateOutputType = {
    id: number
    orderId: number
    userId: number
    messageType: number
    subject: number
    message: number
    isFromAdmin: number
    attachments: number
    read: number
    important: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrderCommunicationMinAggregateInputType = {
    id?: true
    orderId?: true
    userId?: true
    messageType?: true
    subject?: true
    message?: true
    isFromAdmin?: true
    read?: true
    important?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderCommunicationMaxAggregateInputType = {
    id?: true
    orderId?: true
    userId?: true
    messageType?: true
    subject?: true
    message?: true
    isFromAdmin?: true
    read?: true
    important?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderCommunicationCountAggregateInputType = {
    id?: true
    orderId?: true
    userId?: true
    messageType?: true
    subject?: true
    message?: true
    isFromAdmin?: true
    attachments?: true
    read?: true
    important?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrderCommunicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderCommunication to aggregate.
     */
    where?: OrderCommunicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderCommunications to fetch.
     */
    orderBy?: OrderCommunicationOrderByWithRelationInput | OrderCommunicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderCommunicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderCommunications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderCommunications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderCommunications
    **/
    _count?: true | OrderCommunicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderCommunicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderCommunicationMaxAggregateInputType
  }

  export type GetOrderCommunicationAggregateType<T extends OrderCommunicationAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderCommunication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderCommunication[P]>
      : GetScalarType<T[P], AggregateOrderCommunication[P]>
  }




  export type OrderCommunicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderCommunicationWhereInput
    orderBy?: OrderCommunicationOrderByWithAggregationInput | OrderCommunicationOrderByWithAggregationInput[]
    by: OrderCommunicationScalarFieldEnum[] | OrderCommunicationScalarFieldEnum
    having?: OrderCommunicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCommunicationCountAggregateInputType | true
    _min?: OrderCommunicationMinAggregateInputType
    _max?: OrderCommunicationMaxAggregateInputType
  }

  export type OrderCommunicationGroupByOutputType = {
    id: string
    orderId: string
    userId: string
    messageType: $Enums.CommunicationType
    subject: string | null
    message: string
    isFromAdmin: boolean
    attachments: JsonValue | null
    read: boolean
    important: boolean
    createdAt: Date
    updatedAt: Date
    _count: OrderCommunicationCountAggregateOutputType | null
    _min: OrderCommunicationMinAggregateOutputType | null
    _max: OrderCommunicationMaxAggregateOutputType | null
  }

  type GetOrderCommunicationGroupByPayload<T extends OrderCommunicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderCommunicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderCommunicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderCommunicationGroupByOutputType[P]>
            : GetScalarType<T[P], OrderCommunicationGroupByOutputType[P]>
        }
      >
    >


  export type OrderCommunicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    userId?: boolean
    messageType?: boolean
    subject?: boolean
    message?: boolean
    isFromAdmin?: boolean
    attachments?: boolean
    read?: boolean
    important?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | AppOrderDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderCommunication"]>

  export type OrderCommunicationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    userId?: boolean
    messageType?: boolean
    subject?: boolean
    message?: boolean
    isFromAdmin?: boolean
    attachments?: boolean
    read?: boolean
    important?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | AppOrderDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderCommunication"]>

  export type OrderCommunicationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    userId?: boolean
    messageType?: boolean
    subject?: boolean
    message?: boolean
    isFromAdmin?: boolean
    attachments?: boolean
    read?: boolean
    important?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | AppOrderDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderCommunication"]>

  export type OrderCommunicationSelectScalar = {
    id?: boolean
    orderId?: boolean
    userId?: boolean
    messageType?: boolean
    subject?: boolean
    message?: boolean
    isFromAdmin?: boolean
    attachments?: boolean
    read?: boolean
    important?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrderCommunicationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "userId" | "messageType" | "subject" | "message" | "isFromAdmin" | "attachments" | "read" | "important" | "createdAt" | "updatedAt", ExtArgs["result"]["orderCommunication"]>
  export type OrderCommunicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | AppOrderDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type OrderCommunicationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | AppOrderDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type OrderCommunicationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | AppOrderDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OrderCommunicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderCommunication"
    objects: {
      order: Prisma.$AppOrderPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      userId: string
      messageType: $Enums.CommunicationType
      subject: string | null
      message: string
      isFromAdmin: boolean
      attachments: Prisma.JsonValue | null
      read: boolean
      important: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["orderCommunication"]>
    composites: {}
  }

  type OrderCommunicationGetPayload<S extends boolean | null | undefined | OrderCommunicationDefaultArgs> = $Result.GetResult<Prisma.$OrderCommunicationPayload, S>

  type OrderCommunicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderCommunicationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderCommunicationCountAggregateInputType | true
    }

  export interface OrderCommunicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderCommunication'], meta: { name: 'OrderCommunication' } }
    /**
     * Find zero or one OrderCommunication that matches the filter.
     * @param {OrderCommunicationFindUniqueArgs} args - Arguments to find a OrderCommunication
     * @example
     * // Get one OrderCommunication
     * const orderCommunication = await prisma.orderCommunication.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderCommunicationFindUniqueArgs>(args: SelectSubset<T, OrderCommunicationFindUniqueArgs<ExtArgs>>): Prisma__OrderCommunicationClient<$Result.GetResult<Prisma.$OrderCommunicationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderCommunication that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderCommunicationFindUniqueOrThrowArgs} args - Arguments to find a OrderCommunication
     * @example
     * // Get one OrderCommunication
     * const orderCommunication = await prisma.orderCommunication.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderCommunicationFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderCommunicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderCommunicationClient<$Result.GetResult<Prisma.$OrderCommunicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderCommunication that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCommunicationFindFirstArgs} args - Arguments to find a OrderCommunication
     * @example
     * // Get one OrderCommunication
     * const orderCommunication = await prisma.orderCommunication.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderCommunicationFindFirstArgs>(args?: SelectSubset<T, OrderCommunicationFindFirstArgs<ExtArgs>>): Prisma__OrderCommunicationClient<$Result.GetResult<Prisma.$OrderCommunicationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderCommunication that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCommunicationFindFirstOrThrowArgs} args - Arguments to find a OrderCommunication
     * @example
     * // Get one OrderCommunication
     * const orderCommunication = await prisma.orderCommunication.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderCommunicationFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderCommunicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderCommunicationClient<$Result.GetResult<Prisma.$OrderCommunicationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderCommunications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCommunicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderCommunications
     * const orderCommunications = await prisma.orderCommunication.findMany()
     * 
     * // Get first 10 OrderCommunications
     * const orderCommunications = await prisma.orderCommunication.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderCommunicationWithIdOnly = await prisma.orderCommunication.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderCommunicationFindManyArgs>(args?: SelectSubset<T, OrderCommunicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderCommunicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderCommunication.
     * @param {OrderCommunicationCreateArgs} args - Arguments to create a OrderCommunication.
     * @example
     * // Create one OrderCommunication
     * const OrderCommunication = await prisma.orderCommunication.create({
     *   data: {
     *     // ... data to create a OrderCommunication
     *   }
     * })
     * 
     */
    create<T extends OrderCommunicationCreateArgs>(args: SelectSubset<T, OrderCommunicationCreateArgs<ExtArgs>>): Prisma__OrderCommunicationClient<$Result.GetResult<Prisma.$OrderCommunicationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderCommunications.
     * @param {OrderCommunicationCreateManyArgs} args - Arguments to create many OrderCommunications.
     * @example
     * // Create many OrderCommunications
     * const orderCommunication = await prisma.orderCommunication.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCommunicationCreateManyArgs>(args?: SelectSubset<T, OrderCommunicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderCommunications and returns the data saved in the database.
     * @param {OrderCommunicationCreateManyAndReturnArgs} args - Arguments to create many OrderCommunications.
     * @example
     * // Create many OrderCommunications
     * const orderCommunication = await prisma.orderCommunication.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderCommunications and only return the `id`
     * const orderCommunicationWithIdOnly = await prisma.orderCommunication.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderCommunicationCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderCommunicationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderCommunicationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrderCommunication.
     * @param {OrderCommunicationDeleteArgs} args - Arguments to delete one OrderCommunication.
     * @example
     * // Delete one OrderCommunication
     * const OrderCommunication = await prisma.orderCommunication.delete({
     *   where: {
     *     // ... filter to delete one OrderCommunication
     *   }
     * })
     * 
     */
    delete<T extends OrderCommunicationDeleteArgs>(args: SelectSubset<T, OrderCommunicationDeleteArgs<ExtArgs>>): Prisma__OrderCommunicationClient<$Result.GetResult<Prisma.$OrderCommunicationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderCommunication.
     * @param {OrderCommunicationUpdateArgs} args - Arguments to update one OrderCommunication.
     * @example
     * // Update one OrderCommunication
     * const orderCommunication = await prisma.orderCommunication.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderCommunicationUpdateArgs>(args: SelectSubset<T, OrderCommunicationUpdateArgs<ExtArgs>>): Prisma__OrderCommunicationClient<$Result.GetResult<Prisma.$OrderCommunicationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderCommunications.
     * @param {OrderCommunicationDeleteManyArgs} args - Arguments to filter OrderCommunications to delete.
     * @example
     * // Delete a few OrderCommunications
     * const { count } = await prisma.orderCommunication.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderCommunicationDeleteManyArgs>(args?: SelectSubset<T, OrderCommunicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderCommunications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCommunicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderCommunications
     * const orderCommunication = await prisma.orderCommunication.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderCommunicationUpdateManyArgs>(args: SelectSubset<T, OrderCommunicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderCommunications and returns the data updated in the database.
     * @param {OrderCommunicationUpdateManyAndReturnArgs} args - Arguments to update many OrderCommunications.
     * @example
     * // Update many OrderCommunications
     * const orderCommunication = await prisma.orderCommunication.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrderCommunications and only return the `id`
     * const orderCommunicationWithIdOnly = await prisma.orderCommunication.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderCommunicationUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderCommunicationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderCommunicationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrderCommunication.
     * @param {OrderCommunicationUpsertArgs} args - Arguments to update or create a OrderCommunication.
     * @example
     * // Update or create a OrderCommunication
     * const orderCommunication = await prisma.orderCommunication.upsert({
     *   create: {
     *     // ... data to create a OrderCommunication
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderCommunication we want to update
     *   }
     * })
     */
    upsert<T extends OrderCommunicationUpsertArgs>(args: SelectSubset<T, OrderCommunicationUpsertArgs<ExtArgs>>): Prisma__OrderCommunicationClient<$Result.GetResult<Prisma.$OrderCommunicationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderCommunications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCommunicationCountArgs} args - Arguments to filter OrderCommunications to count.
     * @example
     * // Count the number of OrderCommunications
     * const count = await prisma.orderCommunication.count({
     *   where: {
     *     // ... the filter for the OrderCommunications we want to count
     *   }
     * })
    **/
    count<T extends OrderCommunicationCountArgs>(
      args?: Subset<T, OrderCommunicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCommunicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderCommunication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCommunicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderCommunicationAggregateArgs>(args: Subset<T, OrderCommunicationAggregateArgs>): Prisma.PrismaPromise<GetOrderCommunicationAggregateType<T>>

    /**
     * Group by OrderCommunication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCommunicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderCommunicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderCommunicationGroupByArgs['orderBy'] }
        : { orderBy?: OrderCommunicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderCommunicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderCommunicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderCommunication model
   */
  readonly fields: OrderCommunicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderCommunication.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderCommunicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends AppOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AppOrderDefaultArgs<ExtArgs>>): Prisma__AppOrderClient<$Result.GetResult<Prisma.$AppOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderCommunication model
   */
  interface OrderCommunicationFieldRefs {
    readonly id: FieldRef<"OrderCommunication", 'String'>
    readonly orderId: FieldRef<"OrderCommunication", 'String'>
    readonly userId: FieldRef<"OrderCommunication", 'String'>
    readonly messageType: FieldRef<"OrderCommunication", 'CommunicationType'>
    readonly subject: FieldRef<"OrderCommunication", 'String'>
    readonly message: FieldRef<"OrderCommunication", 'String'>
    readonly isFromAdmin: FieldRef<"OrderCommunication", 'Boolean'>
    readonly attachments: FieldRef<"OrderCommunication", 'Json'>
    readonly read: FieldRef<"OrderCommunication", 'Boolean'>
    readonly important: FieldRef<"OrderCommunication", 'Boolean'>
    readonly createdAt: FieldRef<"OrderCommunication", 'DateTime'>
    readonly updatedAt: FieldRef<"OrderCommunication", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrderCommunication findUnique
   */
  export type OrderCommunicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCommunication
     */
    select?: OrderCommunicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderCommunication
     */
    omit?: OrderCommunicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderCommunicationInclude<ExtArgs> | null
    /**
     * Filter, which OrderCommunication to fetch.
     */
    where: OrderCommunicationWhereUniqueInput
  }

  /**
   * OrderCommunication findUniqueOrThrow
   */
  export type OrderCommunicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCommunication
     */
    select?: OrderCommunicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderCommunication
     */
    omit?: OrderCommunicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderCommunicationInclude<ExtArgs> | null
    /**
     * Filter, which OrderCommunication to fetch.
     */
    where: OrderCommunicationWhereUniqueInput
  }

  /**
   * OrderCommunication findFirst
   */
  export type OrderCommunicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCommunication
     */
    select?: OrderCommunicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderCommunication
     */
    omit?: OrderCommunicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderCommunicationInclude<ExtArgs> | null
    /**
     * Filter, which OrderCommunication to fetch.
     */
    where?: OrderCommunicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderCommunications to fetch.
     */
    orderBy?: OrderCommunicationOrderByWithRelationInput | OrderCommunicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderCommunications.
     */
    cursor?: OrderCommunicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderCommunications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderCommunications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderCommunications.
     */
    distinct?: OrderCommunicationScalarFieldEnum | OrderCommunicationScalarFieldEnum[]
  }

  /**
   * OrderCommunication findFirstOrThrow
   */
  export type OrderCommunicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCommunication
     */
    select?: OrderCommunicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderCommunication
     */
    omit?: OrderCommunicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderCommunicationInclude<ExtArgs> | null
    /**
     * Filter, which OrderCommunication to fetch.
     */
    where?: OrderCommunicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderCommunications to fetch.
     */
    orderBy?: OrderCommunicationOrderByWithRelationInput | OrderCommunicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderCommunications.
     */
    cursor?: OrderCommunicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderCommunications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderCommunications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderCommunications.
     */
    distinct?: OrderCommunicationScalarFieldEnum | OrderCommunicationScalarFieldEnum[]
  }

  /**
   * OrderCommunication findMany
   */
  export type OrderCommunicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCommunication
     */
    select?: OrderCommunicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderCommunication
     */
    omit?: OrderCommunicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderCommunicationInclude<ExtArgs> | null
    /**
     * Filter, which OrderCommunications to fetch.
     */
    where?: OrderCommunicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderCommunications to fetch.
     */
    orderBy?: OrderCommunicationOrderByWithRelationInput | OrderCommunicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderCommunications.
     */
    cursor?: OrderCommunicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderCommunications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderCommunications.
     */
    skip?: number
    distinct?: OrderCommunicationScalarFieldEnum | OrderCommunicationScalarFieldEnum[]
  }

  /**
   * OrderCommunication create
   */
  export type OrderCommunicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCommunication
     */
    select?: OrderCommunicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderCommunication
     */
    omit?: OrderCommunicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderCommunicationInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderCommunication.
     */
    data: XOR<OrderCommunicationCreateInput, OrderCommunicationUncheckedCreateInput>
  }

  /**
   * OrderCommunication createMany
   */
  export type OrderCommunicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderCommunications.
     */
    data: OrderCommunicationCreateManyInput | OrderCommunicationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderCommunication createManyAndReturn
   */
  export type OrderCommunicationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCommunication
     */
    select?: OrderCommunicationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderCommunication
     */
    omit?: OrderCommunicationOmit<ExtArgs> | null
    /**
     * The data used to create many OrderCommunications.
     */
    data: OrderCommunicationCreateManyInput | OrderCommunicationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderCommunicationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderCommunication update
   */
  export type OrderCommunicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCommunication
     */
    select?: OrderCommunicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderCommunication
     */
    omit?: OrderCommunicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderCommunicationInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderCommunication.
     */
    data: XOR<OrderCommunicationUpdateInput, OrderCommunicationUncheckedUpdateInput>
    /**
     * Choose, which OrderCommunication to update.
     */
    where: OrderCommunicationWhereUniqueInput
  }

  /**
   * OrderCommunication updateMany
   */
  export type OrderCommunicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderCommunications.
     */
    data: XOR<OrderCommunicationUpdateManyMutationInput, OrderCommunicationUncheckedUpdateManyInput>
    /**
     * Filter which OrderCommunications to update
     */
    where?: OrderCommunicationWhereInput
    /**
     * Limit how many OrderCommunications to update.
     */
    limit?: number
  }

  /**
   * OrderCommunication updateManyAndReturn
   */
  export type OrderCommunicationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCommunication
     */
    select?: OrderCommunicationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderCommunication
     */
    omit?: OrderCommunicationOmit<ExtArgs> | null
    /**
     * The data used to update OrderCommunications.
     */
    data: XOR<OrderCommunicationUpdateManyMutationInput, OrderCommunicationUncheckedUpdateManyInput>
    /**
     * Filter which OrderCommunications to update
     */
    where?: OrderCommunicationWhereInput
    /**
     * Limit how many OrderCommunications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderCommunicationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderCommunication upsert
   */
  export type OrderCommunicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCommunication
     */
    select?: OrderCommunicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderCommunication
     */
    omit?: OrderCommunicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderCommunicationInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderCommunication to update in case it exists.
     */
    where: OrderCommunicationWhereUniqueInput
    /**
     * In case the OrderCommunication found by the `where` argument doesn't exist, create a new OrderCommunication with this data.
     */
    create: XOR<OrderCommunicationCreateInput, OrderCommunicationUncheckedCreateInput>
    /**
     * In case the OrderCommunication was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderCommunicationUpdateInput, OrderCommunicationUncheckedUpdateInput>
  }

  /**
   * OrderCommunication delete
   */
  export type OrderCommunicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCommunication
     */
    select?: OrderCommunicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderCommunication
     */
    omit?: OrderCommunicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderCommunicationInclude<ExtArgs> | null
    /**
     * Filter which OrderCommunication to delete.
     */
    where: OrderCommunicationWhereUniqueInput
  }

  /**
   * OrderCommunication deleteMany
   */
  export type OrderCommunicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderCommunications to delete
     */
    where?: OrderCommunicationWhereInput
    /**
     * Limit how many OrderCommunications to delete.
     */
    limit?: number
  }

  /**
   * OrderCommunication without action
   */
  export type OrderCommunicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCommunication
     */
    select?: OrderCommunicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderCommunication
     */
    omit?: OrderCommunicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderCommunicationInclude<ExtArgs> | null
  }


  /**
   * Model OrderDeliverable
   */

  export type AggregateOrderDeliverable = {
    _count: OrderDeliverableCountAggregateOutputType | null
    _min: OrderDeliverableMinAggregateOutputType | null
    _max: OrderDeliverableMaxAggregateOutputType | null
  }

  export type OrderDeliverableMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    type: $Enums.DeliverableType | null
    title: string | null
    description: string | null
    url: string | null
    filePath: string | null
    status: $Enums.DeliverableStatus | null
    delivered: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderDeliverableMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    type: $Enums.DeliverableType | null
    title: string | null
    description: string | null
    url: string | null
    filePath: string | null
    status: $Enums.DeliverableStatus | null
    delivered: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderDeliverableCountAggregateOutputType = {
    id: number
    orderId: number
    type: number
    title: number
    description: number
    url: number
    filePath: number
    status: number
    delivered: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrderDeliverableMinAggregateInputType = {
    id?: true
    orderId?: true
    type?: true
    title?: true
    description?: true
    url?: true
    filePath?: true
    status?: true
    delivered?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderDeliverableMaxAggregateInputType = {
    id?: true
    orderId?: true
    type?: true
    title?: true
    description?: true
    url?: true
    filePath?: true
    status?: true
    delivered?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderDeliverableCountAggregateInputType = {
    id?: true
    orderId?: true
    type?: true
    title?: true
    description?: true
    url?: true
    filePath?: true
    status?: true
    delivered?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrderDeliverableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderDeliverable to aggregate.
     */
    where?: OrderDeliverableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderDeliverables to fetch.
     */
    orderBy?: OrderDeliverableOrderByWithRelationInput | OrderDeliverableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderDeliverableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderDeliverables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderDeliverables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderDeliverables
    **/
    _count?: true | OrderDeliverableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderDeliverableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderDeliverableMaxAggregateInputType
  }

  export type GetOrderDeliverableAggregateType<T extends OrderDeliverableAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderDeliverable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderDeliverable[P]>
      : GetScalarType<T[P], AggregateOrderDeliverable[P]>
  }




  export type OrderDeliverableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderDeliverableWhereInput
    orderBy?: OrderDeliverableOrderByWithAggregationInput | OrderDeliverableOrderByWithAggregationInput[]
    by: OrderDeliverableScalarFieldEnum[] | OrderDeliverableScalarFieldEnum
    having?: OrderDeliverableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderDeliverableCountAggregateInputType | true
    _min?: OrderDeliverableMinAggregateInputType
    _max?: OrderDeliverableMaxAggregateInputType
  }

  export type OrderDeliverableGroupByOutputType = {
    id: string
    orderId: string
    type: $Enums.DeliverableType
    title: string
    description: string | null
    url: string | null
    filePath: string | null
    status: $Enums.DeliverableStatus
    delivered: boolean
    createdAt: Date
    updatedAt: Date
    _count: OrderDeliverableCountAggregateOutputType | null
    _min: OrderDeliverableMinAggregateOutputType | null
    _max: OrderDeliverableMaxAggregateOutputType | null
  }

  type GetOrderDeliverableGroupByPayload<T extends OrderDeliverableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderDeliverableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderDeliverableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderDeliverableGroupByOutputType[P]>
            : GetScalarType<T[P], OrderDeliverableGroupByOutputType[P]>
        }
      >
    >


  export type OrderDeliverableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    url?: boolean
    filePath?: boolean
    status?: boolean
    delivered?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | AppOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderDeliverable"]>

  export type OrderDeliverableSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    url?: boolean
    filePath?: boolean
    status?: boolean
    delivered?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | AppOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderDeliverable"]>

  export type OrderDeliverableSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    url?: boolean
    filePath?: boolean
    status?: boolean
    delivered?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | AppOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderDeliverable"]>

  export type OrderDeliverableSelectScalar = {
    id?: boolean
    orderId?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    url?: boolean
    filePath?: boolean
    status?: boolean
    delivered?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrderDeliverableOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "type" | "title" | "description" | "url" | "filePath" | "status" | "delivered" | "createdAt" | "updatedAt", ExtArgs["result"]["orderDeliverable"]>
  export type OrderDeliverableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | AppOrderDefaultArgs<ExtArgs>
  }
  export type OrderDeliverableIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | AppOrderDefaultArgs<ExtArgs>
  }
  export type OrderDeliverableIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | AppOrderDefaultArgs<ExtArgs>
  }

  export type $OrderDeliverablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderDeliverable"
    objects: {
      order: Prisma.$AppOrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      type: $Enums.DeliverableType
      title: string
      description: string | null
      url: string | null
      filePath: string | null
      status: $Enums.DeliverableStatus
      delivered: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["orderDeliverable"]>
    composites: {}
  }

  type OrderDeliverableGetPayload<S extends boolean | null | undefined | OrderDeliverableDefaultArgs> = $Result.GetResult<Prisma.$OrderDeliverablePayload, S>

  type OrderDeliverableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderDeliverableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderDeliverableCountAggregateInputType | true
    }

  export interface OrderDeliverableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderDeliverable'], meta: { name: 'OrderDeliverable' } }
    /**
     * Find zero or one OrderDeliverable that matches the filter.
     * @param {OrderDeliverableFindUniqueArgs} args - Arguments to find a OrderDeliverable
     * @example
     * // Get one OrderDeliverable
     * const orderDeliverable = await prisma.orderDeliverable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderDeliverableFindUniqueArgs>(args: SelectSubset<T, OrderDeliverableFindUniqueArgs<ExtArgs>>): Prisma__OrderDeliverableClient<$Result.GetResult<Prisma.$OrderDeliverablePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderDeliverable that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderDeliverableFindUniqueOrThrowArgs} args - Arguments to find a OrderDeliverable
     * @example
     * // Get one OrderDeliverable
     * const orderDeliverable = await prisma.orderDeliverable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderDeliverableFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderDeliverableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderDeliverableClient<$Result.GetResult<Prisma.$OrderDeliverablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderDeliverable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderDeliverableFindFirstArgs} args - Arguments to find a OrderDeliverable
     * @example
     * // Get one OrderDeliverable
     * const orderDeliverable = await prisma.orderDeliverable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderDeliverableFindFirstArgs>(args?: SelectSubset<T, OrderDeliverableFindFirstArgs<ExtArgs>>): Prisma__OrderDeliverableClient<$Result.GetResult<Prisma.$OrderDeliverablePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderDeliverable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderDeliverableFindFirstOrThrowArgs} args - Arguments to find a OrderDeliverable
     * @example
     * // Get one OrderDeliverable
     * const orderDeliverable = await prisma.orderDeliverable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderDeliverableFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderDeliverableFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderDeliverableClient<$Result.GetResult<Prisma.$OrderDeliverablePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderDeliverables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderDeliverableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderDeliverables
     * const orderDeliverables = await prisma.orderDeliverable.findMany()
     * 
     * // Get first 10 OrderDeliverables
     * const orderDeliverables = await prisma.orderDeliverable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderDeliverableWithIdOnly = await prisma.orderDeliverable.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderDeliverableFindManyArgs>(args?: SelectSubset<T, OrderDeliverableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderDeliverablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderDeliverable.
     * @param {OrderDeliverableCreateArgs} args - Arguments to create a OrderDeliverable.
     * @example
     * // Create one OrderDeliverable
     * const OrderDeliverable = await prisma.orderDeliverable.create({
     *   data: {
     *     // ... data to create a OrderDeliverable
     *   }
     * })
     * 
     */
    create<T extends OrderDeliverableCreateArgs>(args: SelectSubset<T, OrderDeliverableCreateArgs<ExtArgs>>): Prisma__OrderDeliverableClient<$Result.GetResult<Prisma.$OrderDeliverablePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderDeliverables.
     * @param {OrderDeliverableCreateManyArgs} args - Arguments to create many OrderDeliverables.
     * @example
     * // Create many OrderDeliverables
     * const orderDeliverable = await prisma.orderDeliverable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderDeliverableCreateManyArgs>(args?: SelectSubset<T, OrderDeliverableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderDeliverables and returns the data saved in the database.
     * @param {OrderDeliverableCreateManyAndReturnArgs} args - Arguments to create many OrderDeliverables.
     * @example
     * // Create many OrderDeliverables
     * const orderDeliverable = await prisma.orderDeliverable.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderDeliverables and only return the `id`
     * const orderDeliverableWithIdOnly = await prisma.orderDeliverable.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderDeliverableCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderDeliverableCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderDeliverablePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrderDeliverable.
     * @param {OrderDeliverableDeleteArgs} args - Arguments to delete one OrderDeliverable.
     * @example
     * // Delete one OrderDeliverable
     * const OrderDeliverable = await prisma.orderDeliverable.delete({
     *   where: {
     *     // ... filter to delete one OrderDeliverable
     *   }
     * })
     * 
     */
    delete<T extends OrderDeliverableDeleteArgs>(args: SelectSubset<T, OrderDeliverableDeleteArgs<ExtArgs>>): Prisma__OrderDeliverableClient<$Result.GetResult<Prisma.$OrderDeliverablePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderDeliverable.
     * @param {OrderDeliverableUpdateArgs} args - Arguments to update one OrderDeliverable.
     * @example
     * // Update one OrderDeliverable
     * const orderDeliverable = await prisma.orderDeliverable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderDeliverableUpdateArgs>(args: SelectSubset<T, OrderDeliverableUpdateArgs<ExtArgs>>): Prisma__OrderDeliverableClient<$Result.GetResult<Prisma.$OrderDeliverablePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderDeliverables.
     * @param {OrderDeliverableDeleteManyArgs} args - Arguments to filter OrderDeliverables to delete.
     * @example
     * // Delete a few OrderDeliverables
     * const { count } = await prisma.orderDeliverable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeliverableDeleteManyArgs>(args?: SelectSubset<T, OrderDeliverableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderDeliverables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderDeliverableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderDeliverables
     * const orderDeliverable = await prisma.orderDeliverable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderDeliverableUpdateManyArgs>(args: SelectSubset<T, OrderDeliverableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderDeliverables and returns the data updated in the database.
     * @param {OrderDeliverableUpdateManyAndReturnArgs} args - Arguments to update many OrderDeliverables.
     * @example
     * // Update many OrderDeliverables
     * const orderDeliverable = await prisma.orderDeliverable.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrderDeliverables and only return the `id`
     * const orderDeliverableWithIdOnly = await prisma.orderDeliverable.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderDeliverableUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderDeliverableUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderDeliverablePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrderDeliverable.
     * @param {OrderDeliverableUpsertArgs} args - Arguments to update or create a OrderDeliverable.
     * @example
     * // Update or create a OrderDeliverable
     * const orderDeliverable = await prisma.orderDeliverable.upsert({
     *   create: {
     *     // ... data to create a OrderDeliverable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderDeliverable we want to update
     *   }
     * })
     */
    upsert<T extends OrderDeliverableUpsertArgs>(args: SelectSubset<T, OrderDeliverableUpsertArgs<ExtArgs>>): Prisma__OrderDeliverableClient<$Result.GetResult<Prisma.$OrderDeliverablePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderDeliverables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderDeliverableCountArgs} args - Arguments to filter OrderDeliverables to count.
     * @example
     * // Count the number of OrderDeliverables
     * const count = await prisma.orderDeliverable.count({
     *   where: {
     *     // ... the filter for the OrderDeliverables we want to count
     *   }
     * })
    **/
    count<T extends OrderDeliverableCountArgs>(
      args?: Subset<T, OrderDeliverableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderDeliverableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderDeliverable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderDeliverableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderDeliverableAggregateArgs>(args: Subset<T, OrderDeliverableAggregateArgs>): Prisma.PrismaPromise<GetOrderDeliverableAggregateType<T>>

    /**
     * Group by OrderDeliverable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderDeliverableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderDeliverableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderDeliverableGroupByArgs['orderBy'] }
        : { orderBy?: OrderDeliverableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderDeliverableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderDeliverableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderDeliverable model
   */
  readonly fields: OrderDeliverableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderDeliverable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderDeliverableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends AppOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AppOrderDefaultArgs<ExtArgs>>): Prisma__AppOrderClient<$Result.GetResult<Prisma.$AppOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderDeliverable model
   */
  interface OrderDeliverableFieldRefs {
    readonly id: FieldRef<"OrderDeliverable", 'String'>
    readonly orderId: FieldRef<"OrderDeliverable", 'String'>
    readonly type: FieldRef<"OrderDeliverable", 'DeliverableType'>
    readonly title: FieldRef<"OrderDeliverable", 'String'>
    readonly description: FieldRef<"OrderDeliverable", 'String'>
    readonly url: FieldRef<"OrderDeliverable", 'String'>
    readonly filePath: FieldRef<"OrderDeliverable", 'String'>
    readonly status: FieldRef<"OrderDeliverable", 'DeliverableStatus'>
    readonly delivered: FieldRef<"OrderDeliverable", 'Boolean'>
    readonly createdAt: FieldRef<"OrderDeliverable", 'DateTime'>
    readonly updatedAt: FieldRef<"OrderDeliverable", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrderDeliverable findUnique
   */
  export type OrderDeliverableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDeliverable
     */
    select?: OrderDeliverableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderDeliverable
     */
    omit?: OrderDeliverableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDeliverableInclude<ExtArgs> | null
    /**
     * Filter, which OrderDeliverable to fetch.
     */
    where: OrderDeliverableWhereUniqueInput
  }

  /**
   * OrderDeliverable findUniqueOrThrow
   */
  export type OrderDeliverableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDeliverable
     */
    select?: OrderDeliverableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderDeliverable
     */
    omit?: OrderDeliverableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDeliverableInclude<ExtArgs> | null
    /**
     * Filter, which OrderDeliverable to fetch.
     */
    where: OrderDeliverableWhereUniqueInput
  }

  /**
   * OrderDeliverable findFirst
   */
  export type OrderDeliverableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDeliverable
     */
    select?: OrderDeliverableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderDeliverable
     */
    omit?: OrderDeliverableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDeliverableInclude<ExtArgs> | null
    /**
     * Filter, which OrderDeliverable to fetch.
     */
    where?: OrderDeliverableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderDeliverables to fetch.
     */
    orderBy?: OrderDeliverableOrderByWithRelationInput | OrderDeliverableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderDeliverables.
     */
    cursor?: OrderDeliverableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderDeliverables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderDeliverables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderDeliverables.
     */
    distinct?: OrderDeliverableScalarFieldEnum | OrderDeliverableScalarFieldEnum[]
  }

  /**
   * OrderDeliverable findFirstOrThrow
   */
  export type OrderDeliverableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDeliverable
     */
    select?: OrderDeliverableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderDeliverable
     */
    omit?: OrderDeliverableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDeliverableInclude<ExtArgs> | null
    /**
     * Filter, which OrderDeliverable to fetch.
     */
    where?: OrderDeliverableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderDeliverables to fetch.
     */
    orderBy?: OrderDeliverableOrderByWithRelationInput | OrderDeliverableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderDeliverables.
     */
    cursor?: OrderDeliverableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderDeliverables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderDeliverables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderDeliverables.
     */
    distinct?: OrderDeliverableScalarFieldEnum | OrderDeliverableScalarFieldEnum[]
  }

  /**
   * OrderDeliverable findMany
   */
  export type OrderDeliverableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDeliverable
     */
    select?: OrderDeliverableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderDeliverable
     */
    omit?: OrderDeliverableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDeliverableInclude<ExtArgs> | null
    /**
     * Filter, which OrderDeliverables to fetch.
     */
    where?: OrderDeliverableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderDeliverables to fetch.
     */
    orderBy?: OrderDeliverableOrderByWithRelationInput | OrderDeliverableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderDeliverables.
     */
    cursor?: OrderDeliverableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderDeliverables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderDeliverables.
     */
    skip?: number
    distinct?: OrderDeliverableScalarFieldEnum | OrderDeliverableScalarFieldEnum[]
  }

  /**
   * OrderDeliverable create
   */
  export type OrderDeliverableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDeliverable
     */
    select?: OrderDeliverableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderDeliverable
     */
    omit?: OrderDeliverableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDeliverableInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderDeliverable.
     */
    data: XOR<OrderDeliverableCreateInput, OrderDeliverableUncheckedCreateInput>
  }

  /**
   * OrderDeliverable createMany
   */
  export type OrderDeliverableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderDeliverables.
     */
    data: OrderDeliverableCreateManyInput | OrderDeliverableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderDeliverable createManyAndReturn
   */
  export type OrderDeliverableCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDeliverable
     */
    select?: OrderDeliverableSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderDeliverable
     */
    omit?: OrderDeliverableOmit<ExtArgs> | null
    /**
     * The data used to create many OrderDeliverables.
     */
    data: OrderDeliverableCreateManyInput | OrderDeliverableCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDeliverableIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderDeliverable update
   */
  export type OrderDeliverableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDeliverable
     */
    select?: OrderDeliverableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderDeliverable
     */
    omit?: OrderDeliverableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDeliverableInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderDeliverable.
     */
    data: XOR<OrderDeliverableUpdateInput, OrderDeliverableUncheckedUpdateInput>
    /**
     * Choose, which OrderDeliverable to update.
     */
    where: OrderDeliverableWhereUniqueInput
  }

  /**
   * OrderDeliverable updateMany
   */
  export type OrderDeliverableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderDeliverables.
     */
    data: XOR<OrderDeliverableUpdateManyMutationInput, OrderDeliverableUncheckedUpdateManyInput>
    /**
     * Filter which OrderDeliverables to update
     */
    where?: OrderDeliverableWhereInput
    /**
     * Limit how many OrderDeliverables to update.
     */
    limit?: number
  }

  /**
   * OrderDeliverable updateManyAndReturn
   */
  export type OrderDeliverableUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDeliverable
     */
    select?: OrderDeliverableSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderDeliverable
     */
    omit?: OrderDeliverableOmit<ExtArgs> | null
    /**
     * The data used to update OrderDeliverables.
     */
    data: XOR<OrderDeliverableUpdateManyMutationInput, OrderDeliverableUncheckedUpdateManyInput>
    /**
     * Filter which OrderDeliverables to update
     */
    where?: OrderDeliverableWhereInput
    /**
     * Limit how many OrderDeliverables to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDeliverableIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderDeliverable upsert
   */
  export type OrderDeliverableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDeliverable
     */
    select?: OrderDeliverableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderDeliverable
     */
    omit?: OrderDeliverableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDeliverableInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderDeliverable to update in case it exists.
     */
    where: OrderDeliverableWhereUniqueInput
    /**
     * In case the OrderDeliverable found by the `where` argument doesn't exist, create a new OrderDeliverable with this data.
     */
    create: XOR<OrderDeliverableCreateInput, OrderDeliverableUncheckedCreateInput>
    /**
     * In case the OrderDeliverable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderDeliverableUpdateInput, OrderDeliverableUncheckedUpdateInput>
  }

  /**
   * OrderDeliverable delete
   */
  export type OrderDeliverableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDeliverable
     */
    select?: OrderDeliverableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderDeliverable
     */
    omit?: OrderDeliverableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDeliverableInclude<ExtArgs> | null
    /**
     * Filter which OrderDeliverable to delete.
     */
    where: OrderDeliverableWhereUniqueInput
  }

  /**
   * OrderDeliverable deleteMany
   */
  export type OrderDeliverableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderDeliverables to delete
     */
    where?: OrderDeliverableWhereInput
    /**
     * Limit how many OrderDeliverables to delete.
     */
    limit?: number
  }

  /**
   * OrderDeliverable without action
   */
  export type OrderDeliverableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDeliverable
     */
    select?: OrderDeliverableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderDeliverable
     */
    omit?: OrderDeliverableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDeliverableInclude<ExtArgs> | null
  }


  /**
   * Model BettingMarket
   */

  export type AggregateBettingMarket = {
    _count: BettingMarketCountAggregateOutputType | null
    _avg: BettingMarketAvgAggregateOutputType | null
    _sum: BettingMarketSumAggregateOutputType | null
    _min: BettingMarketMinAggregateOutputType | null
    _max: BettingMarketMaxAggregateOutputType | null
  }

  export type BettingMarketAvgAggregateOutputType = {
    currentValue: number | null
    predictionTarget: number | null
    odds: number | null
    totalPot: number | null
    minimumBet: number | null
    maximumBet: number | null
    settledValue: number | null
    marketMakerFee: number | null
  }

  export type BettingMarketSumAggregateOutputType = {
    currentValue: number | null
    predictionTarget: number | null
    odds: number | null
    totalPot: number | null
    minimumBet: number | null
    maximumBet: number | null
    settledValue: number | null
    marketMakerFee: number | null
  }

  export type BettingMarketMinAggregateOutputType = {
    id: string | null
    cardId: string | null
    metricType: $Enums.MarketMetricType | null
    title: string | null
    description: string | null
    currentValue: number | null
    predictionTarget: number | null
    targetDirection: $Enums.PredictionDirection | null
    odds: number | null
    totalPot: number | null
    minimumBet: number | null
    maximumBet: number | null
    startTime: Date | null
    expiryDate: Date | null
    settlementDate: Date | null
    status: $Enums.MarketStatus | null
    settled: boolean | null
    settledValue: number | null
    winningDirection: $Enums.PredictionDirection | null
    marketMakerFee: number | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BettingMarketMaxAggregateOutputType = {
    id: string | null
    cardId: string | null
    metricType: $Enums.MarketMetricType | null
    title: string | null
    description: string | null
    currentValue: number | null
    predictionTarget: number | null
    targetDirection: $Enums.PredictionDirection | null
    odds: number | null
    totalPot: number | null
    minimumBet: number | null
    maximumBet: number | null
    startTime: Date | null
    expiryDate: Date | null
    settlementDate: Date | null
    status: $Enums.MarketStatus | null
    settled: boolean | null
    settledValue: number | null
    winningDirection: $Enums.PredictionDirection | null
    marketMakerFee: number | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BettingMarketCountAggregateOutputType = {
    id: number
    cardId: number
    metricType: number
    title: number
    description: number
    currentValue: number
    predictionTarget: number
    targetDirection: number
    odds: number
    totalPot: number
    minimumBet: number
    maximumBet: number
    startTime: number
    expiryDate: number
    settlementDate: number
    status: number
    settled: number
    settledValue: number
    winningDirection: number
    marketMakerFee: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BettingMarketAvgAggregateInputType = {
    currentValue?: true
    predictionTarget?: true
    odds?: true
    totalPot?: true
    minimumBet?: true
    maximumBet?: true
    settledValue?: true
    marketMakerFee?: true
  }

  export type BettingMarketSumAggregateInputType = {
    currentValue?: true
    predictionTarget?: true
    odds?: true
    totalPot?: true
    minimumBet?: true
    maximumBet?: true
    settledValue?: true
    marketMakerFee?: true
  }

  export type BettingMarketMinAggregateInputType = {
    id?: true
    cardId?: true
    metricType?: true
    title?: true
    description?: true
    currentValue?: true
    predictionTarget?: true
    targetDirection?: true
    odds?: true
    totalPot?: true
    minimumBet?: true
    maximumBet?: true
    startTime?: true
    expiryDate?: true
    settlementDate?: true
    status?: true
    settled?: true
    settledValue?: true
    winningDirection?: true
    marketMakerFee?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BettingMarketMaxAggregateInputType = {
    id?: true
    cardId?: true
    metricType?: true
    title?: true
    description?: true
    currentValue?: true
    predictionTarget?: true
    targetDirection?: true
    odds?: true
    totalPot?: true
    minimumBet?: true
    maximumBet?: true
    startTime?: true
    expiryDate?: true
    settlementDate?: true
    status?: true
    settled?: true
    settledValue?: true
    winningDirection?: true
    marketMakerFee?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BettingMarketCountAggregateInputType = {
    id?: true
    cardId?: true
    metricType?: true
    title?: true
    description?: true
    currentValue?: true
    predictionTarget?: true
    targetDirection?: true
    odds?: true
    totalPot?: true
    minimumBet?: true
    maximumBet?: true
    startTime?: true
    expiryDate?: true
    settlementDate?: true
    status?: true
    settled?: true
    settledValue?: true
    winningDirection?: true
    marketMakerFee?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BettingMarketAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BettingMarket to aggregate.
     */
    where?: BettingMarketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BettingMarkets to fetch.
     */
    orderBy?: BettingMarketOrderByWithRelationInput | BettingMarketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BettingMarketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BettingMarkets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BettingMarkets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BettingMarkets
    **/
    _count?: true | BettingMarketCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BettingMarketAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BettingMarketSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BettingMarketMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BettingMarketMaxAggregateInputType
  }

  export type GetBettingMarketAggregateType<T extends BettingMarketAggregateArgs> = {
        [P in keyof T & keyof AggregateBettingMarket]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBettingMarket[P]>
      : GetScalarType<T[P], AggregateBettingMarket[P]>
  }




  export type BettingMarketGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BettingMarketWhereInput
    orderBy?: BettingMarketOrderByWithAggregationInput | BettingMarketOrderByWithAggregationInput[]
    by: BettingMarketScalarFieldEnum[] | BettingMarketScalarFieldEnum
    having?: BettingMarketScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BettingMarketCountAggregateInputType | true
    _avg?: BettingMarketAvgAggregateInputType
    _sum?: BettingMarketSumAggregateInputType
    _min?: BettingMarketMinAggregateInputType
    _max?: BettingMarketMaxAggregateInputType
  }

  export type BettingMarketGroupByOutputType = {
    id: string
    cardId: string
    metricType: $Enums.MarketMetricType
    title: string
    description: string
    currentValue: number
    predictionTarget: number
    targetDirection: $Enums.PredictionDirection
    odds: number
    totalPot: number
    minimumBet: number
    maximumBet: number | null
    startTime: Date
    expiryDate: Date
    settlementDate: Date | null
    status: $Enums.MarketStatus
    settled: boolean
    settledValue: number | null
    winningDirection: $Enums.PredictionDirection | null
    marketMakerFee: number
    createdBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: BettingMarketCountAggregateOutputType | null
    _avg: BettingMarketAvgAggregateOutputType | null
    _sum: BettingMarketSumAggregateOutputType | null
    _min: BettingMarketMinAggregateOutputType | null
    _max: BettingMarketMaxAggregateOutputType | null
  }

  type GetBettingMarketGroupByPayload<T extends BettingMarketGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BettingMarketGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BettingMarketGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BettingMarketGroupByOutputType[P]>
            : GetScalarType<T[P], BettingMarketGroupByOutputType[P]>
        }
      >
    >


  export type BettingMarketSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cardId?: boolean
    metricType?: boolean
    title?: boolean
    description?: boolean
    currentValue?: boolean
    predictionTarget?: boolean
    targetDirection?: boolean
    odds?: boolean
    totalPot?: boolean
    minimumBet?: boolean
    maximumBet?: boolean
    startTime?: boolean
    expiryDate?: boolean
    settlementDate?: boolean
    status?: boolean
    settled?: boolean
    settledValue?: boolean
    winningDirection?: boolean
    marketMakerFee?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    card?: boolean | CardDefaultArgs<ExtArgs>
    positions?: boolean | BettingMarket$positionsArgs<ExtArgs>
    payouts?: boolean | BettingMarket$payoutsArgs<ExtArgs>
    metrics?: boolean | BettingMarket$metricsArgs<ExtArgs>
    _count?: boolean | BettingMarketCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bettingMarket"]>

  export type BettingMarketSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cardId?: boolean
    metricType?: boolean
    title?: boolean
    description?: boolean
    currentValue?: boolean
    predictionTarget?: boolean
    targetDirection?: boolean
    odds?: boolean
    totalPot?: boolean
    minimumBet?: boolean
    maximumBet?: boolean
    startTime?: boolean
    expiryDate?: boolean
    settlementDate?: boolean
    status?: boolean
    settled?: boolean
    settledValue?: boolean
    winningDirection?: boolean
    marketMakerFee?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    card?: boolean | CardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bettingMarket"]>

  export type BettingMarketSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cardId?: boolean
    metricType?: boolean
    title?: boolean
    description?: boolean
    currentValue?: boolean
    predictionTarget?: boolean
    targetDirection?: boolean
    odds?: boolean
    totalPot?: boolean
    minimumBet?: boolean
    maximumBet?: boolean
    startTime?: boolean
    expiryDate?: boolean
    settlementDate?: boolean
    status?: boolean
    settled?: boolean
    settledValue?: boolean
    winningDirection?: boolean
    marketMakerFee?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    card?: boolean | CardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bettingMarket"]>

  export type BettingMarketSelectScalar = {
    id?: boolean
    cardId?: boolean
    metricType?: boolean
    title?: boolean
    description?: boolean
    currentValue?: boolean
    predictionTarget?: boolean
    targetDirection?: boolean
    odds?: boolean
    totalPot?: boolean
    minimumBet?: boolean
    maximumBet?: boolean
    startTime?: boolean
    expiryDate?: boolean
    settlementDate?: boolean
    status?: boolean
    settled?: boolean
    settledValue?: boolean
    winningDirection?: boolean
    marketMakerFee?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BettingMarketOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cardId" | "metricType" | "title" | "description" | "currentValue" | "predictionTarget" | "targetDirection" | "odds" | "totalPot" | "minimumBet" | "maximumBet" | "startTime" | "expiryDate" | "settlementDate" | "status" | "settled" | "settledValue" | "winningDirection" | "marketMakerFee" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["bettingMarket"]>
  export type BettingMarketInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    card?: boolean | CardDefaultArgs<ExtArgs>
    positions?: boolean | BettingMarket$positionsArgs<ExtArgs>
    payouts?: boolean | BettingMarket$payoutsArgs<ExtArgs>
    metrics?: boolean | BettingMarket$metricsArgs<ExtArgs>
    _count?: boolean | BettingMarketCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BettingMarketIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    card?: boolean | CardDefaultArgs<ExtArgs>
  }
  export type BettingMarketIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    card?: boolean | CardDefaultArgs<ExtArgs>
  }

  export type $BettingMarketPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BettingMarket"
    objects: {
      card: Prisma.$CardPayload<ExtArgs>
      positions: Prisma.$BettingPositionPayload<ExtArgs>[]
      payouts: Prisma.$BettingPayoutPayload<ExtArgs>[]
      metrics: Prisma.$MarketMetricsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cardId: string
      metricType: $Enums.MarketMetricType
      title: string
      description: string
      currentValue: number
      predictionTarget: number
      targetDirection: $Enums.PredictionDirection
      odds: number
      totalPot: number
      minimumBet: number
      maximumBet: number | null
      startTime: Date
      expiryDate: Date
      settlementDate: Date | null
      status: $Enums.MarketStatus
      settled: boolean
      settledValue: number | null
      winningDirection: $Enums.PredictionDirection | null
      marketMakerFee: number
      createdBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bettingMarket"]>
    composites: {}
  }

  type BettingMarketGetPayload<S extends boolean | null | undefined | BettingMarketDefaultArgs> = $Result.GetResult<Prisma.$BettingMarketPayload, S>

  type BettingMarketCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BettingMarketFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BettingMarketCountAggregateInputType | true
    }

  export interface BettingMarketDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BettingMarket'], meta: { name: 'BettingMarket' } }
    /**
     * Find zero or one BettingMarket that matches the filter.
     * @param {BettingMarketFindUniqueArgs} args - Arguments to find a BettingMarket
     * @example
     * // Get one BettingMarket
     * const bettingMarket = await prisma.bettingMarket.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BettingMarketFindUniqueArgs>(args: SelectSubset<T, BettingMarketFindUniqueArgs<ExtArgs>>): Prisma__BettingMarketClient<$Result.GetResult<Prisma.$BettingMarketPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BettingMarket that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BettingMarketFindUniqueOrThrowArgs} args - Arguments to find a BettingMarket
     * @example
     * // Get one BettingMarket
     * const bettingMarket = await prisma.bettingMarket.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BettingMarketFindUniqueOrThrowArgs>(args: SelectSubset<T, BettingMarketFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BettingMarketClient<$Result.GetResult<Prisma.$BettingMarketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BettingMarket that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BettingMarketFindFirstArgs} args - Arguments to find a BettingMarket
     * @example
     * // Get one BettingMarket
     * const bettingMarket = await prisma.bettingMarket.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BettingMarketFindFirstArgs>(args?: SelectSubset<T, BettingMarketFindFirstArgs<ExtArgs>>): Prisma__BettingMarketClient<$Result.GetResult<Prisma.$BettingMarketPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BettingMarket that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BettingMarketFindFirstOrThrowArgs} args - Arguments to find a BettingMarket
     * @example
     * // Get one BettingMarket
     * const bettingMarket = await prisma.bettingMarket.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BettingMarketFindFirstOrThrowArgs>(args?: SelectSubset<T, BettingMarketFindFirstOrThrowArgs<ExtArgs>>): Prisma__BettingMarketClient<$Result.GetResult<Prisma.$BettingMarketPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BettingMarkets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BettingMarketFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BettingMarkets
     * const bettingMarkets = await prisma.bettingMarket.findMany()
     * 
     * // Get first 10 BettingMarkets
     * const bettingMarkets = await prisma.bettingMarket.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bettingMarketWithIdOnly = await prisma.bettingMarket.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BettingMarketFindManyArgs>(args?: SelectSubset<T, BettingMarketFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BettingMarketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BettingMarket.
     * @param {BettingMarketCreateArgs} args - Arguments to create a BettingMarket.
     * @example
     * // Create one BettingMarket
     * const BettingMarket = await prisma.bettingMarket.create({
     *   data: {
     *     // ... data to create a BettingMarket
     *   }
     * })
     * 
     */
    create<T extends BettingMarketCreateArgs>(args: SelectSubset<T, BettingMarketCreateArgs<ExtArgs>>): Prisma__BettingMarketClient<$Result.GetResult<Prisma.$BettingMarketPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BettingMarkets.
     * @param {BettingMarketCreateManyArgs} args - Arguments to create many BettingMarkets.
     * @example
     * // Create many BettingMarkets
     * const bettingMarket = await prisma.bettingMarket.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BettingMarketCreateManyArgs>(args?: SelectSubset<T, BettingMarketCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BettingMarkets and returns the data saved in the database.
     * @param {BettingMarketCreateManyAndReturnArgs} args - Arguments to create many BettingMarkets.
     * @example
     * // Create many BettingMarkets
     * const bettingMarket = await prisma.bettingMarket.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BettingMarkets and only return the `id`
     * const bettingMarketWithIdOnly = await prisma.bettingMarket.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BettingMarketCreateManyAndReturnArgs>(args?: SelectSubset<T, BettingMarketCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BettingMarketPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BettingMarket.
     * @param {BettingMarketDeleteArgs} args - Arguments to delete one BettingMarket.
     * @example
     * // Delete one BettingMarket
     * const BettingMarket = await prisma.bettingMarket.delete({
     *   where: {
     *     // ... filter to delete one BettingMarket
     *   }
     * })
     * 
     */
    delete<T extends BettingMarketDeleteArgs>(args: SelectSubset<T, BettingMarketDeleteArgs<ExtArgs>>): Prisma__BettingMarketClient<$Result.GetResult<Prisma.$BettingMarketPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BettingMarket.
     * @param {BettingMarketUpdateArgs} args - Arguments to update one BettingMarket.
     * @example
     * // Update one BettingMarket
     * const bettingMarket = await prisma.bettingMarket.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BettingMarketUpdateArgs>(args: SelectSubset<T, BettingMarketUpdateArgs<ExtArgs>>): Prisma__BettingMarketClient<$Result.GetResult<Prisma.$BettingMarketPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BettingMarkets.
     * @param {BettingMarketDeleteManyArgs} args - Arguments to filter BettingMarkets to delete.
     * @example
     * // Delete a few BettingMarkets
     * const { count } = await prisma.bettingMarket.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BettingMarketDeleteManyArgs>(args?: SelectSubset<T, BettingMarketDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BettingMarkets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BettingMarketUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BettingMarkets
     * const bettingMarket = await prisma.bettingMarket.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BettingMarketUpdateManyArgs>(args: SelectSubset<T, BettingMarketUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BettingMarkets and returns the data updated in the database.
     * @param {BettingMarketUpdateManyAndReturnArgs} args - Arguments to update many BettingMarkets.
     * @example
     * // Update many BettingMarkets
     * const bettingMarket = await prisma.bettingMarket.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BettingMarkets and only return the `id`
     * const bettingMarketWithIdOnly = await prisma.bettingMarket.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BettingMarketUpdateManyAndReturnArgs>(args: SelectSubset<T, BettingMarketUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BettingMarketPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BettingMarket.
     * @param {BettingMarketUpsertArgs} args - Arguments to update or create a BettingMarket.
     * @example
     * // Update or create a BettingMarket
     * const bettingMarket = await prisma.bettingMarket.upsert({
     *   create: {
     *     // ... data to create a BettingMarket
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BettingMarket we want to update
     *   }
     * })
     */
    upsert<T extends BettingMarketUpsertArgs>(args: SelectSubset<T, BettingMarketUpsertArgs<ExtArgs>>): Prisma__BettingMarketClient<$Result.GetResult<Prisma.$BettingMarketPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BettingMarkets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BettingMarketCountArgs} args - Arguments to filter BettingMarkets to count.
     * @example
     * // Count the number of BettingMarkets
     * const count = await prisma.bettingMarket.count({
     *   where: {
     *     // ... the filter for the BettingMarkets we want to count
     *   }
     * })
    **/
    count<T extends BettingMarketCountArgs>(
      args?: Subset<T, BettingMarketCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BettingMarketCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BettingMarket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BettingMarketAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BettingMarketAggregateArgs>(args: Subset<T, BettingMarketAggregateArgs>): Prisma.PrismaPromise<GetBettingMarketAggregateType<T>>

    /**
     * Group by BettingMarket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BettingMarketGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BettingMarketGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BettingMarketGroupByArgs['orderBy'] }
        : { orderBy?: BettingMarketGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BettingMarketGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBettingMarketGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BettingMarket model
   */
  readonly fields: BettingMarketFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BettingMarket.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BettingMarketClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    card<T extends CardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CardDefaultArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    positions<T extends BettingMarket$positionsArgs<ExtArgs> = {}>(args?: Subset<T, BettingMarket$positionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BettingPositionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payouts<T extends BettingMarket$payoutsArgs<ExtArgs> = {}>(args?: Subset<T, BettingMarket$payoutsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BettingPayoutPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    metrics<T extends BettingMarket$metricsArgs<ExtArgs> = {}>(args?: Subset<T, BettingMarket$metricsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketMetricsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BettingMarket model
   */
  interface BettingMarketFieldRefs {
    readonly id: FieldRef<"BettingMarket", 'String'>
    readonly cardId: FieldRef<"BettingMarket", 'String'>
    readonly metricType: FieldRef<"BettingMarket", 'MarketMetricType'>
    readonly title: FieldRef<"BettingMarket", 'String'>
    readonly description: FieldRef<"BettingMarket", 'String'>
    readonly currentValue: FieldRef<"BettingMarket", 'Float'>
    readonly predictionTarget: FieldRef<"BettingMarket", 'Float'>
    readonly targetDirection: FieldRef<"BettingMarket", 'PredictionDirection'>
    readonly odds: FieldRef<"BettingMarket", 'Float'>
    readonly totalPot: FieldRef<"BettingMarket", 'Float'>
    readonly minimumBet: FieldRef<"BettingMarket", 'Float'>
    readonly maximumBet: FieldRef<"BettingMarket", 'Float'>
    readonly startTime: FieldRef<"BettingMarket", 'DateTime'>
    readonly expiryDate: FieldRef<"BettingMarket", 'DateTime'>
    readonly settlementDate: FieldRef<"BettingMarket", 'DateTime'>
    readonly status: FieldRef<"BettingMarket", 'MarketStatus'>
    readonly settled: FieldRef<"BettingMarket", 'Boolean'>
    readonly settledValue: FieldRef<"BettingMarket", 'Float'>
    readonly winningDirection: FieldRef<"BettingMarket", 'PredictionDirection'>
    readonly marketMakerFee: FieldRef<"BettingMarket", 'Float'>
    readonly createdBy: FieldRef<"BettingMarket", 'String'>
    readonly createdAt: FieldRef<"BettingMarket", 'DateTime'>
    readonly updatedAt: FieldRef<"BettingMarket", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BettingMarket findUnique
   */
  export type BettingMarketFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BettingMarket
     */
    select?: BettingMarketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BettingMarket
     */
    omit?: BettingMarketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BettingMarketInclude<ExtArgs> | null
    /**
     * Filter, which BettingMarket to fetch.
     */
    where: BettingMarketWhereUniqueInput
  }

  /**
   * BettingMarket findUniqueOrThrow
   */
  export type BettingMarketFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BettingMarket
     */
    select?: BettingMarketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BettingMarket
     */
    omit?: BettingMarketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BettingMarketInclude<ExtArgs> | null
    /**
     * Filter, which BettingMarket to fetch.
     */
    where: BettingMarketWhereUniqueInput
  }

  /**
   * BettingMarket findFirst
   */
  export type BettingMarketFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BettingMarket
     */
    select?: BettingMarketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BettingMarket
     */
    omit?: BettingMarketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BettingMarketInclude<ExtArgs> | null
    /**
     * Filter, which BettingMarket to fetch.
     */
    where?: BettingMarketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BettingMarkets to fetch.
     */
    orderBy?: BettingMarketOrderByWithRelationInput | BettingMarketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BettingMarkets.
     */
    cursor?: BettingMarketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BettingMarkets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BettingMarkets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BettingMarkets.
     */
    distinct?: BettingMarketScalarFieldEnum | BettingMarketScalarFieldEnum[]
  }

  /**
   * BettingMarket findFirstOrThrow
   */
  export type BettingMarketFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BettingMarket
     */
    select?: BettingMarketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BettingMarket
     */
    omit?: BettingMarketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BettingMarketInclude<ExtArgs> | null
    /**
     * Filter, which BettingMarket to fetch.
     */
    where?: BettingMarketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BettingMarkets to fetch.
     */
    orderBy?: BettingMarketOrderByWithRelationInput | BettingMarketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BettingMarkets.
     */
    cursor?: BettingMarketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BettingMarkets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BettingMarkets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BettingMarkets.
     */
    distinct?: BettingMarketScalarFieldEnum | BettingMarketScalarFieldEnum[]
  }

  /**
   * BettingMarket findMany
   */
  export type BettingMarketFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BettingMarket
     */
    select?: BettingMarketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BettingMarket
     */
    omit?: BettingMarketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BettingMarketInclude<ExtArgs> | null
    /**
     * Filter, which BettingMarkets to fetch.
     */
    where?: BettingMarketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BettingMarkets to fetch.
     */
    orderBy?: BettingMarketOrderByWithRelationInput | BettingMarketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BettingMarkets.
     */
    cursor?: BettingMarketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BettingMarkets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BettingMarkets.
     */
    skip?: number
    distinct?: BettingMarketScalarFieldEnum | BettingMarketScalarFieldEnum[]
  }

  /**
   * BettingMarket create
   */
  export type BettingMarketCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BettingMarket
     */
    select?: BettingMarketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BettingMarket
     */
    omit?: BettingMarketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BettingMarketInclude<ExtArgs> | null
    /**
     * The data needed to create a BettingMarket.
     */
    data: XOR<BettingMarketCreateInput, BettingMarketUncheckedCreateInput>
  }

  /**
   * BettingMarket createMany
   */
  export type BettingMarketCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BettingMarkets.
     */
    data: BettingMarketCreateManyInput | BettingMarketCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BettingMarket createManyAndReturn
   */
  export type BettingMarketCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BettingMarket
     */
    select?: BettingMarketSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BettingMarket
     */
    omit?: BettingMarketOmit<ExtArgs> | null
    /**
     * The data used to create many BettingMarkets.
     */
    data: BettingMarketCreateManyInput | BettingMarketCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BettingMarketIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BettingMarket update
   */
  export type BettingMarketUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BettingMarket
     */
    select?: BettingMarketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BettingMarket
     */
    omit?: BettingMarketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BettingMarketInclude<ExtArgs> | null
    /**
     * The data needed to update a BettingMarket.
     */
    data: XOR<BettingMarketUpdateInput, BettingMarketUncheckedUpdateInput>
    /**
     * Choose, which BettingMarket to update.
     */
    where: BettingMarketWhereUniqueInput
  }

  /**
   * BettingMarket updateMany
   */
  export type BettingMarketUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BettingMarkets.
     */
    data: XOR<BettingMarketUpdateManyMutationInput, BettingMarketUncheckedUpdateManyInput>
    /**
     * Filter which BettingMarkets to update
     */
    where?: BettingMarketWhereInput
    /**
     * Limit how many BettingMarkets to update.
     */
    limit?: number
  }

  /**
   * BettingMarket updateManyAndReturn
   */
  export type BettingMarketUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BettingMarket
     */
    select?: BettingMarketSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BettingMarket
     */
    omit?: BettingMarketOmit<ExtArgs> | null
    /**
     * The data used to update BettingMarkets.
     */
    data: XOR<BettingMarketUpdateManyMutationInput, BettingMarketUncheckedUpdateManyInput>
    /**
     * Filter which BettingMarkets to update
     */
    where?: BettingMarketWhereInput
    /**
     * Limit how many BettingMarkets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BettingMarketIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BettingMarket upsert
   */
  export type BettingMarketUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BettingMarket
     */
    select?: BettingMarketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BettingMarket
     */
    omit?: BettingMarketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BettingMarketInclude<ExtArgs> | null
    /**
     * The filter to search for the BettingMarket to update in case it exists.
     */
    where: BettingMarketWhereUniqueInput
    /**
     * In case the BettingMarket found by the `where` argument doesn't exist, create a new BettingMarket with this data.
     */
    create: XOR<BettingMarketCreateInput, BettingMarketUncheckedCreateInput>
    /**
     * In case the BettingMarket was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BettingMarketUpdateInput, BettingMarketUncheckedUpdateInput>
  }

  /**
   * BettingMarket delete
   */
  export type BettingMarketDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BettingMarket
     */
    select?: BettingMarketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BettingMarket
     */
    omit?: BettingMarketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BettingMarketInclude<ExtArgs> | null
    /**
     * Filter which BettingMarket to delete.
     */
    where: BettingMarketWhereUniqueInput
  }

  /**
   * BettingMarket deleteMany
   */
  export type BettingMarketDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BettingMarkets to delete
     */
    where?: BettingMarketWhereInput
    /**
     * Limit how many BettingMarkets to delete.
     */
    limit?: number
  }

  /**
   * BettingMarket.positions
   */
  export type BettingMarket$positionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BettingPosition
     */
    select?: BettingPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BettingPosition
     */
    omit?: BettingPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BettingPositionInclude<ExtArgs> | null
    where?: BettingPositionWhereInput
    orderBy?: BettingPositionOrderByWithRelationInput | BettingPositionOrderByWithRelationInput[]
    cursor?: BettingPositionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BettingPositionScalarFieldEnum | BettingPositionScalarFieldEnum[]
  }

  /**
   * BettingMarket.payouts
   */
  export type BettingMarket$payoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BettingPayout
     */
    select?: BettingPayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BettingPayout
     */
    omit?: BettingPayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BettingPayoutInclude<ExtArgs> | null
    where?: BettingPayoutWhereInput
    orderBy?: BettingPayoutOrderByWithRelationInput | BettingPayoutOrderByWithRelationInput[]
    cursor?: BettingPayoutWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BettingPayoutScalarFieldEnum | BettingPayoutScalarFieldEnum[]
  }

  /**
   * BettingMarket.metrics
   */
  export type BettingMarket$metricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketMetrics
     */
    select?: MarketMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketMetrics
     */
    omit?: MarketMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketMetricsInclude<ExtArgs> | null
    where?: MarketMetricsWhereInput
    orderBy?: MarketMetricsOrderByWithRelationInput | MarketMetricsOrderByWithRelationInput[]
    cursor?: MarketMetricsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MarketMetricsScalarFieldEnum | MarketMetricsScalarFieldEnum[]
  }

  /**
   * BettingMarket without action
   */
  export type BettingMarketDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BettingMarket
     */
    select?: BettingMarketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BettingMarket
     */
    omit?: BettingMarketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BettingMarketInclude<ExtArgs> | null
  }


  /**
   * Model BettingPosition
   */

  export type AggregateBettingPosition = {
    _count: BettingPositionCountAggregateOutputType | null
    _avg: BettingPositionAvgAggregateOutputType | null
    _sum: BettingPositionSumAggregateOutputType | null
    _min: BettingPositionMinAggregateOutputType | null
    _max: BettingPositionMaxAggregateOutputType | null
  }

  export type BettingPositionAvgAggregateOutputType = {
    amount: number | null
    odds: number | null
    potentialWinning: number | null
    multiplier: number | null
    payout: number | null
  }

  export type BettingPositionSumAggregateOutputType = {
    amount: number | null
    odds: number | null
    potentialWinning: number | null
    multiplier: number | null
    payout: number | null
  }

  export type BettingPositionMinAggregateOutputType = {
    id: string | null
    marketId: string | null
    userId: string | null
    position: $Enums.PredictionDirection | null
    amount: number | null
    odds: number | null
    potentialWinning: number | null
    pickGroupId: string | null
    multiplier: number | null
    powerPlay: boolean | null
    status: $Enums.PositionStatus | null
    settled: boolean | null
    won: boolean | null
    payout: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BettingPositionMaxAggregateOutputType = {
    id: string | null
    marketId: string | null
    userId: string | null
    position: $Enums.PredictionDirection | null
    amount: number | null
    odds: number | null
    potentialWinning: number | null
    pickGroupId: string | null
    multiplier: number | null
    powerPlay: boolean | null
    status: $Enums.PositionStatus | null
    settled: boolean | null
    won: boolean | null
    payout: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BettingPositionCountAggregateOutputType = {
    id: number
    marketId: number
    userId: number
    position: number
    amount: number
    odds: number
    potentialWinning: number
    pickGroupId: number
    multiplier: number
    powerPlay: number
    status: number
    settled: number
    won: number
    payout: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BettingPositionAvgAggregateInputType = {
    amount?: true
    odds?: true
    potentialWinning?: true
    multiplier?: true
    payout?: true
  }

  export type BettingPositionSumAggregateInputType = {
    amount?: true
    odds?: true
    potentialWinning?: true
    multiplier?: true
    payout?: true
  }

  export type BettingPositionMinAggregateInputType = {
    id?: true
    marketId?: true
    userId?: true
    position?: true
    amount?: true
    odds?: true
    potentialWinning?: true
    pickGroupId?: true
    multiplier?: true
    powerPlay?: true
    status?: true
    settled?: true
    won?: true
    payout?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BettingPositionMaxAggregateInputType = {
    id?: true
    marketId?: true
    userId?: true
    position?: true
    amount?: true
    odds?: true
    potentialWinning?: true
    pickGroupId?: true
    multiplier?: true
    powerPlay?: true
    status?: true
    settled?: true
    won?: true
    payout?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BettingPositionCountAggregateInputType = {
    id?: true
    marketId?: true
    userId?: true
    position?: true
    amount?: true
    odds?: true
    potentialWinning?: true
    pickGroupId?: true
    multiplier?: true
    powerPlay?: true
    status?: true
    settled?: true
    won?: true
    payout?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BettingPositionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BettingPosition to aggregate.
     */
    where?: BettingPositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BettingPositions to fetch.
     */
    orderBy?: BettingPositionOrderByWithRelationInput | BettingPositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BettingPositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BettingPositions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BettingPositions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BettingPositions
    **/
    _count?: true | BettingPositionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BettingPositionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BettingPositionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BettingPositionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BettingPositionMaxAggregateInputType
  }

  export type GetBettingPositionAggregateType<T extends BettingPositionAggregateArgs> = {
        [P in keyof T & keyof AggregateBettingPosition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBettingPosition[P]>
      : GetScalarType<T[P], AggregateBettingPosition[P]>
  }




  export type BettingPositionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BettingPositionWhereInput
    orderBy?: BettingPositionOrderByWithAggregationInput | BettingPositionOrderByWithAggregationInput[]
    by: BettingPositionScalarFieldEnum[] | BettingPositionScalarFieldEnum
    having?: BettingPositionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BettingPositionCountAggregateInputType | true
    _avg?: BettingPositionAvgAggregateInputType
    _sum?: BettingPositionSumAggregateInputType
    _min?: BettingPositionMinAggregateInputType
    _max?: BettingPositionMaxAggregateInputType
  }

  export type BettingPositionGroupByOutputType = {
    id: string
    marketId: string
    userId: string
    position: $Enums.PredictionDirection
    amount: number
    odds: number
    potentialWinning: number
    pickGroupId: string | null
    multiplier: number
    powerPlay: boolean
    status: $Enums.PositionStatus
    settled: boolean
    won: boolean | null
    payout: number | null
    createdAt: Date
    updatedAt: Date
    _count: BettingPositionCountAggregateOutputType | null
    _avg: BettingPositionAvgAggregateOutputType | null
    _sum: BettingPositionSumAggregateOutputType | null
    _min: BettingPositionMinAggregateOutputType | null
    _max: BettingPositionMaxAggregateOutputType | null
  }

  type GetBettingPositionGroupByPayload<T extends BettingPositionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BettingPositionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BettingPositionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BettingPositionGroupByOutputType[P]>
            : GetScalarType<T[P], BettingPositionGroupByOutputType[P]>
        }
      >
    >


  export type BettingPositionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    marketId?: boolean
    userId?: boolean
    position?: boolean
    amount?: boolean
    odds?: boolean
    potentialWinning?: boolean
    pickGroupId?: boolean
    multiplier?: boolean
    powerPlay?: boolean
    status?: boolean
    settled?: boolean
    won?: boolean
    payout?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    market?: boolean | BettingMarketDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bettingPosition"]>

  export type BettingPositionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    marketId?: boolean
    userId?: boolean
    position?: boolean
    amount?: boolean
    odds?: boolean
    potentialWinning?: boolean
    pickGroupId?: boolean
    multiplier?: boolean
    powerPlay?: boolean
    status?: boolean
    settled?: boolean
    won?: boolean
    payout?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    market?: boolean | BettingMarketDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bettingPosition"]>

  export type BettingPositionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    marketId?: boolean
    userId?: boolean
    position?: boolean
    amount?: boolean
    odds?: boolean
    potentialWinning?: boolean
    pickGroupId?: boolean
    multiplier?: boolean
    powerPlay?: boolean
    status?: boolean
    settled?: boolean
    won?: boolean
    payout?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    market?: boolean | BettingMarketDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bettingPosition"]>

  export type BettingPositionSelectScalar = {
    id?: boolean
    marketId?: boolean
    userId?: boolean
    position?: boolean
    amount?: boolean
    odds?: boolean
    potentialWinning?: boolean
    pickGroupId?: boolean
    multiplier?: boolean
    powerPlay?: boolean
    status?: boolean
    settled?: boolean
    won?: boolean
    payout?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BettingPositionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "marketId" | "userId" | "position" | "amount" | "odds" | "potentialWinning" | "pickGroupId" | "multiplier" | "powerPlay" | "status" | "settled" | "won" | "payout" | "createdAt" | "updatedAt", ExtArgs["result"]["bettingPosition"]>
  export type BettingPositionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    market?: boolean | BettingMarketDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BettingPositionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    market?: boolean | BettingMarketDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BettingPositionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    market?: boolean | BettingMarketDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BettingPositionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BettingPosition"
    objects: {
      market: Prisma.$BettingMarketPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      marketId: string
      userId: string
      position: $Enums.PredictionDirection
      amount: number
      odds: number
      potentialWinning: number
      pickGroupId: string | null
      multiplier: number
      powerPlay: boolean
      status: $Enums.PositionStatus
      settled: boolean
      won: boolean | null
      payout: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bettingPosition"]>
    composites: {}
  }

  type BettingPositionGetPayload<S extends boolean | null | undefined | BettingPositionDefaultArgs> = $Result.GetResult<Prisma.$BettingPositionPayload, S>

  type BettingPositionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BettingPositionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BettingPositionCountAggregateInputType | true
    }

  export interface BettingPositionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BettingPosition'], meta: { name: 'BettingPosition' } }
    /**
     * Find zero or one BettingPosition that matches the filter.
     * @param {BettingPositionFindUniqueArgs} args - Arguments to find a BettingPosition
     * @example
     * // Get one BettingPosition
     * const bettingPosition = await prisma.bettingPosition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BettingPositionFindUniqueArgs>(args: SelectSubset<T, BettingPositionFindUniqueArgs<ExtArgs>>): Prisma__BettingPositionClient<$Result.GetResult<Prisma.$BettingPositionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BettingPosition that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BettingPositionFindUniqueOrThrowArgs} args - Arguments to find a BettingPosition
     * @example
     * // Get one BettingPosition
     * const bettingPosition = await prisma.bettingPosition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BettingPositionFindUniqueOrThrowArgs>(args: SelectSubset<T, BettingPositionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BettingPositionClient<$Result.GetResult<Prisma.$BettingPositionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BettingPosition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BettingPositionFindFirstArgs} args - Arguments to find a BettingPosition
     * @example
     * // Get one BettingPosition
     * const bettingPosition = await prisma.bettingPosition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BettingPositionFindFirstArgs>(args?: SelectSubset<T, BettingPositionFindFirstArgs<ExtArgs>>): Prisma__BettingPositionClient<$Result.GetResult<Prisma.$BettingPositionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BettingPosition that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BettingPositionFindFirstOrThrowArgs} args - Arguments to find a BettingPosition
     * @example
     * // Get one BettingPosition
     * const bettingPosition = await prisma.bettingPosition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BettingPositionFindFirstOrThrowArgs>(args?: SelectSubset<T, BettingPositionFindFirstOrThrowArgs<ExtArgs>>): Prisma__BettingPositionClient<$Result.GetResult<Prisma.$BettingPositionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BettingPositions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BettingPositionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BettingPositions
     * const bettingPositions = await prisma.bettingPosition.findMany()
     * 
     * // Get first 10 BettingPositions
     * const bettingPositions = await prisma.bettingPosition.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bettingPositionWithIdOnly = await prisma.bettingPosition.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BettingPositionFindManyArgs>(args?: SelectSubset<T, BettingPositionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BettingPositionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BettingPosition.
     * @param {BettingPositionCreateArgs} args - Arguments to create a BettingPosition.
     * @example
     * // Create one BettingPosition
     * const BettingPosition = await prisma.bettingPosition.create({
     *   data: {
     *     // ... data to create a BettingPosition
     *   }
     * })
     * 
     */
    create<T extends BettingPositionCreateArgs>(args: SelectSubset<T, BettingPositionCreateArgs<ExtArgs>>): Prisma__BettingPositionClient<$Result.GetResult<Prisma.$BettingPositionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BettingPositions.
     * @param {BettingPositionCreateManyArgs} args - Arguments to create many BettingPositions.
     * @example
     * // Create many BettingPositions
     * const bettingPosition = await prisma.bettingPosition.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BettingPositionCreateManyArgs>(args?: SelectSubset<T, BettingPositionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BettingPositions and returns the data saved in the database.
     * @param {BettingPositionCreateManyAndReturnArgs} args - Arguments to create many BettingPositions.
     * @example
     * // Create many BettingPositions
     * const bettingPosition = await prisma.bettingPosition.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BettingPositions and only return the `id`
     * const bettingPositionWithIdOnly = await prisma.bettingPosition.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BettingPositionCreateManyAndReturnArgs>(args?: SelectSubset<T, BettingPositionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BettingPositionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BettingPosition.
     * @param {BettingPositionDeleteArgs} args - Arguments to delete one BettingPosition.
     * @example
     * // Delete one BettingPosition
     * const BettingPosition = await prisma.bettingPosition.delete({
     *   where: {
     *     // ... filter to delete one BettingPosition
     *   }
     * })
     * 
     */
    delete<T extends BettingPositionDeleteArgs>(args: SelectSubset<T, BettingPositionDeleteArgs<ExtArgs>>): Prisma__BettingPositionClient<$Result.GetResult<Prisma.$BettingPositionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BettingPosition.
     * @param {BettingPositionUpdateArgs} args - Arguments to update one BettingPosition.
     * @example
     * // Update one BettingPosition
     * const bettingPosition = await prisma.bettingPosition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BettingPositionUpdateArgs>(args: SelectSubset<T, BettingPositionUpdateArgs<ExtArgs>>): Prisma__BettingPositionClient<$Result.GetResult<Prisma.$BettingPositionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BettingPositions.
     * @param {BettingPositionDeleteManyArgs} args - Arguments to filter BettingPositions to delete.
     * @example
     * // Delete a few BettingPositions
     * const { count } = await prisma.bettingPosition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BettingPositionDeleteManyArgs>(args?: SelectSubset<T, BettingPositionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BettingPositions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BettingPositionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BettingPositions
     * const bettingPosition = await prisma.bettingPosition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BettingPositionUpdateManyArgs>(args: SelectSubset<T, BettingPositionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BettingPositions and returns the data updated in the database.
     * @param {BettingPositionUpdateManyAndReturnArgs} args - Arguments to update many BettingPositions.
     * @example
     * // Update many BettingPositions
     * const bettingPosition = await prisma.bettingPosition.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BettingPositions and only return the `id`
     * const bettingPositionWithIdOnly = await prisma.bettingPosition.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BettingPositionUpdateManyAndReturnArgs>(args: SelectSubset<T, BettingPositionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BettingPositionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BettingPosition.
     * @param {BettingPositionUpsertArgs} args - Arguments to update or create a BettingPosition.
     * @example
     * // Update or create a BettingPosition
     * const bettingPosition = await prisma.bettingPosition.upsert({
     *   create: {
     *     // ... data to create a BettingPosition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BettingPosition we want to update
     *   }
     * })
     */
    upsert<T extends BettingPositionUpsertArgs>(args: SelectSubset<T, BettingPositionUpsertArgs<ExtArgs>>): Prisma__BettingPositionClient<$Result.GetResult<Prisma.$BettingPositionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BettingPositions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BettingPositionCountArgs} args - Arguments to filter BettingPositions to count.
     * @example
     * // Count the number of BettingPositions
     * const count = await prisma.bettingPosition.count({
     *   where: {
     *     // ... the filter for the BettingPositions we want to count
     *   }
     * })
    **/
    count<T extends BettingPositionCountArgs>(
      args?: Subset<T, BettingPositionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BettingPositionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BettingPosition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BettingPositionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BettingPositionAggregateArgs>(args: Subset<T, BettingPositionAggregateArgs>): Prisma.PrismaPromise<GetBettingPositionAggregateType<T>>

    /**
     * Group by BettingPosition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BettingPositionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BettingPositionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BettingPositionGroupByArgs['orderBy'] }
        : { orderBy?: BettingPositionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BettingPositionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBettingPositionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BettingPosition model
   */
  readonly fields: BettingPositionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BettingPosition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BettingPositionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    market<T extends BettingMarketDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BettingMarketDefaultArgs<ExtArgs>>): Prisma__BettingMarketClient<$Result.GetResult<Prisma.$BettingMarketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BettingPosition model
   */
  interface BettingPositionFieldRefs {
    readonly id: FieldRef<"BettingPosition", 'String'>
    readonly marketId: FieldRef<"BettingPosition", 'String'>
    readonly userId: FieldRef<"BettingPosition", 'String'>
    readonly position: FieldRef<"BettingPosition", 'PredictionDirection'>
    readonly amount: FieldRef<"BettingPosition", 'Float'>
    readonly odds: FieldRef<"BettingPosition", 'Float'>
    readonly potentialWinning: FieldRef<"BettingPosition", 'Float'>
    readonly pickGroupId: FieldRef<"BettingPosition", 'String'>
    readonly multiplier: FieldRef<"BettingPosition", 'Float'>
    readonly powerPlay: FieldRef<"BettingPosition", 'Boolean'>
    readonly status: FieldRef<"BettingPosition", 'PositionStatus'>
    readonly settled: FieldRef<"BettingPosition", 'Boolean'>
    readonly won: FieldRef<"BettingPosition", 'Boolean'>
    readonly payout: FieldRef<"BettingPosition", 'Float'>
    readonly createdAt: FieldRef<"BettingPosition", 'DateTime'>
    readonly updatedAt: FieldRef<"BettingPosition", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BettingPosition findUnique
   */
  export type BettingPositionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BettingPosition
     */
    select?: BettingPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BettingPosition
     */
    omit?: BettingPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BettingPositionInclude<ExtArgs> | null
    /**
     * Filter, which BettingPosition to fetch.
     */
    where: BettingPositionWhereUniqueInput
  }

  /**
   * BettingPosition findUniqueOrThrow
   */
  export type BettingPositionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BettingPosition
     */
    select?: BettingPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BettingPosition
     */
    omit?: BettingPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BettingPositionInclude<ExtArgs> | null
    /**
     * Filter, which BettingPosition to fetch.
     */
    where: BettingPositionWhereUniqueInput
  }

  /**
   * BettingPosition findFirst
   */
  export type BettingPositionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BettingPosition
     */
    select?: BettingPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BettingPosition
     */
    omit?: BettingPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BettingPositionInclude<ExtArgs> | null
    /**
     * Filter, which BettingPosition to fetch.
     */
    where?: BettingPositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BettingPositions to fetch.
     */
    orderBy?: BettingPositionOrderByWithRelationInput | BettingPositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BettingPositions.
     */
    cursor?: BettingPositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BettingPositions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BettingPositions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BettingPositions.
     */
    distinct?: BettingPositionScalarFieldEnum | BettingPositionScalarFieldEnum[]
  }

  /**
   * BettingPosition findFirstOrThrow
   */
  export type BettingPositionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BettingPosition
     */
    select?: BettingPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BettingPosition
     */
    omit?: BettingPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BettingPositionInclude<ExtArgs> | null
    /**
     * Filter, which BettingPosition to fetch.
     */
    where?: BettingPositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BettingPositions to fetch.
     */
    orderBy?: BettingPositionOrderByWithRelationInput | BettingPositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BettingPositions.
     */
    cursor?: BettingPositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BettingPositions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BettingPositions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BettingPositions.
     */
    distinct?: BettingPositionScalarFieldEnum | BettingPositionScalarFieldEnum[]
  }

  /**
   * BettingPosition findMany
   */
  export type BettingPositionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BettingPosition
     */
    select?: BettingPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BettingPosition
     */
    omit?: BettingPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BettingPositionInclude<ExtArgs> | null
    /**
     * Filter, which BettingPositions to fetch.
     */
    where?: BettingPositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BettingPositions to fetch.
     */
    orderBy?: BettingPositionOrderByWithRelationInput | BettingPositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BettingPositions.
     */
    cursor?: BettingPositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BettingPositions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BettingPositions.
     */
    skip?: number
    distinct?: BettingPositionScalarFieldEnum | BettingPositionScalarFieldEnum[]
  }

  /**
   * BettingPosition create
   */
  export type BettingPositionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BettingPosition
     */
    select?: BettingPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BettingPosition
     */
    omit?: BettingPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BettingPositionInclude<ExtArgs> | null
    /**
     * The data needed to create a BettingPosition.
     */
    data: XOR<BettingPositionCreateInput, BettingPositionUncheckedCreateInput>
  }

  /**
   * BettingPosition createMany
   */
  export type BettingPositionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BettingPositions.
     */
    data: BettingPositionCreateManyInput | BettingPositionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BettingPosition createManyAndReturn
   */
  export type BettingPositionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BettingPosition
     */
    select?: BettingPositionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BettingPosition
     */
    omit?: BettingPositionOmit<ExtArgs> | null
    /**
     * The data used to create many BettingPositions.
     */
    data: BettingPositionCreateManyInput | BettingPositionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BettingPositionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BettingPosition update
   */
  export type BettingPositionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BettingPosition
     */
    select?: BettingPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BettingPosition
     */
    omit?: BettingPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BettingPositionInclude<ExtArgs> | null
    /**
     * The data needed to update a BettingPosition.
     */
    data: XOR<BettingPositionUpdateInput, BettingPositionUncheckedUpdateInput>
    /**
     * Choose, which BettingPosition to update.
     */
    where: BettingPositionWhereUniqueInput
  }

  /**
   * BettingPosition updateMany
   */
  export type BettingPositionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BettingPositions.
     */
    data: XOR<BettingPositionUpdateManyMutationInput, BettingPositionUncheckedUpdateManyInput>
    /**
     * Filter which BettingPositions to update
     */
    where?: BettingPositionWhereInput
    /**
     * Limit how many BettingPositions to update.
     */
    limit?: number
  }

  /**
   * BettingPosition updateManyAndReturn
   */
  export type BettingPositionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BettingPosition
     */
    select?: BettingPositionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BettingPosition
     */
    omit?: BettingPositionOmit<ExtArgs> | null
    /**
     * The data used to update BettingPositions.
     */
    data: XOR<BettingPositionUpdateManyMutationInput, BettingPositionUncheckedUpdateManyInput>
    /**
     * Filter which BettingPositions to update
     */
    where?: BettingPositionWhereInput
    /**
     * Limit how many BettingPositions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BettingPositionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BettingPosition upsert
   */
  export type BettingPositionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BettingPosition
     */
    select?: BettingPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BettingPosition
     */
    omit?: BettingPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BettingPositionInclude<ExtArgs> | null
    /**
     * The filter to search for the BettingPosition to update in case it exists.
     */
    where: BettingPositionWhereUniqueInput
    /**
     * In case the BettingPosition found by the `where` argument doesn't exist, create a new BettingPosition with this data.
     */
    create: XOR<BettingPositionCreateInput, BettingPositionUncheckedCreateInput>
    /**
     * In case the BettingPosition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BettingPositionUpdateInput, BettingPositionUncheckedUpdateInput>
  }

  /**
   * BettingPosition delete
   */
  export type BettingPositionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BettingPosition
     */
    select?: BettingPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BettingPosition
     */
    omit?: BettingPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BettingPositionInclude<ExtArgs> | null
    /**
     * Filter which BettingPosition to delete.
     */
    where: BettingPositionWhereUniqueInput
  }

  /**
   * BettingPosition deleteMany
   */
  export type BettingPositionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BettingPositions to delete
     */
    where?: BettingPositionWhereInput
    /**
     * Limit how many BettingPositions to delete.
     */
    limit?: number
  }

  /**
   * BettingPosition without action
   */
  export type BettingPositionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BettingPosition
     */
    select?: BettingPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BettingPosition
     */
    omit?: BettingPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BettingPositionInclude<ExtArgs> | null
  }


  /**
   * Model MarketMetrics
   */

  export type AggregateMarketMetrics = {
    _count: MarketMetricsCountAggregateOutputType | null
    _avg: MarketMetricsAvgAggregateOutputType | null
    _sum: MarketMetricsSumAggregateOutputType | null
    _min: MarketMetricsMinAggregateOutputType | null
    _max: MarketMetricsMaxAggregateOutputType | null
  }

  export type MarketMetricsAvgAggregateOutputType = {
    revenue: number | null
    userGrowth: number | null
    valuation: number | null
    marketCap: number | null
    quarterlyGrowth: number | null
    userEngagement: number | null
    productLaunches: number | null
    competitorRank: number | null
    sentimentScore: number | null
    trendingScore: number | null
    socialMentions: number | null
  }

  export type MarketMetricsSumAggregateOutputType = {
    revenue: number | null
    userGrowth: number | null
    valuation: number | null
    marketCap: number | null
    quarterlyGrowth: number | null
    userEngagement: number | null
    productLaunches: number | null
    competitorRank: number | null
    sentimentScore: number | null
    trendingScore: number | null
    socialMentions: number | null
  }

  export type MarketMetricsMinAggregateOutputType = {
    id: string | null
    cardId: string | null
    marketId: string | null
    revenue: number | null
    userGrowth: number | null
    valuation: number | null
    marketCap: number | null
    quarterlyGrowth: number | null
    userEngagement: number | null
    productLaunches: number | null
    competitorRank: number | null
    sentimentScore: number | null
    trendingScore: number | null
    socialMentions: number | null
    recordDate: Date | null
    dataSource: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MarketMetricsMaxAggregateOutputType = {
    id: string | null
    cardId: string | null
    marketId: string | null
    revenue: number | null
    userGrowth: number | null
    valuation: number | null
    marketCap: number | null
    quarterlyGrowth: number | null
    userEngagement: number | null
    productLaunches: number | null
    competitorRank: number | null
    sentimentScore: number | null
    trendingScore: number | null
    socialMentions: number | null
    recordDate: Date | null
    dataSource: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MarketMetricsCountAggregateOutputType = {
    id: number
    cardId: number
    marketId: number
    revenue: number
    userGrowth: number
    valuation: number
    marketCap: number
    quarterlyGrowth: number
    userEngagement: number
    productLaunches: number
    competitorRank: number
    sentimentScore: number
    trendingScore: number
    socialMentions: number
    recordDate: number
    dataSource: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MarketMetricsAvgAggregateInputType = {
    revenue?: true
    userGrowth?: true
    valuation?: true
    marketCap?: true
    quarterlyGrowth?: true
    userEngagement?: true
    productLaunches?: true
    competitorRank?: true
    sentimentScore?: true
    trendingScore?: true
    socialMentions?: true
  }

  export type MarketMetricsSumAggregateInputType = {
    revenue?: true
    userGrowth?: true
    valuation?: true
    marketCap?: true
    quarterlyGrowth?: true
    userEngagement?: true
    productLaunches?: true
    competitorRank?: true
    sentimentScore?: true
    trendingScore?: true
    socialMentions?: true
  }

  export type MarketMetricsMinAggregateInputType = {
    id?: true
    cardId?: true
    marketId?: true
    revenue?: true
    userGrowth?: true
    valuation?: true
    marketCap?: true
    quarterlyGrowth?: true
    userEngagement?: true
    productLaunches?: true
    competitorRank?: true
    sentimentScore?: true
    trendingScore?: true
    socialMentions?: true
    recordDate?: true
    dataSource?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MarketMetricsMaxAggregateInputType = {
    id?: true
    cardId?: true
    marketId?: true
    revenue?: true
    userGrowth?: true
    valuation?: true
    marketCap?: true
    quarterlyGrowth?: true
    userEngagement?: true
    productLaunches?: true
    competitorRank?: true
    sentimentScore?: true
    trendingScore?: true
    socialMentions?: true
    recordDate?: true
    dataSource?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MarketMetricsCountAggregateInputType = {
    id?: true
    cardId?: true
    marketId?: true
    revenue?: true
    userGrowth?: true
    valuation?: true
    marketCap?: true
    quarterlyGrowth?: true
    userEngagement?: true
    productLaunches?: true
    competitorRank?: true
    sentimentScore?: true
    trendingScore?: true
    socialMentions?: true
    recordDate?: true
    dataSource?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MarketMetricsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketMetrics to aggregate.
     */
    where?: MarketMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketMetrics to fetch.
     */
    orderBy?: MarketMetricsOrderByWithRelationInput | MarketMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MarketMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MarketMetrics
    **/
    _count?: true | MarketMetricsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MarketMetricsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MarketMetricsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MarketMetricsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MarketMetricsMaxAggregateInputType
  }

  export type GetMarketMetricsAggregateType<T extends MarketMetricsAggregateArgs> = {
        [P in keyof T & keyof AggregateMarketMetrics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarketMetrics[P]>
      : GetScalarType<T[P], AggregateMarketMetrics[P]>
  }




  export type MarketMetricsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketMetricsWhereInput
    orderBy?: MarketMetricsOrderByWithAggregationInput | MarketMetricsOrderByWithAggregationInput[]
    by: MarketMetricsScalarFieldEnum[] | MarketMetricsScalarFieldEnum
    having?: MarketMetricsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MarketMetricsCountAggregateInputType | true
    _avg?: MarketMetricsAvgAggregateInputType
    _sum?: MarketMetricsSumAggregateInputType
    _min?: MarketMetricsMinAggregateInputType
    _max?: MarketMetricsMaxAggregateInputType
  }

  export type MarketMetricsGroupByOutputType = {
    id: string
    cardId: string
    marketId: string | null
    revenue: number | null
    userGrowth: number | null
    valuation: number | null
    marketCap: number | null
    quarterlyGrowth: number | null
    userEngagement: number | null
    productLaunches: number | null
    competitorRank: number | null
    sentimentScore: number | null
    trendingScore: number | null
    socialMentions: number | null
    recordDate: Date
    dataSource: string | null
    createdAt: Date
    updatedAt: Date
    _count: MarketMetricsCountAggregateOutputType | null
    _avg: MarketMetricsAvgAggregateOutputType | null
    _sum: MarketMetricsSumAggregateOutputType | null
    _min: MarketMetricsMinAggregateOutputType | null
    _max: MarketMetricsMaxAggregateOutputType | null
  }

  type GetMarketMetricsGroupByPayload<T extends MarketMetricsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MarketMetricsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MarketMetricsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarketMetricsGroupByOutputType[P]>
            : GetScalarType<T[P], MarketMetricsGroupByOutputType[P]>
        }
      >
    >


  export type MarketMetricsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cardId?: boolean
    marketId?: boolean
    revenue?: boolean
    userGrowth?: boolean
    valuation?: boolean
    marketCap?: boolean
    quarterlyGrowth?: boolean
    userEngagement?: boolean
    productLaunches?: boolean
    competitorRank?: boolean
    sentimentScore?: boolean
    trendingScore?: boolean
    socialMentions?: boolean
    recordDate?: boolean
    dataSource?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    card?: boolean | CardDefaultArgs<ExtArgs>
    market?: boolean | MarketMetrics$marketArgs<ExtArgs>
  }, ExtArgs["result"]["marketMetrics"]>

  export type MarketMetricsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cardId?: boolean
    marketId?: boolean
    revenue?: boolean
    userGrowth?: boolean
    valuation?: boolean
    marketCap?: boolean
    quarterlyGrowth?: boolean
    userEngagement?: boolean
    productLaunches?: boolean
    competitorRank?: boolean
    sentimentScore?: boolean
    trendingScore?: boolean
    socialMentions?: boolean
    recordDate?: boolean
    dataSource?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    card?: boolean | CardDefaultArgs<ExtArgs>
    market?: boolean | MarketMetrics$marketArgs<ExtArgs>
  }, ExtArgs["result"]["marketMetrics"]>

  export type MarketMetricsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cardId?: boolean
    marketId?: boolean
    revenue?: boolean
    userGrowth?: boolean
    valuation?: boolean
    marketCap?: boolean
    quarterlyGrowth?: boolean
    userEngagement?: boolean
    productLaunches?: boolean
    competitorRank?: boolean
    sentimentScore?: boolean
    trendingScore?: boolean
    socialMentions?: boolean
    recordDate?: boolean
    dataSource?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    card?: boolean | CardDefaultArgs<ExtArgs>
    market?: boolean | MarketMetrics$marketArgs<ExtArgs>
  }, ExtArgs["result"]["marketMetrics"]>

  export type MarketMetricsSelectScalar = {
    id?: boolean
    cardId?: boolean
    marketId?: boolean
    revenue?: boolean
    userGrowth?: boolean
    valuation?: boolean
    marketCap?: boolean
    quarterlyGrowth?: boolean
    userEngagement?: boolean
    productLaunches?: boolean
    competitorRank?: boolean
    sentimentScore?: boolean
    trendingScore?: boolean
    socialMentions?: boolean
    recordDate?: boolean
    dataSource?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MarketMetricsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cardId" | "marketId" | "revenue" | "userGrowth" | "valuation" | "marketCap" | "quarterlyGrowth" | "userEngagement" | "productLaunches" | "competitorRank" | "sentimentScore" | "trendingScore" | "socialMentions" | "recordDate" | "dataSource" | "createdAt" | "updatedAt", ExtArgs["result"]["marketMetrics"]>
  export type MarketMetricsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    card?: boolean | CardDefaultArgs<ExtArgs>
    market?: boolean | MarketMetrics$marketArgs<ExtArgs>
  }
  export type MarketMetricsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    card?: boolean | CardDefaultArgs<ExtArgs>
    market?: boolean | MarketMetrics$marketArgs<ExtArgs>
  }
  export type MarketMetricsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    card?: boolean | CardDefaultArgs<ExtArgs>
    market?: boolean | MarketMetrics$marketArgs<ExtArgs>
  }

  export type $MarketMetricsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MarketMetrics"
    objects: {
      card: Prisma.$CardPayload<ExtArgs>
      market: Prisma.$BettingMarketPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cardId: string
      marketId: string | null
      revenue: number | null
      userGrowth: number | null
      valuation: number | null
      marketCap: number | null
      quarterlyGrowth: number | null
      userEngagement: number | null
      productLaunches: number | null
      competitorRank: number | null
      sentimentScore: number | null
      trendingScore: number | null
      socialMentions: number | null
      recordDate: Date
      dataSource: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["marketMetrics"]>
    composites: {}
  }

  type MarketMetricsGetPayload<S extends boolean | null | undefined | MarketMetricsDefaultArgs> = $Result.GetResult<Prisma.$MarketMetricsPayload, S>

  type MarketMetricsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MarketMetricsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MarketMetricsCountAggregateInputType | true
    }

  export interface MarketMetricsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MarketMetrics'], meta: { name: 'MarketMetrics' } }
    /**
     * Find zero or one MarketMetrics that matches the filter.
     * @param {MarketMetricsFindUniqueArgs} args - Arguments to find a MarketMetrics
     * @example
     * // Get one MarketMetrics
     * const marketMetrics = await prisma.marketMetrics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MarketMetricsFindUniqueArgs>(args: SelectSubset<T, MarketMetricsFindUniqueArgs<ExtArgs>>): Prisma__MarketMetricsClient<$Result.GetResult<Prisma.$MarketMetricsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MarketMetrics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MarketMetricsFindUniqueOrThrowArgs} args - Arguments to find a MarketMetrics
     * @example
     * // Get one MarketMetrics
     * const marketMetrics = await prisma.marketMetrics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MarketMetricsFindUniqueOrThrowArgs>(args: SelectSubset<T, MarketMetricsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MarketMetricsClient<$Result.GetResult<Prisma.$MarketMetricsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MarketMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketMetricsFindFirstArgs} args - Arguments to find a MarketMetrics
     * @example
     * // Get one MarketMetrics
     * const marketMetrics = await prisma.marketMetrics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MarketMetricsFindFirstArgs>(args?: SelectSubset<T, MarketMetricsFindFirstArgs<ExtArgs>>): Prisma__MarketMetricsClient<$Result.GetResult<Prisma.$MarketMetricsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MarketMetrics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketMetricsFindFirstOrThrowArgs} args - Arguments to find a MarketMetrics
     * @example
     * // Get one MarketMetrics
     * const marketMetrics = await prisma.marketMetrics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MarketMetricsFindFirstOrThrowArgs>(args?: SelectSubset<T, MarketMetricsFindFirstOrThrowArgs<ExtArgs>>): Prisma__MarketMetricsClient<$Result.GetResult<Prisma.$MarketMetricsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MarketMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketMetricsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MarketMetrics
     * const marketMetrics = await prisma.marketMetrics.findMany()
     * 
     * // Get first 10 MarketMetrics
     * const marketMetrics = await prisma.marketMetrics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const marketMetricsWithIdOnly = await prisma.marketMetrics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MarketMetricsFindManyArgs>(args?: SelectSubset<T, MarketMetricsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketMetricsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MarketMetrics.
     * @param {MarketMetricsCreateArgs} args - Arguments to create a MarketMetrics.
     * @example
     * // Create one MarketMetrics
     * const MarketMetrics = await prisma.marketMetrics.create({
     *   data: {
     *     // ... data to create a MarketMetrics
     *   }
     * })
     * 
     */
    create<T extends MarketMetricsCreateArgs>(args: SelectSubset<T, MarketMetricsCreateArgs<ExtArgs>>): Prisma__MarketMetricsClient<$Result.GetResult<Prisma.$MarketMetricsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MarketMetrics.
     * @param {MarketMetricsCreateManyArgs} args - Arguments to create many MarketMetrics.
     * @example
     * // Create many MarketMetrics
     * const marketMetrics = await prisma.marketMetrics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MarketMetricsCreateManyArgs>(args?: SelectSubset<T, MarketMetricsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MarketMetrics and returns the data saved in the database.
     * @param {MarketMetricsCreateManyAndReturnArgs} args - Arguments to create many MarketMetrics.
     * @example
     * // Create many MarketMetrics
     * const marketMetrics = await prisma.marketMetrics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MarketMetrics and only return the `id`
     * const marketMetricsWithIdOnly = await prisma.marketMetrics.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MarketMetricsCreateManyAndReturnArgs>(args?: SelectSubset<T, MarketMetricsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketMetricsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MarketMetrics.
     * @param {MarketMetricsDeleteArgs} args - Arguments to delete one MarketMetrics.
     * @example
     * // Delete one MarketMetrics
     * const MarketMetrics = await prisma.marketMetrics.delete({
     *   where: {
     *     // ... filter to delete one MarketMetrics
     *   }
     * })
     * 
     */
    delete<T extends MarketMetricsDeleteArgs>(args: SelectSubset<T, MarketMetricsDeleteArgs<ExtArgs>>): Prisma__MarketMetricsClient<$Result.GetResult<Prisma.$MarketMetricsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MarketMetrics.
     * @param {MarketMetricsUpdateArgs} args - Arguments to update one MarketMetrics.
     * @example
     * // Update one MarketMetrics
     * const marketMetrics = await prisma.marketMetrics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MarketMetricsUpdateArgs>(args: SelectSubset<T, MarketMetricsUpdateArgs<ExtArgs>>): Prisma__MarketMetricsClient<$Result.GetResult<Prisma.$MarketMetricsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MarketMetrics.
     * @param {MarketMetricsDeleteManyArgs} args - Arguments to filter MarketMetrics to delete.
     * @example
     * // Delete a few MarketMetrics
     * const { count } = await prisma.marketMetrics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MarketMetricsDeleteManyArgs>(args?: SelectSubset<T, MarketMetricsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarketMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketMetricsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MarketMetrics
     * const marketMetrics = await prisma.marketMetrics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MarketMetricsUpdateManyArgs>(args: SelectSubset<T, MarketMetricsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarketMetrics and returns the data updated in the database.
     * @param {MarketMetricsUpdateManyAndReturnArgs} args - Arguments to update many MarketMetrics.
     * @example
     * // Update many MarketMetrics
     * const marketMetrics = await prisma.marketMetrics.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MarketMetrics and only return the `id`
     * const marketMetricsWithIdOnly = await prisma.marketMetrics.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MarketMetricsUpdateManyAndReturnArgs>(args: SelectSubset<T, MarketMetricsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketMetricsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MarketMetrics.
     * @param {MarketMetricsUpsertArgs} args - Arguments to update or create a MarketMetrics.
     * @example
     * // Update or create a MarketMetrics
     * const marketMetrics = await prisma.marketMetrics.upsert({
     *   create: {
     *     // ... data to create a MarketMetrics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MarketMetrics we want to update
     *   }
     * })
     */
    upsert<T extends MarketMetricsUpsertArgs>(args: SelectSubset<T, MarketMetricsUpsertArgs<ExtArgs>>): Prisma__MarketMetricsClient<$Result.GetResult<Prisma.$MarketMetricsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MarketMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketMetricsCountArgs} args - Arguments to filter MarketMetrics to count.
     * @example
     * // Count the number of MarketMetrics
     * const count = await prisma.marketMetrics.count({
     *   where: {
     *     // ... the filter for the MarketMetrics we want to count
     *   }
     * })
    **/
    count<T extends MarketMetricsCountArgs>(
      args?: Subset<T, MarketMetricsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarketMetricsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MarketMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketMetricsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MarketMetricsAggregateArgs>(args: Subset<T, MarketMetricsAggregateArgs>): Prisma.PrismaPromise<GetMarketMetricsAggregateType<T>>

    /**
     * Group by MarketMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketMetricsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MarketMetricsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MarketMetricsGroupByArgs['orderBy'] }
        : { orderBy?: MarketMetricsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MarketMetricsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarketMetricsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MarketMetrics model
   */
  readonly fields: MarketMetricsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MarketMetrics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MarketMetricsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    card<T extends CardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CardDefaultArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    market<T extends MarketMetrics$marketArgs<ExtArgs> = {}>(args?: Subset<T, MarketMetrics$marketArgs<ExtArgs>>): Prisma__BettingMarketClient<$Result.GetResult<Prisma.$BettingMarketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MarketMetrics model
   */
  interface MarketMetricsFieldRefs {
    readonly id: FieldRef<"MarketMetrics", 'String'>
    readonly cardId: FieldRef<"MarketMetrics", 'String'>
    readonly marketId: FieldRef<"MarketMetrics", 'String'>
    readonly revenue: FieldRef<"MarketMetrics", 'Float'>
    readonly userGrowth: FieldRef<"MarketMetrics", 'Float'>
    readonly valuation: FieldRef<"MarketMetrics", 'Float'>
    readonly marketCap: FieldRef<"MarketMetrics", 'Float'>
    readonly quarterlyGrowth: FieldRef<"MarketMetrics", 'Float'>
    readonly userEngagement: FieldRef<"MarketMetrics", 'Float'>
    readonly productLaunches: FieldRef<"MarketMetrics", 'Int'>
    readonly competitorRank: FieldRef<"MarketMetrics", 'Int'>
    readonly sentimentScore: FieldRef<"MarketMetrics", 'Float'>
    readonly trendingScore: FieldRef<"MarketMetrics", 'Float'>
    readonly socialMentions: FieldRef<"MarketMetrics", 'Int'>
    readonly recordDate: FieldRef<"MarketMetrics", 'DateTime'>
    readonly dataSource: FieldRef<"MarketMetrics", 'String'>
    readonly createdAt: FieldRef<"MarketMetrics", 'DateTime'>
    readonly updatedAt: FieldRef<"MarketMetrics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MarketMetrics findUnique
   */
  export type MarketMetricsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketMetrics
     */
    select?: MarketMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketMetrics
     */
    omit?: MarketMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketMetricsInclude<ExtArgs> | null
    /**
     * Filter, which MarketMetrics to fetch.
     */
    where: MarketMetricsWhereUniqueInput
  }

  /**
   * MarketMetrics findUniqueOrThrow
   */
  export type MarketMetricsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketMetrics
     */
    select?: MarketMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketMetrics
     */
    omit?: MarketMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketMetricsInclude<ExtArgs> | null
    /**
     * Filter, which MarketMetrics to fetch.
     */
    where: MarketMetricsWhereUniqueInput
  }

  /**
   * MarketMetrics findFirst
   */
  export type MarketMetricsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketMetrics
     */
    select?: MarketMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketMetrics
     */
    omit?: MarketMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketMetricsInclude<ExtArgs> | null
    /**
     * Filter, which MarketMetrics to fetch.
     */
    where?: MarketMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketMetrics to fetch.
     */
    orderBy?: MarketMetricsOrderByWithRelationInput | MarketMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketMetrics.
     */
    cursor?: MarketMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketMetrics.
     */
    distinct?: MarketMetricsScalarFieldEnum | MarketMetricsScalarFieldEnum[]
  }

  /**
   * MarketMetrics findFirstOrThrow
   */
  export type MarketMetricsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketMetrics
     */
    select?: MarketMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketMetrics
     */
    omit?: MarketMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketMetricsInclude<ExtArgs> | null
    /**
     * Filter, which MarketMetrics to fetch.
     */
    where?: MarketMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketMetrics to fetch.
     */
    orderBy?: MarketMetricsOrderByWithRelationInput | MarketMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketMetrics.
     */
    cursor?: MarketMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketMetrics.
     */
    distinct?: MarketMetricsScalarFieldEnum | MarketMetricsScalarFieldEnum[]
  }

  /**
   * MarketMetrics findMany
   */
  export type MarketMetricsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketMetrics
     */
    select?: MarketMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketMetrics
     */
    omit?: MarketMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketMetricsInclude<ExtArgs> | null
    /**
     * Filter, which MarketMetrics to fetch.
     */
    where?: MarketMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketMetrics to fetch.
     */
    orderBy?: MarketMetricsOrderByWithRelationInput | MarketMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MarketMetrics.
     */
    cursor?: MarketMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketMetrics.
     */
    skip?: number
    distinct?: MarketMetricsScalarFieldEnum | MarketMetricsScalarFieldEnum[]
  }

  /**
   * MarketMetrics create
   */
  export type MarketMetricsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketMetrics
     */
    select?: MarketMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketMetrics
     */
    omit?: MarketMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketMetricsInclude<ExtArgs> | null
    /**
     * The data needed to create a MarketMetrics.
     */
    data: XOR<MarketMetricsCreateInput, MarketMetricsUncheckedCreateInput>
  }

  /**
   * MarketMetrics createMany
   */
  export type MarketMetricsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MarketMetrics.
     */
    data: MarketMetricsCreateManyInput | MarketMetricsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MarketMetrics createManyAndReturn
   */
  export type MarketMetricsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketMetrics
     */
    select?: MarketMetricsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MarketMetrics
     */
    omit?: MarketMetricsOmit<ExtArgs> | null
    /**
     * The data used to create many MarketMetrics.
     */
    data: MarketMetricsCreateManyInput | MarketMetricsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketMetricsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MarketMetrics update
   */
  export type MarketMetricsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketMetrics
     */
    select?: MarketMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketMetrics
     */
    omit?: MarketMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketMetricsInclude<ExtArgs> | null
    /**
     * The data needed to update a MarketMetrics.
     */
    data: XOR<MarketMetricsUpdateInput, MarketMetricsUncheckedUpdateInput>
    /**
     * Choose, which MarketMetrics to update.
     */
    where: MarketMetricsWhereUniqueInput
  }

  /**
   * MarketMetrics updateMany
   */
  export type MarketMetricsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MarketMetrics.
     */
    data: XOR<MarketMetricsUpdateManyMutationInput, MarketMetricsUncheckedUpdateManyInput>
    /**
     * Filter which MarketMetrics to update
     */
    where?: MarketMetricsWhereInput
    /**
     * Limit how many MarketMetrics to update.
     */
    limit?: number
  }

  /**
   * MarketMetrics updateManyAndReturn
   */
  export type MarketMetricsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketMetrics
     */
    select?: MarketMetricsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MarketMetrics
     */
    omit?: MarketMetricsOmit<ExtArgs> | null
    /**
     * The data used to update MarketMetrics.
     */
    data: XOR<MarketMetricsUpdateManyMutationInput, MarketMetricsUncheckedUpdateManyInput>
    /**
     * Filter which MarketMetrics to update
     */
    where?: MarketMetricsWhereInput
    /**
     * Limit how many MarketMetrics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketMetricsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MarketMetrics upsert
   */
  export type MarketMetricsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketMetrics
     */
    select?: MarketMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketMetrics
     */
    omit?: MarketMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketMetricsInclude<ExtArgs> | null
    /**
     * The filter to search for the MarketMetrics to update in case it exists.
     */
    where: MarketMetricsWhereUniqueInput
    /**
     * In case the MarketMetrics found by the `where` argument doesn't exist, create a new MarketMetrics with this data.
     */
    create: XOR<MarketMetricsCreateInput, MarketMetricsUncheckedCreateInput>
    /**
     * In case the MarketMetrics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MarketMetricsUpdateInput, MarketMetricsUncheckedUpdateInput>
  }

  /**
   * MarketMetrics delete
   */
  export type MarketMetricsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketMetrics
     */
    select?: MarketMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketMetrics
     */
    omit?: MarketMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketMetricsInclude<ExtArgs> | null
    /**
     * Filter which MarketMetrics to delete.
     */
    where: MarketMetricsWhereUniqueInput
  }

  /**
   * MarketMetrics deleteMany
   */
  export type MarketMetricsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketMetrics to delete
     */
    where?: MarketMetricsWhereInput
    /**
     * Limit how many MarketMetrics to delete.
     */
    limit?: number
  }

  /**
   * MarketMetrics.market
   */
  export type MarketMetrics$marketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BettingMarket
     */
    select?: BettingMarketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BettingMarket
     */
    omit?: BettingMarketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BettingMarketInclude<ExtArgs> | null
    where?: BettingMarketWhereInput
  }

  /**
   * MarketMetrics without action
   */
  export type MarketMetricsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketMetrics
     */
    select?: MarketMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketMetrics
     */
    omit?: MarketMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketMetricsInclude<ExtArgs> | null
  }


  /**
   * Model BettingPayout
   */

  export type AggregateBettingPayout = {
    _count: BettingPayoutCountAggregateOutputType | null
    _avg: BettingPayoutAvgAggregateOutputType | null
    _sum: BettingPayoutSumAggregateOutputType | null
    _min: BettingPayoutMinAggregateOutputType | null
    _max: BettingPayoutMaxAggregateOutputType | null
  }

  export type BettingPayoutAvgAggregateOutputType = {
    winnings: number | null
    originalBet: number | null
    multiplier: number | null
  }

  export type BettingPayoutSumAggregateOutputType = {
    winnings: number | null
    originalBet: number | null
    multiplier: number | null
  }

  export type BettingPayoutMinAggregateOutputType = {
    id: string | null
    marketId: string | null
    userId: string | null
    positionId: string | null
    winnings: number | null
    originalBet: number | null
    multiplier: number | null
    status: $Enums.PayoutStatus | null
    payoutDate: Date | null
    transactionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BettingPayoutMaxAggregateOutputType = {
    id: string | null
    marketId: string | null
    userId: string | null
    positionId: string | null
    winnings: number | null
    originalBet: number | null
    multiplier: number | null
    status: $Enums.PayoutStatus | null
    payoutDate: Date | null
    transactionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BettingPayoutCountAggregateOutputType = {
    id: number
    marketId: number
    userId: number
    positionId: number
    winnings: number
    originalBet: number
    multiplier: number
    status: number
    payoutDate: number
    transactionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BettingPayoutAvgAggregateInputType = {
    winnings?: true
    originalBet?: true
    multiplier?: true
  }

  export type BettingPayoutSumAggregateInputType = {
    winnings?: true
    originalBet?: true
    multiplier?: true
  }

  export type BettingPayoutMinAggregateInputType = {
    id?: true
    marketId?: true
    userId?: true
    positionId?: true
    winnings?: true
    originalBet?: true
    multiplier?: true
    status?: true
    payoutDate?: true
    transactionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BettingPayoutMaxAggregateInputType = {
    id?: true
    marketId?: true
    userId?: true
    positionId?: true
    winnings?: true
    originalBet?: true
    multiplier?: true
    status?: true
    payoutDate?: true
    transactionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BettingPayoutCountAggregateInputType = {
    id?: true
    marketId?: true
    userId?: true
    positionId?: true
    winnings?: true
    originalBet?: true
    multiplier?: true
    status?: true
    payoutDate?: true
    transactionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BettingPayoutAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BettingPayout to aggregate.
     */
    where?: BettingPayoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BettingPayouts to fetch.
     */
    orderBy?: BettingPayoutOrderByWithRelationInput | BettingPayoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BettingPayoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BettingPayouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BettingPayouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BettingPayouts
    **/
    _count?: true | BettingPayoutCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BettingPayoutAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BettingPayoutSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BettingPayoutMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BettingPayoutMaxAggregateInputType
  }

  export type GetBettingPayoutAggregateType<T extends BettingPayoutAggregateArgs> = {
        [P in keyof T & keyof AggregateBettingPayout]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBettingPayout[P]>
      : GetScalarType<T[P], AggregateBettingPayout[P]>
  }




  export type BettingPayoutGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BettingPayoutWhereInput
    orderBy?: BettingPayoutOrderByWithAggregationInput | BettingPayoutOrderByWithAggregationInput[]
    by: BettingPayoutScalarFieldEnum[] | BettingPayoutScalarFieldEnum
    having?: BettingPayoutScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BettingPayoutCountAggregateInputType | true
    _avg?: BettingPayoutAvgAggregateInputType
    _sum?: BettingPayoutSumAggregateInputType
    _min?: BettingPayoutMinAggregateInputType
    _max?: BettingPayoutMaxAggregateInputType
  }

  export type BettingPayoutGroupByOutputType = {
    id: string
    marketId: string
    userId: string
    positionId: string
    winnings: number
    originalBet: number
    multiplier: number
    status: $Enums.PayoutStatus
    payoutDate: Date | null
    transactionId: string | null
    createdAt: Date
    updatedAt: Date
    _count: BettingPayoutCountAggregateOutputType | null
    _avg: BettingPayoutAvgAggregateOutputType | null
    _sum: BettingPayoutSumAggregateOutputType | null
    _min: BettingPayoutMinAggregateOutputType | null
    _max: BettingPayoutMaxAggregateOutputType | null
  }

  type GetBettingPayoutGroupByPayload<T extends BettingPayoutGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BettingPayoutGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BettingPayoutGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BettingPayoutGroupByOutputType[P]>
            : GetScalarType<T[P], BettingPayoutGroupByOutputType[P]>
        }
      >
    >


  export type BettingPayoutSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    marketId?: boolean
    userId?: boolean
    positionId?: boolean
    winnings?: boolean
    originalBet?: boolean
    multiplier?: boolean
    status?: boolean
    payoutDate?: boolean
    transactionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    market?: boolean | BettingMarketDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bettingPayout"]>

  export type BettingPayoutSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    marketId?: boolean
    userId?: boolean
    positionId?: boolean
    winnings?: boolean
    originalBet?: boolean
    multiplier?: boolean
    status?: boolean
    payoutDate?: boolean
    transactionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    market?: boolean | BettingMarketDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bettingPayout"]>

  export type BettingPayoutSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    marketId?: boolean
    userId?: boolean
    positionId?: boolean
    winnings?: boolean
    originalBet?: boolean
    multiplier?: boolean
    status?: boolean
    payoutDate?: boolean
    transactionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    market?: boolean | BettingMarketDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bettingPayout"]>

  export type BettingPayoutSelectScalar = {
    id?: boolean
    marketId?: boolean
    userId?: boolean
    positionId?: boolean
    winnings?: boolean
    originalBet?: boolean
    multiplier?: boolean
    status?: boolean
    payoutDate?: boolean
    transactionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BettingPayoutOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "marketId" | "userId" | "positionId" | "winnings" | "originalBet" | "multiplier" | "status" | "payoutDate" | "transactionId" | "createdAt" | "updatedAt", ExtArgs["result"]["bettingPayout"]>
  export type BettingPayoutInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    market?: boolean | BettingMarketDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BettingPayoutIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    market?: boolean | BettingMarketDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BettingPayoutIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    market?: boolean | BettingMarketDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BettingPayoutPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BettingPayout"
    objects: {
      market: Prisma.$BettingMarketPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      marketId: string
      userId: string
      positionId: string
      winnings: number
      originalBet: number
      multiplier: number
      status: $Enums.PayoutStatus
      payoutDate: Date | null
      transactionId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bettingPayout"]>
    composites: {}
  }

  type BettingPayoutGetPayload<S extends boolean | null | undefined | BettingPayoutDefaultArgs> = $Result.GetResult<Prisma.$BettingPayoutPayload, S>

  type BettingPayoutCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BettingPayoutFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BettingPayoutCountAggregateInputType | true
    }

  export interface BettingPayoutDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BettingPayout'], meta: { name: 'BettingPayout' } }
    /**
     * Find zero or one BettingPayout that matches the filter.
     * @param {BettingPayoutFindUniqueArgs} args - Arguments to find a BettingPayout
     * @example
     * // Get one BettingPayout
     * const bettingPayout = await prisma.bettingPayout.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BettingPayoutFindUniqueArgs>(args: SelectSubset<T, BettingPayoutFindUniqueArgs<ExtArgs>>): Prisma__BettingPayoutClient<$Result.GetResult<Prisma.$BettingPayoutPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BettingPayout that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BettingPayoutFindUniqueOrThrowArgs} args - Arguments to find a BettingPayout
     * @example
     * // Get one BettingPayout
     * const bettingPayout = await prisma.bettingPayout.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BettingPayoutFindUniqueOrThrowArgs>(args: SelectSubset<T, BettingPayoutFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BettingPayoutClient<$Result.GetResult<Prisma.$BettingPayoutPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BettingPayout that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BettingPayoutFindFirstArgs} args - Arguments to find a BettingPayout
     * @example
     * // Get one BettingPayout
     * const bettingPayout = await prisma.bettingPayout.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BettingPayoutFindFirstArgs>(args?: SelectSubset<T, BettingPayoutFindFirstArgs<ExtArgs>>): Prisma__BettingPayoutClient<$Result.GetResult<Prisma.$BettingPayoutPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BettingPayout that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BettingPayoutFindFirstOrThrowArgs} args - Arguments to find a BettingPayout
     * @example
     * // Get one BettingPayout
     * const bettingPayout = await prisma.bettingPayout.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BettingPayoutFindFirstOrThrowArgs>(args?: SelectSubset<T, BettingPayoutFindFirstOrThrowArgs<ExtArgs>>): Prisma__BettingPayoutClient<$Result.GetResult<Prisma.$BettingPayoutPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BettingPayouts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BettingPayoutFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BettingPayouts
     * const bettingPayouts = await prisma.bettingPayout.findMany()
     * 
     * // Get first 10 BettingPayouts
     * const bettingPayouts = await prisma.bettingPayout.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bettingPayoutWithIdOnly = await prisma.bettingPayout.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BettingPayoutFindManyArgs>(args?: SelectSubset<T, BettingPayoutFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BettingPayoutPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BettingPayout.
     * @param {BettingPayoutCreateArgs} args - Arguments to create a BettingPayout.
     * @example
     * // Create one BettingPayout
     * const BettingPayout = await prisma.bettingPayout.create({
     *   data: {
     *     // ... data to create a BettingPayout
     *   }
     * })
     * 
     */
    create<T extends BettingPayoutCreateArgs>(args: SelectSubset<T, BettingPayoutCreateArgs<ExtArgs>>): Prisma__BettingPayoutClient<$Result.GetResult<Prisma.$BettingPayoutPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BettingPayouts.
     * @param {BettingPayoutCreateManyArgs} args - Arguments to create many BettingPayouts.
     * @example
     * // Create many BettingPayouts
     * const bettingPayout = await prisma.bettingPayout.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BettingPayoutCreateManyArgs>(args?: SelectSubset<T, BettingPayoutCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BettingPayouts and returns the data saved in the database.
     * @param {BettingPayoutCreateManyAndReturnArgs} args - Arguments to create many BettingPayouts.
     * @example
     * // Create many BettingPayouts
     * const bettingPayout = await prisma.bettingPayout.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BettingPayouts and only return the `id`
     * const bettingPayoutWithIdOnly = await prisma.bettingPayout.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BettingPayoutCreateManyAndReturnArgs>(args?: SelectSubset<T, BettingPayoutCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BettingPayoutPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BettingPayout.
     * @param {BettingPayoutDeleteArgs} args - Arguments to delete one BettingPayout.
     * @example
     * // Delete one BettingPayout
     * const BettingPayout = await prisma.bettingPayout.delete({
     *   where: {
     *     // ... filter to delete one BettingPayout
     *   }
     * })
     * 
     */
    delete<T extends BettingPayoutDeleteArgs>(args: SelectSubset<T, BettingPayoutDeleteArgs<ExtArgs>>): Prisma__BettingPayoutClient<$Result.GetResult<Prisma.$BettingPayoutPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BettingPayout.
     * @param {BettingPayoutUpdateArgs} args - Arguments to update one BettingPayout.
     * @example
     * // Update one BettingPayout
     * const bettingPayout = await prisma.bettingPayout.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BettingPayoutUpdateArgs>(args: SelectSubset<T, BettingPayoutUpdateArgs<ExtArgs>>): Prisma__BettingPayoutClient<$Result.GetResult<Prisma.$BettingPayoutPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BettingPayouts.
     * @param {BettingPayoutDeleteManyArgs} args - Arguments to filter BettingPayouts to delete.
     * @example
     * // Delete a few BettingPayouts
     * const { count } = await prisma.bettingPayout.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BettingPayoutDeleteManyArgs>(args?: SelectSubset<T, BettingPayoutDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BettingPayouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BettingPayoutUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BettingPayouts
     * const bettingPayout = await prisma.bettingPayout.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BettingPayoutUpdateManyArgs>(args: SelectSubset<T, BettingPayoutUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BettingPayouts and returns the data updated in the database.
     * @param {BettingPayoutUpdateManyAndReturnArgs} args - Arguments to update many BettingPayouts.
     * @example
     * // Update many BettingPayouts
     * const bettingPayout = await prisma.bettingPayout.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BettingPayouts and only return the `id`
     * const bettingPayoutWithIdOnly = await prisma.bettingPayout.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BettingPayoutUpdateManyAndReturnArgs>(args: SelectSubset<T, BettingPayoutUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BettingPayoutPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BettingPayout.
     * @param {BettingPayoutUpsertArgs} args - Arguments to update or create a BettingPayout.
     * @example
     * // Update or create a BettingPayout
     * const bettingPayout = await prisma.bettingPayout.upsert({
     *   create: {
     *     // ... data to create a BettingPayout
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BettingPayout we want to update
     *   }
     * })
     */
    upsert<T extends BettingPayoutUpsertArgs>(args: SelectSubset<T, BettingPayoutUpsertArgs<ExtArgs>>): Prisma__BettingPayoutClient<$Result.GetResult<Prisma.$BettingPayoutPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BettingPayouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BettingPayoutCountArgs} args - Arguments to filter BettingPayouts to count.
     * @example
     * // Count the number of BettingPayouts
     * const count = await prisma.bettingPayout.count({
     *   where: {
     *     // ... the filter for the BettingPayouts we want to count
     *   }
     * })
    **/
    count<T extends BettingPayoutCountArgs>(
      args?: Subset<T, BettingPayoutCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BettingPayoutCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BettingPayout.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BettingPayoutAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BettingPayoutAggregateArgs>(args: Subset<T, BettingPayoutAggregateArgs>): Prisma.PrismaPromise<GetBettingPayoutAggregateType<T>>

    /**
     * Group by BettingPayout.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BettingPayoutGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BettingPayoutGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BettingPayoutGroupByArgs['orderBy'] }
        : { orderBy?: BettingPayoutGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BettingPayoutGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBettingPayoutGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BettingPayout model
   */
  readonly fields: BettingPayoutFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BettingPayout.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BettingPayoutClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    market<T extends BettingMarketDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BettingMarketDefaultArgs<ExtArgs>>): Prisma__BettingMarketClient<$Result.GetResult<Prisma.$BettingMarketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BettingPayout model
   */
  interface BettingPayoutFieldRefs {
    readonly id: FieldRef<"BettingPayout", 'String'>
    readonly marketId: FieldRef<"BettingPayout", 'String'>
    readonly userId: FieldRef<"BettingPayout", 'String'>
    readonly positionId: FieldRef<"BettingPayout", 'String'>
    readonly winnings: FieldRef<"BettingPayout", 'Float'>
    readonly originalBet: FieldRef<"BettingPayout", 'Float'>
    readonly multiplier: FieldRef<"BettingPayout", 'Float'>
    readonly status: FieldRef<"BettingPayout", 'PayoutStatus'>
    readonly payoutDate: FieldRef<"BettingPayout", 'DateTime'>
    readonly transactionId: FieldRef<"BettingPayout", 'String'>
    readonly createdAt: FieldRef<"BettingPayout", 'DateTime'>
    readonly updatedAt: FieldRef<"BettingPayout", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BettingPayout findUnique
   */
  export type BettingPayoutFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BettingPayout
     */
    select?: BettingPayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BettingPayout
     */
    omit?: BettingPayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BettingPayoutInclude<ExtArgs> | null
    /**
     * Filter, which BettingPayout to fetch.
     */
    where: BettingPayoutWhereUniqueInput
  }

  /**
   * BettingPayout findUniqueOrThrow
   */
  export type BettingPayoutFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BettingPayout
     */
    select?: BettingPayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BettingPayout
     */
    omit?: BettingPayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BettingPayoutInclude<ExtArgs> | null
    /**
     * Filter, which BettingPayout to fetch.
     */
    where: BettingPayoutWhereUniqueInput
  }

  /**
   * BettingPayout findFirst
   */
  export type BettingPayoutFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BettingPayout
     */
    select?: BettingPayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BettingPayout
     */
    omit?: BettingPayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BettingPayoutInclude<ExtArgs> | null
    /**
     * Filter, which BettingPayout to fetch.
     */
    where?: BettingPayoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BettingPayouts to fetch.
     */
    orderBy?: BettingPayoutOrderByWithRelationInput | BettingPayoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BettingPayouts.
     */
    cursor?: BettingPayoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BettingPayouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BettingPayouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BettingPayouts.
     */
    distinct?: BettingPayoutScalarFieldEnum | BettingPayoutScalarFieldEnum[]
  }

  /**
   * BettingPayout findFirstOrThrow
   */
  export type BettingPayoutFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BettingPayout
     */
    select?: BettingPayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BettingPayout
     */
    omit?: BettingPayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BettingPayoutInclude<ExtArgs> | null
    /**
     * Filter, which BettingPayout to fetch.
     */
    where?: BettingPayoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BettingPayouts to fetch.
     */
    orderBy?: BettingPayoutOrderByWithRelationInput | BettingPayoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BettingPayouts.
     */
    cursor?: BettingPayoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BettingPayouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BettingPayouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BettingPayouts.
     */
    distinct?: BettingPayoutScalarFieldEnum | BettingPayoutScalarFieldEnum[]
  }

  /**
   * BettingPayout findMany
   */
  export type BettingPayoutFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BettingPayout
     */
    select?: BettingPayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BettingPayout
     */
    omit?: BettingPayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BettingPayoutInclude<ExtArgs> | null
    /**
     * Filter, which BettingPayouts to fetch.
     */
    where?: BettingPayoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BettingPayouts to fetch.
     */
    orderBy?: BettingPayoutOrderByWithRelationInput | BettingPayoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BettingPayouts.
     */
    cursor?: BettingPayoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BettingPayouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BettingPayouts.
     */
    skip?: number
    distinct?: BettingPayoutScalarFieldEnum | BettingPayoutScalarFieldEnum[]
  }

  /**
   * BettingPayout create
   */
  export type BettingPayoutCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BettingPayout
     */
    select?: BettingPayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BettingPayout
     */
    omit?: BettingPayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BettingPayoutInclude<ExtArgs> | null
    /**
     * The data needed to create a BettingPayout.
     */
    data: XOR<BettingPayoutCreateInput, BettingPayoutUncheckedCreateInput>
  }

  /**
   * BettingPayout createMany
   */
  export type BettingPayoutCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BettingPayouts.
     */
    data: BettingPayoutCreateManyInput | BettingPayoutCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BettingPayout createManyAndReturn
   */
  export type BettingPayoutCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BettingPayout
     */
    select?: BettingPayoutSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BettingPayout
     */
    omit?: BettingPayoutOmit<ExtArgs> | null
    /**
     * The data used to create many BettingPayouts.
     */
    data: BettingPayoutCreateManyInput | BettingPayoutCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BettingPayoutIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BettingPayout update
   */
  export type BettingPayoutUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BettingPayout
     */
    select?: BettingPayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BettingPayout
     */
    omit?: BettingPayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BettingPayoutInclude<ExtArgs> | null
    /**
     * The data needed to update a BettingPayout.
     */
    data: XOR<BettingPayoutUpdateInput, BettingPayoutUncheckedUpdateInput>
    /**
     * Choose, which BettingPayout to update.
     */
    where: BettingPayoutWhereUniqueInput
  }

  /**
   * BettingPayout updateMany
   */
  export type BettingPayoutUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BettingPayouts.
     */
    data: XOR<BettingPayoutUpdateManyMutationInput, BettingPayoutUncheckedUpdateManyInput>
    /**
     * Filter which BettingPayouts to update
     */
    where?: BettingPayoutWhereInput
    /**
     * Limit how many BettingPayouts to update.
     */
    limit?: number
  }

  /**
   * BettingPayout updateManyAndReturn
   */
  export type BettingPayoutUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BettingPayout
     */
    select?: BettingPayoutSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BettingPayout
     */
    omit?: BettingPayoutOmit<ExtArgs> | null
    /**
     * The data used to update BettingPayouts.
     */
    data: XOR<BettingPayoutUpdateManyMutationInput, BettingPayoutUncheckedUpdateManyInput>
    /**
     * Filter which BettingPayouts to update
     */
    where?: BettingPayoutWhereInput
    /**
     * Limit how many BettingPayouts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BettingPayoutIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BettingPayout upsert
   */
  export type BettingPayoutUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BettingPayout
     */
    select?: BettingPayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BettingPayout
     */
    omit?: BettingPayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BettingPayoutInclude<ExtArgs> | null
    /**
     * The filter to search for the BettingPayout to update in case it exists.
     */
    where: BettingPayoutWhereUniqueInput
    /**
     * In case the BettingPayout found by the `where` argument doesn't exist, create a new BettingPayout with this data.
     */
    create: XOR<BettingPayoutCreateInput, BettingPayoutUncheckedCreateInput>
    /**
     * In case the BettingPayout was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BettingPayoutUpdateInput, BettingPayoutUncheckedUpdateInput>
  }

  /**
   * BettingPayout delete
   */
  export type BettingPayoutDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BettingPayout
     */
    select?: BettingPayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BettingPayout
     */
    omit?: BettingPayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BettingPayoutInclude<ExtArgs> | null
    /**
     * Filter which BettingPayout to delete.
     */
    where: BettingPayoutWhereUniqueInput
  }

  /**
   * BettingPayout deleteMany
   */
  export type BettingPayoutDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BettingPayouts to delete
     */
    where?: BettingPayoutWhereInput
    /**
     * Limit how many BettingPayouts to delete.
     */
    limit?: number
  }

  /**
   * BettingPayout without action
   */
  export type BettingPayoutDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BettingPayout
     */
    select?: BettingPayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BettingPayout
     */
    omit?: BettingPayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BettingPayoutInclude<ExtArgs> | null
  }


  /**
   * Model CardAuction
   */

  export type AggregateCardAuction = {
    _count: CardAuctionCountAggregateOutputType | null
    _avg: CardAuctionAvgAggregateOutputType | null
    _sum: CardAuctionSumAggregateOutputType | null
    _min: CardAuctionMinAggregateOutputType | null
    _max: CardAuctionMaxAggregateOutputType | null
  }

  export type CardAuctionAvgAggregateOutputType = {
    startPrice: number | null
    reservePrice: number | null
    currentBid: number | null
    bidIncrement: number | null
    viewCount: number | null
    watcherCount: number | null
    bidCount: number | null
  }

  export type CardAuctionSumAggregateOutputType = {
    startPrice: number | null
    reservePrice: number | null
    currentBid: number | null
    bidIncrement: number | null
    viewCount: number | null
    watcherCount: number | null
    bidCount: number | null
  }

  export type CardAuctionMinAggregateOutputType = {
    id: string | null
    cardId: string | null
    ownerId: string | null
    title: string | null
    description: string | null
    startPrice: number | null
    reservePrice: number | null
    currentBid: number | null
    bidIncrement: number | null
    startTime: Date | null
    endTime: Date | null
    autoExtend: boolean | null
    status: $Enums.AuctionStatus | null
    finalized: boolean | null
    winnerId: string | null
    viewCount: number | null
    watcherCount: number | null
    bidCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CardAuctionMaxAggregateOutputType = {
    id: string | null
    cardId: string | null
    ownerId: string | null
    title: string | null
    description: string | null
    startPrice: number | null
    reservePrice: number | null
    currentBid: number | null
    bidIncrement: number | null
    startTime: Date | null
    endTime: Date | null
    autoExtend: boolean | null
    status: $Enums.AuctionStatus | null
    finalized: boolean | null
    winnerId: string | null
    viewCount: number | null
    watcherCount: number | null
    bidCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CardAuctionCountAggregateOutputType = {
    id: number
    cardId: number
    ownerId: number
    title: number
    description: number
    startPrice: number
    reservePrice: number
    currentBid: number
    bidIncrement: number
    startTime: number
    endTime: number
    autoExtend: number
    status: number
    finalized: number
    winnerId: number
    viewCount: number
    watcherCount: number
    bidCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CardAuctionAvgAggregateInputType = {
    startPrice?: true
    reservePrice?: true
    currentBid?: true
    bidIncrement?: true
    viewCount?: true
    watcherCount?: true
    bidCount?: true
  }

  export type CardAuctionSumAggregateInputType = {
    startPrice?: true
    reservePrice?: true
    currentBid?: true
    bidIncrement?: true
    viewCount?: true
    watcherCount?: true
    bidCount?: true
  }

  export type CardAuctionMinAggregateInputType = {
    id?: true
    cardId?: true
    ownerId?: true
    title?: true
    description?: true
    startPrice?: true
    reservePrice?: true
    currentBid?: true
    bidIncrement?: true
    startTime?: true
    endTime?: true
    autoExtend?: true
    status?: true
    finalized?: true
    winnerId?: true
    viewCount?: true
    watcherCount?: true
    bidCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CardAuctionMaxAggregateInputType = {
    id?: true
    cardId?: true
    ownerId?: true
    title?: true
    description?: true
    startPrice?: true
    reservePrice?: true
    currentBid?: true
    bidIncrement?: true
    startTime?: true
    endTime?: true
    autoExtend?: true
    status?: true
    finalized?: true
    winnerId?: true
    viewCount?: true
    watcherCount?: true
    bidCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CardAuctionCountAggregateInputType = {
    id?: true
    cardId?: true
    ownerId?: true
    title?: true
    description?: true
    startPrice?: true
    reservePrice?: true
    currentBid?: true
    bidIncrement?: true
    startTime?: true
    endTime?: true
    autoExtend?: true
    status?: true
    finalized?: true
    winnerId?: true
    viewCount?: true
    watcherCount?: true
    bidCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CardAuctionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CardAuction to aggregate.
     */
    where?: CardAuctionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CardAuctions to fetch.
     */
    orderBy?: CardAuctionOrderByWithRelationInput | CardAuctionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CardAuctionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CardAuctions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CardAuctions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CardAuctions
    **/
    _count?: true | CardAuctionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CardAuctionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CardAuctionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CardAuctionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CardAuctionMaxAggregateInputType
  }

  export type GetCardAuctionAggregateType<T extends CardAuctionAggregateArgs> = {
        [P in keyof T & keyof AggregateCardAuction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCardAuction[P]>
      : GetScalarType<T[P], AggregateCardAuction[P]>
  }




  export type CardAuctionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CardAuctionWhereInput
    orderBy?: CardAuctionOrderByWithAggregationInput | CardAuctionOrderByWithAggregationInput[]
    by: CardAuctionScalarFieldEnum[] | CardAuctionScalarFieldEnum
    having?: CardAuctionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CardAuctionCountAggregateInputType | true
    _avg?: CardAuctionAvgAggregateInputType
    _sum?: CardAuctionSumAggregateInputType
    _min?: CardAuctionMinAggregateInputType
    _max?: CardAuctionMaxAggregateInputType
  }

  export type CardAuctionGroupByOutputType = {
    id: string
    cardId: string
    ownerId: string
    title: string
    description: string | null
    startPrice: number
    reservePrice: number | null
    currentBid: number | null
    bidIncrement: number
    startTime: Date
    endTime: Date
    autoExtend: boolean
    status: $Enums.AuctionStatus
    finalized: boolean
    winnerId: string | null
    viewCount: number
    watcherCount: number
    bidCount: number
    createdAt: Date
    updatedAt: Date
    _count: CardAuctionCountAggregateOutputType | null
    _avg: CardAuctionAvgAggregateOutputType | null
    _sum: CardAuctionSumAggregateOutputType | null
    _min: CardAuctionMinAggregateOutputType | null
    _max: CardAuctionMaxAggregateOutputType | null
  }

  type GetCardAuctionGroupByPayload<T extends CardAuctionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CardAuctionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CardAuctionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CardAuctionGroupByOutputType[P]>
            : GetScalarType<T[P], CardAuctionGroupByOutputType[P]>
        }
      >
    >


  export type CardAuctionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cardId?: boolean
    ownerId?: boolean
    title?: boolean
    description?: boolean
    startPrice?: boolean
    reservePrice?: boolean
    currentBid?: boolean
    bidIncrement?: boolean
    startTime?: boolean
    endTime?: boolean
    autoExtend?: boolean
    status?: boolean
    finalized?: boolean
    winnerId?: boolean
    viewCount?: boolean
    watcherCount?: boolean
    bidCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    card?: boolean | CardDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    conditions?: boolean | CardAuction$conditionsArgs<ExtArgs>
    winner?: boolean | CardAuction$winnerArgs<ExtArgs>
    bids?: boolean | CardAuction$bidsArgs<ExtArgs>
    watchers?: boolean | CardAuction$watchersArgs<ExtArgs>
    history?: boolean | CardAuction$historyArgs<ExtArgs>
    _count?: boolean | CardAuctionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cardAuction"]>

  export type CardAuctionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cardId?: boolean
    ownerId?: boolean
    title?: boolean
    description?: boolean
    startPrice?: boolean
    reservePrice?: boolean
    currentBid?: boolean
    bidIncrement?: boolean
    startTime?: boolean
    endTime?: boolean
    autoExtend?: boolean
    status?: boolean
    finalized?: boolean
    winnerId?: boolean
    viewCount?: boolean
    watcherCount?: boolean
    bidCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    card?: boolean | CardDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    winner?: boolean | CardAuction$winnerArgs<ExtArgs>
  }, ExtArgs["result"]["cardAuction"]>

  export type CardAuctionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cardId?: boolean
    ownerId?: boolean
    title?: boolean
    description?: boolean
    startPrice?: boolean
    reservePrice?: boolean
    currentBid?: boolean
    bidIncrement?: boolean
    startTime?: boolean
    endTime?: boolean
    autoExtend?: boolean
    status?: boolean
    finalized?: boolean
    winnerId?: boolean
    viewCount?: boolean
    watcherCount?: boolean
    bidCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    card?: boolean | CardDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    winner?: boolean | CardAuction$winnerArgs<ExtArgs>
  }, ExtArgs["result"]["cardAuction"]>

  export type CardAuctionSelectScalar = {
    id?: boolean
    cardId?: boolean
    ownerId?: boolean
    title?: boolean
    description?: boolean
    startPrice?: boolean
    reservePrice?: boolean
    currentBid?: boolean
    bidIncrement?: boolean
    startTime?: boolean
    endTime?: boolean
    autoExtend?: boolean
    status?: boolean
    finalized?: boolean
    winnerId?: boolean
    viewCount?: boolean
    watcherCount?: boolean
    bidCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CardAuctionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cardId" | "ownerId" | "title" | "description" | "startPrice" | "reservePrice" | "currentBid" | "bidIncrement" | "startTime" | "endTime" | "autoExtend" | "status" | "finalized" | "winnerId" | "viewCount" | "watcherCount" | "bidCount" | "createdAt" | "updatedAt", ExtArgs["result"]["cardAuction"]>
  export type CardAuctionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    card?: boolean | CardDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    conditions?: boolean | CardAuction$conditionsArgs<ExtArgs>
    winner?: boolean | CardAuction$winnerArgs<ExtArgs>
    bids?: boolean | CardAuction$bidsArgs<ExtArgs>
    watchers?: boolean | CardAuction$watchersArgs<ExtArgs>
    history?: boolean | CardAuction$historyArgs<ExtArgs>
    _count?: boolean | CardAuctionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CardAuctionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    card?: boolean | CardDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    winner?: boolean | CardAuction$winnerArgs<ExtArgs>
  }
  export type CardAuctionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    card?: boolean | CardDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    winner?: boolean | CardAuction$winnerArgs<ExtArgs>
  }

  export type $CardAuctionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CardAuction"
    objects: {
      card: Prisma.$CardPayload<ExtArgs>
      owner: Prisma.$UserPayload<ExtArgs>
      conditions: Prisma.$AuctionConditionsPayload<ExtArgs> | null
      winner: Prisma.$UserPayload<ExtArgs> | null
      bids: Prisma.$AuctionBidPayload<ExtArgs>[]
      watchers: Prisma.$AuctionWatcherPayload<ExtArgs>[]
      history: Prisma.$AuctionHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cardId: string
      ownerId: string
      title: string
      description: string | null
      startPrice: number
      reservePrice: number | null
      currentBid: number | null
      bidIncrement: number
      startTime: Date
      endTime: Date
      autoExtend: boolean
      status: $Enums.AuctionStatus
      finalized: boolean
      winnerId: string | null
      viewCount: number
      watcherCount: number
      bidCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cardAuction"]>
    composites: {}
  }

  type CardAuctionGetPayload<S extends boolean | null | undefined | CardAuctionDefaultArgs> = $Result.GetResult<Prisma.$CardAuctionPayload, S>

  type CardAuctionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CardAuctionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CardAuctionCountAggregateInputType | true
    }

  export interface CardAuctionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CardAuction'], meta: { name: 'CardAuction' } }
    /**
     * Find zero or one CardAuction that matches the filter.
     * @param {CardAuctionFindUniqueArgs} args - Arguments to find a CardAuction
     * @example
     * // Get one CardAuction
     * const cardAuction = await prisma.cardAuction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CardAuctionFindUniqueArgs>(args: SelectSubset<T, CardAuctionFindUniqueArgs<ExtArgs>>): Prisma__CardAuctionClient<$Result.GetResult<Prisma.$CardAuctionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CardAuction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CardAuctionFindUniqueOrThrowArgs} args - Arguments to find a CardAuction
     * @example
     * // Get one CardAuction
     * const cardAuction = await prisma.cardAuction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CardAuctionFindUniqueOrThrowArgs>(args: SelectSubset<T, CardAuctionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CardAuctionClient<$Result.GetResult<Prisma.$CardAuctionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CardAuction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardAuctionFindFirstArgs} args - Arguments to find a CardAuction
     * @example
     * // Get one CardAuction
     * const cardAuction = await prisma.cardAuction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CardAuctionFindFirstArgs>(args?: SelectSubset<T, CardAuctionFindFirstArgs<ExtArgs>>): Prisma__CardAuctionClient<$Result.GetResult<Prisma.$CardAuctionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CardAuction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardAuctionFindFirstOrThrowArgs} args - Arguments to find a CardAuction
     * @example
     * // Get one CardAuction
     * const cardAuction = await prisma.cardAuction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CardAuctionFindFirstOrThrowArgs>(args?: SelectSubset<T, CardAuctionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CardAuctionClient<$Result.GetResult<Prisma.$CardAuctionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CardAuctions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardAuctionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CardAuctions
     * const cardAuctions = await prisma.cardAuction.findMany()
     * 
     * // Get first 10 CardAuctions
     * const cardAuctions = await prisma.cardAuction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cardAuctionWithIdOnly = await prisma.cardAuction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CardAuctionFindManyArgs>(args?: SelectSubset<T, CardAuctionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CardAuctionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CardAuction.
     * @param {CardAuctionCreateArgs} args - Arguments to create a CardAuction.
     * @example
     * // Create one CardAuction
     * const CardAuction = await prisma.cardAuction.create({
     *   data: {
     *     // ... data to create a CardAuction
     *   }
     * })
     * 
     */
    create<T extends CardAuctionCreateArgs>(args: SelectSubset<T, CardAuctionCreateArgs<ExtArgs>>): Prisma__CardAuctionClient<$Result.GetResult<Prisma.$CardAuctionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CardAuctions.
     * @param {CardAuctionCreateManyArgs} args - Arguments to create many CardAuctions.
     * @example
     * // Create many CardAuctions
     * const cardAuction = await prisma.cardAuction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CardAuctionCreateManyArgs>(args?: SelectSubset<T, CardAuctionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CardAuctions and returns the data saved in the database.
     * @param {CardAuctionCreateManyAndReturnArgs} args - Arguments to create many CardAuctions.
     * @example
     * // Create many CardAuctions
     * const cardAuction = await prisma.cardAuction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CardAuctions and only return the `id`
     * const cardAuctionWithIdOnly = await prisma.cardAuction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CardAuctionCreateManyAndReturnArgs>(args?: SelectSubset<T, CardAuctionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CardAuctionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CardAuction.
     * @param {CardAuctionDeleteArgs} args - Arguments to delete one CardAuction.
     * @example
     * // Delete one CardAuction
     * const CardAuction = await prisma.cardAuction.delete({
     *   where: {
     *     // ... filter to delete one CardAuction
     *   }
     * })
     * 
     */
    delete<T extends CardAuctionDeleteArgs>(args: SelectSubset<T, CardAuctionDeleteArgs<ExtArgs>>): Prisma__CardAuctionClient<$Result.GetResult<Prisma.$CardAuctionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CardAuction.
     * @param {CardAuctionUpdateArgs} args - Arguments to update one CardAuction.
     * @example
     * // Update one CardAuction
     * const cardAuction = await prisma.cardAuction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CardAuctionUpdateArgs>(args: SelectSubset<T, CardAuctionUpdateArgs<ExtArgs>>): Prisma__CardAuctionClient<$Result.GetResult<Prisma.$CardAuctionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CardAuctions.
     * @param {CardAuctionDeleteManyArgs} args - Arguments to filter CardAuctions to delete.
     * @example
     * // Delete a few CardAuctions
     * const { count } = await prisma.cardAuction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CardAuctionDeleteManyArgs>(args?: SelectSubset<T, CardAuctionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CardAuctions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardAuctionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CardAuctions
     * const cardAuction = await prisma.cardAuction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CardAuctionUpdateManyArgs>(args: SelectSubset<T, CardAuctionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CardAuctions and returns the data updated in the database.
     * @param {CardAuctionUpdateManyAndReturnArgs} args - Arguments to update many CardAuctions.
     * @example
     * // Update many CardAuctions
     * const cardAuction = await prisma.cardAuction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CardAuctions and only return the `id`
     * const cardAuctionWithIdOnly = await prisma.cardAuction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CardAuctionUpdateManyAndReturnArgs>(args: SelectSubset<T, CardAuctionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CardAuctionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CardAuction.
     * @param {CardAuctionUpsertArgs} args - Arguments to update or create a CardAuction.
     * @example
     * // Update or create a CardAuction
     * const cardAuction = await prisma.cardAuction.upsert({
     *   create: {
     *     // ... data to create a CardAuction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CardAuction we want to update
     *   }
     * })
     */
    upsert<T extends CardAuctionUpsertArgs>(args: SelectSubset<T, CardAuctionUpsertArgs<ExtArgs>>): Prisma__CardAuctionClient<$Result.GetResult<Prisma.$CardAuctionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CardAuctions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardAuctionCountArgs} args - Arguments to filter CardAuctions to count.
     * @example
     * // Count the number of CardAuctions
     * const count = await prisma.cardAuction.count({
     *   where: {
     *     // ... the filter for the CardAuctions we want to count
     *   }
     * })
    **/
    count<T extends CardAuctionCountArgs>(
      args?: Subset<T, CardAuctionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CardAuctionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CardAuction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardAuctionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CardAuctionAggregateArgs>(args: Subset<T, CardAuctionAggregateArgs>): Prisma.PrismaPromise<GetCardAuctionAggregateType<T>>

    /**
     * Group by CardAuction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardAuctionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CardAuctionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CardAuctionGroupByArgs['orderBy'] }
        : { orderBy?: CardAuctionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CardAuctionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCardAuctionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CardAuction model
   */
  readonly fields: CardAuctionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CardAuction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CardAuctionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    card<T extends CardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CardDefaultArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    conditions<T extends CardAuction$conditionsArgs<ExtArgs> = {}>(args?: Subset<T, CardAuction$conditionsArgs<ExtArgs>>): Prisma__AuctionConditionsClient<$Result.GetResult<Prisma.$AuctionConditionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    winner<T extends CardAuction$winnerArgs<ExtArgs> = {}>(args?: Subset<T, CardAuction$winnerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    bids<T extends CardAuction$bidsArgs<ExtArgs> = {}>(args?: Subset<T, CardAuction$bidsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuctionBidPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    watchers<T extends CardAuction$watchersArgs<ExtArgs> = {}>(args?: Subset<T, CardAuction$watchersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuctionWatcherPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    history<T extends CardAuction$historyArgs<ExtArgs> = {}>(args?: Subset<T, CardAuction$historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuctionHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CardAuction model
   */
  interface CardAuctionFieldRefs {
    readonly id: FieldRef<"CardAuction", 'String'>
    readonly cardId: FieldRef<"CardAuction", 'String'>
    readonly ownerId: FieldRef<"CardAuction", 'String'>
    readonly title: FieldRef<"CardAuction", 'String'>
    readonly description: FieldRef<"CardAuction", 'String'>
    readonly startPrice: FieldRef<"CardAuction", 'Float'>
    readonly reservePrice: FieldRef<"CardAuction", 'Float'>
    readonly currentBid: FieldRef<"CardAuction", 'Float'>
    readonly bidIncrement: FieldRef<"CardAuction", 'Float'>
    readonly startTime: FieldRef<"CardAuction", 'DateTime'>
    readonly endTime: FieldRef<"CardAuction", 'DateTime'>
    readonly autoExtend: FieldRef<"CardAuction", 'Boolean'>
    readonly status: FieldRef<"CardAuction", 'AuctionStatus'>
    readonly finalized: FieldRef<"CardAuction", 'Boolean'>
    readonly winnerId: FieldRef<"CardAuction", 'String'>
    readonly viewCount: FieldRef<"CardAuction", 'Int'>
    readonly watcherCount: FieldRef<"CardAuction", 'Int'>
    readonly bidCount: FieldRef<"CardAuction", 'Int'>
    readonly createdAt: FieldRef<"CardAuction", 'DateTime'>
    readonly updatedAt: FieldRef<"CardAuction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CardAuction findUnique
   */
  export type CardAuctionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardAuction
     */
    select?: CardAuctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardAuction
     */
    omit?: CardAuctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardAuctionInclude<ExtArgs> | null
    /**
     * Filter, which CardAuction to fetch.
     */
    where: CardAuctionWhereUniqueInput
  }

  /**
   * CardAuction findUniqueOrThrow
   */
  export type CardAuctionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardAuction
     */
    select?: CardAuctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardAuction
     */
    omit?: CardAuctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardAuctionInclude<ExtArgs> | null
    /**
     * Filter, which CardAuction to fetch.
     */
    where: CardAuctionWhereUniqueInput
  }

  /**
   * CardAuction findFirst
   */
  export type CardAuctionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardAuction
     */
    select?: CardAuctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardAuction
     */
    omit?: CardAuctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardAuctionInclude<ExtArgs> | null
    /**
     * Filter, which CardAuction to fetch.
     */
    where?: CardAuctionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CardAuctions to fetch.
     */
    orderBy?: CardAuctionOrderByWithRelationInput | CardAuctionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CardAuctions.
     */
    cursor?: CardAuctionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CardAuctions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CardAuctions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CardAuctions.
     */
    distinct?: CardAuctionScalarFieldEnum | CardAuctionScalarFieldEnum[]
  }

  /**
   * CardAuction findFirstOrThrow
   */
  export type CardAuctionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardAuction
     */
    select?: CardAuctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardAuction
     */
    omit?: CardAuctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardAuctionInclude<ExtArgs> | null
    /**
     * Filter, which CardAuction to fetch.
     */
    where?: CardAuctionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CardAuctions to fetch.
     */
    orderBy?: CardAuctionOrderByWithRelationInput | CardAuctionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CardAuctions.
     */
    cursor?: CardAuctionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CardAuctions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CardAuctions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CardAuctions.
     */
    distinct?: CardAuctionScalarFieldEnum | CardAuctionScalarFieldEnum[]
  }

  /**
   * CardAuction findMany
   */
  export type CardAuctionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardAuction
     */
    select?: CardAuctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardAuction
     */
    omit?: CardAuctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardAuctionInclude<ExtArgs> | null
    /**
     * Filter, which CardAuctions to fetch.
     */
    where?: CardAuctionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CardAuctions to fetch.
     */
    orderBy?: CardAuctionOrderByWithRelationInput | CardAuctionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CardAuctions.
     */
    cursor?: CardAuctionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CardAuctions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CardAuctions.
     */
    skip?: number
    distinct?: CardAuctionScalarFieldEnum | CardAuctionScalarFieldEnum[]
  }

  /**
   * CardAuction create
   */
  export type CardAuctionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardAuction
     */
    select?: CardAuctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardAuction
     */
    omit?: CardAuctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardAuctionInclude<ExtArgs> | null
    /**
     * The data needed to create a CardAuction.
     */
    data: XOR<CardAuctionCreateInput, CardAuctionUncheckedCreateInput>
  }

  /**
   * CardAuction createMany
   */
  export type CardAuctionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CardAuctions.
     */
    data: CardAuctionCreateManyInput | CardAuctionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CardAuction createManyAndReturn
   */
  export type CardAuctionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardAuction
     */
    select?: CardAuctionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CardAuction
     */
    omit?: CardAuctionOmit<ExtArgs> | null
    /**
     * The data used to create many CardAuctions.
     */
    data: CardAuctionCreateManyInput | CardAuctionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardAuctionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CardAuction update
   */
  export type CardAuctionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardAuction
     */
    select?: CardAuctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardAuction
     */
    omit?: CardAuctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardAuctionInclude<ExtArgs> | null
    /**
     * The data needed to update a CardAuction.
     */
    data: XOR<CardAuctionUpdateInput, CardAuctionUncheckedUpdateInput>
    /**
     * Choose, which CardAuction to update.
     */
    where: CardAuctionWhereUniqueInput
  }

  /**
   * CardAuction updateMany
   */
  export type CardAuctionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CardAuctions.
     */
    data: XOR<CardAuctionUpdateManyMutationInput, CardAuctionUncheckedUpdateManyInput>
    /**
     * Filter which CardAuctions to update
     */
    where?: CardAuctionWhereInput
    /**
     * Limit how many CardAuctions to update.
     */
    limit?: number
  }

  /**
   * CardAuction updateManyAndReturn
   */
  export type CardAuctionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardAuction
     */
    select?: CardAuctionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CardAuction
     */
    omit?: CardAuctionOmit<ExtArgs> | null
    /**
     * The data used to update CardAuctions.
     */
    data: XOR<CardAuctionUpdateManyMutationInput, CardAuctionUncheckedUpdateManyInput>
    /**
     * Filter which CardAuctions to update
     */
    where?: CardAuctionWhereInput
    /**
     * Limit how many CardAuctions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardAuctionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CardAuction upsert
   */
  export type CardAuctionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardAuction
     */
    select?: CardAuctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardAuction
     */
    omit?: CardAuctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardAuctionInclude<ExtArgs> | null
    /**
     * The filter to search for the CardAuction to update in case it exists.
     */
    where: CardAuctionWhereUniqueInput
    /**
     * In case the CardAuction found by the `where` argument doesn't exist, create a new CardAuction with this data.
     */
    create: XOR<CardAuctionCreateInput, CardAuctionUncheckedCreateInput>
    /**
     * In case the CardAuction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CardAuctionUpdateInput, CardAuctionUncheckedUpdateInput>
  }

  /**
   * CardAuction delete
   */
  export type CardAuctionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardAuction
     */
    select?: CardAuctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardAuction
     */
    omit?: CardAuctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardAuctionInclude<ExtArgs> | null
    /**
     * Filter which CardAuction to delete.
     */
    where: CardAuctionWhereUniqueInput
  }

  /**
   * CardAuction deleteMany
   */
  export type CardAuctionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CardAuctions to delete
     */
    where?: CardAuctionWhereInput
    /**
     * Limit how many CardAuctions to delete.
     */
    limit?: number
  }

  /**
   * CardAuction.conditions
   */
  export type CardAuction$conditionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionConditions
     */
    select?: AuctionConditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionConditions
     */
    omit?: AuctionConditionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionConditionsInclude<ExtArgs> | null
    where?: AuctionConditionsWhereInput
  }

  /**
   * CardAuction.winner
   */
  export type CardAuction$winnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * CardAuction.bids
   */
  export type CardAuction$bidsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionBid
     */
    select?: AuctionBidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionBid
     */
    omit?: AuctionBidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionBidInclude<ExtArgs> | null
    where?: AuctionBidWhereInput
    orderBy?: AuctionBidOrderByWithRelationInput | AuctionBidOrderByWithRelationInput[]
    cursor?: AuctionBidWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuctionBidScalarFieldEnum | AuctionBidScalarFieldEnum[]
  }

  /**
   * CardAuction.watchers
   */
  export type CardAuction$watchersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionWatcher
     */
    select?: AuctionWatcherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionWatcher
     */
    omit?: AuctionWatcherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionWatcherInclude<ExtArgs> | null
    where?: AuctionWatcherWhereInput
    orderBy?: AuctionWatcherOrderByWithRelationInput | AuctionWatcherOrderByWithRelationInput[]
    cursor?: AuctionWatcherWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuctionWatcherScalarFieldEnum | AuctionWatcherScalarFieldEnum[]
  }

  /**
   * CardAuction.history
   */
  export type CardAuction$historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionHistory
     */
    select?: AuctionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionHistory
     */
    omit?: AuctionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionHistoryInclude<ExtArgs> | null
    where?: AuctionHistoryWhereInput
    orderBy?: AuctionHistoryOrderByWithRelationInput | AuctionHistoryOrderByWithRelationInput[]
    cursor?: AuctionHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuctionHistoryScalarFieldEnum | AuctionHistoryScalarFieldEnum[]
  }

  /**
   * CardAuction without action
   */
  export type CardAuctionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardAuction
     */
    select?: CardAuctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardAuction
     */
    omit?: CardAuctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardAuctionInclude<ExtArgs> | null
  }


  /**
   * Model AuctionConditions
   */

  export type AggregateAuctionConditions = {
    _count: AuctionConditionsCountAggregateOutputType | null
    _avg: AuctionConditionsAvgAggregateOutputType | null
    _sum: AuctionConditionsSumAggregateOutputType | null
    _min: AuctionConditionsMinAggregateOutputType | null
    _max: AuctionConditionsMaxAggregateOutputType | null
  }

  export type AuctionConditionsAvgAggregateOutputType = {
    minimumRating: number | null
    minimumNetWorth: number | null
    minimumPortfolioValue: number | null
    minimumCardsOwned: number | null
  }

  export type AuctionConditionsSumAggregateOutputType = {
    minimumRating: number | null
    minimumNetWorth: number | null
    minimumPortfolioValue: number | null
    minimumCardsOwned: number | null
  }

  export type AuctionConditionsMinAggregateOutputType = {
    id: string | null
    auctionId: string | null
    proMembersOnly: boolean | null
    minimumRating: number | null
    minimumNetWorth: number | null
    verificationRequired: boolean | null
    minimumPortfolioValue: number | null
    minimumCardsOwned: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuctionConditionsMaxAggregateOutputType = {
    id: string | null
    auctionId: string | null
    proMembersOnly: boolean | null
    minimumRating: number | null
    minimumNetWorth: number | null
    verificationRequired: boolean | null
    minimumPortfolioValue: number | null
    minimumCardsOwned: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuctionConditionsCountAggregateOutputType = {
    id: number
    auctionId: number
    proMembersOnly: number
    minimumRating: number
    geographicRestrictions: number
    minimumNetWorth: number
    verificationRequired: number
    minimumPortfolioValue: number
    minimumCardsOwned: number
    industryRestrictions: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AuctionConditionsAvgAggregateInputType = {
    minimumRating?: true
    minimumNetWorth?: true
    minimumPortfolioValue?: true
    minimumCardsOwned?: true
  }

  export type AuctionConditionsSumAggregateInputType = {
    minimumRating?: true
    minimumNetWorth?: true
    minimumPortfolioValue?: true
    minimumCardsOwned?: true
  }

  export type AuctionConditionsMinAggregateInputType = {
    id?: true
    auctionId?: true
    proMembersOnly?: true
    minimumRating?: true
    minimumNetWorth?: true
    verificationRequired?: true
    minimumPortfolioValue?: true
    minimumCardsOwned?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuctionConditionsMaxAggregateInputType = {
    id?: true
    auctionId?: true
    proMembersOnly?: true
    minimumRating?: true
    minimumNetWorth?: true
    verificationRequired?: true
    minimumPortfolioValue?: true
    minimumCardsOwned?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuctionConditionsCountAggregateInputType = {
    id?: true
    auctionId?: true
    proMembersOnly?: true
    minimumRating?: true
    geographicRestrictions?: true
    minimumNetWorth?: true
    verificationRequired?: true
    minimumPortfolioValue?: true
    minimumCardsOwned?: true
    industryRestrictions?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AuctionConditionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuctionConditions to aggregate.
     */
    where?: AuctionConditionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuctionConditions to fetch.
     */
    orderBy?: AuctionConditionsOrderByWithRelationInput | AuctionConditionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuctionConditionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuctionConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuctionConditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuctionConditions
    **/
    _count?: true | AuctionConditionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuctionConditionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuctionConditionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuctionConditionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuctionConditionsMaxAggregateInputType
  }

  export type GetAuctionConditionsAggregateType<T extends AuctionConditionsAggregateArgs> = {
        [P in keyof T & keyof AggregateAuctionConditions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuctionConditions[P]>
      : GetScalarType<T[P], AggregateAuctionConditions[P]>
  }




  export type AuctionConditionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuctionConditionsWhereInput
    orderBy?: AuctionConditionsOrderByWithAggregationInput | AuctionConditionsOrderByWithAggregationInput[]
    by: AuctionConditionsScalarFieldEnum[] | AuctionConditionsScalarFieldEnum
    having?: AuctionConditionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuctionConditionsCountAggregateInputType | true
    _avg?: AuctionConditionsAvgAggregateInputType
    _sum?: AuctionConditionsSumAggregateInputType
    _min?: AuctionConditionsMinAggregateInputType
    _max?: AuctionConditionsMaxAggregateInputType
  }

  export type AuctionConditionsGroupByOutputType = {
    id: string
    auctionId: string
    proMembersOnly: boolean
    minimumRating: number | null
    geographicRestrictions: string[]
    minimumNetWorth: number | null
    verificationRequired: boolean
    minimumPortfolioValue: number | null
    minimumCardsOwned: number | null
    industryRestrictions: string[]
    createdAt: Date
    updatedAt: Date
    _count: AuctionConditionsCountAggregateOutputType | null
    _avg: AuctionConditionsAvgAggregateOutputType | null
    _sum: AuctionConditionsSumAggregateOutputType | null
    _min: AuctionConditionsMinAggregateOutputType | null
    _max: AuctionConditionsMaxAggregateOutputType | null
  }

  type GetAuctionConditionsGroupByPayload<T extends AuctionConditionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuctionConditionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuctionConditionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuctionConditionsGroupByOutputType[P]>
            : GetScalarType<T[P], AuctionConditionsGroupByOutputType[P]>
        }
      >
    >


  export type AuctionConditionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auctionId?: boolean
    proMembersOnly?: boolean
    minimumRating?: boolean
    geographicRestrictions?: boolean
    minimumNetWorth?: boolean
    verificationRequired?: boolean
    minimumPortfolioValue?: boolean
    minimumCardsOwned?: boolean
    industryRestrictions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    auction?: boolean | CardAuctionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auctionConditions"]>

  export type AuctionConditionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auctionId?: boolean
    proMembersOnly?: boolean
    minimumRating?: boolean
    geographicRestrictions?: boolean
    minimumNetWorth?: boolean
    verificationRequired?: boolean
    minimumPortfolioValue?: boolean
    minimumCardsOwned?: boolean
    industryRestrictions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    auction?: boolean | CardAuctionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auctionConditions"]>

  export type AuctionConditionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auctionId?: boolean
    proMembersOnly?: boolean
    minimumRating?: boolean
    geographicRestrictions?: boolean
    minimumNetWorth?: boolean
    verificationRequired?: boolean
    minimumPortfolioValue?: boolean
    minimumCardsOwned?: boolean
    industryRestrictions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    auction?: boolean | CardAuctionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auctionConditions"]>

  export type AuctionConditionsSelectScalar = {
    id?: boolean
    auctionId?: boolean
    proMembersOnly?: boolean
    minimumRating?: boolean
    geographicRestrictions?: boolean
    minimumNetWorth?: boolean
    verificationRequired?: boolean
    minimumPortfolioValue?: boolean
    minimumCardsOwned?: boolean
    industryRestrictions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AuctionConditionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "auctionId" | "proMembersOnly" | "minimumRating" | "geographicRestrictions" | "minimumNetWorth" | "verificationRequired" | "minimumPortfolioValue" | "minimumCardsOwned" | "industryRestrictions" | "createdAt" | "updatedAt", ExtArgs["result"]["auctionConditions"]>
  export type AuctionConditionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auction?: boolean | CardAuctionDefaultArgs<ExtArgs>
  }
  export type AuctionConditionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auction?: boolean | CardAuctionDefaultArgs<ExtArgs>
  }
  export type AuctionConditionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auction?: boolean | CardAuctionDefaultArgs<ExtArgs>
  }

  export type $AuctionConditionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuctionConditions"
    objects: {
      auction: Prisma.$CardAuctionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      auctionId: string
      proMembersOnly: boolean
      minimumRating: number | null
      geographicRestrictions: string[]
      minimumNetWorth: number | null
      verificationRequired: boolean
      minimumPortfolioValue: number | null
      minimumCardsOwned: number | null
      industryRestrictions: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["auctionConditions"]>
    composites: {}
  }

  type AuctionConditionsGetPayload<S extends boolean | null | undefined | AuctionConditionsDefaultArgs> = $Result.GetResult<Prisma.$AuctionConditionsPayload, S>

  type AuctionConditionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuctionConditionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuctionConditionsCountAggregateInputType | true
    }

  export interface AuctionConditionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuctionConditions'], meta: { name: 'AuctionConditions' } }
    /**
     * Find zero or one AuctionConditions that matches the filter.
     * @param {AuctionConditionsFindUniqueArgs} args - Arguments to find a AuctionConditions
     * @example
     * // Get one AuctionConditions
     * const auctionConditions = await prisma.auctionConditions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuctionConditionsFindUniqueArgs>(args: SelectSubset<T, AuctionConditionsFindUniqueArgs<ExtArgs>>): Prisma__AuctionConditionsClient<$Result.GetResult<Prisma.$AuctionConditionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuctionConditions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuctionConditionsFindUniqueOrThrowArgs} args - Arguments to find a AuctionConditions
     * @example
     * // Get one AuctionConditions
     * const auctionConditions = await prisma.auctionConditions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuctionConditionsFindUniqueOrThrowArgs>(args: SelectSubset<T, AuctionConditionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuctionConditionsClient<$Result.GetResult<Prisma.$AuctionConditionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuctionConditions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuctionConditionsFindFirstArgs} args - Arguments to find a AuctionConditions
     * @example
     * // Get one AuctionConditions
     * const auctionConditions = await prisma.auctionConditions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuctionConditionsFindFirstArgs>(args?: SelectSubset<T, AuctionConditionsFindFirstArgs<ExtArgs>>): Prisma__AuctionConditionsClient<$Result.GetResult<Prisma.$AuctionConditionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuctionConditions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuctionConditionsFindFirstOrThrowArgs} args - Arguments to find a AuctionConditions
     * @example
     * // Get one AuctionConditions
     * const auctionConditions = await prisma.auctionConditions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuctionConditionsFindFirstOrThrowArgs>(args?: SelectSubset<T, AuctionConditionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuctionConditionsClient<$Result.GetResult<Prisma.$AuctionConditionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuctionConditions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuctionConditionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuctionConditions
     * const auctionConditions = await prisma.auctionConditions.findMany()
     * 
     * // Get first 10 AuctionConditions
     * const auctionConditions = await prisma.auctionConditions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auctionConditionsWithIdOnly = await prisma.auctionConditions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuctionConditionsFindManyArgs>(args?: SelectSubset<T, AuctionConditionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuctionConditionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuctionConditions.
     * @param {AuctionConditionsCreateArgs} args - Arguments to create a AuctionConditions.
     * @example
     * // Create one AuctionConditions
     * const AuctionConditions = await prisma.auctionConditions.create({
     *   data: {
     *     // ... data to create a AuctionConditions
     *   }
     * })
     * 
     */
    create<T extends AuctionConditionsCreateArgs>(args: SelectSubset<T, AuctionConditionsCreateArgs<ExtArgs>>): Prisma__AuctionConditionsClient<$Result.GetResult<Prisma.$AuctionConditionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuctionConditions.
     * @param {AuctionConditionsCreateManyArgs} args - Arguments to create many AuctionConditions.
     * @example
     * // Create many AuctionConditions
     * const auctionConditions = await prisma.auctionConditions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuctionConditionsCreateManyArgs>(args?: SelectSubset<T, AuctionConditionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuctionConditions and returns the data saved in the database.
     * @param {AuctionConditionsCreateManyAndReturnArgs} args - Arguments to create many AuctionConditions.
     * @example
     * // Create many AuctionConditions
     * const auctionConditions = await prisma.auctionConditions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuctionConditions and only return the `id`
     * const auctionConditionsWithIdOnly = await prisma.auctionConditions.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuctionConditionsCreateManyAndReturnArgs>(args?: SelectSubset<T, AuctionConditionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuctionConditionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuctionConditions.
     * @param {AuctionConditionsDeleteArgs} args - Arguments to delete one AuctionConditions.
     * @example
     * // Delete one AuctionConditions
     * const AuctionConditions = await prisma.auctionConditions.delete({
     *   where: {
     *     // ... filter to delete one AuctionConditions
     *   }
     * })
     * 
     */
    delete<T extends AuctionConditionsDeleteArgs>(args: SelectSubset<T, AuctionConditionsDeleteArgs<ExtArgs>>): Prisma__AuctionConditionsClient<$Result.GetResult<Prisma.$AuctionConditionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuctionConditions.
     * @param {AuctionConditionsUpdateArgs} args - Arguments to update one AuctionConditions.
     * @example
     * // Update one AuctionConditions
     * const auctionConditions = await prisma.auctionConditions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuctionConditionsUpdateArgs>(args: SelectSubset<T, AuctionConditionsUpdateArgs<ExtArgs>>): Prisma__AuctionConditionsClient<$Result.GetResult<Prisma.$AuctionConditionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuctionConditions.
     * @param {AuctionConditionsDeleteManyArgs} args - Arguments to filter AuctionConditions to delete.
     * @example
     * // Delete a few AuctionConditions
     * const { count } = await prisma.auctionConditions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuctionConditionsDeleteManyArgs>(args?: SelectSubset<T, AuctionConditionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuctionConditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuctionConditionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuctionConditions
     * const auctionConditions = await prisma.auctionConditions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuctionConditionsUpdateManyArgs>(args: SelectSubset<T, AuctionConditionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuctionConditions and returns the data updated in the database.
     * @param {AuctionConditionsUpdateManyAndReturnArgs} args - Arguments to update many AuctionConditions.
     * @example
     * // Update many AuctionConditions
     * const auctionConditions = await prisma.auctionConditions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuctionConditions and only return the `id`
     * const auctionConditionsWithIdOnly = await prisma.auctionConditions.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuctionConditionsUpdateManyAndReturnArgs>(args: SelectSubset<T, AuctionConditionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuctionConditionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuctionConditions.
     * @param {AuctionConditionsUpsertArgs} args - Arguments to update or create a AuctionConditions.
     * @example
     * // Update or create a AuctionConditions
     * const auctionConditions = await prisma.auctionConditions.upsert({
     *   create: {
     *     // ... data to create a AuctionConditions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuctionConditions we want to update
     *   }
     * })
     */
    upsert<T extends AuctionConditionsUpsertArgs>(args: SelectSubset<T, AuctionConditionsUpsertArgs<ExtArgs>>): Prisma__AuctionConditionsClient<$Result.GetResult<Prisma.$AuctionConditionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuctionConditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuctionConditionsCountArgs} args - Arguments to filter AuctionConditions to count.
     * @example
     * // Count the number of AuctionConditions
     * const count = await prisma.auctionConditions.count({
     *   where: {
     *     // ... the filter for the AuctionConditions we want to count
     *   }
     * })
    **/
    count<T extends AuctionConditionsCountArgs>(
      args?: Subset<T, AuctionConditionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuctionConditionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuctionConditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuctionConditionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuctionConditionsAggregateArgs>(args: Subset<T, AuctionConditionsAggregateArgs>): Prisma.PrismaPromise<GetAuctionConditionsAggregateType<T>>

    /**
     * Group by AuctionConditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuctionConditionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuctionConditionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuctionConditionsGroupByArgs['orderBy'] }
        : { orderBy?: AuctionConditionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuctionConditionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuctionConditionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuctionConditions model
   */
  readonly fields: AuctionConditionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuctionConditions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuctionConditionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    auction<T extends CardAuctionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CardAuctionDefaultArgs<ExtArgs>>): Prisma__CardAuctionClient<$Result.GetResult<Prisma.$CardAuctionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuctionConditions model
   */
  interface AuctionConditionsFieldRefs {
    readonly id: FieldRef<"AuctionConditions", 'String'>
    readonly auctionId: FieldRef<"AuctionConditions", 'String'>
    readonly proMembersOnly: FieldRef<"AuctionConditions", 'Boolean'>
    readonly minimumRating: FieldRef<"AuctionConditions", 'Float'>
    readonly geographicRestrictions: FieldRef<"AuctionConditions", 'String[]'>
    readonly minimumNetWorth: FieldRef<"AuctionConditions", 'Float'>
    readonly verificationRequired: FieldRef<"AuctionConditions", 'Boolean'>
    readonly minimumPortfolioValue: FieldRef<"AuctionConditions", 'Float'>
    readonly minimumCardsOwned: FieldRef<"AuctionConditions", 'Int'>
    readonly industryRestrictions: FieldRef<"AuctionConditions", 'String[]'>
    readonly createdAt: FieldRef<"AuctionConditions", 'DateTime'>
    readonly updatedAt: FieldRef<"AuctionConditions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuctionConditions findUnique
   */
  export type AuctionConditionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionConditions
     */
    select?: AuctionConditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionConditions
     */
    omit?: AuctionConditionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionConditionsInclude<ExtArgs> | null
    /**
     * Filter, which AuctionConditions to fetch.
     */
    where: AuctionConditionsWhereUniqueInput
  }

  /**
   * AuctionConditions findUniqueOrThrow
   */
  export type AuctionConditionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionConditions
     */
    select?: AuctionConditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionConditions
     */
    omit?: AuctionConditionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionConditionsInclude<ExtArgs> | null
    /**
     * Filter, which AuctionConditions to fetch.
     */
    where: AuctionConditionsWhereUniqueInput
  }

  /**
   * AuctionConditions findFirst
   */
  export type AuctionConditionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionConditions
     */
    select?: AuctionConditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionConditions
     */
    omit?: AuctionConditionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionConditionsInclude<ExtArgs> | null
    /**
     * Filter, which AuctionConditions to fetch.
     */
    where?: AuctionConditionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuctionConditions to fetch.
     */
    orderBy?: AuctionConditionsOrderByWithRelationInput | AuctionConditionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuctionConditions.
     */
    cursor?: AuctionConditionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuctionConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuctionConditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuctionConditions.
     */
    distinct?: AuctionConditionsScalarFieldEnum | AuctionConditionsScalarFieldEnum[]
  }

  /**
   * AuctionConditions findFirstOrThrow
   */
  export type AuctionConditionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionConditions
     */
    select?: AuctionConditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionConditions
     */
    omit?: AuctionConditionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionConditionsInclude<ExtArgs> | null
    /**
     * Filter, which AuctionConditions to fetch.
     */
    where?: AuctionConditionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuctionConditions to fetch.
     */
    orderBy?: AuctionConditionsOrderByWithRelationInput | AuctionConditionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuctionConditions.
     */
    cursor?: AuctionConditionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuctionConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuctionConditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuctionConditions.
     */
    distinct?: AuctionConditionsScalarFieldEnum | AuctionConditionsScalarFieldEnum[]
  }

  /**
   * AuctionConditions findMany
   */
  export type AuctionConditionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionConditions
     */
    select?: AuctionConditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionConditions
     */
    omit?: AuctionConditionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionConditionsInclude<ExtArgs> | null
    /**
     * Filter, which AuctionConditions to fetch.
     */
    where?: AuctionConditionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuctionConditions to fetch.
     */
    orderBy?: AuctionConditionsOrderByWithRelationInput | AuctionConditionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuctionConditions.
     */
    cursor?: AuctionConditionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuctionConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuctionConditions.
     */
    skip?: number
    distinct?: AuctionConditionsScalarFieldEnum | AuctionConditionsScalarFieldEnum[]
  }

  /**
   * AuctionConditions create
   */
  export type AuctionConditionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionConditions
     */
    select?: AuctionConditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionConditions
     */
    omit?: AuctionConditionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionConditionsInclude<ExtArgs> | null
    /**
     * The data needed to create a AuctionConditions.
     */
    data: XOR<AuctionConditionsCreateInput, AuctionConditionsUncheckedCreateInput>
  }

  /**
   * AuctionConditions createMany
   */
  export type AuctionConditionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuctionConditions.
     */
    data: AuctionConditionsCreateManyInput | AuctionConditionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuctionConditions createManyAndReturn
   */
  export type AuctionConditionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionConditions
     */
    select?: AuctionConditionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionConditions
     */
    omit?: AuctionConditionsOmit<ExtArgs> | null
    /**
     * The data used to create many AuctionConditions.
     */
    data: AuctionConditionsCreateManyInput | AuctionConditionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionConditionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuctionConditions update
   */
  export type AuctionConditionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionConditions
     */
    select?: AuctionConditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionConditions
     */
    omit?: AuctionConditionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionConditionsInclude<ExtArgs> | null
    /**
     * The data needed to update a AuctionConditions.
     */
    data: XOR<AuctionConditionsUpdateInput, AuctionConditionsUncheckedUpdateInput>
    /**
     * Choose, which AuctionConditions to update.
     */
    where: AuctionConditionsWhereUniqueInput
  }

  /**
   * AuctionConditions updateMany
   */
  export type AuctionConditionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuctionConditions.
     */
    data: XOR<AuctionConditionsUpdateManyMutationInput, AuctionConditionsUncheckedUpdateManyInput>
    /**
     * Filter which AuctionConditions to update
     */
    where?: AuctionConditionsWhereInput
    /**
     * Limit how many AuctionConditions to update.
     */
    limit?: number
  }

  /**
   * AuctionConditions updateManyAndReturn
   */
  export type AuctionConditionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionConditions
     */
    select?: AuctionConditionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionConditions
     */
    omit?: AuctionConditionsOmit<ExtArgs> | null
    /**
     * The data used to update AuctionConditions.
     */
    data: XOR<AuctionConditionsUpdateManyMutationInput, AuctionConditionsUncheckedUpdateManyInput>
    /**
     * Filter which AuctionConditions to update
     */
    where?: AuctionConditionsWhereInput
    /**
     * Limit how many AuctionConditions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionConditionsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuctionConditions upsert
   */
  export type AuctionConditionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionConditions
     */
    select?: AuctionConditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionConditions
     */
    omit?: AuctionConditionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionConditionsInclude<ExtArgs> | null
    /**
     * The filter to search for the AuctionConditions to update in case it exists.
     */
    where: AuctionConditionsWhereUniqueInput
    /**
     * In case the AuctionConditions found by the `where` argument doesn't exist, create a new AuctionConditions with this data.
     */
    create: XOR<AuctionConditionsCreateInput, AuctionConditionsUncheckedCreateInput>
    /**
     * In case the AuctionConditions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuctionConditionsUpdateInput, AuctionConditionsUncheckedUpdateInput>
  }

  /**
   * AuctionConditions delete
   */
  export type AuctionConditionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionConditions
     */
    select?: AuctionConditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionConditions
     */
    omit?: AuctionConditionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionConditionsInclude<ExtArgs> | null
    /**
     * Filter which AuctionConditions to delete.
     */
    where: AuctionConditionsWhereUniqueInput
  }

  /**
   * AuctionConditions deleteMany
   */
  export type AuctionConditionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuctionConditions to delete
     */
    where?: AuctionConditionsWhereInput
    /**
     * Limit how many AuctionConditions to delete.
     */
    limit?: number
  }

  /**
   * AuctionConditions without action
   */
  export type AuctionConditionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionConditions
     */
    select?: AuctionConditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionConditions
     */
    omit?: AuctionConditionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionConditionsInclude<ExtArgs> | null
  }


  /**
   * Model AuctionBid
   */

  export type AggregateAuctionBid = {
    _count: AuctionBidCountAggregateOutputType | null
    _avg: AuctionBidAvgAggregateOutputType | null
    _sum: AuctionBidSumAggregateOutputType | null
    _min: AuctionBidMinAggregateOutputType | null
    _max: AuctionBidMaxAggregateOutputType | null
  }

  export type AuctionBidAvgAggregateOutputType = {
    bidAmount: number | null
    maxAutoBid: number | null
  }

  export type AuctionBidSumAggregateOutputType = {
    bidAmount: number | null
    maxAutoBid: number | null
  }

  export type AuctionBidMinAggregateOutputType = {
    id: string | null
    auctionId: string | null
    bidderId: string | null
    bidAmount: number | null
    maxAutoBid: number | null
    bidType: $Enums.BidType | null
    status: $Enums.AuctionBidStatus | null
    isWinning: boolean | null
    outbidNotified: boolean | null
    userAgent: string | null
    ipAddress: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuctionBidMaxAggregateOutputType = {
    id: string | null
    auctionId: string | null
    bidderId: string | null
    bidAmount: number | null
    maxAutoBid: number | null
    bidType: $Enums.BidType | null
    status: $Enums.AuctionBidStatus | null
    isWinning: boolean | null
    outbidNotified: boolean | null
    userAgent: string | null
    ipAddress: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuctionBidCountAggregateOutputType = {
    id: number
    auctionId: number
    bidderId: number
    bidAmount: number
    maxAutoBid: number
    bidType: number
    status: number
    isWinning: number
    outbidNotified: number
    userAgent: number
    ipAddress: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AuctionBidAvgAggregateInputType = {
    bidAmount?: true
    maxAutoBid?: true
  }

  export type AuctionBidSumAggregateInputType = {
    bidAmount?: true
    maxAutoBid?: true
  }

  export type AuctionBidMinAggregateInputType = {
    id?: true
    auctionId?: true
    bidderId?: true
    bidAmount?: true
    maxAutoBid?: true
    bidType?: true
    status?: true
    isWinning?: true
    outbidNotified?: true
    userAgent?: true
    ipAddress?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuctionBidMaxAggregateInputType = {
    id?: true
    auctionId?: true
    bidderId?: true
    bidAmount?: true
    maxAutoBid?: true
    bidType?: true
    status?: true
    isWinning?: true
    outbidNotified?: true
    userAgent?: true
    ipAddress?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuctionBidCountAggregateInputType = {
    id?: true
    auctionId?: true
    bidderId?: true
    bidAmount?: true
    maxAutoBid?: true
    bidType?: true
    status?: true
    isWinning?: true
    outbidNotified?: true
    userAgent?: true
    ipAddress?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AuctionBidAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuctionBid to aggregate.
     */
    where?: AuctionBidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuctionBids to fetch.
     */
    orderBy?: AuctionBidOrderByWithRelationInput | AuctionBidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuctionBidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuctionBids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuctionBids.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuctionBids
    **/
    _count?: true | AuctionBidCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuctionBidAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuctionBidSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuctionBidMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuctionBidMaxAggregateInputType
  }

  export type GetAuctionBidAggregateType<T extends AuctionBidAggregateArgs> = {
        [P in keyof T & keyof AggregateAuctionBid]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuctionBid[P]>
      : GetScalarType<T[P], AggregateAuctionBid[P]>
  }




  export type AuctionBidGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuctionBidWhereInput
    orderBy?: AuctionBidOrderByWithAggregationInput | AuctionBidOrderByWithAggregationInput[]
    by: AuctionBidScalarFieldEnum[] | AuctionBidScalarFieldEnum
    having?: AuctionBidScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuctionBidCountAggregateInputType | true
    _avg?: AuctionBidAvgAggregateInputType
    _sum?: AuctionBidSumAggregateInputType
    _min?: AuctionBidMinAggregateInputType
    _max?: AuctionBidMaxAggregateInputType
  }

  export type AuctionBidGroupByOutputType = {
    id: string
    auctionId: string
    bidderId: string
    bidAmount: number
    maxAutoBid: number | null
    bidType: $Enums.BidType
    status: $Enums.AuctionBidStatus
    isWinning: boolean
    outbidNotified: boolean
    userAgent: string | null
    ipAddress: string | null
    createdAt: Date
    updatedAt: Date
    _count: AuctionBidCountAggregateOutputType | null
    _avg: AuctionBidAvgAggregateOutputType | null
    _sum: AuctionBidSumAggregateOutputType | null
    _min: AuctionBidMinAggregateOutputType | null
    _max: AuctionBidMaxAggregateOutputType | null
  }

  type GetAuctionBidGroupByPayload<T extends AuctionBidGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuctionBidGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuctionBidGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuctionBidGroupByOutputType[P]>
            : GetScalarType<T[P], AuctionBidGroupByOutputType[P]>
        }
      >
    >


  export type AuctionBidSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auctionId?: boolean
    bidderId?: boolean
    bidAmount?: boolean
    maxAutoBid?: boolean
    bidType?: boolean
    status?: boolean
    isWinning?: boolean
    outbidNotified?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    auction?: boolean | CardAuctionDefaultArgs<ExtArgs>
    bidder?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auctionBid"]>

  export type AuctionBidSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auctionId?: boolean
    bidderId?: boolean
    bidAmount?: boolean
    maxAutoBid?: boolean
    bidType?: boolean
    status?: boolean
    isWinning?: boolean
    outbidNotified?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    auction?: boolean | CardAuctionDefaultArgs<ExtArgs>
    bidder?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auctionBid"]>

  export type AuctionBidSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auctionId?: boolean
    bidderId?: boolean
    bidAmount?: boolean
    maxAutoBid?: boolean
    bidType?: boolean
    status?: boolean
    isWinning?: boolean
    outbidNotified?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    auction?: boolean | CardAuctionDefaultArgs<ExtArgs>
    bidder?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auctionBid"]>

  export type AuctionBidSelectScalar = {
    id?: boolean
    auctionId?: boolean
    bidderId?: boolean
    bidAmount?: boolean
    maxAutoBid?: boolean
    bidType?: boolean
    status?: boolean
    isWinning?: boolean
    outbidNotified?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AuctionBidOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "auctionId" | "bidderId" | "bidAmount" | "maxAutoBid" | "bidType" | "status" | "isWinning" | "outbidNotified" | "userAgent" | "ipAddress" | "createdAt" | "updatedAt", ExtArgs["result"]["auctionBid"]>
  export type AuctionBidInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auction?: boolean | CardAuctionDefaultArgs<ExtArgs>
    bidder?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuctionBidIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auction?: boolean | CardAuctionDefaultArgs<ExtArgs>
    bidder?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuctionBidIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auction?: boolean | CardAuctionDefaultArgs<ExtArgs>
    bidder?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuctionBidPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuctionBid"
    objects: {
      auction: Prisma.$CardAuctionPayload<ExtArgs>
      bidder: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      auctionId: string
      bidderId: string
      bidAmount: number
      maxAutoBid: number | null
      bidType: $Enums.BidType
      status: $Enums.AuctionBidStatus
      isWinning: boolean
      outbidNotified: boolean
      userAgent: string | null
      ipAddress: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["auctionBid"]>
    composites: {}
  }

  type AuctionBidGetPayload<S extends boolean | null | undefined | AuctionBidDefaultArgs> = $Result.GetResult<Prisma.$AuctionBidPayload, S>

  type AuctionBidCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuctionBidFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuctionBidCountAggregateInputType | true
    }

  export interface AuctionBidDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuctionBid'], meta: { name: 'AuctionBid' } }
    /**
     * Find zero or one AuctionBid that matches the filter.
     * @param {AuctionBidFindUniqueArgs} args - Arguments to find a AuctionBid
     * @example
     * // Get one AuctionBid
     * const auctionBid = await prisma.auctionBid.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuctionBidFindUniqueArgs>(args: SelectSubset<T, AuctionBidFindUniqueArgs<ExtArgs>>): Prisma__AuctionBidClient<$Result.GetResult<Prisma.$AuctionBidPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuctionBid that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuctionBidFindUniqueOrThrowArgs} args - Arguments to find a AuctionBid
     * @example
     * // Get one AuctionBid
     * const auctionBid = await prisma.auctionBid.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuctionBidFindUniqueOrThrowArgs>(args: SelectSubset<T, AuctionBidFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuctionBidClient<$Result.GetResult<Prisma.$AuctionBidPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuctionBid that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuctionBidFindFirstArgs} args - Arguments to find a AuctionBid
     * @example
     * // Get one AuctionBid
     * const auctionBid = await prisma.auctionBid.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuctionBidFindFirstArgs>(args?: SelectSubset<T, AuctionBidFindFirstArgs<ExtArgs>>): Prisma__AuctionBidClient<$Result.GetResult<Prisma.$AuctionBidPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuctionBid that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuctionBidFindFirstOrThrowArgs} args - Arguments to find a AuctionBid
     * @example
     * // Get one AuctionBid
     * const auctionBid = await prisma.auctionBid.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuctionBidFindFirstOrThrowArgs>(args?: SelectSubset<T, AuctionBidFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuctionBidClient<$Result.GetResult<Prisma.$AuctionBidPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuctionBids that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuctionBidFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuctionBids
     * const auctionBids = await prisma.auctionBid.findMany()
     * 
     * // Get first 10 AuctionBids
     * const auctionBids = await prisma.auctionBid.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auctionBidWithIdOnly = await prisma.auctionBid.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuctionBidFindManyArgs>(args?: SelectSubset<T, AuctionBidFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuctionBidPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuctionBid.
     * @param {AuctionBidCreateArgs} args - Arguments to create a AuctionBid.
     * @example
     * // Create one AuctionBid
     * const AuctionBid = await prisma.auctionBid.create({
     *   data: {
     *     // ... data to create a AuctionBid
     *   }
     * })
     * 
     */
    create<T extends AuctionBidCreateArgs>(args: SelectSubset<T, AuctionBidCreateArgs<ExtArgs>>): Prisma__AuctionBidClient<$Result.GetResult<Prisma.$AuctionBidPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuctionBids.
     * @param {AuctionBidCreateManyArgs} args - Arguments to create many AuctionBids.
     * @example
     * // Create many AuctionBids
     * const auctionBid = await prisma.auctionBid.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuctionBidCreateManyArgs>(args?: SelectSubset<T, AuctionBidCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuctionBids and returns the data saved in the database.
     * @param {AuctionBidCreateManyAndReturnArgs} args - Arguments to create many AuctionBids.
     * @example
     * // Create many AuctionBids
     * const auctionBid = await prisma.auctionBid.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuctionBids and only return the `id`
     * const auctionBidWithIdOnly = await prisma.auctionBid.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuctionBidCreateManyAndReturnArgs>(args?: SelectSubset<T, AuctionBidCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuctionBidPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuctionBid.
     * @param {AuctionBidDeleteArgs} args - Arguments to delete one AuctionBid.
     * @example
     * // Delete one AuctionBid
     * const AuctionBid = await prisma.auctionBid.delete({
     *   where: {
     *     // ... filter to delete one AuctionBid
     *   }
     * })
     * 
     */
    delete<T extends AuctionBidDeleteArgs>(args: SelectSubset<T, AuctionBidDeleteArgs<ExtArgs>>): Prisma__AuctionBidClient<$Result.GetResult<Prisma.$AuctionBidPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuctionBid.
     * @param {AuctionBidUpdateArgs} args - Arguments to update one AuctionBid.
     * @example
     * // Update one AuctionBid
     * const auctionBid = await prisma.auctionBid.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuctionBidUpdateArgs>(args: SelectSubset<T, AuctionBidUpdateArgs<ExtArgs>>): Prisma__AuctionBidClient<$Result.GetResult<Prisma.$AuctionBidPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuctionBids.
     * @param {AuctionBidDeleteManyArgs} args - Arguments to filter AuctionBids to delete.
     * @example
     * // Delete a few AuctionBids
     * const { count } = await prisma.auctionBid.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuctionBidDeleteManyArgs>(args?: SelectSubset<T, AuctionBidDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuctionBids.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuctionBidUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuctionBids
     * const auctionBid = await prisma.auctionBid.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuctionBidUpdateManyArgs>(args: SelectSubset<T, AuctionBidUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuctionBids and returns the data updated in the database.
     * @param {AuctionBidUpdateManyAndReturnArgs} args - Arguments to update many AuctionBids.
     * @example
     * // Update many AuctionBids
     * const auctionBid = await prisma.auctionBid.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuctionBids and only return the `id`
     * const auctionBidWithIdOnly = await prisma.auctionBid.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuctionBidUpdateManyAndReturnArgs>(args: SelectSubset<T, AuctionBidUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuctionBidPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuctionBid.
     * @param {AuctionBidUpsertArgs} args - Arguments to update or create a AuctionBid.
     * @example
     * // Update or create a AuctionBid
     * const auctionBid = await prisma.auctionBid.upsert({
     *   create: {
     *     // ... data to create a AuctionBid
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuctionBid we want to update
     *   }
     * })
     */
    upsert<T extends AuctionBidUpsertArgs>(args: SelectSubset<T, AuctionBidUpsertArgs<ExtArgs>>): Prisma__AuctionBidClient<$Result.GetResult<Prisma.$AuctionBidPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuctionBids.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuctionBidCountArgs} args - Arguments to filter AuctionBids to count.
     * @example
     * // Count the number of AuctionBids
     * const count = await prisma.auctionBid.count({
     *   where: {
     *     // ... the filter for the AuctionBids we want to count
     *   }
     * })
    **/
    count<T extends AuctionBidCountArgs>(
      args?: Subset<T, AuctionBidCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuctionBidCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuctionBid.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuctionBidAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuctionBidAggregateArgs>(args: Subset<T, AuctionBidAggregateArgs>): Prisma.PrismaPromise<GetAuctionBidAggregateType<T>>

    /**
     * Group by AuctionBid.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuctionBidGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuctionBidGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuctionBidGroupByArgs['orderBy'] }
        : { orderBy?: AuctionBidGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuctionBidGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuctionBidGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuctionBid model
   */
  readonly fields: AuctionBidFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuctionBid.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuctionBidClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    auction<T extends CardAuctionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CardAuctionDefaultArgs<ExtArgs>>): Prisma__CardAuctionClient<$Result.GetResult<Prisma.$CardAuctionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bidder<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuctionBid model
   */
  interface AuctionBidFieldRefs {
    readonly id: FieldRef<"AuctionBid", 'String'>
    readonly auctionId: FieldRef<"AuctionBid", 'String'>
    readonly bidderId: FieldRef<"AuctionBid", 'String'>
    readonly bidAmount: FieldRef<"AuctionBid", 'Float'>
    readonly maxAutoBid: FieldRef<"AuctionBid", 'Float'>
    readonly bidType: FieldRef<"AuctionBid", 'BidType'>
    readonly status: FieldRef<"AuctionBid", 'AuctionBidStatus'>
    readonly isWinning: FieldRef<"AuctionBid", 'Boolean'>
    readonly outbidNotified: FieldRef<"AuctionBid", 'Boolean'>
    readonly userAgent: FieldRef<"AuctionBid", 'String'>
    readonly ipAddress: FieldRef<"AuctionBid", 'String'>
    readonly createdAt: FieldRef<"AuctionBid", 'DateTime'>
    readonly updatedAt: FieldRef<"AuctionBid", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuctionBid findUnique
   */
  export type AuctionBidFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionBid
     */
    select?: AuctionBidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionBid
     */
    omit?: AuctionBidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionBidInclude<ExtArgs> | null
    /**
     * Filter, which AuctionBid to fetch.
     */
    where: AuctionBidWhereUniqueInput
  }

  /**
   * AuctionBid findUniqueOrThrow
   */
  export type AuctionBidFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionBid
     */
    select?: AuctionBidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionBid
     */
    omit?: AuctionBidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionBidInclude<ExtArgs> | null
    /**
     * Filter, which AuctionBid to fetch.
     */
    where: AuctionBidWhereUniqueInput
  }

  /**
   * AuctionBid findFirst
   */
  export type AuctionBidFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionBid
     */
    select?: AuctionBidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionBid
     */
    omit?: AuctionBidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionBidInclude<ExtArgs> | null
    /**
     * Filter, which AuctionBid to fetch.
     */
    where?: AuctionBidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuctionBids to fetch.
     */
    orderBy?: AuctionBidOrderByWithRelationInput | AuctionBidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuctionBids.
     */
    cursor?: AuctionBidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuctionBids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuctionBids.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuctionBids.
     */
    distinct?: AuctionBidScalarFieldEnum | AuctionBidScalarFieldEnum[]
  }

  /**
   * AuctionBid findFirstOrThrow
   */
  export type AuctionBidFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionBid
     */
    select?: AuctionBidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionBid
     */
    omit?: AuctionBidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionBidInclude<ExtArgs> | null
    /**
     * Filter, which AuctionBid to fetch.
     */
    where?: AuctionBidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuctionBids to fetch.
     */
    orderBy?: AuctionBidOrderByWithRelationInput | AuctionBidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuctionBids.
     */
    cursor?: AuctionBidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuctionBids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuctionBids.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuctionBids.
     */
    distinct?: AuctionBidScalarFieldEnum | AuctionBidScalarFieldEnum[]
  }

  /**
   * AuctionBid findMany
   */
  export type AuctionBidFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionBid
     */
    select?: AuctionBidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionBid
     */
    omit?: AuctionBidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionBidInclude<ExtArgs> | null
    /**
     * Filter, which AuctionBids to fetch.
     */
    where?: AuctionBidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuctionBids to fetch.
     */
    orderBy?: AuctionBidOrderByWithRelationInput | AuctionBidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuctionBids.
     */
    cursor?: AuctionBidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuctionBids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuctionBids.
     */
    skip?: number
    distinct?: AuctionBidScalarFieldEnum | AuctionBidScalarFieldEnum[]
  }

  /**
   * AuctionBid create
   */
  export type AuctionBidCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionBid
     */
    select?: AuctionBidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionBid
     */
    omit?: AuctionBidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionBidInclude<ExtArgs> | null
    /**
     * The data needed to create a AuctionBid.
     */
    data: XOR<AuctionBidCreateInput, AuctionBidUncheckedCreateInput>
  }

  /**
   * AuctionBid createMany
   */
  export type AuctionBidCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuctionBids.
     */
    data: AuctionBidCreateManyInput | AuctionBidCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuctionBid createManyAndReturn
   */
  export type AuctionBidCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionBid
     */
    select?: AuctionBidSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionBid
     */
    omit?: AuctionBidOmit<ExtArgs> | null
    /**
     * The data used to create many AuctionBids.
     */
    data: AuctionBidCreateManyInput | AuctionBidCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionBidIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuctionBid update
   */
  export type AuctionBidUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionBid
     */
    select?: AuctionBidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionBid
     */
    omit?: AuctionBidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionBidInclude<ExtArgs> | null
    /**
     * The data needed to update a AuctionBid.
     */
    data: XOR<AuctionBidUpdateInput, AuctionBidUncheckedUpdateInput>
    /**
     * Choose, which AuctionBid to update.
     */
    where: AuctionBidWhereUniqueInput
  }

  /**
   * AuctionBid updateMany
   */
  export type AuctionBidUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuctionBids.
     */
    data: XOR<AuctionBidUpdateManyMutationInput, AuctionBidUncheckedUpdateManyInput>
    /**
     * Filter which AuctionBids to update
     */
    where?: AuctionBidWhereInput
    /**
     * Limit how many AuctionBids to update.
     */
    limit?: number
  }

  /**
   * AuctionBid updateManyAndReturn
   */
  export type AuctionBidUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionBid
     */
    select?: AuctionBidSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionBid
     */
    omit?: AuctionBidOmit<ExtArgs> | null
    /**
     * The data used to update AuctionBids.
     */
    data: XOR<AuctionBidUpdateManyMutationInput, AuctionBidUncheckedUpdateManyInput>
    /**
     * Filter which AuctionBids to update
     */
    where?: AuctionBidWhereInput
    /**
     * Limit how many AuctionBids to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionBidIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuctionBid upsert
   */
  export type AuctionBidUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionBid
     */
    select?: AuctionBidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionBid
     */
    omit?: AuctionBidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionBidInclude<ExtArgs> | null
    /**
     * The filter to search for the AuctionBid to update in case it exists.
     */
    where: AuctionBidWhereUniqueInput
    /**
     * In case the AuctionBid found by the `where` argument doesn't exist, create a new AuctionBid with this data.
     */
    create: XOR<AuctionBidCreateInput, AuctionBidUncheckedCreateInput>
    /**
     * In case the AuctionBid was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuctionBidUpdateInput, AuctionBidUncheckedUpdateInput>
  }

  /**
   * AuctionBid delete
   */
  export type AuctionBidDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionBid
     */
    select?: AuctionBidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionBid
     */
    omit?: AuctionBidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionBidInclude<ExtArgs> | null
    /**
     * Filter which AuctionBid to delete.
     */
    where: AuctionBidWhereUniqueInput
  }

  /**
   * AuctionBid deleteMany
   */
  export type AuctionBidDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuctionBids to delete
     */
    where?: AuctionBidWhereInput
    /**
     * Limit how many AuctionBids to delete.
     */
    limit?: number
  }

  /**
   * AuctionBid without action
   */
  export type AuctionBidDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionBid
     */
    select?: AuctionBidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionBid
     */
    omit?: AuctionBidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionBidInclude<ExtArgs> | null
  }


  /**
   * Model AuctionWatcher
   */

  export type AggregateAuctionWatcher = {
    _count: AuctionWatcherCountAggregateOutputType | null
    _avg: AuctionWatcherAvgAggregateOutputType | null
    _sum: AuctionWatcherSumAggregateOutputType | null
    _min: AuctionWatcherMinAggregateOutputType | null
    _max: AuctionWatcherMaxAggregateOutputType | null
  }

  export type AuctionWatcherAvgAggregateOutputType = {
    alertThreshold: number | null
  }

  export type AuctionWatcherSumAggregateOutputType = {
    alertThreshold: number | null
  }

  export type AuctionWatcherMinAggregateOutputType = {
    id: string | null
    auctionId: string | null
    userId: string | null
    bidNotifications: boolean | null
    endingNotifications: boolean | null
    priceAlerts: boolean | null
    alertThreshold: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuctionWatcherMaxAggregateOutputType = {
    id: string | null
    auctionId: string | null
    userId: string | null
    bidNotifications: boolean | null
    endingNotifications: boolean | null
    priceAlerts: boolean | null
    alertThreshold: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuctionWatcherCountAggregateOutputType = {
    id: number
    auctionId: number
    userId: number
    bidNotifications: number
    endingNotifications: number
    priceAlerts: number
    alertThreshold: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AuctionWatcherAvgAggregateInputType = {
    alertThreshold?: true
  }

  export type AuctionWatcherSumAggregateInputType = {
    alertThreshold?: true
  }

  export type AuctionWatcherMinAggregateInputType = {
    id?: true
    auctionId?: true
    userId?: true
    bidNotifications?: true
    endingNotifications?: true
    priceAlerts?: true
    alertThreshold?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuctionWatcherMaxAggregateInputType = {
    id?: true
    auctionId?: true
    userId?: true
    bidNotifications?: true
    endingNotifications?: true
    priceAlerts?: true
    alertThreshold?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuctionWatcherCountAggregateInputType = {
    id?: true
    auctionId?: true
    userId?: true
    bidNotifications?: true
    endingNotifications?: true
    priceAlerts?: true
    alertThreshold?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AuctionWatcherAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuctionWatcher to aggregate.
     */
    where?: AuctionWatcherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuctionWatchers to fetch.
     */
    orderBy?: AuctionWatcherOrderByWithRelationInput | AuctionWatcherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuctionWatcherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuctionWatchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuctionWatchers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuctionWatchers
    **/
    _count?: true | AuctionWatcherCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuctionWatcherAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuctionWatcherSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuctionWatcherMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuctionWatcherMaxAggregateInputType
  }

  export type GetAuctionWatcherAggregateType<T extends AuctionWatcherAggregateArgs> = {
        [P in keyof T & keyof AggregateAuctionWatcher]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuctionWatcher[P]>
      : GetScalarType<T[P], AggregateAuctionWatcher[P]>
  }




  export type AuctionWatcherGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuctionWatcherWhereInput
    orderBy?: AuctionWatcherOrderByWithAggregationInput | AuctionWatcherOrderByWithAggregationInput[]
    by: AuctionWatcherScalarFieldEnum[] | AuctionWatcherScalarFieldEnum
    having?: AuctionWatcherScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuctionWatcherCountAggregateInputType | true
    _avg?: AuctionWatcherAvgAggregateInputType
    _sum?: AuctionWatcherSumAggregateInputType
    _min?: AuctionWatcherMinAggregateInputType
    _max?: AuctionWatcherMaxAggregateInputType
  }

  export type AuctionWatcherGroupByOutputType = {
    id: string
    auctionId: string
    userId: string
    bidNotifications: boolean
    endingNotifications: boolean
    priceAlerts: boolean
    alertThreshold: number | null
    createdAt: Date
    updatedAt: Date
    _count: AuctionWatcherCountAggregateOutputType | null
    _avg: AuctionWatcherAvgAggregateOutputType | null
    _sum: AuctionWatcherSumAggregateOutputType | null
    _min: AuctionWatcherMinAggregateOutputType | null
    _max: AuctionWatcherMaxAggregateOutputType | null
  }

  type GetAuctionWatcherGroupByPayload<T extends AuctionWatcherGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuctionWatcherGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuctionWatcherGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuctionWatcherGroupByOutputType[P]>
            : GetScalarType<T[P], AuctionWatcherGroupByOutputType[P]>
        }
      >
    >


  export type AuctionWatcherSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auctionId?: boolean
    userId?: boolean
    bidNotifications?: boolean
    endingNotifications?: boolean
    priceAlerts?: boolean
    alertThreshold?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    auction?: boolean | CardAuctionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auctionWatcher"]>

  export type AuctionWatcherSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auctionId?: boolean
    userId?: boolean
    bidNotifications?: boolean
    endingNotifications?: boolean
    priceAlerts?: boolean
    alertThreshold?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    auction?: boolean | CardAuctionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auctionWatcher"]>

  export type AuctionWatcherSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auctionId?: boolean
    userId?: boolean
    bidNotifications?: boolean
    endingNotifications?: boolean
    priceAlerts?: boolean
    alertThreshold?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    auction?: boolean | CardAuctionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auctionWatcher"]>

  export type AuctionWatcherSelectScalar = {
    id?: boolean
    auctionId?: boolean
    userId?: boolean
    bidNotifications?: boolean
    endingNotifications?: boolean
    priceAlerts?: boolean
    alertThreshold?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AuctionWatcherOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "auctionId" | "userId" | "bidNotifications" | "endingNotifications" | "priceAlerts" | "alertThreshold" | "createdAt" | "updatedAt", ExtArgs["result"]["auctionWatcher"]>
  export type AuctionWatcherInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auction?: boolean | CardAuctionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuctionWatcherIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auction?: boolean | CardAuctionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuctionWatcherIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auction?: boolean | CardAuctionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuctionWatcherPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuctionWatcher"
    objects: {
      auction: Prisma.$CardAuctionPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      auctionId: string
      userId: string
      bidNotifications: boolean
      endingNotifications: boolean
      priceAlerts: boolean
      alertThreshold: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["auctionWatcher"]>
    composites: {}
  }

  type AuctionWatcherGetPayload<S extends boolean | null | undefined | AuctionWatcherDefaultArgs> = $Result.GetResult<Prisma.$AuctionWatcherPayload, S>

  type AuctionWatcherCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuctionWatcherFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuctionWatcherCountAggregateInputType | true
    }

  export interface AuctionWatcherDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuctionWatcher'], meta: { name: 'AuctionWatcher' } }
    /**
     * Find zero or one AuctionWatcher that matches the filter.
     * @param {AuctionWatcherFindUniqueArgs} args - Arguments to find a AuctionWatcher
     * @example
     * // Get one AuctionWatcher
     * const auctionWatcher = await prisma.auctionWatcher.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuctionWatcherFindUniqueArgs>(args: SelectSubset<T, AuctionWatcherFindUniqueArgs<ExtArgs>>): Prisma__AuctionWatcherClient<$Result.GetResult<Prisma.$AuctionWatcherPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuctionWatcher that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuctionWatcherFindUniqueOrThrowArgs} args - Arguments to find a AuctionWatcher
     * @example
     * // Get one AuctionWatcher
     * const auctionWatcher = await prisma.auctionWatcher.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuctionWatcherFindUniqueOrThrowArgs>(args: SelectSubset<T, AuctionWatcherFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuctionWatcherClient<$Result.GetResult<Prisma.$AuctionWatcherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuctionWatcher that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuctionWatcherFindFirstArgs} args - Arguments to find a AuctionWatcher
     * @example
     * // Get one AuctionWatcher
     * const auctionWatcher = await prisma.auctionWatcher.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuctionWatcherFindFirstArgs>(args?: SelectSubset<T, AuctionWatcherFindFirstArgs<ExtArgs>>): Prisma__AuctionWatcherClient<$Result.GetResult<Prisma.$AuctionWatcherPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuctionWatcher that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuctionWatcherFindFirstOrThrowArgs} args - Arguments to find a AuctionWatcher
     * @example
     * // Get one AuctionWatcher
     * const auctionWatcher = await prisma.auctionWatcher.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuctionWatcherFindFirstOrThrowArgs>(args?: SelectSubset<T, AuctionWatcherFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuctionWatcherClient<$Result.GetResult<Prisma.$AuctionWatcherPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuctionWatchers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuctionWatcherFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuctionWatchers
     * const auctionWatchers = await prisma.auctionWatcher.findMany()
     * 
     * // Get first 10 AuctionWatchers
     * const auctionWatchers = await prisma.auctionWatcher.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auctionWatcherWithIdOnly = await prisma.auctionWatcher.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuctionWatcherFindManyArgs>(args?: SelectSubset<T, AuctionWatcherFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuctionWatcherPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuctionWatcher.
     * @param {AuctionWatcherCreateArgs} args - Arguments to create a AuctionWatcher.
     * @example
     * // Create one AuctionWatcher
     * const AuctionWatcher = await prisma.auctionWatcher.create({
     *   data: {
     *     // ... data to create a AuctionWatcher
     *   }
     * })
     * 
     */
    create<T extends AuctionWatcherCreateArgs>(args: SelectSubset<T, AuctionWatcherCreateArgs<ExtArgs>>): Prisma__AuctionWatcherClient<$Result.GetResult<Prisma.$AuctionWatcherPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuctionWatchers.
     * @param {AuctionWatcherCreateManyArgs} args - Arguments to create many AuctionWatchers.
     * @example
     * // Create many AuctionWatchers
     * const auctionWatcher = await prisma.auctionWatcher.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuctionWatcherCreateManyArgs>(args?: SelectSubset<T, AuctionWatcherCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuctionWatchers and returns the data saved in the database.
     * @param {AuctionWatcherCreateManyAndReturnArgs} args - Arguments to create many AuctionWatchers.
     * @example
     * // Create many AuctionWatchers
     * const auctionWatcher = await prisma.auctionWatcher.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuctionWatchers and only return the `id`
     * const auctionWatcherWithIdOnly = await prisma.auctionWatcher.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuctionWatcherCreateManyAndReturnArgs>(args?: SelectSubset<T, AuctionWatcherCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuctionWatcherPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuctionWatcher.
     * @param {AuctionWatcherDeleteArgs} args - Arguments to delete one AuctionWatcher.
     * @example
     * // Delete one AuctionWatcher
     * const AuctionWatcher = await prisma.auctionWatcher.delete({
     *   where: {
     *     // ... filter to delete one AuctionWatcher
     *   }
     * })
     * 
     */
    delete<T extends AuctionWatcherDeleteArgs>(args: SelectSubset<T, AuctionWatcherDeleteArgs<ExtArgs>>): Prisma__AuctionWatcherClient<$Result.GetResult<Prisma.$AuctionWatcherPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuctionWatcher.
     * @param {AuctionWatcherUpdateArgs} args - Arguments to update one AuctionWatcher.
     * @example
     * // Update one AuctionWatcher
     * const auctionWatcher = await prisma.auctionWatcher.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuctionWatcherUpdateArgs>(args: SelectSubset<T, AuctionWatcherUpdateArgs<ExtArgs>>): Prisma__AuctionWatcherClient<$Result.GetResult<Prisma.$AuctionWatcherPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuctionWatchers.
     * @param {AuctionWatcherDeleteManyArgs} args - Arguments to filter AuctionWatchers to delete.
     * @example
     * // Delete a few AuctionWatchers
     * const { count } = await prisma.auctionWatcher.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuctionWatcherDeleteManyArgs>(args?: SelectSubset<T, AuctionWatcherDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuctionWatchers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuctionWatcherUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuctionWatchers
     * const auctionWatcher = await prisma.auctionWatcher.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuctionWatcherUpdateManyArgs>(args: SelectSubset<T, AuctionWatcherUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuctionWatchers and returns the data updated in the database.
     * @param {AuctionWatcherUpdateManyAndReturnArgs} args - Arguments to update many AuctionWatchers.
     * @example
     * // Update many AuctionWatchers
     * const auctionWatcher = await prisma.auctionWatcher.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuctionWatchers and only return the `id`
     * const auctionWatcherWithIdOnly = await prisma.auctionWatcher.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuctionWatcherUpdateManyAndReturnArgs>(args: SelectSubset<T, AuctionWatcherUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuctionWatcherPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuctionWatcher.
     * @param {AuctionWatcherUpsertArgs} args - Arguments to update or create a AuctionWatcher.
     * @example
     * // Update or create a AuctionWatcher
     * const auctionWatcher = await prisma.auctionWatcher.upsert({
     *   create: {
     *     // ... data to create a AuctionWatcher
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuctionWatcher we want to update
     *   }
     * })
     */
    upsert<T extends AuctionWatcherUpsertArgs>(args: SelectSubset<T, AuctionWatcherUpsertArgs<ExtArgs>>): Prisma__AuctionWatcherClient<$Result.GetResult<Prisma.$AuctionWatcherPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuctionWatchers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuctionWatcherCountArgs} args - Arguments to filter AuctionWatchers to count.
     * @example
     * // Count the number of AuctionWatchers
     * const count = await prisma.auctionWatcher.count({
     *   where: {
     *     // ... the filter for the AuctionWatchers we want to count
     *   }
     * })
    **/
    count<T extends AuctionWatcherCountArgs>(
      args?: Subset<T, AuctionWatcherCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuctionWatcherCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuctionWatcher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuctionWatcherAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuctionWatcherAggregateArgs>(args: Subset<T, AuctionWatcherAggregateArgs>): Prisma.PrismaPromise<GetAuctionWatcherAggregateType<T>>

    /**
     * Group by AuctionWatcher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuctionWatcherGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuctionWatcherGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuctionWatcherGroupByArgs['orderBy'] }
        : { orderBy?: AuctionWatcherGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuctionWatcherGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuctionWatcherGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuctionWatcher model
   */
  readonly fields: AuctionWatcherFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuctionWatcher.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuctionWatcherClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    auction<T extends CardAuctionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CardAuctionDefaultArgs<ExtArgs>>): Prisma__CardAuctionClient<$Result.GetResult<Prisma.$CardAuctionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuctionWatcher model
   */
  interface AuctionWatcherFieldRefs {
    readonly id: FieldRef<"AuctionWatcher", 'String'>
    readonly auctionId: FieldRef<"AuctionWatcher", 'String'>
    readonly userId: FieldRef<"AuctionWatcher", 'String'>
    readonly bidNotifications: FieldRef<"AuctionWatcher", 'Boolean'>
    readonly endingNotifications: FieldRef<"AuctionWatcher", 'Boolean'>
    readonly priceAlerts: FieldRef<"AuctionWatcher", 'Boolean'>
    readonly alertThreshold: FieldRef<"AuctionWatcher", 'Float'>
    readonly createdAt: FieldRef<"AuctionWatcher", 'DateTime'>
    readonly updatedAt: FieldRef<"AuctionWatcher", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuctionWatcher findUnique
   */
  export type AuctionWatcherFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionWatcher
     */
    select?: AuctionWatcherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionWatcher
     */
    omit?: AuctionWatcherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionWatcherInclude<ExtArgs> | null
    /**
     * Filter, which AuctionWatcher to fetch.
     */
    where: AuctionWatcherWhereUniqueInput
  }

  /**
   * AuctionWatcher findUniqueOrThrow
   */
  export type AuctionWatcherFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionWatcher
     */
    select?: AuctionWatcherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionWatcher
     */
    omit?: AuctionWatcherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionWatcherInclude<ExtArgs> | null
    /**
     * Filter, which AuctionWatcher to fetch.
     */
    where: AuctionWatcherWhereUniqueInput
  }

  /**
   * AuctionWatcher findFirst
   */
  export type AuctionWatcherFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionWatcher
     */
    select?: AuctionWatcherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionWatcher
     */
    omit?: AuctionWatcherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionWatcherInclude<ExtArgs> | null
    /**
     * Filter, which AuctionWatcher to fetch.
     */
    where?: AuctionWatcherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuctionWatchers to fetch.
     */
    orderBy?: AuctionWatcherOrderByWithRelationInput | AuctionWatcherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuctionWatchers.
     */
    cursor?: AuctionWatcherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuctionWatchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuctionWatchers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuctionWatchers.
     */
    distinct?: AuctionWatcherScalarFieldEnum | AuctionWatcherScalarFieldEnum[]
  }

  /**
   * AuctionWatcher findFirstOrThrow
   */
  export type AuctionWatcherFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionWatcher
     */
    select?: AuctionWatcherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionWatcher
     */
    omit?: AuctionWatcherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionWatcherInclude<ExtArgs> | null
    /**
     * Filter, which AuctionWatcher to fetch.
     */
    where?: AuctionWatcherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuctionWatchers to fetch.
     */
    orderBy?: AuctionWatcherOrderByWithRelationInput | AuctionWatcherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuctionWatchers.
     */
    cursor?: AuctionWatcherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuctionWatchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuctionWatchers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuctionWatchers.
     */
    distinct?: AuctionWatcherScalarFieldEnum | AuctionWatcherScalarFieldEnum[]
  }

  /**
   * AuctionWatcher findMany
   */
  export type AuctionWatcherFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionWatcher
     */
    select?: AuctionWatcherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionWatcher
     */
    omit?: AuctionWatcherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionWatcherInclude<ExtArgs> | null
    /**
     * Filter, which AuctionWatchers to fetch.
     */
    where?: AuctionWatcherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuctionWatchers to fetch.
     */
    orderBy?: AuctionWatcherOrderByWithRelationInput | AuctionWatcherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuctionWatchers.
     */
    cursor?: AuctionWatcherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuctionWatchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuctionWatchers.
     */
    skip?: number
    distinct?: AuctionWatcherScalarFieldEnum | AuctionWatcherScalarFieldEnum[]
  }

  /**
   * AuctionWatcher create
   */
  export type AuctionWatcherCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionWatcher
     */
    select?: AuctionWatcherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionWatcher
     */
    omit?: AuctionWatcherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionWatcherInclude<ExtArgs> | null
    /**
     * The data needed to create a AuctionWatcher.
     */
    data: XOR<AuctionWatcherCreateInput, AuctionWatcherUncheckedCreateInput>
  }

  /**
   * AuctionWatcher createMany
   */
  export type AuctionWatcherCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuctionWatchers.
     */
    data: AuctionWatcherCreateManyInput | AuctionWatcherCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuctionWatcher createManyAndReturn
   */
  export type AuctionWatcherCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionWatcher
     */
    select?: AuctionWatcherSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionWatcher
     */
    omit?: AuctionWatcherOmit<ExtArgs> | null
    /**
     * The data used to create many AuctionWatchers.
     */
    data: AuctionWatcherCreateManyInput | AuctionWatcherCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionWatcherIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuctionWatcher update
   */
  export type AuctionWatcherUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionWatcher
     */
    select?: AuctionWatcherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionWatcher
     */
    omit?: AuctionWatcherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionWatcherInclude<ExtArgs> | null
    /**
     * The data needed to update a AuctionWatcher.
     */
    data: XOR<AuctionWatcherUpdateInput, AuctionWatcherUncheckedUpdateInput>
    /**
     * Choose, which AuctionWatcher to update.
     */
    where: AuctionWatcherWhereUniqueInput
  }

  /**
   * AuctionWatcher updateMany
   */
  export type AuctionWatcherUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuctionWatchers.
     */
    data: XOR<AuctionWatcherUpdateManyMutationInput, AuctionWatcherUncheckedUpdateManyInput>
    /**
     * Filter which AuctionWatchers to update
     */
    where?: AuctionWatcherWhereInput
    /**
     * Limit how many AuctionWatchers to update.
     */
    limit?: number
  }

  /**
   * AuctionWatcher updateManyAndReturn
   */
  export type AuctionWatcherUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionWatcher
     */
    select?: AuctionWatcherSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionWatcher
     */
    omit?: AuctionWatcherOmit<ExtArgs> | null
    /**
     * The data used to update AuctionWatchers.
     */
    data: XOR<AuctionWatcherUpdateManyMutationInput, AuctionWatcherUncheckedUpdateManyInput>
    /**
     * Filter which AuctionWatchers to update
     */
    where?: AuctionWatcherWhereInput
    /**
     * Limit how many AuctionWatchers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionWatcherIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuctionWatcher upsert
   */
  export type AuctionWatcherUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionWatcher
     */
    select?: AuctionWatcherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionWatcher
     */
    omit?: AuctionWatcherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionWatcherInclude<ExtArgs> | null
    /**
     * The filter to search for the AuctionWatcher to update in case it exists.
     */
    where: AuctionWatcherWhereUniqueInput
    /**
     * In case the AuctionWatcher found by the `where` argument doesn't exist, create a new AuctionWatcher with this data.
     */
    create: XOR<AuctionWatcherCreateInput, AuctionWatcherUncheckedCreateInput>
    /**
     * In case the AuctionWatcher was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuctionWatcherUpdateInput, AuctionWatcherUncheckedUpdateInput>
  }

  /**
   * AuctionWatcher delete
   */
  export type AuctionWatcherDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionWatcher
     */
    select?: AuctionWatcherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionWatcher
     */
    omit?: AuctionWatcherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionWatcherInclude<ExtArgs> | null
    /**
     * Filter which AuctionWatcher to delete.
     */
    where: AuctionWatcherWhereUniqueInput
  }

  /**
   * AuctionWatcher deleteMany
   */
  export type AuctionWatcherDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuctionWatchers to delete
     */
    where?: AuctionWatcherWhereInput
    /**
     * Limit how many AuctionWatchers to delete.
     */
    limit?: number
  }

  /**
   * AuctionWatcher without action
   */
  export type AuctionWatcherDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionWatcher
     */
    select?: AuctionWatcherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionWatcher
     */
    omit?: AuctionWatcherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionWatcherInclude<ExtArgs> | null
  }


  /**
   * Model AuctionHistory
   */

  export type AggregateAuctionHistory = {
    _count: AuctionHistoryCountAggregateOutputType | null
    _avg: AuctionHistoryAvgAggregateOutputType | null
    _sum: AuctionHistorySumAggregateOutputType | null
    _min: AuctionHistoryMinAggregateOutputType | null
    _max: AuctionHistoryMaxAggregateOutputType | null
  }

  export type AuctionHistoryAvgAggregateOutputType = {
    salePrice: number | null
    daysSinceListing: number | null
    numberOfBids: number | null
    highestBid: number | null
  }

  export type AuctionHistorySumAggregateOutputType = {
    salePrice: number | null
    daysSinceListing: number | null
    numberOfBids: number | null
    highestBid: number | null
  }

  export type AuctionHistoryMinAggregateOutputType = {
    id: string | null
    cardId: string | null
    auctionId: string | null
    salePrice: number | null
    sellerId: string | null
    buyerId: string | null
    saleType: $Enums.SaleType | null
    daysSinceListing: number | null
    numberOfBids: number | null
    highestBid: number | null
    saleDate: Date | null
    createdAt: Date | null
  }

  export type AuctionHistoryMaxAggregateOutputType = {
    id: string | null
    cardId: string | null
    auctionId: string | null
    salePrice: number | null
    sellerId: string | null
    buyerId: string | null
    saleType: $Enums.SaleType | null
    daysSinceListing: number | null
    numberOfBids: number | null
    highestBid: number | null
    saleDate: Date | null
    createdAt: Date | null
  }

  export type AuctionHistoryCountAggregateOutputType = {
    id: number
    cardId: number
    auctionId: number
    salePrice: number
    sellerId: number
    buyerId: number
    saleType: number
    marketTrends: number
    priceHistory: number
    daysSinceListing: number
    numberOfBids: number
    highestBid: number
    saleDate: number
    createdAt: number
    _all: number
  }


  export type AuctionHistoryAvgAggregateInputType = {
    salePrice?: true
    daysSinceListing?: true
    numberOfBids?: true
    highestBid?: true
  }

  export type AuctionHistorySumAggregateInputType = {
    salePrice?: true
    daysSinceListing?: true
    numberOfBids?: true
    highestBid?: true
  }

  export type AuctionHistoryMinAggregateInputType = {
    id?: true
    cardId?: true
    auctionId?: true
    salePrice?: true
    sellerId?: true
    buyerId?: true
    saleType?: true
    daysSinceListing?: true
    numberOfBids?: true
    highestBid?: true
    saleDate?: true
    createdAt?: true
  }

  export type AuctionHistoryMaxAggregateInputType = {
    id?: true
    cardId?: true
    auctionId?: true
    salePrice?: true
    sellerId?: true
    buyerId?: true
    saleType?: true
    daysSinceListing?: true
    numberOfBids?: true
    highestBid?: true
    saleDate?: true
    createdAt?: true
  }

  export type AuctionHistoryCountAggregateInputType = {
    id?: true
    cardId?: true
    auctionId?: true
    salePrice?: true
    sellerId?: true
    buyerId?: true
    saleType?: true
    marketTrends?: true
    priceHistory?: true
    daysSinceListing?: true
    numberOfBids?: true
    highestBid?: true
    saleDate?: true
    createdAt?: true
    _all?: true
  }

  export type AuctionHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuctionHistory to aggregate.
     */
    where?: AuctionHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuctionHistories to fetch.
     */
    orderBy?: AuctionHistoryOrderByWithRelationInput | AuctionHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuctionHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuctionHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuctionHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuctionHistories
    **/
    _count?: true | AuctionHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuctionHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuctionHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuctionHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuctionHistoryMaxAggregateInputType
  }

  export type GetAuctionHistoryAggregateType<T extends AuctionHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateAuctionHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuctionHistory[P]>
      : GetScalarType<T[P], AggregateAuctionHistory[P]>
  }




  export type AuctionHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuctionHistoryWhereInput
    orderBy?: AuctionHistoryOrderByWithAggregationInput | AuctionHistoryOrderByWithAggregationInput[]
    by: AuctionHistoryScalarFieldEnum[] | AuctionHistoryScalarFieldEnum
    having?: AuctionHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuctionHistoryCountAggregateInputType | true
    _avg?: AuctionHistoryAvgAggregateInputType
    _sum?: AuctionHistorySumAggregateInputType
    _min?: AuctionHistoryMinAggregateInputType
    _max?: AuctionHistoryMaxAggregateInputType
  }

  export type AuctionHistoryGroupByOutputType = {
    id: string
    cardId: string
    auctionId: string | null
    salePrice: number
    sellerId: string
    buyerId: string
    saleType: $Enums.SaleType
    marketTrends: JsonValue | null
    priceHistory: JsonValue | null
    daysSinceListing: number | null
    numberOfBids: number | null
    highestBid: number | null
    saleDate: Date
    createdAt: Date
    _count: AuctionHistoryCountAggregateOutputType | null
    _avg: AuctionHistoryAvgAggregateOutputType | null
    _sum: AuctionHistorySumAggregateOutputType | null
    _min: AuctionHistoryMinAggregateOutputType | null
    _max: AuctionHistoryMaxAggregateOutputType | null
  }

  type GetAuctionHistoryGroupByPayload<T extends AuctionHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuctionHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuctionHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuctionHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], AuctionHistoryGroupByOutputType[P]>
        }
      >
    >


  export type AuctionHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cardId?: boolean
    auctionId?: boolean
    salePrice?: boolean
    sellerId?: boolean
    buyerId?: boolean
    saleType?: boolean
    marketTrends?: boolean
    priceHistory?: boolean
    daysSinceListing?: boolean
    numberOfBids?: boolean
    highestBid?: boolean
    saleDate?: boolean
    createdAt?: boolean
    card?: boolean | CardDefaultArgs<ExtArgs>
    auction?: boolean | AuctionHistory$auctionArgs<ExtArgs>
  }, ExtArgs["result"]["auctionHistory"]>

  export type AuctionHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cardId?: boolean
    auctionId?: boolean
    salePrice?: boolean
    sellerId?: boolean
    buyerId?: boolean
    saleType?: boolean
    marketTrends?: boolean
    priceHistory?: boolean
    daysSinceListing?: boolean
    numberOfBids?: boolean
    highestBid?: boolean
    saleDate?: boolean
    createdAt?: boolean
    card?: boolean | CardDefaultArgs<ExtArgs>
    auction?: boolean | AuctionHistory$auctionArgs<ExtArgs>
  }, ExtArgs["result"]["auctionHistory"]>

  export type AuctionHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cardId?: boolean
    auctionId?: boolean
    salePrice?: boolean
    sellerId?: boolean
    buyerId?: boolean
    saleType?: boolean
    marketTrends?: boolean
    priceHistory?: boolean
    daysSinceListing?: boolean
    numberOfBids?: boolean
    highestBid?: boolean
    saleDate?: boolean
    createdAt?: boolean
    card?: boolean | CardDefaultArgs<ExtArgs>
    auction?: boolean | AuctionHistory$auctionArgs<ExtArgs>
  }, ExtArgs["result"]["auctionHistory"]>

  export type AuctionHistorySelectScalar = {
    id?: boolean
    cardId?: boolean
    auctionId?: boolean
    salePrice?: boolean
    sellerId?: boolean
    buyerId?: boolean
    saleType?: boolean
    marketTrends?: boolean
    priceHistory?: boolean
    daysSinceListing?: boolean
    numberOfBids?: boolean
    highestBid?: boolean
    saleDate?: boolean
    createdAt?: boolean
  }

  export type AuctionHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cardId" | "auctionId" | "salePrice" | "sellerId" | "buyerId" | "saleType" | "marketTrends" | "priceHistory" | "daysSinceListing" | "numberOfBids" | "highestBid" | "saleDate" | "createdAt", ExtArgs["result"]["auctionHistory"]>
  export type AuctionHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    card?: boolean | CardDefaultArgs<ExtArgs>
    auction?: boolean | AuctionHistory$auctionArgs<ExtArgs>
  }
  export type AuctionHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    card?: boolean | CardDefaultArgs<ExtArgs>
    auction?: boolean | AuctionHistory$auctionArgs<ExtArgs>
  }
  export type AuctionHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    card?: boolean | CardDefaultArgs<ExtArgs>
    auction?: boolean | AuctionHistory$auctionArgs<ExtArgs>
  }

  export type $AuctionHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuctionHistory"
    objects: {
      card: Prisma.$CardPayload<ExtArgs>
      auction: Prisma.$CardAuctionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cardId: string
      auctionId: string | null
      salePrice: number
      sellerId: string
      buyerId: string
      saleType: $Enums.SaleType
      marketTrends: Prisma.JsonValue | null
      priceHistory: Prisma.JsonValue | null
      daysSinceListing: number | null
      numberOfBids: number | null
      highestBid: number | null
      saleDate: Date
      createdAt: Date
    }, ExtArgs["result"]["auctionHistory"]>
    composites: {}
  }

  type AuctionHistoryGetPayload<S extends boolean | null | undefined | AuctionHistoryDefaultArgs> = $Result.GetResult<Prisma.$AuctionHistoryPayload, S>

  type AuctionHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuctionHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuctionHistoryCountAggregateInputType | true
    }

  export interface AuctionHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuctionHistory'], meta: { name: 'AuctionHistory' } }
    /**
     * Find zero or one AuctionHistory that matches the filter.
     * @param {AuctionHistoryFindUniqueArgs} args - Arguments to find a AuctionHistory
     * @example
     * // Get one AuctionHistory
     * const auctionHistory = await prisma.auctionHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuctionHistoryFindUniqueArgs>(args: SelectSubset<T, AuctionHistoryFindUniqueArgs<ExtArgs>>): Prisma__AuctionHistoryClient<$Result.GetResult<Prisma.$AuctionHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuctionHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuctionHistoryFindUniqueOrThrowArgs} args - Arguments to find a AuctionHistory
     * @example
     * // Get one AuctionHistory
     * const auctionHistory = await prisma.auctionHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuctionHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, AuctionHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuctionHistoryClient<$Result.GetResult<Prisma.$AuctionHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuctionHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuctionHistoryFindFirstArgs} args - Arguments to find a AuctionHistory
     * @example
     * // Get one AuctionHistory
     * const auctionHistory = await prisma.auctionHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuctionHistoryFindFirstArgs>(args?: SelectSubset<T, AuctionHistoryFindFirstArgs<ExtArgs>>): Prisma__AuctionHistoryClient<$Result.GetResult<Prisma.$AuctionHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuctionHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuctionHistoryFindFirstOrThrowArgs} args - Arguments to find a AuctionHistory
     * @example
     * // Get one AuctionHistory
     * const auctionHistory = await prisma.auctionHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuctionHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, AuctionHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuctionHistoryClient<$Result.GetResult<Prisma.$AuctionHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuctionHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuctionHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuctionHistories
     * const auctionHistories = await prisma.auctionHistory.findMany()
     * 
     * // Get first 10 AuctionHistories
     * const auctionHistories = await prisma.auctionHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auctionHistoryWithIdOnly = await prisma.auctionHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuctionHistoryFindManyArgs>(args?: SelectSubset<T, AuctionHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuctionHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuctionHistory.
     * @param {AuctionHistoryCreateArgs} args - Arguments to create a AuctionHistory.
     * @example
     * // Create one AuctionHistory
     * const AuctionHistory = await prisma.auctionHistory.create({
     *   data: {
     *     // ... data to create a AuctionHistory
     *   }
     * })
     * 
     */
    create<T extends AuctionHistoryCreateArgs>(args: SelectSubset<T, AuctionHistoryCreateArgs<ExtArgs>>): Prisma__AuctionHistoryClient<$Result.GetResult<Prisma.$AuctionHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuctionHistories.
     * @param {AuctionHistoryCreateManyArgs} args - Arguments to create many AuctionHistories.
     * @example
     * // Create many AuctionHistories
     * const auctionHistory = await prisma.auctionHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuctionHistoryCreateManyArgs>(args?: SelectSubset<T, AuctionHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuctionHistories and returns the data saved in the database.
     * @param {AuctionHistoryCreateManyAndReturnArgs} args - Arguments to create many AuctionHistories.
     * @example
     * // Create many AuctionHistories
     * const auctionHistory = await prisma.auctionHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuctionHistories and only return the `id`
     * const auctionHistoryWithIdOnly = await prisma.auctionHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuctionHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, AuctionHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuctionHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuctionHistory.
     * @param {AuctionHistoryDeleteArgs} args - Arguments to delete one AuctionHistory.
     * @example
     * // Delete one AuctionHistory
     * const AuctionHistory = await prisma.auctionHistory.delete({
     *   where: {
     *     // ... filter to delete one AuctionHistory
     *   }
     * })
     * 
     */
    delete<T extends AuctionHistoryDeleteArgs>(args: SelectSubset<T, AuctionHistoryDeleteArgs<ExtArgs>>): Prisma__AuctionHistoryClient<$Result.GetResult<Prisma.$AuctionHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuctionHistory.
     * @param {AuctionHistoryUpdateArgs} args - Arguments to update one AuctionHistory.
     * @example
     * // Update one AuctionHistory
     * const auctionHistory = await prisma.auctionHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuctionHistoryUpdateArgs>(args: SelectSubset<T, AuctionHistoryUpdateArgs<ExtArgs>>): Prisma__AuctionHistoryClient<$Result.GetResult<Prisma.$AuctionHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuctionHistories.
     * @param {AuctionHistoryDeleteManyArgs} args - Arguments to filter AuctionHistories to delete.
     * @example
     * // Delete a few AuctionHistories
     * const { count } = await prisma.auctionHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuctionHistoryDeleteManyArgs>(args?: SelectSubset<T, AuctionHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuctionHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuctionHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuctionHistories
     * const auctionHistory = await prisma.auctionHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuctionHistoryUpdateManyArgs>(args: SelectSubset<T, AuctionHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuctionHistories and returns the data updated in the database.
     * @param {AuctionHistoryUpdateManyAndReturnArgs} args - Arguments to update many AuctionHistories.
     * @example
     * // Update many AuctionHistories
     * const auctionHistory = await prisma.auctionHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuctionHistories and only return the `id`
     * const auctionHistoryWithIdOnly = await prisma.auctionHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuctionHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, AuctionHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuctionHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuctionHistory.
     * @param {AuctionHistoryUpsertArgs} args - Arguments to update or create a AuctionHistory.
     * @example
     * // Update or create a AuctionHistory
     * const auctionHistory = await prisma.auctionHistory.upsert({
     *   create: {
     *     // ... data to create a AuctionHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuctionHistory we want to update
     *   }
     * })
     */
    upsert<T extends AuctionHistoryUpsertArgs>(args: SelectSubset<T, AuctionHistoryUpsertArgs<ExtArgs>>): Prisma__AuctionHistoryClient<$Result.GetResult<Prisma.$AuctionHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuctionHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuctionHistoryCountArgs} args - Arguments to filter AuctionHistories to count.
     * @example
     * // Count the number of AuctionHistories
     * const count = await prisma.auctionHistory.count({
     *   where: {
     *     // ... the filter for the AuctionHistories we want to count
     *   }
     * })
    **/
    count<T extends AuctionHistoryCountArgs>(
      args?: Subset<T, AuctionHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuctionHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuctionHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuctionHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuctionHistoryAggregateArgs>(args: Subset<T, AuctionHistoryAggregateArgs>): Prisma.PrismaPromise<GetAuctionHistoryAggregateType<T>>

    /**
     * Group by AuctionHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuctionHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuctionHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuctionHistoryGroupByArgs['orderBy'] }
        : { orderBy?: AuctionHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuctionHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuctionHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuctionHistory model
   */
  readonly fields: AuctionHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuctionHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuctionHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    card<T extends CardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CardDefaultArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    auction<T extends AuctionHistory$auctionArgs<ExtArgs> = {}>(args?: Subset<T, AuctionHistory$auctionArgs<ExtArgs>>): Prisma__CardAuctionClient<$Result.GetResult<Prisma.$CardAuctionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuctionHistory model
   */
  interface AuctionHistoryFieldRefs {
    readonly id: FieldRef<"AuctionHistory", 'String'>
    readonly cardId: FieldRef<"AuctionHistory", 'String'>
    readonly auctionId: FieldRef<"AuctionHistory", 'String'>
    readonly salePrice: FieldRef<"AuctionHistory", 'Float'>
    readonly sellerId: FieldRef<"AuctionHistory", 'String'>
    readonly buyerId: FieldRef<"AuctionHistory", 'String'>
    readonly saleType: FieldRef<"AuctionHistory", 'SaleType'>
    readonly marketTrends: FieldRef<"AuctionHistory", 'Json'>
    readonly priceHistory: FieldRef<"AuctionHistory", 'Json'>
    readonly daysSinceListing: FieldRef<"AuctionHistory", 'Int'>
    readonly numberOfBids: FieldRef<"AuctionHistory", 'Int'>
    readonly highestBid: FieldRef<"AuctionHistory", 'Float'>
    readonly saleDate: FieldRef<"AuctionHistory", 'DateTime'>
    readonly createdAt: FieldRef<"AuctionHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuctionHistory findUnique
   */
  export type AuctionHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionHistory
     */
    select?: AuctionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionHistory
     */
    omit?: AuctionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionHistoryInclude<ExtArgs> | null
    /**
     * Filter, which AuctionHistory to fetch.
     */
    where: AuctionHistoryWhereUniqueInput
  }

  /**
   * AuctionHistory findUniqueOrThrow
   */
  export type AuctionHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionHistory
     */
    select?: AuctionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionHistory
     */
    omit?: AuctionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionHistoryInclude<ExtArgs> | null
    /**
     * Filter, which AuctionHistory to fetch.
     */
    where: AuctionHistoryWhereUniqueInput
  }

  /**
   * AuctionHistory findFirst
   */
  export type AuctionHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionHistory
     */
    select?: AuctionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionHistory
     */
    omit?: AuctionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionHistoryInclude<ExtArgs> | null
    /**
     * Filter, which AuctionHistory to fetch.
     */
    where?: AuctionHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuctionHistories to fetch.
     */
    orderBy?: AuctionHistoryOrderByWithRelationInput | AuctionHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuctionHistories.
     */
    cursor?: AuctionHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuctionHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuctionHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuctionHistories.
     */
    distinct?: AuctionHistoryScalarFieldEnum | AuctionHistoryScalarFieldEnum[]
  }

  /**
   * AuctionHistory findFirstOrThrow
   */
  export type AuctionHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionHistory
     */
    select?: AuctionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionHistory
     */
    omit?: AuctionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionHistoryInclude<ExtArgs> | null
    /**
     * Filter, which AuctionHistory to fetch.
     */
    where?: AuctionHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuctionHistories to fetch.
     */
    orderBy?: AuctionHistoryOrderByWithRelationInput | AuctionHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuctionHistories.
     */
    cursor?: AuctionHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuctionHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuctionHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuctionHistories.
     */
    distinct?: AuctionHistoryScalarFieldEnum | AuctionHistoryScalarFieldEnum[]
  }

  /**
   * AuctionHistory findMany
   */
  export type AuctionHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionHistory
     */
    select?: AuctionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionHistory
     */
    omit?: AuctionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionHistoryInclude<ExtArgs> | null
    /**
     * Filter, which AuctionHistories to fetch.
     */
    where?: AuctionHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuctionHistories to fetch.
     */
    orderBy?: AuctionHistoryOrderByWithRelationInput | AuctionHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuctionHistories.
     */
    cursor?: AuctionHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuctionHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuctionHistories.
     */
    skip?: number
    distinct?: AuctionHistoryScalarFieldEnum | AuctionHistoryScalarFieldEnum[]
  }

  /**
   * AuctionHistory create
   */
  export type AuctionHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionHistory
     */
    select?: AuctionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionHistory
     */
    omit?: AuctionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a AuctionHistory.
     */
    data: XOR<AuctionHistoryCreateInput, AuctionHistoryUncheckedCreateInput>
  }

  /**
   * AuctionHistory createMany
   */
  export type AuctionHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuctionHistories.
     */
    data: AuctionHistoryCreateManyInput | AuctionHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuctionHistory createManyAndReturn
   */
  export type AuctionHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionHistory
     */
    select?: AuctionHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionHistory
     */
    omit?: AuctionHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many AuctionHistories.
     */
    data: AuctionHistoryCreateManyInput | AuctionHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuctionHistory update
   */
  export type AuctionHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionHistory
     */
    select?: AuctionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionHistory
     */
    omit?: AuctionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a AuctionHistory.
     */
    data: XOR<AuctionHistoryUpdateInput, AuctionHistoryUncheckedUpdateInput>
    /**
     * Choose, which AuctionHistory to update.
     */
    where: AuctionHistoryWhereUniqueInput
  }

  /**
   * AuctionHistory updateMany
   */
  export type AuctionHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuctionHistories.
     */
    data: XOR<AuctionHistoryUpdateManyMutationInput, AuctionHistoryUncheckedUpdateManyInput>
    /**
     * Filter which AuctionHistories to update
     */
    where?: AuctionHistoryWhereInput
    /**
     * Limit how many AuctionHistories to update.
     */
    limit?: number
  }

  /**
   * AuctionHistory updateManyAndReturn
   */
  export type AuctionHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionHistory
     */
    select?: AuctionHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionHistory
     */
    omit?: AuctionHistoryOmit<ExtArgs> | null
    /**
     * The data used to update AuctionHistories.
     */
    data: XOR<AuctionHistoryUpdateManyMutationInput, AuctionHistoryUncheckedUpdateManyInput>
    /**
     * Filter which AuctionHistories to update
     */
    where?: AuctionHistoryWhereInput
    /**
     * Limit how many AuctionHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuctionHistory upsert
   */
  export type AuctionHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionHistory
     */
    select?: AuctionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionHistory
     */
    omit?: AuctionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the AuctionHistory to update in case it exists.
     */
    where: AuctionHistoryWhereUniqueInput
    /**
     * In case the AuctionHistory found by the `where` argument doesn't exist, create a new AuctionHistory with this data.
     */
    create: XOR<AuctionHistoryCreateInput, AuctionHistoryUncheckedCreateInput>
    /**
     * In case the AuctionHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuctionHistoryUpdateInput, AuctionHistoryUncheckedUpdateInput>
  }

  /**
   * AuctionHistory delete
   */
  export type AuctionHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionHistory
     */
    select?: AuctionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionHistory
     */
    omit?: AuctionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionHistoryInclude<ExtArgs> | null
    /**
     * Filter which AuctionHistory to delete.
     */
    where: AuctionHistoryWhereUniqueInput
  }

  /**
   * AuctionHistory deleteMany
   */
  export type AuctionHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuctionHistories to delete
     */
    where?: AuctionHistoryWhereInput
    /**
     * Limit how many AuctionHistories to delete.
     */
    limit?: number
  }

  /**
   * AuctionHistory.auction
   */
  export type AuctionHistory$auctionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardAuction
     */
    select?: CardAuctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardAuction
     */
    omit?: CardAuctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardAuctionInclude<ExtArgs> | null
    where?: CardAuctionWhereInput
  }

  /**
   * AuctionHistory without action
   */
  export type AuctionHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionHistory
     */
    select?: AuctionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionHistory
     */
    omit?: AuctionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionHistoryInclude<ExtArgs> | null
  }


  /**
   * Model MABattle
   */

  export type AggregateMABattle = {
    _count: MABattleCountAggregateOutputType | null
    _avg: MABattleAvgAggregateOutputType | null
    _sum: MABattleSumAggregateOutputType | null
    _min: MABattleMinAggregateOutputType | null
    _max: MABattleMaxAggregateOutputType | null
  }

  export type MABattleAvgAggregateOutputType = {
    stakes: number | null
    viewCount: number | null
    participantCount: number | null
  }

  export type MABattleSumAggregateOutputType = {
    stakes: number | null
    viewCount: number | null
    participantCount: number | null
  }

  export type MABattleMinAggregateOutputType = {
    id: string | null
    initiatorCardId: string | null
    targetCardId: string | null
    initiatorUserId: string | null
    targetUserId: string | null
    battleType: $Enums.BattleType | null
    title: string | null
    description: string | null
    stakes: number | null
    timeline: Date | null
    votingPeriod: Date | null
    status: $Enums.BattleStatus | null
    resolved: boolean | null
    viewCount: number | null
    participantCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MABattleMaxAggregateOutputType = {
    id: string | null
    initiatorCardId: string | null
    targetCardId: string | null
    initiatorUserId: string | null
    targetUserId: string | null
    battleType: $Enums.BattleType | null
    title: string | null
    description: string | null
    stakes: number | null
    timeline: Date | null
    votingPeriod: Date | null
    status: $Enums.BattleStatus | null
    resolved: boolean | null
    viewCount: number | null
    participantCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MABattleCountAggregateOutputType = {
    id: number
    initiatorCardId: number
    targetCardId: number
    initiatorUserId: number
    targetUserId: number
    battleType: number
    title: number
    description: number
    stakes: number
    timeline: number
    votingPeriod: number
    status: number
    resolved: number
    viewCount: number
    participantCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MABattleAvgAggregateInputType = {
    stakes?: true
    viewCount?: true
    participantCount?: true
  }

  export type MABattleSumAggregateInputType = {
    stakes?: true
    viewCount?: true
    participantCount?: true
  }

  export type MABattleMinAggregateInputType = {
    id?: true
    initiatorCardId?: true
    targetCardId?: true
    initiatorUserId?: true
    targetUserId?: true
    battleType?: true
    title?: true
    description?: true
    stakes?: true
    timeline?: true
    votingPeriod?: true
    status?: true
    resolved?: true
    viewCount?: true
    participantCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MABattleMaxAggregateInputType = {
    id?: true
    initiatorCardId?: true
    targetCardId?: true
    initiatorUserId?: true
    targetUserId?: true
    battleType?: true
    title?: true
    description?: true
    stakes?: true
    timeline?: true
    votingPeriod?: true
    status?: true
    resolved?: true
    viewCount?: true
    participantCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MABattleCountAggregateInputType = {
    id?: true
    initiatorCardId?: true
    targetCardId?: true
    initiatorUserId?: true
    targetUserId?: true
    battleType?: true
    title?: true
    description?: true
    stakes?: true
    timeline?: true
    votingPeriod?: true
    status?: true
    resolved?: true
    viewCount?: true
    participantCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MABattleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MABattle to aggregate.
     */
    where?: MABattleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MABattles to fetch.
     */
    orderBy?: MABattleOrderByWithRelationInput | MABattleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MABattleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MABattles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MABattles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MABattles
    **/
    _count?: true | MABattleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MABattleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MABattleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MABattleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MABattleMaxAggregateInputType
  }

  export type GetMABattleAggregateType<T extends MABattleAggregateArgs> = {
        [P in keyof T & keyof AggregateMABattle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMABattle[P]>
      : GetScalarType<T[P], AggregateMABattle[P]>
  }




  export type MABattleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MABattleWhereInput
    orderBy?: MABattleOrderByWithAggregationInput | MABattleOrderByWithAggregationInput[]
    by: MABattleScalarFieldEnum[] | MABattleScalarFieldEnum
    having?: MABattleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MABattleCountAggregateInputType | true
    _avg?: MABattleAvgAggregateInputType
    _sum?: MABattleSumAggregateInputType
    _min?: MABattleMinAggregateInputType
    _max?: MABattleMaxAggregateInputType
  }

  export type MABattleGroupByOutputType = {
    id: string
    initiatorCardId: string
    targetCardId: string
    initiatorUserId: string
    targetUserId: string | null
    battleType: $Enums.BattleType
    title: string
    description: string
    stakes: number
    timeline: Date
    votingPeriod: Date
    status: $Enums.BattleStatus
    resolved: boolean
    viewCount: number
    participantCount: number
    createdAt: Date
    updatedAt: Date
    _count: MABattleCountAggregateOutputType | null
    _avg: MABattleAvgAggregateOutputType | null
    _sum: MABattleSumAggregateOutputType | null
    _min: MABattleMinAggregateOutputType | null
    _max: MABattleMaxAggregateOutputType | null
  }

  type GetMABattleGroupByPayload<T extends MABattleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MABattleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MABattleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MABattleGroupByOutputType[P]>
            : GetScalarType<T[P], MABattleGroupByOutputType[P]>
        }
      >
    >


  export type MABattleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    initiatorCardId?: boolean
    targetCardId?: boolean
    initiatorUserId?: boolean
    targetUserId?: boolean
    battleType?: boolean
    title?: boolean
    description?: boolean
    stakes?: boolean
    timeline?: boolean
    votingPeriod?: boolean
    status?: boolean
    resolved?: boolean
    viewCount?: boolean
    participantCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    initiatorCard?: boolean | CardDefaultArgs<ExtArgs>
    targetCard?: boolean | CardDefaultArgs<ExtArgs>
    initiator?: boolean | UserDefaultArgs<ExtArgs>
    target?: boolean | MABattle$targetArgs<ExtArgs>
    winner?: boolean | MABattle$winnerArgs<ExtArgs>
    proposals?: boolean | MABattle$proposalsArgs<ExtArgs>
    votes?: boolean | MABattle$votesArgs<ExtArgs>
    outcomes?: boolean | MABattle$outcomesArgs<ExtArgs>
    _count?: boolean | MABattleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mABattle"]>

  export type MABattleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    initiatorCardId?: boolean
    targetCardId?: boolean
    initiatorUserId?: boolean
    targetUserId?: boolean
    battleType?: boolean
    title?: boolean
    description?: boolean
    stakes?: boolean
    timeline?: boolean
    votingPeriod?: boolean
    status?: boolean
    resolved?: boolean
    viewCount?: boolean
    participantCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    initiatorCard?: boolean | CardDefaultArgs<ExtArgs>
    targetCard?: boolean | CardDefaultArgs<ExtArgs>
    initiator?: boolean | UserDefaultArgs<ExtArgs>
    target?: boolean | MABattle$targetArgs<ExtArgs>
  }, ExtArgs["result"]["mABattle"]>

  export type MABattleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    initiatorCardId?: boolean
    targetCardId?: boolean
    initiatorUserId?: boolean
    targetUserId?: boolean
    battleType?: boolean
    title?: boolean
    description?: boolean
    stakes?: boolean
    timeline?: boolean
    votingPeriod?: boolean
    status?: boolean
    resolved?: boolean
    viewCount?: boolean
    participantCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    initiatorCard?: boolean | CardDefaultArgs<ExtArgs>
    targetCard?: boolean | CardDefaultArgs<ExtArgs>
    initiator?: boolean | UserDefaultArgs<ExtArgs>
    target?: boolean | MABattle$targetArgs<ExtArgs>
  }, ExtArgs["result"]["mABattle"]>

  export type MABattleSelectScalar = {
    id?: boolean
    initiatorCardId?: boolean
    targetCardId?: boolean
    initiatorUserId?: boolean
    targetUserId?: boolean
    battleType?: boolean
    title?: boolean
    description?: boolean
    stakes?: boolean
    timeline?: boolean
    votingPeriod?: boolean
    status?: boolean
    resolved?: boolean
    viewCount?: boolean
    participantCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MABattleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "initiatorCardId" | "targetCardId" | "initiatorUserId" | "targetUserId" | "battleType" | "title" | "description" | "stakes" | "timeline" | "votingPeriod" | "status" | "resolved" | "viewCount" | "participantCount" | "createdAt" | "updatedAt", ExtArgs["result"]["mABattle"]>
  export type MABattleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    initiatorCard?: boolean | CardDefaultArgs<ExtArgs>
    targetCard?: boolean | CardDefaultArgs<ExtArgs>
    initiator?: boolean | UserDefaultArgs<ExtArgs>
    target?: boolean | MABattle$targetArgs<ExtArgs>
    winner?: boolean | MABattle$winnerArgs<ExtArgs>
    proposals?: boolean | MABattle$proposalsArgs<ExtArgs>
    votes?: boolean | MABattle$votesArgs<ExtArgs>
    outcomes?: boolean | MABattle$outcomesArgs<ExtArgs>
    _count?: boolean | MABattleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MABattleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    initiatorCard?: boolean | CardDefaultArgs<ExtArgs>
    targetCard?: boolean | CardDefaultArgs<ExtArgs>
    initiator?: boolean | UserDefaultArgs<ExtArgs>
    target?: boolean | MABattle$targetArgs<ExtArgs>
  }
  export type MABattleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    initiatorCard?: boolean | CardDefaultArgs<ExtArgs>
    targetCard?: boolean | CardDefaultArgs<ExtArgs>
    initiator?: boolean | UserDefaultArgs<ExtArgs>
    target?: boolean | MABattle$targetArgs<ExtArgs>
  }

  export type $MABattlePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MABattle"
    objects: {
      initiatorCard: Prisma.$CardPayload<ExtArgs>
      targetCard: Prisma.$CardPayload<ExtArgs>
      initiator: Prisma.$UserPayload<ExtArgs>
      target: Prisma.$UserPayload<ExtArgs> | null
      winner: Prisma.$BattleOutcomePayload<ExtArgs> | null
      proposals: Prisma.$BattleProposalPayload<ExtArgs>[]
      votes: Prisma.$BattleVotingPayload<ExtArgs>[]
      outcomes: Prisma.$BattleOutcomePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      initiatorCardId: string
      targetCardId: string
      initiatorUserId: string
      targetUserId: string | null
      battleType: $Enums.BattleType
      title: string
      description: string
      stakes: number
      timeline: Date
      votingPeriod: Date
      status: $Enums.BattleStatus
      resolved: boolean
      viewCount: number
      participantCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["mABattle"]>
    composites: {}
  }

  type MABattleGetPayload<S extends boolean | null | undefined | MABattleDefaultArgs> = $Result.GetResult<Prisma.$MABattlePayload, S>

  type MABattleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MABattleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MABattleCountAggregateInputType | true
    }

  export interface MABattleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MABattle'], meta: { name: 'MABattle' } }
    /**
     * Find zero or one MABattle that matches the filter.
     * @param {MABattleFindUniqueArgs} args - Arguments to find a MABattle
     * @example
     * // Get one MABattle
     * const mABattle = await prisma.mABattle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MABattleFindUniqueArgs>(args: SelectSubset<T, MABattleFindUniqueArgs<ExtArgs>>): Prisma__MABattleClient<$Result.GetResult<Prisma.$MABattlePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MABattle that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MABattleFindUniqueOrThrowArgs} args - Arguments to find a MABattle
     * @example
     * // Get one MABattle
     * const mABattle = await prisma.mABattle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MABattleFindUniqueOrThrowArgs>(args: SelectSubset<T, MABattleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MABattleClient<$Result.GetResult<Prisma.$MABattlePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MABattle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MABattleFindFirstArgs} args - Arguments to find a MABattle
     * @example
     * // Get one MABattle
     * const mABattle = await prisma.mABattle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MABattleFindFirstArgs>(args?: SelectSubset<T, MABattleFindFirstArgs<ExtArgs>>): Prisma__MABattleClient<$Result.GetResult<Prisma.$MABattlePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MABattle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MABattleFindFirstOrThrowArgs} args - Arguments to find a MABattle
     * @example
     * // Get one MABattle
     * const mABattle = await prisma.mABattle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MABattleFindFirstOrThrowArgs>(args?: SelectSubset<T, MABattleFindFirstOrThrowArgs<ExtArgs>>): Prisma__MABattleClient<$Result.GetResult<Prisma.$MABattlePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MABattles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MABattleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MABattles
     * const mABattles = await prisma.mABattle.findMany()
     * 
     * // Get first 10 MABattles
     * const mABattles = await prisma.mABattle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mABattleWithIdOnly = await prisma.mABattle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MABattleFindManyArgs>(args?: SelectSubset<T, MABattleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MABattlePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MABattle.
     * @param {MABattleCreateArgs} args - Arguments to create a MABattle.
     * @example
     * // Create one MABattle
     * const MABattle = await prisma.mABattle.create({
     *   data: {
     *     // ... data to create a MABattle
     *   }
     * })
     * 
     */
    create<T extends MABattleCreateArgs>(args: SelectSubset<T, MABattleCreateArgs<ExtArgs>>): Prisma__MABattleClient<$Result.GetResult<Prisma.$MABattlePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MABattles.
     * @param {MABattleCreateManyArgs} args - Arguments to create many MABattles.
     * @example
     * // Create many MABattles
     * const mABattle = await prisma.mABattle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MABattleCreateManyArgs>(args?: SelectSubset<T, MABattleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MABattles and returns the data saved in the database.
     * @param {MABattleCreateManyAndReturnArgs} args - Arguments to create many MABattles.
     * @example
     * // Create many MABattles
     * const mABattle = await prisma.mABattle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MABattles and only return the `id`
     * const mABattleWithIdOnly = await prisma.mABattle.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MABattleCreateManyAndReturnArgs>(args?: SelectSubset<T, MABattleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MABattlePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MABattle.
     * @param {MABattleDeleteArgs} args - Arguments to delete one MABattle.
     * @example
     * // Delete one MABattle
     * const MABattle = await prisma.mABattle.delete({
     *   where: {
     *     // ... filter to delete one MABattle
     *   }
     * })
     * 
     */
    delete<T extends MABattleDeleteArgs>(args: SelectSubset<T, MABattleDeleteArgs<ExtArgs>>): Prisma__MABattleClient<$Result.GetResult<Prisma.$MABattlePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MABattle.
     * @param {MABattleUpdateArgs} args - Arguments to update one MABattle.
     * @example
     * // Update one MABattle
     * const mABattle = await prisma.mABattle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MABattleUpdateArgs>(args: SelectSubset<T, MABattleUpdateArgs<ExtArgs>>): Prisma__MABattleClient<$Result.GetResult<Prisma.$MABattlePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MABattles.
     * @param {MABattleDeleteManyArgs} args - Arguments to filter MABattles to delete.
     * @example
     * // Delete a few MABattles
     * const { count } = await prisma.mABattle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MABattleDeleteManyArgs>(args?: SelectSubset<T, MABattleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MABattles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MABattleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MABattles
     * const mABattle = await prisma.mABattle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MABattleUpdateManyArgs>(args: SelectSubset<T, MABattleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MABattles and returns the data updated in the database.
     * @param {MABattleUpdateManyAndReturnArgs} args - Arguments to update many MABattles.
     * @example
     * // Update many MABattles
     * const mABattle = await prisma.mABattle.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MABattles and only return the `id`
     * const mABattleWithIdOnly = await prisma.mABattle.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MABattleUpdateManyAndReturnArgs>(args: SelectSubset<T, MABattleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MABattlePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MABattle.
     * @param {MABattleUpsertArgs} args - Arguments to update or create a MABattle.
     * @example
     * // Update or create a MABattle
     * const mABattle = await prisma.mABattle.upsert({
     *   create: {
     *     // ... data to create a MABattle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MABattle we want to update
     *   }
     * })
     */
    upsert<T extends MABattleUpsertArgs>(args: SelectSubset<T, MABattleUpsertArgs<ExtArgs>>): Prisma__MABattleClient<$Result.GetResult<Prisma.$MABattlePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MABattles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MABattleCountArgs} args - Arguments to filter MABattles to count.
     * @example
     * // Count the number of MABattles
     * const count = await prisma.mABattle.count({
     *   where: {
     *     // ... the filter for the MABattles we want to count
     *   }
     * })
    **/
    count<T extends MABattleCountArgs>(
      args?: Subset<T, MABattleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MABattleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MABattle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MABattleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MABattleAggregateArgs>(args: Subset<T, MABattleAggregateArgs>): Prisma.PrismaPromise<GetMABattleAggregateType<T>>

    /**
     * Group by MABattle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MABattleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MABattleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MABattleGroupByArgs['orderBy'] }
        : { orderBy?: MABattleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MABattleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMABattleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MABattle model
   */
  readonly fields: MABattleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MABattle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MABattleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    initiatorCard<T extends CardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CardDefaultArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    targetCard<T extends CardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CardDefaultArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    initiator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    target<T extends MABattle$targetArgs<ExtArgs> = {}>(args?: Subset<T, MABattle$targetArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    winner<T extends MABattle$winnerArgs<ExtArgs> = {}>(args?: Subset<T, MABattle$winnerArgs<ExtArgs>>): Prisma__BattleOutcomeClient<$Result.GetResult<Prisma.$BattleOutcomePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    proposals<T extends MABattle$proposalsArgs<ExtArgs> = {}>(args?: Subset<T, MABattle$proposalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BattleProposalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    votes<T extends MABattle$votesArgs<ExtArgs> = {}>(args?: Subset<T, MABattle$votesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BattleVotingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    outcomes<T extends MABattle$outcomesArgs<ExtArgs> = {}>(args?: Subset<T, MABattle$outcomesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BattleOutcomePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MABattle model
   */
  interface MABattleFieldRefs {
    readonly id: FieldRef<"MABattle", 'String'>
    readonly initiatorCardId: FieldRef<"MABattle", 'String'>
    readonly targetCardId: FieldRef<"MABattle", 'String'>
    readonly initiatorUserId: FieldRef<"MABattle", 'String'>
    readonly targetUserId: FieldRef<"MABattle", 'String'>
    readonly battleType: FieldRef<"MABattle", 'BattleType'>
    readonly title: FieldRef<"MABattle", 'String'>
    readonly description: FieldRef<"MABattle", 'String'>
    readonly stakes: FieldRef<"MABattle", 'Float'>
    readonly timeline: FieldRef<"MABattle", 'DateTime'>
    readonly votingPeriod: FieldRef<"MABattle", 'DateTime'>
    readonly status: FieldRef<"MABattle", 'BattleStatus'>
    readonly resolved: FieldRef<"MABattle", 'Boolean'>
    readonly viewCount: FieldRef<"MABattle", 'Int'>
    readonly participantCount: FieldRef<"MABattle", 'Int'>
    readonly createdAt: FieldRef<"MABattle", 'DateTime'>
    readonly updatedAt: FieldRef<"MABattle", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MABattle findUnique
   */
  export type MABattleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MABattle
     */
    select?: MABattleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MABattle
     */
    omit?: MABattleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MABattleInclude<ExtArgs> | null
    /**
     * Filter, which MABattle to fetch.
     */
    where: MABattleWhereUniqueInput
  }

  /**
   * MABattle findUniqueOrThrow
   */
  export type MABattleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MABattle
     */
    select?: MABattleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MABattle
     */
    omit?: MABattleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MABattleInclude<ExtArgs> | null
    /**
     * Filter, which MABattle to fetch.
     */
    where: MABattleWhereUniqueInput
  }

  /**
   * MABattle findFirst
   */
  export type MABattleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MABattle
     */
    select?: MABattleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MABattle
     */
    omit?: MABattleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MABattleInclude<ExtArgs> | null
    /**
     * Filter, which MABattle to fetch.
     */
    where?: MABattleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MABattles to fetch.
     */
    orderBy?: MABattleOrderByWithRelationInput | MABattleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MABattles.
     */
    cursor?: MABattleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MABattles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MABattles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MABattles.
     */
    distinct?: MABattleScalarFieldEnum | MABattleScalarFieldEnum[]
  }

  /**
   * MABattle findFirstOrThrow
   */
  export type MABattleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MABattle
     */
    select?: MABattleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MABattle
     */
    omit?: MABattleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MABattleInclude<ExtArgs> | null
    /**
     * Filter, which MABattle to fetch.
     */
    where?: MABattleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MABattles to fetch.
     */
    orderBy?: MABattleOrderByWithRelationInput | MABattleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MABattles.
     */
    cursor?: MABattleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MABattles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MABattles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MABattles.
     */
    distinct?: MABattleScalarFieldEnum | MABattleScalarFieldEnum[]
  }

  /**
   * MABattle findMany
   */
  export type MABattleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MABattle
     */
    select?: MABattleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MABattle
     */
    omit?: MABattleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MABattleInclude<ExtArgs> | null
    /**
     * Filter, which MABattles to fetch.
     */
    where?: MABattleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MABattles to fetch.
     */
    orderBy?: MABattleOrderByWithRelationInput | MABattleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MABattles.
     */
    cursor?: MABattleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MABattles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MABattles.
     */
    skip?: number
    distinct?: MABattleScalarFieldEnum | MABattleScalarFieldEnum[]
  }

  /**
   * MABattle create
   */
  export type MABattleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MABattle
     */
    select?: MABattleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MABattle
     */
    omit?: MABattleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MABattleInclude<ExtArgs> | null
    /**
     * The data needed to create a MABattle.
     */
    data: XOR<MABattleCreateInput, MABattleUncheckedCreateInput>
  }

  /**
   * MABattle createMany
   */
  export type MABattleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MABattles.
     */
    data: MABattleCreateManyInput | MABattleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MABattle createManyAndReturn
   */
  export type MABattleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MABattle
     */
    select?: MABattleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MABattle
     */
    omit?: MABattleOmit<ExtArgs> | null
    /**
     * The data used to create many MABattles.
     */
    data: MABattleCreateManyInput | MABattleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MABattleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MABattle update
   */
  export type MABattleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MABattle
     */
    select?: MABattleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MABattle
     */
    omit?: MABattleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MABattleInclude<ExtArgs> | null
    /**
     * The data needed to update a MABattle.
     */
    data: XOR<MABattleUpdateInput, MABattleUncheckedUpdateInput>
    /**
     * Choose, which MABattle to update.
     */
    where: MABattleWhereUniqueInput
  }

  /**
   * MABattle updateMany
   */
  export type MABattleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MABattles.
     */
    data: XOR<MABattleUpdateManyMutationInput, MABattleUncheckedUpdateManyInput>
    /**
     * Filter which MABattles to update
     */
    where?: MABattleWhereInput
    /**
     * Limit how many MABattles to update.
     */
    limit?: number
  }

  /**
   * MABattle updateManyAndReturn
   */
  export type MABattleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MABattle
     */
    select?: MABattleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MABattle
     */
    omit?: MABattleOmit<ExtArgs> | null
    /**
     * The data used to update MABattles.
     */
    data: XOR<MABattleUpdateManyMutationInput, MABattleUncheckedUpdateManyInput>
    /**
     * Filter which MABattles to update
     */
    where?: MABattleWhereInput
    /**
     * Limit how many MABattles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MABattleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MABattle upsert
   */
  export type MABattleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MABattle
     */
    select?: MABattleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MABattle
     */
    omit?: MABattleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MABattleInclude<ExtArgs> | null
    /**
     * The filter to search for the MABattle to update in case it exists.
     */
    where: MABattleWhereUniqueInput
    /**
     * In case the MABattle found by the `where` argument doesn't exist, create a new MABattle with this data.
     */
    create: XOR<MABattleCreateInput, MABattleUncheckedCreateInput>
    /**
     * In case the MABattle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MABattleUpdateInput, MABattleUncheckedUpdateInput>
  }

  /**
   * MABattle delete
   */
  export type MABattleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MABattle
     */
    select?: MABattleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MABattle
     */
    omit?: MABattleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MABattleInclude<ExtArgs> | null
    /**
     * Filter which MABattle to delete.
     */
    where: MABattleWhereUniqueInput
  }

  /**
   * MABattle deleteMany
   */
  export type MABattleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MABattles to delete
     */
    where?: MABattleWhereInput
    /**
     * Limit how many MABattles to delete.
     */
    limit?: number
  }

  /**
   * MABattle.target
   */
  export type MABattle$targetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * MABattle.winner
   */
  export type MABattle$winnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BattleOutcome
     */
    select?: BattleOutcomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BattleOutcome
     */
    omit?: BattleOutcomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleOutcomeInclude<ExtArgs> | null
    where?: BattleOutcomeWhereInput
  }

  /**
   * MABattle.proposals
   */
  export type MABattle$proposalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BattleProposal
     */
    select?: BattleProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BattleProposal
     */
    omit?: BattleProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleProposalInclude<ExtArgs> | null
    where?: BattleProposalWhereInput
    orderBy?: BattleProposalOrderByWithRelationInput | BattleProposalOrderByWithRelationInput[]
    cursor?: BattleProposalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BattleProposalScalarFieldEnum | BattleProposalScalarFieldEnum[]
  }

  /**
   * MABattle.votes
   */
  export type MABattle$votesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BattleVoting
     */
    select?: BattleVotingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BattleVoting
     */
    omit?: BattleVotingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleVotingInclude<ExtArgs> | null
    where?: BattleVotingWhereInput
    orderBy?: BattleVotingOrderByWithRelationInput | BattleVotingOrderByWithRelationInput[]
    cursor?: BattleVotingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BattleVotingScalarFieldEnum | BattleVotingScalarFieldEnum[]
  }

  /**
   * MABattle.outcomes
   */
  export type MABattle$outcomesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BattleOutcome
     */
    select?: BattleOutcomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BattleOutcome
     */
    omit?: BattleOutcomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleOutcomeInclude<ExtArgs> | null
    where?: BattleOutcomeWhereInput
    orderBy?: BattleOutcomeOrderByWithRelationInput | BattleOutcomeOrderByWithRelationInput[]
    cursor?: BattleOutcomeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BattleOutcomeScalarFieldEnum | BattleOutcomeScalarFieldEnum[]
  }

  /**
   * MABattle without action
   */
  export type MABattleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MABattle
     */
    select?: MABattleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MABattle
     */
    omit?: MABattleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MABattleInclude<ExtArgs> | null
  }


  /**
   * Model BattleProposal
   */

  export type AggregateBattleProposal = {
    _count: BattleProposalCountAggregateOutputType | null
    _avg: BattleProposalAvgAggregateOutputType | null
    _sum: BattleProposalSumAggregateOutputType | null
    _min: BattleProposalMinAggregateOutputType | null
    _max: BattleProposalMaxAggregateOutputType | null
  }

  export type BattleProposalAvgAggregateOutputType = {
    valuation: number | null
  }

  export type BattleProposalSumAggregateOutputType = {
    valuation: number | null
  }

  export type BattleProposalMinAggregateOutputType = {
    id: string | null
    battleId: string | null
    proposerId: string | null
    proposalType: $Enums.ProposalType | null
    title: string | null
    description: string | null
    valuation: number | null
    status: $Enums.ProposalStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BattleProposalMaxAggregateOutputType = {
    id: string | null
    battleId: string | null
    proposerId: string | null
    proposalType: $Enums.ProposalType | null
    title: string | null
    description: string | null
    valuation: number | null
    status: $Enums.ProposalStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BattleProposalCountAggregateOutputType = {
    id: number
    battleId: number
    proposerId: number
    proposalType: number
    title: number
    description: number
    terms: number
    valuation: number
    paymentStructure: number
    timeline: number
    synergies: number
    conditions: number
    contingencies: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BattleProposalAvgAggregateInputType = {
    valuation?: true
  }

  export type BattleProposalSumAggregateInputType = {
    valuation?: true
  }

  export type BattleProposalMinAggregateInputType = {
    id?: true
    battleId?: true
    proposerId?: true
    proposalType?: true
    title?: true
    description?: true
    valuation?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BattleProposalMaxAggregateInputType = {
    id?: true
    battleId?: true
    proposerId?: true
    proposalType?: true
    title?: true
    description?: true
    valuation?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BattleProposalCountAggregateInputType = {
    id?: true
    battleId?: true
    proposerId?: true
    proposalType?: true
    title?: true
    description?: true
    terms?: true
    valuation?: true
    paymentStructure?: true
    timeline?: true
    synergies?: true
    conditions?: true
    contingencies?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BattleProposalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BattleProposal to aggregate.
     */
    where?: BattleProposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BattleProposals to fetch.
     */
    orderBy?: BattleProposalOrderByWithRelationInput | BattleProposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BattleProposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BattleProposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BattleProposals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BattleProposals
    **/
    _count?: true | BattleProposalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BattleProposalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BattleProposalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BattleProposalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BattleProposalMaxAggregateInputType
  }

  export type GetBattleProposalAggregateType<T extends BattleProposalAggregateArgs> = {
        [P in keyof T & keyof AggregateBattleProposal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBattleProposal[P]>
      : GetScalarType<T[P], AggregateBattleProposal[P]>
  }




  export type BattleProposalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BattleProposalWhereInput
    orderBy?: BattleProposalOrderByWithAggregationInput | BattleProposalOrderByWithAggregationInput[]
    by: BattleProposalScalarFieldEnum[] | BattleProposalScalarFieldEnum
    having?: BattleProposalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BattleProposalCountAggregateInputType | true
    _avg?: BattleProposalAvgAggregateInputType
    _sum?: BattleProposalSumAggregateInputType
    _min?: BattleProposalMinAggregateInputType
    _max?: BattleProposalMaxAggregateInputType
  }

  export type BattleProposalGroupByOutputType = {
    id: string
    battleId: string
    proposerId: string
    proposalType: $Enums.ProposalType
    title: string
    description: string
    terms: JsonValue
    valuation: number
    paymentStructure: JsonValue
    timeline: JsonValue
    synergies: JsonValue
    conditions: JsonValue
    contingencies: JsonValue
    status: $Enums.ProposalStatus
    createdAt: Date
    updatedAt: Date
    _count: BattleProposalCountAggregateOutputType | null
    _avg: BattleProposalAvgAggregateOutputType | null
    _sum: BattleProposalSumAggregateOutputType | null
    _min: BattleProposalMinAggregateOutputType | null
    _max: BattleProposalMaxAggregateOutputType | null
  }

  type GetBattleProposalGroupByPayload<T extends BattleProposalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BattleProposalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BattleProposalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BattleProposalGroupByOutputType[P]>
            : GetScalarType<T[P], BattleProposalGroupByOutputType[P]>
        }
      >
    >


  export type BattleProposalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    battleId?: boolean
    proposerId?: boolean
    proposalType?: boolean
    title?: boolean
    description?: boolean
    terms?: boolean
    valuation?: boolean
    paymentStructure?: boolean
    timeline?: boolean
    synergies?: boolean
    conditions?: boolean
    contingencies?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    battle?: boolean | MABattleDefaultArgs<ExtArgs>
    proposer?: boolean | UserDefaultArgs<ExtArgs>
    votes?: boolean | BattleProposal$votesArgs<ExtArgs>
    _count?: boolean | BattleProposalCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["battleProposal"]>

  export type BattleProposalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    battleId?: boolean
    proposerId?: boolean
    proposalType?: boolean
    title?: boolean
    description?: boolean
    terms?: boolean
    valuation?: boolean
    paymentStructure?: boolean
    timeline?: boolean
    synergies?: boolean
    conditions?: boolean
    contingencies?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    battle?: boolean | MABattleDefaultArgs<ExtArgs>
    proposer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["battleProposal"]>

  export type BattleProposalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    battleId?: boolean
    proposerId?: boolean
    proposalType?: boolean
    title?: boolean
    description?: boolean
    terms?: boolean
    valuation?: boolean
    paymentStructure?: boolean
    timeline?: boolean
    synergies?: boolean
    conditions?: boolean
    contingencies?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    battle?: boolean | MABattleDefaultArgs<ExtArgs>
    proposer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["battleProposal"]>

  export type BattleProposalSelectScalar = {
    id?: boolean
    battleId?: boolean
    proposerId?: boolean
    proposalType?: boolean
    title?: boolean
    description?: boolean
    terms?: boolean
    valuation?: boolean
    paymentStructure?: boolean
    timeline?: boolean
    synergies?: boolean
    conditions?: boolean
    contingencies?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BattleProposalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "battleId" | "proposerId" | "proposalType" | "title" | "description" | "terms" | "valuation" | "paymentStructure" | "timeline" | "synergies" | "conditions" | "contingencies" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["battleProposal"]>
  export type BattleProposalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    battle?: boolean | MABattleDefaultArgs<ExtArgs>
    proposer?: boolean | UserDefaultArgs<ExtArgs>
    votes?: boolean | BattleProposal$votesArgs<ExtArgs>
    _count?: boolean | BattleProposalCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BattleProposalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    battle?: boolean | MABattleDefaultArgs<ExtArgs>
    proposer?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BattleProposalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    battle?: boolean | MABattleDefaultArgs<ExtArgs>
    proposer?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BattleProposalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BattleProposal"
    objects: {
      battle: Prisma.$MABattlePayload<ExtArgs>
      proposer: Prisma.$UserPayload<ExtArgs>
      votes: Prisma.$BattleVotingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      battleId: string
      proposerId: string
      proposalType: $Enums.ProposalType
      title: string
      description: string
      terms: Prisma.JsonValue
      valuation: number
      paymentStructure: Prisma.JsonValue
      timeline: Prisma.JsonValue
      synergies: Prisma.JsonValue
      conditions: Prisma.JsonValue
      contingencies: Prisma.JsonValue
      status: $Enums.ProposalStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["battleProposal"]>
    composites: {}
  }

  type BattleProposalGetPayload<S extends boolean | null | undefined | BattleProposalDefaultArgs> = $Result.GetResult<Prisma.$BattleProposalPayload, S>

  type BattleProposalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BattleProposalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BattleProposalCountAggregateInputType | true
    }

  export interface BattleProposalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BattleProposal'], meta: { name: 'BattleProposal' } }
    /**
     * Find zero or one BattleProposal that matches the filter.
     * @param {BattleProposalFindUniqueArgs} args - Arguments to find a BattleProposal
     * @example
     * // Get one BattleProposal
     * const battleProposal = await prisma.battleProposal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BattleProposalFindUniqueArgs>(args: SelectSubset<T, BattleProposalFindUniqueArgs<ExtArgs>>): Prisma__BattleProposalClient<$Result.GetResult<Prisma.$BattleProposalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BattleProposal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BattleProposalFindUniqueOrThrowArgs} args - Arguments to find a BattleProposal
     * @example
     * // Get one BattleProposal
     * const battleProposal = await prisma.battleProposal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BattleProposalFindUniqueOrThrowArgs>(args: SelectSubset<T, BattleProposalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BattleProposalClient<$Result.GetResult<Prisma.$BattleProposalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BattleProposal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BattleProposalFindFirstArgs} args - Arguments to find a BattleProposal
     * @example
     * // Get one BattleProposal
     * const battleProposal = await prisma.battleProposal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BattleProposalFindFirstArgs>(args?: SelectSubset<T, BattleProposalFindFirstArgs<ExtArgs>>): Prisma__BattleProposalClient<$Result.GetResult<Prisma.$BattleProposalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BattleProposal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BattleProposalFindFirstOrThrowArgs} args - Arguments to find a BattleProposal
     * @example
     * // Get one BattleProposal
     * const battleProposal = await prisma.battleProposal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BattleProposalFindFirstOrThrowArgs>(args?: SelectSubset<T, BattleProposalFindFirstOrThrowArgs<ExtArgs>>): Prisma__BattleProposalClient<$Result.GetResult<Prisma.$BattleProposalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BattleProposals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BattleProposalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BattleProposals
     * const battleProposals = await prisma.battleProposal.findMany()
     * 
     * // Get first 10 BattleProposals
     * const battleProposals = await prisma.battleProposal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const battleProposalWithIdOnly = await prisma.battleProposal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BattleProposalFindManyArgs>(args?: SelectSubset<T, BattleProposalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BattleProposalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BattleProposal.
     * @param {BattleProposalCreateArgs} args - Arguments to create a BattleProposal.
     * @example
     * // Create one BattleProposal
     * const BattleProposal = await prisma.battleProposal.create({
     *   data: {
     *     // ... data to create a BattleProposal
     *   }
     * })
     * 
     */
    create<T extends BattleProposalCreateArgs>(args: SelectSubset<T, BattleProposalCreateArgs<ExtArgs>>): Prisma__BattleProposalClient<$Result.GetResult<Prisma.$BattleProposalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BattleProposals.
     * @param {BattleProposalCreateManyArgs} args - Arguments to create many BattleProposals.
     * @example
     * // Create many BattleProposals
     * const battleProposal = await prisma.battleProposal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BattleProposalCreateManyArgs>(args?: SelectSubset<T, BattleProposalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BattleProposals and returns the data saved in the database.
     * @param {BattleProposalCreateManyAndReturnArgs} args - Arguments to create many BattleProposals.
     * @example
     * // Create many BattleProposals
     * const battleProposal = await prisma.battleProposal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BattleProposals and only return the `id`
     * const battleProposalWithIdOnly = await prisma.battleProposal.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BattleProposalCreateManyAndReturnArgs>(args?: SelectSubset<T, BattleProposalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BattleProposalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BattleProposal.
     * @param {BattleProposalDeleteArgs} args - Arguments to delete one BattleProposal.
     * @example
     * // Delete one BattleProposal
     * const BattleProposal = await prisma.battleProposal.delete({
     *   where: {
     *     // ... filter to delete one BattleProposal
     *   }
     * })
     * 
     */
    delete<T extends BattleProposalDeleteArgs>(args: SelectSubset<T, BattleProposalDeleteArgs<ExtArgs>>): Prisma__BattleProposalClient<$Result.GetResult<Prisma.$BattleProposalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BattleProposal.
     * @param {BattleProposalUpdateArgs} args - Arguments to update one BattleProposal.
     * @example
     * // Update one BattleProposal
     * const battleProposal = await prisma.battleProposal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BattleProposalUpdateArgs>(args: SelectSubset<T, BattleProposalUpdateArgs<ExtArgs>>): Prisma__BattleProposalClient<$Result.GetResult<Prisma.$BattleProposalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BattleProposals.
     * @param {BattleProposalDeleteManyArgs} args - Arguments to filter BattleProposals to delete.
     * @example
     * // Delete a few BattleProposals
     * const { count } = await prisma.battleProposal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BattleProposalDeleteManyArgs>(args?: SelectSubset<T, BattleProposalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BattleProposals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BattleProposalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BattleProposals
     * const battleProposal = await prisma.battleProposal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BattleProposalUpdateManyArgs>(args: SelectSubset<T, BattleProposalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BattleProposals and returns the data updated in the database.
     * @param {BattleProposalUpdateManyAndReturnArgs} args - Arguments to update many BattleProposals.
     * @example
     * // Update many BattleProposals
     * const battleProposal = await prisma.battleProposal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BattleProposals and only return the `id`
     * const battleProposalWithIdOnly = await prisma.battleProposal.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BattleProposalUpdateManyAndReturnArgs>(args: SelectSubset<T, BattleProposalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BattleProposalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BattleProposal.
     * @param {BattleProposalUpsertArgs} args - Arguments to update or create a BattleProposal.
     * @example
     * // Update or create a BattleProposal
     * const battleProposal = await prisma.battleProposal.upsert({
     *   create: {
     *     // ... data to create a BattleProposal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BattleProposal we want to update
     *   }
     * })
     */
    upsert<T extends BattleProposalUpsertArgs>(args: SelectSubset<T, BattleProposalUpsertArgs<ExtArgs>>): Prisma__BattleProposalClient<$Result.GetResult<Prisma.$BattleProposalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BattleProposals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BattleProposalCountArgs} args - Arguments to filter BattleProposals to count.
     * @example
     * // Count the number of BattleProposals
     * const count = await prisma.battleProposal.count({
     *   where: {
     *     // ... the filter for the BattleProposals we want to count
     *   }
     * })
    **/
    count<T extends BattleProposalCountArgs>(
      args?: Subset<T, BattleProposalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BattleProposalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BattleProposal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BattleProposalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BattleProposalAggregateArgs>(args: Subset<T, BattleProposalAggregateArgs>): Prisma.PrismaPromise<GetBattleProposalAggregateType<T>>

    /**
     * Group by BattleProposal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BattleProposalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BattleProposalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BattleProposalGroupByArgs['orderBy'] }
        : { orderBy?: BattleProposalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BattleProposalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBattleProposalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BattleProposal model
   */
  readonly fields: BattleProposalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BattleProposal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BattleProposalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    battle<T extends MABattleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MABattleDefaultArgs<ExtArgs>>): Prisma__MABattleClient<$Result.GetResult<Prisma.$MABattlePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    proposer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    votes<T extends BattleProposal$votesArgs<ExtArgs> = {}>(args?: Subset<T, BattleProposal$votesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BattleVotingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BattleProposal model
   */
  interface BattleProposalFieldRefs {
    readonly id: FieldRef<"BattleProposal", 'String'>
    readonly battleId: FieldRef<"BattleProposal", 'String'>
    readonly proposerId: FieldRef<"BattleProposal", 'String'>
    readonly proposalType: FieldRef<"BattleProposal", 'ProposalType'>
    readonly title: FieldRef<"BattleProposal", 'String'>
    readonly description: FieldRef<"BattleProposal", 'String'>
    readonly terms: FieldRef<"BattleProposal", 'Json'>
    readonly valuation: FieldRef<"BattleProposal", 'Float'>
    readonly paymentStructure: FieldRef<"BattleProposal", 'Json'>
    readonly timeline: FieldRef<"BattleProposal", 'Json'>
    readonly synergies: FieldRef<"BattleProposal", 'Json'>
    readonly conditions: FieldRef<"BattleProposal", 'Json'>
    readonly contingencies: FieldRef<"BattleProposal", 'Json'>
    readonly status: FieldRef<"BattleProposal", 'ProposalStatus'>
    readonly createdAt: FieldRef<"BattleProposal", 'DateTime'>
    readonly updatedAt: FieldRef<"BattleProposal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BattleProposal findUnique
   */
  export type BattleProposalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BattleProposal
     */
    select?: BattleProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BattleProposal
     */
    omit?: BattleProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleProposalInclude<ExtArgs> | null
    /**
     * Filter, which BattleProposal to fetch.
     */
    where: BattleProposalWhereUniqueInput
  }

  /**
   * BattleProposal findUniqueOrThrow
   */
  export type BattleProposalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BattleProposal
     */
    select?: BattleProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BattleProposal
     */
    omit?: BattleProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleProposalInclude<ExtArgs> | null
    /**
     * Filter, which BattleProposal to fetch.
     */
    where: BattleProposalWhereUniqueInput
  }

  /**
   * BattleProposal findFirst
   */
  export type BattleProposalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BattleProposal
     */
    select?: BattleProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BattleProposal
     */
    omit?: BattleProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleProposalInclude<ExtArgs> | null
    /**
     * Filter, which BattleProposal to fetch.
     */
    where?: BattleProposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BattleProposals to fetch.
     */
    orderBy?: BattleProposalOrderByWithRelationInput | BattleProposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BattleProposals.
     */
    cursor?: BattleProposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BattleProposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BattleProposals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BattleProposals.
     */
    distinct?: BattleProposalScalarFieldEnum | BattleProposalScalarFieldEnum[]
  }

  /**
   * BattleProposal findFirstOrThrow
   */
  export type BattleProposalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BattleProposal
     */
    select?: BattleProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BattleProposal
     */
    omit?: BattleProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleProposalInclude<ExtArgs> | null
    /**
     * Filter, which BattleProposal to fetch.
     */
    where?: BattleProposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BattleProposals to fetch.
     */
    orderBy?: BattleProposalOrderByWithRelationInput | BattleProposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BattleProposals.
     */
    cursor?: BattleProposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BattleProposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BattleProposals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BattleProposals.
     */
    distinct?: BattleProposalScalarFieldEnum | BattleProposalScalarFieldEnum[]
  }

  /**
   * BattleProposal findMany
   */
  export type BattleProposalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BattleProposal
     */
    select?: BattleProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BattleProposal
     */
    omit?: BattleProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleProposalInclude<ExtArgs> | null
    /**
     * Filter, which BattleProposals to fetch.
     */
    where?: BattleProposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BattleProposals to fetch.
     */
    orderBy?: BattleProposalOrderByWithRelationInput | BattleProposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BattleProposals.
     */
    cursor?: BattleProposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BattleProposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BattleProposals.
     */
    skip?: number
    distinct?: BattleProposalScalarFieldEnum | BattleProposalScalarFieldEnum[]
  }

  /**
   * BattleProposal create
   */
  export type BattleProposalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BattleProposal
     */
    select?: BattleProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BattleProposal
     */
    omit?: BattleProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleProposalInclude<ExtArgs> | null
    /**
     * The data needed to create a BattleProposal.
     */
    data: XOR<BattleProposalCreateInput, BattleProposalUncheckedCreateInput>
  }

  /**
   * BattleProposal createMany
   */
  export type BattleProposalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BattleProposals.
     */
    data: BattleProposalCreateManyInput | BattleProposalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BattleProposal createManyAndReturn
   */
  export type BattleProposalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BattleProposal
     */
    select?: BattleProposalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BattleProposal
     */
    omit?: BattleProposalOmit<ExtArgs> | null
    /**
     * The data used to create many BattleProposals.
     */
    data: BattleProposalCreateManyInput | BattleProposalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleProposalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BattleProposal update
   */
  export type BattleProposalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BattleProposal
     */
    select?: BattleProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BattleProposal
     */
    omit?: BattleProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleProposalInclude<ExtArgs> | null
    /**
     * The data needed to update a BattleProposal.
     */
    data: XOR<BattleProposalUpdateInput, BattleProposalUncheckedUpdateInput>
    /**
     * Choose, which BattleProposal to update.
     */
    where: BattleProposalWhereUniqueInput
  }

  /**
   * BattleProposal updateMany
   */
  export type BattleProposalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BattleProposals.
     */
    data: XOR<BattleProposalUpdateManyMutationInput, BattleProposalUncheckedUpdateManyInput>
    /**
     * Filter which BattleProposals to update
     */
    where?: BattleProposalWhereInput
    /**
     * Limit how many BattleProposals to update.
     */
    limit?: number
  }

  /**
   * BattleProposal updateManyAndReturn
   */
  export type BattleProposalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BattleProposal
     */
    select?: BattleProposalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BattleProposal
     */
    omit?: BattleProposalOmit<ExtArgs> | null
    /**
     * The data used to update BattleProposals.
     */
    data: XOR<BattleProposalUpdateManyMutationInput, BattleProposalUncheckedUpdateManyInput>
    /**
     * Filter which BattleProposals to update
     */
    where?: BattleProposalWhereInput
    /**
     * Limit how many BattleProposals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleProposalIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BattleProposal upsert
   */
  export type BattleProposalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BattleProposal
     */
    select?: BattleProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BattleProposal
     */
    omit?: BattleProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleProposalInclude<ExtArgs> | null
    /**
     * The filter to search for the BattleProposal to update in case it exists.
     */
    where: BattleProposalWhereUniqueInput
    /**
     * In case the BattleProposal found by the `where` argument doesn't exist, create a new BattleProposal with this data.
     */
    create: XOR<BattleProposalCreateInput, BattleProposalUncheckedCreateInput>
    /**
     * In case the BattleProposal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BattleProposalUpdateInput, BattleProposalUncheckedUpdateInput>
  }

  /**
   * BattleProposal delete
   */
  export type BattleProposalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BattleProposal
     */
    select?: BattleProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BattleProposal
     */
    omit?: BattleProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleProposalInclude<ExtArgs> | null
    /**
     * Filter which BattleProposal to delete.
     */
    where: BattleProposalWhereUniqueInput
  }

  /**
   * BattleProposal deleteMany
   */
  export type BattleProposalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BattleProposals to delete
     */
    where?: BattleProposalWhereInput
    /**
     * Limit how many BattleProposals to delete.
     */
    limit?: number
  }

  /**
   * BattleProposal.votes
   */
  export type BattleProposal$votesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BattleVoting
     */
    select?: BattleVotingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BattleVoting
     */
    omit?: BattleVotingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleVotingInclude<ExtArgs> | null
    where?: BattleVotingWhereInput
    orderBy?: BattleVotingOrderByWithRelationInput | BattleVotingOrderByWithRelationInput[]
    cursor?: BattleVotingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BattleVotingScalarFieldEnum | BattleVotingScalarFieldEnum[]
  }

  /**
   * BattleProposal without action
   */
  export type BattleProposalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BattleProposal
     */
    select?: BattleProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BattleProposal
     */
    omit?: BattleProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleProposalInclude<ExtArgs> | null
  }


  /**
   * Model BattleVoting
   */

  export type AggregateBattleVoting = {
    _count: BattleVotingCountAggregateOutputType | null
    _avg: BattleVotingAvgAggregateOutputType | null
    _sum: BattleVotingSumAggregateOutputType | null
    _min: BattleVotingMinAggregateOutputType | null
    _max: BattleVotingMaxAggregateOutputType | null
  }

  export type BattleVotingAvgAggregateOutputType = {
    voteWeight: number | null
    confidence: number | null
    eceStaked: number | null
    expertRating: number | null
    portfolioValue: number | null
  }

  export type BattleVotingSumAggregateOutputType = {
    voteWeight: number | null
    confidence: number | null
    eceStaked: number | null
    expertRating: number | null
    portfolioValue: number | null
  }

  export type BattleVotingMinAggregateOutputType = {
    id: string | null
    battleId: string | null
    proposalId: string | null
    voterId: string | null
    vote: $Enums.VoteDirection | null
    voteWeight: number | null
    reasoning: string | null
    confidence: number | null
    eceStaked: number | null
    expertRating: number | null
    portfolioValue: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BattleVotingMaxAggregateOutputType = {
    id: string | null
    battleId: string | null
    proposalId: string | null
    voterId: string | null
    vote: $Enums.VoteDirection | null
    voteWeight: number | null
    reasoning: string | null
    confidence: number | null
    eceStaked: number | null
    expertRating: number | null
    portfolioValue: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BattleVotingCountAggregateOutputType = {
    id: number
    battleId: number
    proposalId: number
    voterId: number
    vote: number
    voteWeight: number
    reasoning: number
    confidence: number
    eceStaked: number
    expertRating: number
    portfolioValue: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BattleVotingAvgAggregateInputType = {
    voteWeight?: true
    confidence?: true
    eceStaked?: true
    expertRating?: true
    portfolioValue?: true
  }

  export type BattleVotingSumAggregateInputType = {
    voteWeight?: true
    confidence?: true
    eceStaked?: true
    expertRating?: true
    portfolioValue?: true
  }

  export type BattleVotingMinAggregateInputType = {
    id?: true
    battleId?: true
    proposalId?: true
    voterId?: true
    vote?: true
    voteWeight?: true
    reasoning?: true
    confidence?: true
    eceStaked?: true
    expertRating?: true
    portfolioValue?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BattleVotingMaxAggregateInputType = {
    id?: true
    battleId?: true
    proposalId?: true
    voterId?: true
    vote?: true
    voteWeight?: true
    reasoning?: true
    confidence?: true
    eceStaked?: true
    expertRating?: true
    portfolioValue?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BattleVotingCountAggregateInputType = {
    id?: true
    battleId?: true
    proposalId?: true
    voterId?: true
    vote?: true
    voteWeight?: true
    reasoning?: true
    confidence?: true
    eceStaked?: true
    expertRating?: true
    portfolioValue?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BattleVotingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BattleVoting to aggregate.
     */
    where?: BattleVotingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BattleVotings to fetch.
     */
    orderBy?: BattleVotingOrderByWithRelationInput | BattleVotingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BattleVotingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BattleVotings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BattleVotings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BattleVotings
    **/
    _count?: true | BattleVotingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BattleVotingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BattleVotingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BattleVotingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BattleVotingMaxAggregateInputType
  }

  export type GetBattleVotingAggregateType<T extends BattleVotingAggregateArgs> = {
        [P in keyof T & keyof AggregateBattleVoting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBattleVoting[P]>
      : GetScalarType<T[P], AggregateBattleVoting[P]>
  }




  export type BattleVotingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BattleVotingWhereInput
    orderBy?: BattleVotingOrderByWithAggregationInput | BattleVotingOrderByWithAggregationInput[]
    by: BattleVotingScalarFieldEnum[] | BattleVotingScalarFieldEnum
    having?: BattleVotingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BattleVotingCountAggregateInputType | true
    _avg?: BattleVotingAvgAggregateInputType
    _sum?: BattleVotingSumAggregateInputType
    _min?: BattleVotingMinAggregateInputType
    _max?: BattleVotingMaxAggregateInputType
  }

  export type BattleVotingGroupByOutputType = {
    id: string
    battleId: string
    proposalId: string | null
    voterId: string
    vote: $Enums.VoteDirection
    voteWeight: number
    reasoning: string | null
    confidence: number | null
    eceStaked: number | null
    expertRating: number | null
    portfolioValue: number | null
    createdAt: Date
    updatedAt: Date
    _count: BattleVotingCountAggregateOutputType | null
    _avg: BattleVotingAvgAggregateOutputType | null
    _sum: BattleVotingSumAggregateOutputType | null
    _min: BattleVotingMinAggregateOutputType | null
    _max: BattleVotingMaxAggregateOutputType | null
  }

  type GetBattleVotingGroupByPayload<T extends BattleVotingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BattleVotingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BattleVotingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BattleVotingGroupByOutputType[P]>
            : GetScalarType<T[P], BattleVotingGroupByOutputType[P]>
        }
      >
    >


  export type BattleVotingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    battleId?: boolean
    proposalId?: boolean
    voterId?: boolean
    vote?: boolean
    voteWeight?: boolean
    reasoning?: boolean
    confidence?: boolean
    eceStaked?: boolean
    expertRating?: boolean
    portfolioValue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    battle?: boolean | MABattleDefaultArgs<ExtArgs>
    proposal?: boolean | BattleVoting$proposalArgs<ExtArgs>
    voter?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["battleVoting"]>

  export type BattleVotingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    battleId?: boolean
    proposalId?: boolean
    voterId?: boolean
    vote?: boolean
    voteWeight?: boolean
    reasoning?: boolean
    confidence?: boolean
    eceStaked?: boolean
    expertRating?: boolean
    portfolioValue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    battle?: boolean | MABattleDefaultArgs<ExtArgs>
    proposal?: boolean | BattleVoting$proposalArgs<ExtArgs>
    voter?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["battleVoting"]>

  export type BattleVotingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    battleId?: boolean
    proposalId?: boolean
    voterId?: boolean
    vote?: boolean
    voteWeight?: boolean
    reasoning?: boolean
    confidence?: boolean
    eceStaked?: boolean
    expertRating?: boolean
    portfolioValue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    battle?: boolean | MABattleDefaultArgs<ExtArgs>
    proposal?: boolean | BattleVoting$proposalArgs<ExtArgs>
    voter?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["battleVoting"]>

  export type BattleVotingSelectScalar = {
    id?: boolean
    battleId?: boolean
    proposalId?: boolean
    voterId?: boolean
    vote?: boolean
    voteWeight?: boolean
    reasoning?: boolean
    confidence?: boolean
    eceStaked?: boolean
    expertRating?: boolean
    portfolioValue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BattleVotingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "battleId" | "proposalId" | "voterId" | "vote" | "voteWeight" | "reasoning" | "confidence" | "eceStaked" | "expertRating" | "portfolioValue" | "createdAt" | "updatedAt", ExtArgs["result"]["battleVoting"]>
  export type BattleVotingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    battle?: boolean | MABattleDefaultArgs<ExtArgs>
    proposal?: boolean | BattleVoting$proposalArgs<ExtArgs>
    voter?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BattleVotingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    battle?: boolean | MABattleDefaultArgs<ExtArgs>
    proposal?: boolean | BattleVoting$proposalArgs<ExtArgs>
    voter?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BattleVotingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    battle?: boolean | MABattleDefaultArgs<ExtArgs>
    proposal?: boolean | BattleVoting$proposalArgs<ExtArgs>
    voter?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BattleVotingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BattleVoting"
    objects: {
      battle: Prisma.$MABattlePayload<ExtArgs>
      proposal: Prisma.$BattleProposalPayload<ExtArgs> | null
      voter: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      battleId: string
      proposalId: string | null
      voterId: string
      vote: $Enums.VoteDirection
      voteWeight: number
      reasoning: string | null
      confidence: number | null
      eceStaked: number | null
      expertRating: number | null
      portfolioValue: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["battleVoting"]>
    composites: {}
  }

  type BattleVotingGetPayload<S extends boolean | null | undefined | BattleVotingDefaultArgs> = $Result.GetResult<Prisma.$BattleVotingPayload, S>

  type BattleVotingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BattleVotingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BattleVotingCountAggregateInputType | true
    }

  export interface BattleVotingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BattleVoting'], meta: { name: 'BattleVoting' } }
    /**
     * Find zero or one BattleVoting that matches the filter.
     * @param {BattleVotingFindUniqueArgs} args - Arguments to find a BattleVoting
     * @example
     * // Get one BattleVoting
     * const battleVoting = await prisma.battleVoting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BattleVotingFindUniqueArgs>(args: SelectSubset<T, BattleVotingFindUniqueArgs<ExtArgs>>): Prisma__BattleVotingClient<$Result.GetResult<Prisma.$BattleVotingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BattleVoting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BattleVotingFindUniqueOrThrowArgs} args - Arguments to find a BattleVoting
     * @example
     * // Get one BattleVoting
     * const battleVoting = await prisma.battleVoting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BattleVotingFindUniqueOrThrowArgs>(args: SelectSubset<T, BattleVotingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BattleVotingClient<$Result.GetResult<Prisma.$BattleVotingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BattleVoting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BattleVotingFindFirstArgs} args - Arguments to find a BattleVoting
     * @example
     * // Get one BattleVoting
     * const battleVoting = await prisma.battleVoting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BattleVotingFindFirstArgs>(args?: SelectSubset<T, BattleVotingFindFirstArgs<ExtArgs>>): Prisma__BattleVotingClient<$Result.GetResult<Prisma.$BattleVotingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BattleVoting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BattleVotingFindFirstOrThrowArgs} args - Arguments to find a BattleVoting
     * @example
     * // Get one BattleVoting
     * const battleVoting = await prisma.battleVoting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BattleVotingFindFirstOrThrowArgs>(args?: SelectSubset<T, BattleVotingFindFirstOrThrowArgs<ExtArgs>>): Prisma__BattleVotingClient<$Result.GetResult<Prisma.$BattleVotingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BattleVotings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BattleVotingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BattleVotings
     * const battleVotings = await prisma.battleVoting.findMany()
     * 
     * // Get first 10 BattleVotings
     * const battleVotings = await prisma.battleVoting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const battleVotingWithIdOnly = await prisma.battleVoting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BattleVotingFindManyArgs>(args?: SelectSubset<T, BattleVotingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BattleVotingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BattleVoting.
     * @param {BattleVotingCreateArgs} args - Arguments to create a BattleVoting.
     * @example
     * // Create one BattleVoting
     * const BattleVoting = await prisma.battleVoting.create({
     *   data: {
     *     // ... data to create a BattleVoting
     *   }
     * })
     * 
     */
    create<T extends BattleVotingCreateArgs>(args: SelectSubset<T, BattleVotingCreateArgs<ExtArgs>>): Prisma__BattleVotingClient<$Result.GetResult<Prisma.$BattleVotingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BattleVotings.
     * @param {BattleVotingCreateManyArgs} args - Arguments to create many BattleVotings.
     * @example
     * // Create many BattleVotings
     * const battleVoting = await prisma.battleVoting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BattleVotingCreateManyArgs>(args?: SelectSubset<T, BattleVotingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BattleVotings and returns the data saved in the database.
     * @param {BattleVotingCreateManyAndReturnArgs} args - Arguments to create many BattleVotings.
     * @example
     * // Create many BattleVotings
     * const battleVoting = await prisma.battleVoting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BattleVotings and only return the `id`
     * const battleVotingWithIdOnly = await prisma.battleVoting.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BattleVotingCreateManyAndReturnArgs>(args?: SelectSubset<T, BattleVotingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BattleVotingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BattleVoting.
     * @param {BattleVotingDeleteArgs} args - Arguments to delete one BattleVoting.
     * @example
     * // Delete one BattleVoting
     * const BattleVoting = await prisma.battleVoting.delete({
     *   where: {
     *     // ... filter to delete one BattleVoting
     *   }
     * })
     * 
     */
    delete<T extends BattleVotingDeleteArgs>(args: SelectSubset<T, BattleVotingDeleteArgs<ExtArgs>>): Prisma__BattleVotingClient<$Result.GetResult<Prisma.$BattleVotingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BattleVoting.
     * @param {BattleVotingUpdateArgs} args - Arguments to update one BattleVoting.
     * @example
     * // Update one BattleVoting
     * const battleVoting = await prisma.battleVoting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BattleVotingUpdateArgs>(args: SelectSubset<T, BattleVotingUpdateArgs<ExtArgs>>): Prisma__BattleVotingClient<$Result.GetResult<Prisma.$BattleVotingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BattleVotings.
     * @param {BattleVotingDeleteManyArgs} args - Arguments to filter BattleVotings to delete.
     * @example
     * // Delete a few BattleVotings
     * const { count } = await prisma.battleVoting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BattleVotingDeleteManyArgs>(args?: SelectSubset<T, BattleVotingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BattleVotings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BattleVotingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BattleVotings
     * const battleVoting = await prisma.battleVoting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BattleVotingUpdateManyArgs>(args: SelectSubset<T, BattleVotingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BattleVotings and returns the data updated in the database.
     * @param {BattleVotingUpdateManyAndReturnArgs} args - Arguments to update many BattleVotings.
     * @example
     * // Update many BattleVotings
     * const battleVoting = await prisma.battleVoting.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BattleVotings and only return the `id`
     * const battleVotingWithIdOnly = await prisma.battleVoting.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BattleVotingUpdateManyAndReturnArgs>(args: SelectSubset<T, BattleVotingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BattleVotingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BattleVoting.
     * @param {BattleVotingUpsertArgs} args - Arguments to update or create a BattleVoting.
     * @example
     * // Update or create a BattleVoting
     * const battleVoting = await prisma.battleVoting.upsert({
     *   create: {
     *     // ... data to create a BattleVoting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BattleVoting we want to update
     *   }
     * })
     */
    upsert<T extends BattleVotingUpsertArgs>(args: SelectSubset<T, BattleVotingUpsertArgs<ExtArgs>>): Prisma__BattleVotingClient<$Result.GetResult<Prisma.$BattleVotingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BattleVotings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BattleVotingCountArgs} args - Arguments to filter BattleVotings to count.
     * @example
     * // Count the number of BattleVotings
     * const count = await prisma.battleVoting.count({
     *   where: {
     *     // ... the filter for the BattleVotings we want to count
     *   }
     * })
    **/
    count<T extends BattleVotingCountArgs>(
      args?: Subset<T, BattleVotingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BattleVotingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BattleVoting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BattleVotingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BattleVotingAggregateArgs>(args: Subset<T, BattleVotingAggregateArgs>): Prisma.PrismaPromise<GetBattleVotingAggregateType<T>>

    /**
     * Group by BattleVoting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BattleVotingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BattleVotingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BattleVotingGroupByArgs['orderBy'] }
        : { orderBy?: BattleVotingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BattleVotingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBattleVotingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BattleVoting model
   */
  readonly fields: BattleVotingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BattleVoting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BattleVotingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    battle<T extends MABattleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MABattleDefaultArgs<ExtArgs>>): Prisma__MABattleClient<$Result.GetResult<Prisma.$MABattlePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    proposal<T extends BattleVoting$proposalArgs<ExtArgs> = {}>(args?: Subset<T, BattleVoting$proposalArgs<ExtArgs>>): Prisma__BattleProposalClient<$Result.GetResult<Prisma.$BattleProposalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    voter<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BattleVoting model
   */
  interface BattleVotingFieldRefs {
    readonly id: FieldRef<"BattleVoting", 'String'>
    readonly battleId: FieldRef<"BattleVoting", 'String'>
    readonly proposalId: FieldRef<"BattleVoting", 'String'>
    readonly voterId: FieldRef<"BattleVoting", 'String'>
    readonly vote: FieldRef<"BattleVoting", 'VoteDirection'>
    readonly voteWeight: FieldRef<"BattleVoting", 'Float'>
    readonly reasoning: FieldRef<"BattleVoting", 'String'>
    readonly confidence: FieldRef<"BattleVoting", 'Float'>
    readonly eceStaked: FieldRef<"BattleVoting", 'Float'>
    readonly expertRating: FieldRef<"BattleVoting", 'Float'>
    readonly portfolioValue: FieldRef<"BattleVoting", 'Float'>
    readonly createdAt: FieldRef<"BattleVoting", 'DateTime'>
    readonly updatedAt: FieldRef<"BattleVoting", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BattleVoting findUnique
   */
  export type BattleVotingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BattleVoting
     */
    select?: BattleVotingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BattleVoting
     */
    omit?: BattleVotingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleVotingInclude<ExtArgs> | null
    /**
     * Filter, which BattleVoting to fetch.
     */
    where: BattleVotingWhereUniqueInput
  }

  /**
   * BattleVoting findUniqueOrThrow
   */
  export type BattleVotingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BattleVoting
     */
    select?: BattleVotingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BattleVoting
     */
    omit?: BattleVotingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleVotingInclude<ExtArgs> | null
    /**
     * Filter, which BattleVoting to fetch.
     */
    where: BattleVotingWhereUniqueInput
  }

  /**
   * BattleVoting findFirst
   */
  export type BattleVotingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BattleVoting
     */
    select?: BattleVotingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BattleVoting
     */
    omit?: BattleVotingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleVotingInclude<ExtArgs> | null
    /**
     * Filter, which BattleVoting to fetch.
     */
    where?: BattleVotingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BattleVotings to fetch.
     */
    orderBy?: BattleVotingOrderByWithRelationInput | BattleVotingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BattleVotings.
     */
    cursor?: BattleVotingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BattleVotings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BattleVotings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BattleVotings.
     */
    distinct?: BattleVotingScalarFieldEnum | BattleVotingScalarFieldEnum[]
  }

  /**
   * BattleVoting findFirstOrThrow
   */
  export type BattleVotingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BattleVoting
     */
    select?: BattleVotingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BattleVoting
     */
    omit?: BattleVotingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleVotingInclude<ExtArgs> | null
    /**
     * Filter, which BattleVoting to fetch.
     */
    where?: BattleVotingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BattleVotings to fetch.
     */
    orderBy?: BattleVotingOrderByWithRelationInput | BattleVotingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BattleVotings.
     */
    cursor?: BattleVotingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BattleVotings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BattleVotings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BattleVotings.
     */
    distinct?: BattleVotingScalarFieldEnum | BattleVotingScalarFieldEnum[]
  }

  /**
   * BattleVoting findMany
   */
  export type BattleVotingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BattleVoting
     */
    select?: BattleVotingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BattleVoting
     */
    omit?: BattleVotingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleVotingInclude<ExtArgs> | null
    /**
     * Filter, which BattleVotings to fetch.
     */
    where?: BattleVotingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BattleVotings to fetch.
     */
    orderBy?: BattleVotingOrderByWithRelationInput | BattleVotingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BattleVotings.
     */
    cursor?: BattleVotingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BattleVotings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BattleVotings.
     */
    skip?: number
    distinct?: BattleVotingScalarFieldEnum | BattleVotingScalarFieldEnum[]
  }

  /**
   * BattleVoting create
   */
  export type BattleVotingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BattleVoting
     */
    select?: BattleVotingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BattleVoting
     */
    omit?: BattleVotingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleVotingInclude<ExtArgs> | null
    /**
     * The data needed to create a BattleVoting.
     */
    data: XOR<BattleVotingCreateInput, BattleVotingUncheckedCreateInput>
  }

  /**
   * BattleVoting createMany
   */
  export type BattleVotingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BattleVotings.
     */
    data: BattleVotingCreateManyInput | BattleVotingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BattleVoting createManyAndReturn
   */
  export type BattleVotingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BattleVoting
     */
    select?: BattleVotingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BattleVoting
     */
    omit?: BattleVotingOmit<ExtArgs> | null
    /**
     * The data used to create many BattleVotings.
     */
    data: BattleVotingCreateManyInput | BattleVotingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleVotingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BattleVoting update
   */
  export type BattleVotingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BattleVoting
     */
    select?: BattleVotingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BattleVoting
     */
    omit?: BattleVotingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleVotingInclude<ExtArgs> | null
    /**
     * The data needed to update a BattleVoting.
     */
    data: XOR<BattleVotingUpdateInput, BattleVotingUncheckedUpdateInput>
    /**
     * Choose, which BattleVoting to update.
     */
    where: BattleVotingWhereUniqueInput
  }

  /**
   * BattleVoting updateMany
   */
  export type BattleVotingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BattleVotings.
     */
    data: XOR<BattleVotingUpdateManyMutationInput, BattleVotingUncheckedUpdateManyInput>
    /**
     * Filter which BattleVotings to update
     */
    where?: BattleVotingWhereInput
    /**
     * Limit how many BattleVotings to update.
     */
    limit?: number
  }

  /**
   * BattleVoting updateManyAndReturn
   */
  export type BattleVotingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BattleVoting
     */
    select?: BattleVotingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BattleVoting
     */
    omit?: BattleVotingOmit<ExtArgs> | null
    /**
     * The data used to update BattleVotings.
     */
    data: XOR<BattleVotingUpdateManyMutationInput, BattleVotingUncheckedUpdateManyInput>
    /**
     * Filter which BattleVotings to update
     */
    where?: BattleVotingWhereInput
    /**
     * Limit how many BattleVotings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleVotingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BattleVoting upsert
   */
  export type BattleVotingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BattleVoting
     */
    select?: BattleVotingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BattleVoting
     */
    omit?: BattleVotingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleVotingInclude<ExtArgs> | null
    /**
     * The filter to search for the BattleVoting to update in case it exists.
     */
    where: BattleVotingWhereUniqueInput
    /**
     * In case the BattleVoting found by the `where` argument doesn't exist, create a new BattleVoting with this data.
     */
    create: XOR<BattleVotingCreateInput, BattleVotingUncheckedCreateInput>
    /**
     * In case the BattleVoting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BattleVotingUpdateInput, BattleVotingUncheckedUpdateInput>
  }

  /**
   * BattleVoting delete
   */
  export type BattleVotingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BattleVoting
     */
    select?: BattleVotingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BattleVoting
     */
    omit?: BattleVotingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleVotingInclude<ExtArgs> | null
    /**
     * Filter which BattleVoting to delete.
     */
    where: BattleVotingWhereUniqueInput
  }

  /**
   * BattleVoting deleteMany
   */
  export type BattleVotingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BattleVotings to delete
     */
    where?: BattleVotingWhereInput
    /**
     * Limit how many BattleVotings to delete.
     */
    limit?: number
  }

  /**
   * BattleVoting.proposal
   */
  export type BattleVoting$proposalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BattleProposal
     */
    select?: BattleProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BattleProposal
     */
    omit?: BattleProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleProposalInclude<ExtArgs> | null
    where?: BattleProposalWhereInput
  }

  /**
   * BattleVoting without action
   */
  export type BattleVotingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BattleVoting
     */
    select?: BattleVotingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BattleVoting
     */
    omit?: BattleVotingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleVotingInclude<ExtArgs> | null
  }


  /**
   * Model BattleOutcome
   */

  export type AggregateBattleOutcome = {
    _count: BattleOutcomeCountAggregateOutputType | null
    _avg: BattleOutcomeAvgAggregateOutputType | null
    _sum: BattleOutcomeSumAggregateOutputType | null
    _min: BattleOutcomeMinAggregateOutputType | null
    _max: BattleOutcomeMaxAggregateOutputType | null
  }

  export type BattleOutcomeAvgAggregateOutputType = {
    finalValuation: number | null
  }

  export type BattleOutcomeSumAggregateOutputType = {
    finalValuation: number | null
  }

  export type BattleOutcomeMinAggregateOutputType = {
    id: string | null
    battleId: string | null
    winningBattleId: string | null
    winner: $Enums.BattleWinner | null
    winningProposalId: string | null
    finalValuation: number | null
    completionDate: Date | null
    realWorldImpact: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BattleOutcomeMaxAggregateOutputType = {
    id: string | null
    battleId: string | null
    winningBattleId: string | null
    winner: $Enums.BattleWinner | null
    winningProposalId: string | null
    finalValuation: number | null
    completionDate: Date | null
    realWorldImpact: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BattleOutcomeCountAggregateOutputType = {
    id: number
    battleId: number
    winningBattleId: number
    winner: number
    winningProposalId: number
    finalTerms: number
    finalValuation: number
    implementation: number
    stakeholdersPayouts: number
    tokenRewards: number
    completionDate: number
    realWorldImpact: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BattleOutcomeAvgAggregateInputType = {
    finalValuation?: true
  }

  export type BattleOutcomeSumAggregateInputType = {
    finalValuation?: true
  }

  export type BattleOutcomeMinAggregateInputType = {
    id?: true
    battleId?: true
    winningBattleId?: true
    winner?: true
    winningProposalId?: true
    finalValuation?: true
    completionDate?: true
    realWorldImpact?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BattleOutcomeMaxAggregateInputType = {
    id?: true
    battleId?: true
    winningBattleId?: true
    winner?: true
    winningProposalId?: true
    finalValuation?: true
    completionDate?: true
    realWorldImpact?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BattleOutcomeCountAggregateInputType = {
    id?: true
    battleId?: true
    winningBattleId?: true
    winner?: true
    winningProposalId?: true
    finalTerms?: true
    finalValuation?: true
    implementation?: true
    stakeholdersPayouts?: true
    tokenRewards?: true
    completionDate?: true
    realWorldImpact?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BattleOutcomeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BattleOutcome to aggregate.
     */
    where?: BattleOutcomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BattleOutcomes to fetch.
     */
    orderBy?: BattleOutcomeOrderByWithRelationInput | BattleOutcomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BattleOutcomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BattleOutcomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BattleOutcomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BattleOutcomes
    **/
    _count?: true | BattleOutcomeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BattleOutcomeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BattleOutcomeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BattleOutcomeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BattleOutcomeMaxAggregateInputType
  }

  export type GetBattleOutcomeAggregateType<T extends BattleOutcomeAggregateArgs> = {
        [P in keyof T & keyof AggregateBattleOutcome]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBattleOutcome[P]>
      : GetScalarType<T[P], AggregateBattleOutcome[P]>
  }




  export type BattleOutcomeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BattleOutcomeWhereInput
    orderBy?: BattleOutcomeOrderByWithAggregationInput | BattleOutcomeOrderByWithAggregationInput[]
    by: BattleOutcomeScalarFieldEnum[] | BattleOutcomeScalarFieldEnum
    having?: BattleOutcomeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BattleOutcomeCountAggregateInputType | true
    _avg?: BattleOutcomeAvgAggregateInputType
    _sum?: BattleOutcomeSumAggregateInputType
    _min?: BattleOutcomeMinAggregateInputType
    _max?: BattleOutcomeMaxAggregateInputType
  }

  export type BattleOutcomeGroupByOutputType = {
    id: string
    battleId: string
    winningBattleId: string | null
    winner: $Enums.BattleWinner
    winningProposalId: string | null
    finalTerms: JsonValue
    finalValuation: number
    implementation: JsonValue
    stakeholdersPayouts: JsonValue
    tokenRewards: JsonValue
    completionDate: Date | null
    realWorldImpact: string | null
    createdAt: Date
    updatedAt: Date
    _count: BattleOutcomeCountAggregateOutputType | null
    _avg: BattleOutcomeAvgAggregateOutputType | null
    _sum: BattleOutcomeSumAggregateOutputType | null
    _min: BattleOutcomeMinAggregateOutputType | null
    _max: BattleOutcomeMaxAggregateOutputType | null
  }

  type GetBattleOutcomeGroupByPayload<T extends BattleOutcomeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BattleOutcomeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BattleOutcomeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BattleOutcomeGroupByOutputType[P]>
            : GetScalarType<T[P], BattleOutcomeGroupByOutputType[P]>
        }
      >
    >


  export type BattleOutcomeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    battleId?: boolean
    winningBattleId?: boolean
    winner?: boolean
    winningProposalId?: boolean
    finalTerms?: boolean
    finalValuation?: boolean
    implementation?: boolean
    stakeholdersPayouts?: boolean
    tokenRewards?: boolean
    completionDate?: boolean
    realWorldImpact?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    battle?: boolean | MABattleDefaultArgs<ExtArgs>
    winningBattle?: boolean | BattleOutcome$winningBattleArgs<ExtArgs>
  }, ExtArgs["result"]["battleOutcome"]>

  export type BattleOutcomeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    battleId?: boolean
    winningBattleId?: boolean
    winner?: boolean
    winningProposalId?: boolean
    finalTerms?: boolean
    finalValuation?: boolean
    implementation?: boolean
    stakeholdersPayouts?: boolean
    tokenRewards?: boolean
    completionDate?: boolean
    realWorldImpact?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    battle?: boolean | MABattleDefaultArgs<ExtArgs>
    winningBattle?: boolean | BattleOutcome$winningBattleArgs<ExtArgs>
  }, ExtArgs["result"]["battleOutcome"]>

  export type BattleOutcomeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    battleId?: boolean
    winningBattleId?: boolean
    winner?: boolean
    winningProposalId?: boolean
    finalTerms?: boolean
    finalValuation?: boolean
    implementation?: boolean
    stakeholdersPayouts?: boolean
    tokenRewards?: boolean
    completionDate?: boolean
    realWorldImpact?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    battle?: boolean | MABattleDefaultArgs<ExtArgs>
    winningBattle?: boolean | BattleOutcome$winningBattleArgs<ExtArgs>
  }, ExtArgs["result"]["battleOutcome"]>

  export type BattleOutcomeSelectScalar = {
    id?: boolean
    battleId?: boolean
    winningBattleId?: boolean
    winner?: boolean
    winningProposalId?: boolean
    finalTerms?: boolean
    finalValuation?: boolean
    implementation?: boolean
    stakeholdersPayouts?: boolean
    tokenRewards?: boolean
    completionDate?: boolean
    realWorldImpact?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BattleOutcomeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "battleId" | "winningBattleId" | "winner" | "winningProposalId" | "finalTerms" | "finalValuation" | "implementation" | "stakeholdersPayouts" | "tokenRewards" | "completionDate" | "realWorldImpact" | "createdAt" | "updatedAt", ExtArgs["result"]["battleOutcome"]>
  export type BattleOutcomeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    battle?: boolean | MABattleDefaultArgs<ExtArgs>
    winningBattle?: boolean | BattleOutcome$winningBattleArgs<ExtArgs>
  }
  export type BattleOutcomeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    battle?: boolean | MABattleDefaultArgs<ExtArgs>
    winningBattle?: boolean | BattleOutcome$winningBattleArgs<ExtArgs>
  }
  export type BattleOutcomeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    battle?: boolean | MABattleDefaultArgs<ExtArgs>
    winningBattle?: boolean | BattleOutcome$winningBattleArgs<ExtArgs>
  }

  export type $BattleOutcomePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BattleOutcome"
    objects: {
      battle: Prisma.$MABattlePayload<ExtArgs>
      winningBattle: Prisma.$MABattlePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      battleId: string
      winningBattleId: string | null
      winner: $Enums.BattleWinner
      winningProposalId: string | null
      finalTerms: Prisma.JsonValue
      finalValuation: number
      implementation: Prisma.JsonValue
      stakeholdersPayouts: Prisma.JsonValue
      tokenRewards: Prisma.JsonValue
      completionDate: Date | null
      realWorldImpact: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["battleOutcome"]>
    composites: {}
  }

  type BattleOutcomeGetPayload<S extends boolean | null | undefined | BattleOutcomeDefaultArgs> = $Result.GetResult<Prisma.$BattleOutcomePayload, S>

  type BattleOutcomeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BattleOutcomeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BattleOutcomeCountAggregateInputType | true
    }

  export interface BattleOutcomeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BattleOutcome'], meta: { name: 'BattleOutcome' } }
    /**
     * Find zero or one BattleOutcome that matches the filter.
     * @param {BattleOutcomeFindUniqueArgs} args - Arguments to find a BattleOutcome
     * @example
     * // Get one BattleOutcome
     * const battleOutcome = await prisma.battleOutcome.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BattleOutcomeFindUniqueArgs>(args: SelectSubset<T, BattleOutcomeFindUniqueArgs<ExtArgs>>): Prisma__BattleOutcomeClient<$Result.GetResult<Prisma.$BattleOutcomePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BattleOutcome that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BattleOutcomeFindUniqueOrThrowArgs} args - Arguments to find a BattleOutcome
     * @example
     * // Get one BattleOutcome
     * const battleOutcome = await prisma.battleOutcome.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BattleOutcomeFindUniqueOrThrowArgs>(args: SelectSubset<T, BattleOutcomeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BattleOutcomeClient<$Result.GetResult<Prisma.$BattleOutcomePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BattleOutcome that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BattleOutcomeFindFirstArgs} args - Arguments to find a BattleOutcome
     * @example
     * // Get one BattleOutcome
     * const battleOutcome = await prisma.battleOutcome.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BattleOutcomeFindFirstArgs>(args?: SelectSubset<T, BattleOutcomeFindFirstArgs<ExtArgs>>): Prisma__BattleOutcomeClient<$Result.GetResult<Prisma.$BattleOutcomePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BattleOutcome that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BattleOutcomeFindFirstOrThrowArgs} args - Arguments to find a BattleOutcome
     * @example
     * // Get one BattleOutcome
     * const battleOutcome = await prisma.battleOutcome.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BattleOutcomeFindFirstOrThrowArgs>(args?: SelectSubset<T, BattleOutcomeFindFirstOrThrowArgs<ExtArgs>>): Prisma__BattleOutcomeClient<$Result.GetResult<Prisma.$BattleOutcomePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BattleOutcomes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BattleOutcomeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BattleOutcomes
     * const battleOutcomes = await prisma.battleOutcome.findMany()
     * 
     * // Get first 10 BattleOutcomes
     * const battleOutcomes = await prisma.battleOutcome.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const battleOutcomeWithIdOnly = await prisma.battleOutcome.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BattleOutcomeFindManyArgs>(args?: SelectSubset<T, BattleOutcomeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BattleOutcomePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BattleOutcome.
     * @param {BattleOutcomeCreateArgs} args - Arguments to create a BattleOutcome.
     * @example
     * // Create one BattleOutcome
     * const BattleOutcome = await prisma.battleOutcome.create({
     *   data: {
     *     // ... data to create a BattleOutcome
     *   }
     * })
     * 
     */
    create<T extends BattleOutcomeCreateArgs>(args: SelectSubset<T, BattleOutcomeCreateArgs<ExtArgs>>): Prisma__BattleOutcomeClient<$Result.GetResult<Prisma.$BattleOutcomePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BattleOutcomes.
     * @param {BattleOutcomeCreateManyArgs} args - Arguments to create many BattleOutcomes.
     * @example
     * // Create many BattleOutcomes
     * const battleOutcome = await prisma.battleOutcome.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BattleOutcomeCreateManyArgs>(args?: SelectSubset<T, BattleOutcomeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BattleOutcomes and returns the data saved in the database.
     * @param {BattleOutcomeCreateManyAndReturnArgs} args - Arguments to create many BattleOutcomes.
     * @example
     * // Create many BattleOutcomes
     * const battleOutcome = await prisma.battleOutcome.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BattleOutcomes and only return the `id`
     * const battleOutcomeWithIdOnly = await prisma.battleOutcome.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BattleOutcomeCreateManyAndReturnArgs>(args?: SelectSubset<T, BattleOutcomeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BattleOutcomePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BattleOutcome.
     * @param {BattleOutcomeDeleteArgs} args - Arguments to delete one BattleOutcome.
     * @example
     * // Delete one BattleOutcome
     * const BattleOutcome = await prisma.battleOutcome.delete({
     *   where: {
     *     // ... filter to delete one BattleOutcome
     *   }
     * })
     * 
     */
    delete<T extends BattleOutcomeDeleteArgs>(args: SelectSubset<T, BattleOutcomeDeleteArgs<ExtArgs>>): Prisma__BattleOutcomeClient<$Result.GetResult<Prisma.$BattleOutcomePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BattleOutcome.
     * @param {BattleOutcomeUpdateArgs} args - Arguments to update one BattleOutcome.
     * @example
     * // Update one BattleOutcome
     * const battleOutcome = await prisma.battleOutcome.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BattleOutcomeUpdateArgs>(args: SelectSubset<T, BattleOutcomeUpdateArgs<ExtArgs>>): Prisma__BattleOutcomeClient<$Result.GetResult<Prisma.$BattleOutcomePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BattleOutcomes.
     * @param {BattleOutcomeDeleteManyArgs} args - Arguments to filter BattleOutcomes to delete.
     * @example
     * // Delete a few BattleOutcomes
     * const { count } = await prisma.battleOutcome.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BattleOutcomeDeleteManyArgs>(args?: SelectSubset<T, BattleOutcomeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BattleOutcomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BattleOutcomeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BattleOutcomes
     * const battleOutcome = await prisma.battleOutcome.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BattleOutcomeUpdateManyArgs>(args: SelectSubset<T, BattleOutcomeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BattleOutcomes and returns the data updated in the database.
     * @param {BattleOutcomeUpdateManyAndReturnArgs} args - Arguments to update many BattleOutcomes.
     * @example
     * // Update many BattleOutcomes
     * const battleOutcome = await prisma.battleOutcome.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BattleOutcomes and only return the `id`
     * const battleOutcomeWithIdOnly = await prisma.battleOutcome.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BattleOutcomeUpdateManyAndReturnArgs>(args: SelectSubset<T, BattleOutcomeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BattleOutcomePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BattleOutcome.
     * @param {BattleOutcomeUpsertArgs} args - Arguments to update or create a BattleOutcome.
     * @example
     * // Update or create a BattleOutcome
     * const battleOutcome = await prisma.battleOutcome.upsert({
     *   create: {
     *     // ... data to create a BattleOutcome
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BattleOutcome we want to update
     *   }
     * })
     */
    upsert<T extends BattleOutcomeUpsertArgs>(args: SelectSubset<T, BattleOutcomeUpsertArgs<ExtArgs>>): Prisma__BattleOutcomeClient<$Result.GetResult<Prisma.$BattleOutcomePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BattleOutcomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BattleOutcomeCountArgs} args - Arguments to filter BattleOutcomes to count.
     * @example
     * // Count the number of BattleOutcomes
     * const count = await prisma.battleOutcome.count({
     *   where: {
     *     // ... the filter for the BattleOutcomes we want to count
     *   }
     * })
    **/
    count<T extends BattleOutcomeCountArgs>(
      args?: Subset<T, BattleOutcomeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BattleOutcomeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BattleOutcome.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BattleOutcomeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BattleOutcomeAggregateArgs>(args: Subset<T, BattleOutcomeAggregateArgs>): Prisma.PrismaPromise<GetBattleOutcomeAggregateType<T>>

    /**
     * Group by BattleOutcome.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BattleOutcomeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BattleOutcomeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BattleOutcomeGroupByArgs['orderBy'] }
        : { orderBy?: BattleOutcomeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BattleOutcomeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBattleOutcomeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BattleOutcome model
   */
  readonly fields: BattleOutcomeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BattleOutcome.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BattleOutcomeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    battle<T extends MABattleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MABattleDefaultArgs<ExtArgs>>): Prisma__MABattleClient<$Result.GetResult<Prisma.$MABattlePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    winningBattle<T extends BattleOutcome$winningBattleArgs<ExtArgs> = {}>(args?: Subset<T, BattleOutcome$winningBattleArgs<ExtArgs>>): Prisma__MABattleClient<$Result.GetResult<Prisma.$MABattlePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BattleOutcome model
   */
  interface BattleOutcomeFieldRefs {
    readonly id: FieldRef<"BattleOutcome", 'String'>
    readonly battleId: FieldRef<"BattleOutcome", 'String'>
    readonly winningBattleId: FieldRef<"BattleOutcome", 'String'>
    readonly winner: FieldRef<"BattleOutcome", 'BattleWinner'>
    readonly winningProposalId: FieldRef<"BattleOutcome", 'String'>
    readonly finalTerms: FieldRef<"BattleOutcome", 'Json'>
    readonly finalValuation: FieldRef<"BattleOutcome", 'Float'>
    readonly implementation: FieldRef<"BattleOutcome", 'Json'>
    readonly stakeholdersPayouts: FieldRef<"BattleOutcome", 'Json'>
    readonly tokenRewards: FieldRef<"BattleOutcome", 'Json'>
    readonly completionDate: FieldRef<"BattleOutcome", 'DateTime'>
    readonly realWorldImpact: FieldRef<"BattleOutcome", 'String'>
    readonly createdAt: FieldRef<"BattleOutcome", 'DateTime'>
    readonly updatedAt: FieldRef<"BattleOutcome", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BattleOutcome findUnique
   */
  export type BattleOutcomeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BattleOutcome
     */
    select?: BattleOutcomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BattleOutcome
     */
    omit?: BattleOutcomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleOutcomeInclude<ExtArgs> | null
    /**
     * Filter, which BattleOutcome to fetch.
     */
    where: BattleOutcomeWhereUniqueInput
  }

  /**
   * BattleOutcome findUniqueOrThrow
   */
  export type BattleOutcomeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BattleOutcome
     */
    select?: BattleOutcomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BattleOutcome
     */
    omit?: BattleOutcomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleOutcomeInclude<ExtArgs> | null
    /**
     * Filter, which BattleOutcome to fetch.
     */
    where: BattleOutcomeWhereUniqueInput
  }

  /**
   * BattleOutcome findFirst
   */
  export type BattleOutcomeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BattleOutcome
     */
    select?: BattleOutcomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BattleOutcome
     */
    omit?: BattleOutcomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleOutcomeInclude<ExtArgs> | null
    /**
     * Filter, which BattleOutcome to fetch.
     */
    where?: BattleOutcomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BattleOutcomes to fetch.
     */
    orderBy?: BattleOutcomeOrderByWithRelationInput | BattleOutcomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BattleOutcomes.
     */
    cursor?: BattleOutcomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BattleOutcomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BattleOutcomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BattleOutcomes.
     */
    distinct?: BattleOutcomeScalarFieldEnum | BattleOutcomeScalarFieldEnum[]
  }

  /**
   * BattleOutcome findFirstOrThrow
   */
  export type BattleOutcomeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BattleOutcome
     */
    select?: BattleOutcomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BattleOutcome
     */
    omit?: BattleOutcomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleOutcomeInclude<ExtArgs> | null
    /**
     * Filter, which BattleOutcome to fetch.
     */
    where?: BattleOutcomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BattleOutcomes to fetch.
     */
    orderBy?: BattleOutcomeOrderByWithRelationInput | BattleOutcomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BattleOutcomes.
     */
    cursor?: BattleOutcomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BattleOutcomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BattleOutcomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BattleOutcomes.
     */
    distinct?: BattleOutcomeScalarFieldEnum | BattleOutcomeScalarFieldEnum[]
  }

  /**
   * BattleOutcome findMany
   */
  export type BattleOutcomeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BattleOutcome
     */
    select?: BattleOutcomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BattleOutcome
     */
    omit?: BattleOutcomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleOutcomeInclude<ExtArgs> | null
    /**
     * Filter, which BattleOutcomes to fetch.
     */
    where?: BattleOutcomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BattleOutcomes to fetch.
     */
    orderBy?: BattleOutcomeOrderByWithRelationInput | BattleOutcomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BattleOutcomes.
     */
    cursor?: BattleOutcomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BattleOutcomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BattleOutcomes.
     */
    skip?: number
    distinct?: BattleOutcomeScalarFieldEnum | BattleOutcomeScalarFieldEnum[]
  }

  /**
   * BattleOutcome create
   */
  export type BattleOutcomeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BattleOutcome
     */
    select?: BattleOutcomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BattleOutcome
     */
    omit?: BattleOutcomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleOutcomeInclude<ExtArgs> | null
    /**
     * The data needed to create a BattleOutcome.
     */
    data: XOR<BattleOutcomeCreateInput, BattleOutcomeUncheckedCreateInput>
  }

  /**
   * BattleOutcome createMany
   */
  export type BattleOutcomeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BattleOutcomes.
     */
    data: BattleOutcomeCreateManyInput | BattleOutcomeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BattleOutcome createManyAndReturn
   */
  export type BattleOutcomeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BattleOutcome
     */
    select?: BattleOutcomeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BattleOutcome
     */
    omit?: BattleOutcomeOmit<ExtArgs> | null
    /**
     * The data used to create many BattleOutcomes.
     */
    data: BattleOutcomeCreateManyInput | BattleOutcomeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleOutcomeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BattleOutcome update
   */
  export type BattleOutcomeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BattleOutcome
     */
    select?: BattleOutcomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BattleOutcome
     */
    omit?: BattleOutcomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleOutcomeInclude<ExtArgs> | null
    /**
     * The data needed to update a BattleOutcome.
     */
    data: XOR<BattleOutcomeUpdateInput, BattleOutcomeUncheckedUpdateInput>
    /**
     * Choose, which BattleOutcome to update.
     */
    where: BattleOutcomeWhereUniqueInput
  }

  /**
   * BattleOutcome updateMany
   */
  export type BattleOutcomeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BattleOutcomes.
     */
    data: XOR<BattleOutcomeUpdateManyMutationInput, BattleOutcomeUncheckedUpdateManyInput>
    /**
     * Filter which BattleOutcomes to update
     */
    where?: BattleOutcomeWhereInput
    /**
     * Limit how many BattleOutcomes to update.
     */
    limit?: number
  }

  /**
   * BattleOutcome updateManyAndReturn
   */
  export type BattleOutcomeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BattleOutcome
     */
    select?: BattleOutcomeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BattleOutcome
     */
    omit?: BattleOutcomeOmit<ExtArgs> | null
    /**
     * The data used to update BattleOutcomes.
     */
    data: XOR<BattleOutcomeUpdateManyMutationInput, BattleOutcomeUncheckedUpdateManyInput>
    /**
     * Filter which BattleOutcomes to update
     */
    where?: BattleOutcomeWhereInput
    /**
     * Limit how many BattleOutcomes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleOutcomeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BattleOutcome upsert
   */
  export type BattleOutcomeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BattleOutcome
     */
    select?: BattleOutcomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BattleOutcome
     */
    omit?: BattleOutcomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleOutcomeInclude<ExtArgs> | null
    /**
     * The filter to search for the BattleOutcome to update in case it exists.
     */
    where: BattleOutcomeWhereUniqueInput
    /**
     * In case the BattleOutcome found by the `where` argument doesn't exist, create a new BattleOutcome with this data.
     */
    create: XOR<BattleOutcomeCreateInput, BattleOutcomeUncheckedCreateInput>
    /**
     * In case the BattleOutcome was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BattleOutcomeUpdateInput, BattleOutcomeUncheckedUpdateInput>
  }

  /**
   * BattleOutcome delete
   */
  export type BattleOutcomeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BattleOutcome
     */
    select?: BattleOutcomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BattleOutcome
     */
    omit?: BattleOutcomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleOutcomeInclude<ExtArgs> | null
    /**
     * Filter which BattleOutcome to delete.
     */
    where: BattleOutcomeWhereUniqueInput
  }

  /**
   * BattleOutcome deleteMany
   */
  export type BattleOutcomeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BattleOutcomes to delete
     */
    where?: BattleOutcomeWhereInput
    /**
     * Limit how many BattleOutcomes to delete.
     */
    limit?: number
  }

  /**
   * BattleOutcome.winningBattle
   */
  export type BattleOutcome$winningBattleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MABattle
     */
    select?: MABattleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MABattle
     */
    omit?: MABattleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MABattleInclude<ExtArgs> | null
    where?: MABattleWhereInput
  }

  /**
   * BattleOutcome without action
   */
  export type BattleOutcomeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BattleOutcome
     */
    select?: BattleOutcomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BattleOutcome
     */
    omit?: BattleOutcomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleOutcomeInclude<ExtArgs> | null
  }


  /**
   * Model StakingPool
   */

  export type AggregateStakingPool = {
    _count: StakingPoolCountAggregateOutputType | null
    _avg: StakingPoolAvgAggregateOutputType | null
    _sum: StakingPoolSumAggregateOutputType | null
    _min: StakingPoolMinAggregateOutputType | null
    _max: StakingPoolMaxAggregateOutputType | null
  }

  export type StakingPoolAvgAggregateOutputType = {
    totalStaked: number | null
    totalRewards: number | null
    apy: number | null
    minStakeAmount: number | null
    lockupPeriod: number | null
  }

  export type StakingPoolSumAggregateOutputType = {
    totalStaked: number | null
    totalRewards: number | null
    apy: number | null
    minStakeAmount: number | null
    lockupPeriod: number | null
  }

  export type StakingPoolMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    poolType: $Enums.StakingPoolType | null
    totalStaked: number | null
    totalRewards: number | null
    apy: number | null
    minStakeAmount: number | null
    lockupPeriod: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StakingPoolMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    poolType: $Enums.StakingPoolType | null
    totalStaked: number | null
    totalRewards: number | null
    apy: number | null
    minStakeAmount: number | null
    lockupPeriod: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StakingPoolCountAggregateOutputType = {
    id: number
    name: number
    description: number
    poolType: number
    totalStaked: number
    totalRewards: number
    apy: number
    minStakeAmount: number
    lockupPeriod: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StakingPoolAvgAggregateInputType = {
    totalStaked?: true
    totalRewards?: true
    apy?: true
    minStakeAmount?: true
    lockupPeriod?: true
  }

  export type StakingPoolSumAggregateInputType = {
    totalStaked?: true
    totalRewards?: true
    apy?: true
    minStakeAmount?: true
    lockupPeriod?: true
  }

  export type StakingPoolMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    poolType?: true
    totalStaked?: true
    totalRewards?: true
    apy?: true
    minStakeAmount?: true
    lockupPeriod?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StakingPoolMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    poolType?: true
    totalStaked?: true
    totalRewards?: true
    apy?: true
    minStakeAmount?: true
    lockupPeriod?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StakingPoolCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    poolType?: true
    totalStaked?: true
    totalRewards?: true
    apy?: true
    minStakeAmount?: true
    lockupPeriod?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StakingPoolAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StakingPool to aggregate.
     */
    where?: StakingPoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StakingPools to fetch.
     */
    orderBy?: StakingPoolOrderByWithRelationInput | StakingPoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StakingPoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StakingPools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StakingPools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StakingPools
    **/
    _count?: true | StakingPoolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StakingPoolAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StakingPoolSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StakingPoolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StakingPoolMaxAggregateInputType
  }

  export type GetStakingPoolAggregateType<T extends StakingPoolAggregateArgs> = {
        [P in keyof T & keyof AggregateStakingPool]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStakingPool[P]>
      : GetScalarType<T[P], AggregateStakingPool[P]>
  }




  export type StakingPoolGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StakingPoolWhereInput
    orderBy?: StakingPoolOrderByWithAggregationInput | StakingPoolOrderByWithAggregationInput[]
    by: StakingPoolScalarFieldEnum[] | StakingPoolScalarFieldEnum
    having?: StakingPoolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StakingPoolCountAggregateInputType | true
    _avg?: StakingPoolAvgAggregateInputType
    _sum?: StakingPoolSumAggregateInputType
    _min?: StakingPoolMinAggregateInputType
    _max?: StakingPoolMaxAggregateInputType
  }

  export type StakingPoolGroupByOutputType = {
    id: string
    name: string
    description: string | null
    poolType: $Enums.StakingPoolType
    totalStaked: number
    totalRewards: number
    apy: number
    minStakeAmount: number
    lockupPeriod: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: StakingPoolCountAggregateOutputType | null
    _avg: StakingPoolAvgAggregateOutputType | null
    _sum: StakingPoolSumAggregateOutputType | null
    _min: StakingPoolMinAggregateOutputType | null
    _max: StakingPoolMaxAggregateOutputType | null
  }

  type GetStakingPoolGroupByPayload<T extends StakingPoolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StakingPoolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StakingPoolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StakingPoolGroupByOutputType[P]>
            : GetScalarType<T[P], StakingPoolGroupByOutputType[P]>
        }
      >
    >


  export type StakingPoolSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    poolType?: boolean
    totalStaked?: boolean
    totalRewards?: boolean
    apy?: boolean
    minStakeAmount?: boolean
    lockupPeriod?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    stakes?: boolean | StakingPool$stakesArgs<ExtArgs>
    rewards?: boolean | StakingPool$rewardsArgs<ExtArgs>
    _count?: boolean | StakingPoolCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stakingPool"]>

  export type StakingPoolSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    poolType?: boolean
    totalStaked?: boolean
    totalRewards?: boolean
    apy?: boolean
    minStakeAmount?: boolean
    lockupPeriod?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["stakingPool"]>

  export type StakingPoolSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    poolType?: boolean
    totalStaked?: boolean
    totalRewards?: boolean
    apy?: boolean
    minStakeAmount?: boolean
    lockupPeriod?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["stakingPool"]>

  export type StakingPoolSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    poolType?: boolean
    totalStaked?: boolean
    totalRewards?: boolean
    apy?: boolean
    minStakeAmount?: boolean
    lockupPeriod?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StakingPoolOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "poolType" | "totalStaked" | "totalRewards" | "apy" | "minStakeAmount" | "lockupPeriod" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["stakingPool"]>
  export type StakingPoolInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stakes?: boolean | StakingPool$stakesArgs<ExtArgs>
    rewards?: boolean | StakingPool$rewardsArgs<ExtArgs>
    _count?: boolean | StakingPoolCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StakingPoolIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type StakingPoolIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $StakingPoolPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StakingPool"
    objects: {
      stakes: Prisma.$StakingPositionPayload<ExtArgs>[]
      rewards: Prisma.$StakingRewardPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      poolType: $Enums.StakingPoolType
      totalStaked: number
      totalRewards: number
      apy: number
      minStakeAmount: number
      lockupPeriod: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["stakingPool"]>
    composites: {}
  }

  type StakingPoolGetPayload<S extends boolean | null | undefined | StakingPoolDefaultArgs> = $Result.GetResult<Prisma.$StakingPoolPayload, S>

  type StakingPoolCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StakingPoolFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StakingPoolCountAggregateInputType | true
    }

  export interface StakingPoolDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StakingPool'], meta: { name: 'StakingPool' } }
    /**
     * Find zero or one StakingPool that matches the filter.
     * @param {StakingPoolFindUniqueArgs} args - Arguments to find a StakingPool
     * @example
     * // Get one StakingPool
     * const stakingPool = await prisma.stakingPool.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StakingPoolFindUniqueArgs>(args: SelectSubset<T, StakingPoolFindUniqueArgs<ExtArgs>>): Prisma__StakingPoolClient<$Result.GetResult<Prisma.$StakingPoolPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StakingPool that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StakingPoolFindUniqueOrThrowArgs} args - Arguments to find a StakingPool
     * @example
     * // Get one StakingPool
     * const stakingPool = await prisma.stakingPool.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StakingPoolFindUniqueOrThrowArgs>(args: SelectSubset<T, StakingPoolFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StakingPoolClient<$Result.GetResult<Prisma.$StakingPoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StakingPool that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StakingPoolFindFirstArgs} args - Arguments to find a StakingPool
     * @example
     * // Get one StakingPool
     * const stakingPool = await prisma.stakingPool.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StakingPoolFindFirstArgs>(args?: SelectSubset<T, StakingPoolFindFirstArgs<ExtArgs>>): Prisma__StakingPoolClient<$Result.GetResult<Prisma.$StakingPoolPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StakingPool that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StakingPoolFindFirstOrThrowArgs} args - Arguments to find a StakingPool
     * @example
     * // Get one StakingPool
     * const stakingPool = await prisma.stakingPool.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StakingPoolFindFirstOrThrowArgs>(args?: SelectSubset<T, StakingPoolFindFirstOrThrowArgs<ExtArgs>>): Prisma__StakingPoolClient<$Result.GetResult<Prisma.$StakingPoolPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StakingPools that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StakingPoolFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StakingPools
     * const stakingPools = await prisma.stakingPool.findMany()
     * 
     * // Get first 10 StakingPools
     * const stakingPools = await prisma.stakingPool.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stakingPoolWithIdOnly = await prisma.stakingPool.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StakingPoolFindManyArgs>(args?: SelectSubset<T, StakingPoolFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StakingPoolPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StakingPool.
     * @param {StakingPoolCreateArgs} args - Arguments to create a StakingPool.
     * @example
     * // Create one StakingPool
     * const StakingPool = await prisma.stakingPool.create({
     *   data: {
     *     // ... data to create a StakingPool
     *   }
     * })
     * 
     */
    create<T extends StakingPoolCreateArgs>(args: SelectSubset<T, StakingPoolCreateArgs<ExtArgs>>): Prisma__StakingPoolClient<$Result.GetResult<Prisma.$StakingPoolPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StakingPools.
     * @param {StakingPoolCreateManyArgs} args - Arguments to create many StakingPools.
     * @example
     * // Create many StakingPools
     * const stakingPool = await prisma.stakingPool.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StakingPoolCreateManyArgs>(args?: SelectSubset<T, StakingPoolCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StakingPools and returns the data saved in the database.
     * @param {StakingPoolCreateManyAndReturnArgs} args - Arguments to create many StakingPools.
     * @example
     * // Create many StakingPools
     * const stakingPool = await prisma.stakingPool.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StakingPools and only return the `id`
     * const stakingPoolWithIdOnly = await prisma.stakingPool.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StakingPoolCreateManyAndReturnArgs>(args?: SelectSubset<T, StakingPoolCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StakingPoolPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StakingPool.
     * @param {StakingPoolDeleteArgs} args - Arguments to delete one StakingPool.
     * @example
     * // Delete one StakingPool
     * const StakingPool = await prisma.stakingPool.delete({
     *   where: {
     *     // ... filter to delete one StakingPool
     *   }
     * })
     * 
     */
    delete<T extends StakingPoolDeleteArgs>(args: SelectSubset<T, StakingPoolDeleteArgs<ExtArgs>>): Prisma__StakingPoolClient<$Result.GetResult<Prisma.$StakingPoolPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StakingPool.
     * @param {StakingPoolUpdateArgs} args - Arguments to update one StakingPool.
     * @example
     * // Update one StakingPool
     * const stakingPool = await prisma.stakingPool.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StakingPoolUpdateArgs>(args: SelectSubset<T, StakingPoolUpdateArgs<ExtArgs>>): Prisma__StakingPoolClient<$Result.GetResult<Prisma.$StakingPoolPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StakingPools.
     * @param {StakingPoolDeleteManyArgs} args - Arguments to filter StakingPools to delete.
     * @example
     * // Delete a few StakingPools
     * const { count } = await prisma.stakingPool.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StakingPoolDeleteManyArgs>(args?: SelectSubset<T, StakingPoolDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StakingPools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StakingPoolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StakingPools
     * const stakingPool = await prisma.stakingPool.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StakingPoolUpdateManyArgs>(args: SelectSubset<T, StakingPoolUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StakingPools and returns the data updated in the database.
     * @param {StakingPoolUpdateManyAndReturnArgs} args - Arguments to update many StakingPools.
     * @example
     * // Update many StakingPools
     * const stakingPool = await prisma.stakingPool.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StakingPools and only return the `id`
     * const stakingPoolWithIdOnly = await prisma.stakingPool.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StakingPoolUpdateManyAndReturnArgs>(args: SelectSubset<T, StakingPoolUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StakingPoolPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StakingPool.
     * @param {StakingPoolUpsertArgs} args - Arguments to update or create a StakingPool.
     * @example
     * // Update or create a StakingPool
     * const stakingPool = await prisma.stakingPool.upsert({
     *   create: {
     *     // ... data to create a StakingPool
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StakingPool we want to update
     *   }
     * })
     */
    upsert<T extends StakingPoolUpsertArgs>(args: SelectSubset<T, StakingPoolUpsertArgs<ExtArgs>>): Prisma__StakingPoolClient<$Result.GetResult<Prisma.$StakingPoolPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StakingPools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StakingPoolCountArgs} args - Arguments to filter StakingPools to count.
     * @example
     * // Count the number of StakingPools
     * const count = await prisma.stakingPool.count({
     *   where: {
     *     // ... the filter for the StakingPools we want to count
     *   }
     * })
    **/
    count<T extends StakingPoolCountArgs>(
      args?: Subset<T, StakingPoolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StakingPoolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StakingPool.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StakingPoolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StakingPoolAggregateArgs>(args: Subset<T, StakingPoolAggregateArgs>): Prisma.PrismaPromise<GetStakingPoolAggregateType<T>>

    /**
     * Group by StakingPool.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StakingPoolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StakingPoolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StakingPoolGroupByArgs['orderBy'] }
        : { orderBy?: StakingPoolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StakingPoolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStakingPoolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StakingPool model
   */
  readonly fields: StakingPoolFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StakingPool.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StakingPoolClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stakes<T extends StakingPool$stakesArgs<ExtArgs> = {}>(args?: Subset<T, StakingPool$stakesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StakingPositionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rewards<T extends StakingPool$rewardsArgs<ExtArgs> = {}>(args?: Subset<T, StakingPool$rewardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StakingRewardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StakingPool model
   */
  interface StakingPoolFieldRefs {
    readonly id: FieldRef<"StakingPool", 'String'>
    readonly name: FieldRef<"StakingPool", 'String'>
    readonly description: FieldRef<"StakingPool", 'String'>
    readonly poolType: FieldRef<"StakingPool", 'StakingPoolType'>
    readonly totalStaked: FieldRef<"StakingPool", 'Float'>
    readonly totalRewards: FieldRef<"StakingPool", 'Float'>
    readonly apy: FieldRef<"StakingPool", 'Float'>
    readonly minStakeAmount: FieldRef<"StakingPool", 'Float'>
    readonly lockupPeriod: FieldRef<"StakingPool", 'Int'>
    readonly isActive: FieldRef<"StakingPool", 'Boolean'>
    readonly createdAt: FieldRef<"StakingPool", 'DateTime'>
    readonly updatedAt: FieldRef<"StakingPool", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StakingPool findUnique
   */
  export type StakingPoolFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakingPool
     */
    select?: StakingPoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakingPool
     */
    omit?: StakingPoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakingPoolInclude<ExtArgs> | null
    /**
     * Filter, which StakingPool to fetch.
     */
    where: StakingPoolWhereUniqueInput
  }

  /**
   * StakingPool findUniqueOrThrow
   */
  export type StakingPoolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakingPool
     */
    select?: StakingPoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakingPool
     */
    omit?: StakingPoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakingPoolInclude<ExtArgs> | null
    /**
     * Filter, which StakingPool to fetch.
     */
    where: StakingPoolWhereUniqueInput
  }

  /**
   * StakingPool findFirst
   */
  export type StakingPoolFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakingPool
     */
    select?: StakingPoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakingPool
     */
    omit?: StakingPoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakingPoolInclude<ExtArgs> | null
    /**
     * Filter, which StakingPool to fetch.
     */
    where?: StakingPoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StakingPools to fetch.
     */
    orderBy?: StakingPoolOrderByWithRelationInput | StakingPoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StakingPools.
     */
    cursor?: StakingPoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StakingPools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StakingPools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StakingPools.
     */
    distinct?: StakingPoolScalarFieldEnum | StakingPoolScalarFieldEnum[]
  }

  /**
   * StakingPool findFirstOrThrow
   */
  export type StakingPoolFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakingPool
     */
    select?: StakingPoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakingPool
     */
    omit?: StakingPoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakingPoolInclude<ExtArgs> | null
    /**
     * Filter, which StakingPool to fetch.
     */
    where?: StakingPoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StakingPools to fetch.
     */
    orderBy?: StakingPoolOrderByWithRelationInput | StakingPoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StakingPools.
     */
    cursor?: StakingPoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StakingPools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StakingPools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StakingPools.
     */
    distinct?: StakingPoolScalarFieldEnum | StakingPoolScalarFieldEnum[]
  }

  /**
   * StakingPool findMany
   */
  export type StakingPoolFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakingPool
     */
    select?: StakingPoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakingPool
     */
    omit?: StakingPoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakingPoolInclude<ExtArgs> | null
    /**
     * Filter, which StakingPools to fetch.
     */
    where?: StakingPoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StakingPools to fetch.
     */
    orderBy?: StakingPoolOrderByWithRelationInput | StakingPoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StakingPools.
     */
    cursor?: StakingPoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StakingPools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StakingPools.
     */
    skip?: number
    distinct?: StakingPoolScalarFieldEnum | StakingPoolScalarFieldEnum[]
  }

  /**
   * StakingPool create
   */
  export type StakingPoolCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakingPool
     */
    select?: StakingPoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakingPool
     */
    omit?: StakingPoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakingPoolInclude<ExtArgs> | null
    /**
     * The data needed to create a StakingPool.
     */
    data: XOR<StakingPoolCreateInput, StakingPoolUncheckedCreateInput>
  }

  /**
   * StakingPool createMany
   */
  export type StakingPoolCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StakingPools.
     */
    data: StakingPoolCreateManyInput | StakingPoolCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StakingPool createManyAndReturn
   */
  export type StakingPoolCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakingPool
     */
    select?: StakingPoolSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StakingPool
     */
    omit?: StakingPoolOmit<ExtArgs> | null
    /**
     * The data used to create many StakingPools.
     */
    data: StakingPoolCreateManyInput | StakingPoolCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StakingPool update
   */
  export type StakingPoolUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakingPool
     */
    select?: StakingPoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakingPool
     */
    omit?: StakingPoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakingPoolInclude<ExtArgs> | null
    /**
     * The data needed to update a StakingPool.
     */
    data: XOR<StakingPoolUpdateInput, StakingPoolUncheckedUpdateInput>
    /**
     * Choose, which StakingPool to update.
     */
    where: StakingPoolWhereUniqueInput
  }

  /**
   * StakingPool updateMany
   */
  export type StakingPoolUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StakingPools.
     */
    data: XOR<StakingPoolUpdateManyMutationInput, StakingPoolUncheckedUpdateManyInput>
    /**
     * Filter which StakingPools to update
     */
    where?: StakingPoolWhereInput
    /**
     * Limit how many StakingPools to update.
     */
    limit?: number
  }

  /**
   * StakingPool updateManyAndReturn
   */
  export type StakingPoolUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakingPool
     */
    select?: StakingPoolSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StakingPool
     */
    omit?: StakingPoolOmit<ExtArgs> | null
    /**
     * The data used to update StakingPools.
     */
    data: XOR<StakingPoolUpdateManyMutationInput, StakingPoolUncheckedUpdateManyInput>
    /**
     * Filter which StakingPools to update
     */
    where?: StakingPoolWhereInput
    /**
     * Limit how many StakingPools to update.
     */
    limit?: number
  }

  /**
   * StakingPool upsert
   */
  export type StakingPoolUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakingPool
     */
    select?: StakingPoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakingPool
     */
    omit?: StakingPoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakingPoolInclude<ExtArgs> | null
    /**
     * The filter to search for the StakingPool to update in case it exists.
     */
    where: StakingPoolWhereUniqueInput
    /**
     * In case the StakingPool found by the `where` argument doesn't exist, create a new StakingPool with this data.
     */
    create: XOR<StakingPoolCreateInput, StakingPoolUncheckedCreateInput>
    /**
     * In case the StakingPool was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StakingPoolUpdateInput, StakingPoolUncheckedUpdateInput>
  }

  /**
   * StakingPool delete
   */
  export type StakingPoolDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakingPool
     */
    select?: StakingPoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakingPool
     */
    omit?: StakingPoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakingPoolInclude<ExtArgs> | null
    /**
     * Filter which StakingPool to delete.
     */
    where: StakingPoolWhereUniqueInput
  }

  /**
   * StakingPool deleteMany
   */
  export type StakingPoolDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StakingPools to delete
     */
    where?: StakingPoolWhereInput
    /**
     * Limit how many StakingPools to delete.
     */
    limit?: number
  }

  /**
   * StakingPool.stakes
   */
  export type StakingPool$stakesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakingPosition
     */
    select?: StakingPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakingPosition
     */
    omit?: StakingPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakingPositionInclude<ExtArgs> | null
    where?: StakingPositionWhereInput
    orderBy?: StakingPositionOrderByWithRelationInput | StakingPositionOrderByWithRelationInput[]
    cursor?: StakingPositionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StakingPositionScalarFieldEnum | StakingPositionScalarFieldEnum[]
  }

  /**
   * StakingPool.rewards
   */
  export type StakingPool$rewardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakingReward
     */
    select?: StakingRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakingReward
     */
    omit?: StakingRewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakingRewardInclude<ExtArgs> | null
    where?: StakingRewardWhereInput
    orderBy?: StakingRewardOrderByWithRelationInput | StakingRewardOrderByWithRelationInput[]
    cursor?: StakingRewardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StakingRewardScalarFieldEnum | StakingRewardScalarFieldEnum[]
  }

  /**
   * StakingPool without action
   */
  export type StakingPoolDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakingPool
     */
    select?: StakingPoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakingPool
     */
    omit?: StakingPoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakingPoolInclude<ExtArgs> | null
  }


  /**
   * Model StakingPosition
   */

  export type AggregateStakingPosition = {
    _count: StakingPositionCountAggregateOutputType | null
    _avg: StakingPositionAvgAggregateOutputType | null
    _sum: StakingPositionSumAggregateOutputType | null
    _min: StakingPositionMinAggregateOutputType | null
    _max: StakingPositionMaxAggregateOutputType | null
  }

  export type StakingPositionAvgAggregateOutputType = {
    amount: number | null
  }

  export type StakingPositionSumAggregateOutputType = {
    amount: number | null
  }

  export type StakingPositionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    poolId: string | null
    amount: number | null
    stakedAt: Date | null
    unstakedAt: Date | null
    lockupEndsAt: Date | null
    isActive: boolean | null
  }

  export type StakingPositionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    poolId: string | null
    amount: number | null
    stakedAt: Date | null
    unstakedAt: Date | null
    lockupEndsAt: Date | null
    isActive: boolean | null
  }

  export type StakingPositionCountAggregateOutputType = {
    id: number
    userId: number
    poolId: number
    amount: number
    stakedAt: number
    unstakedAt: number
    lockupEndsAt: number
    isActive: number
    _all: number
  }


  export type StakingPositionAvgAggregateInputType = {
    amount?: true
  }

  export type StakingPositionSumAggregateInputType = {
    amount?: true
  }

  export type StakingPositionMinAggregateInputType = {
    id?: true
    userId?: true
    poolId?: true
    amount?: true
    stakedAt?: true
    unstakedAt?: true
    lockupEndsAt?: true
    isActive?: true
  }

  export type StakingPositionMaxAggregateInputType = {
    id?: true
    userId?: true
    poolId?: true
    amount?: true
    stakedAt?: true
    unstakedAt?: true
    lockupEndsAt?: true
    isActive?: true
  }

  export type StakingPositionCountAggregateInputType = {
    id?: true
    userId?: true
    poolId?: true
    amount?: true
    stakedAt?: true
    unstakedAt?: true
    lockupEndsAt?: true
    isActive?: true
    _all?: true
  }

  export type StakingPositionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StakingPosition to aggregate.
     */
    where?: StakingPositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StakingPositions to fetch.
     */
    orderBy?: StakingPositionOrderByWithRelationInput | StakingPositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StakingPositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StakingPositions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StakingPositions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StakingPositions
    **/
    _count?: true | StakingPositionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StakingPositionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StakingPositionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StakingPositionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StakingPositionMaxAggregateInputType
  }

  export type GetStakingPositionAggregateType<T extends StakingPositionAggregateArgs> = {
        [P in keyof T & keyof AggregateStakingPosition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStakingPosition[P]>
      : GetScalarType<T[P], AggregateStakingPosition[P]>
  }




  export type StakingPositionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StakingPositionWhereInput
    orderBy?: StakingPositionOrderByWithAggregationInput | StakingPositionOrderByWithAggregationInput[]
    by: StakingPositionScalarFieldEnum[] | StakingPositionScalarFieldEnum
    having?: StakingPositionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StakingPositionCountAggregateInputType | true
    _avg?: StakingPositionAvgAggregateInputType
    _sum?: StakingPositionSumAggregateInputType
    _min?: StakingPositionMinAggregateInputType
    _max?: StakingPositionMaxAggregateInputType
  }

  export type StakingPositionGroupByOutputType = {
    id: string
    userId: string
    poolId: string
    amount: number
    stakedAt: Date
    unstakedAt: Date | null
    lockupEndsAt: Date | null
    isActive: boolean
    _count: StakingPositionCountAggregateOutputType | null
    _avg: StakingPositionAvgAggregateOutputType | null
    _sum: StakingPositionSumAggregateOutputType | null
    _min: StakingPositionMinAggregateOutputType | null
    _max: StakingPositionMaxAggregateOutputType | null
  }

  type GetStakingPositionGroupByPayload<T extends StakingPositionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StakingPositionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StakingPositionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StakingPositionGroupByOutputType[P]>
            : GetScalarType<T[P], StakingPositionGroupByOutputType[P]>
        }
      >
    >


  export type StakingPositionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    poolId?: boolean
    amount?: boolean
    stakedAt?: boolean
    unstakedAt?: boolean
    lockupEndsAt?: boolean
    isActive?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    pool?: boolean | StakingPoolDefaultArgs<ExtArgs>
    rewards?: boolean | StakingPosition$rewardsArgs<ExtArgs>
    _count?: boolean | StakingPositionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stakingPosition"]>

  export type StakingPositionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    poolId?: boolean
    amount?: boolean
    stakedAt?: boolean
    unstakedAt?: boolean
    lockupEndsAt?: boolean
    isActive?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    pool?: boolean | StakingPoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stakingPosition"]>

  export type StakingPositionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    poolId?: boolean
    amount?: boolean
    stakedAt?: boolean
    unstakedAt?: boolean
    lockupEndsAt?: boolean
    isActive?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    pool?: boolean | StakingPoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stakingPosition"]>

  export type StakingPositionSelectScalar = {
    id?: boolean
    userId?: boolean
    poolId?: boolean
    amount?: boolean
    stakedAt?: boolean
    unstakedAt?: boolean
    lockupEndsAt?: boolean
    isActive?: boolean
  }

  export type StakingPositionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "poolId" | "amount" | "stakedAt" | "unstakedAt" | "lockupEndsAt" | "isActive", ExtArgs["result"]["stakingPosition"]>
  export type StakingPositionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    pool?: boolean | StakingPoolDefaultArgs<ExtArgs>
    rewards?: boolean | StakingPosition$rewardsArgs<ExtArgs>
    _count?: boolean | StakingPositionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StakingPositionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    pool?: boolean | StakingPoolDefaultArgs<ExtArgs>
  }
  export type StakingPositionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    pool?: boolean | StakingPoolDefaultArgs<ExtArgs>
  }

  export type $StakingPositionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StakingPosition"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      pool: Prisma.$StakingPoolPayload<ExtArgs>
      rewards: Prisma.$StakingRewardPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      poolId: string
      amount: number
      stakedAt: Date
      unstakedAt: Date | null
      lockupEndsAt: Date | null
      isActive: boolean
    }, ExtArgs["result"]["stakingPosition"]>
    composites: {}
  }

  type StakingPositionGetPayload<S extends boolean | null | undefined | StakingPositionDefaultArgs> = $Result.GetResult<Prisma.$StakingPositionPayload, S>

  type StakingPositionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StakingPositionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StakingPositionCountAggregateInputType | true
    }

  export interface StakingPositionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StakingPosition'], meta: { name: 'StakingPosition' } }
    /**
     * Find zero or one StakingPosition that matches the filter.
     * @param {StakingPositionFindUniqueArgs} args - Arguments to find a StakingPosition
     * @example
     * // Get one StakingPosition
     * const stakingPosition = await prisma.stakingPosition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StakingPositionFindUniqueArgs>(args: SelectSubset<T, StakingPositionFindUniqueArgs<ExtArgs>>): Prisma__StakingPositionClient<$Result.GetResult<Prisma.$StakingPositionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StakingPosition that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StakingPositionFindUniqueOrThrowArgs} args - Arguments to find a StakingPosition
     * @example
     * // Get one StakingPosition
     * const stakingPosition = await prisma.stakingPosition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StakingPositionFindUniqueOrThrowArgs>(args: SelectSubset<T, StakingPositionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StakingPositionClient<$Result.GetResult<Prisma.$StakingPositionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StakingPosition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StakingPositionFindFirstArgs} args - Arguments to find a StakingPosition
     * @example
     * // Get one StakingPosition
     * const stakingPosition = await prisma.stakingPosition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StakingPositionFindFirstArgs>(args?: SelectSubset<T, StakingPositionFindFirstArgs<ExtArgs>>): Prisma__StakingPositionClient<$Result.GetResult<Prisma.$StakingPositionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StakingPosition that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StakingPositionFindFirstOrThrowArgs} args - Arguments to find a StakingPosition
     * @example
     * // Get one StakingPosition
     * const stakingPosition = await prisma.stakingPosition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StakingPositionFindFirstOrThrowArgs>(args?: SelectSubset<T, StakingPositionFindFirstOrThrowArgs<ExtArgs>>): Prisma__StakingPositionClient<$Result.GetResult<Prisma.$StakingPositionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StakingPositions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StakingPositionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StakingPositions
     * const stakingPositions = await prisma.stakingPosition.findMany()
     * 
     * // Get first 10 StakingPositions
     * const stakingPositions = await prisma.stakingPosition.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stakingPositionWithIdOnly = await prisma.stakingPosition.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StakingPositionFindManyArgs>(args?: SelectSubset<T, StakingPositionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StakingPositionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StakingPosition.
     * @param {StakingPositionCreateArgs} args - Arguments to create a StakingPosition.
     * @example
     * // Create one StakingPosition
     * const StakingPosition = await prisma.stakingPosition.create({
     *   data: {
     *     // ... data to create a StakingPosition
     *   }
     * })
     * 
     */
    create<T extends StakingPositionCreateArgs>(args: SelectSubset<T, StakingPositionCreateArgs<ExtArgs>>): Prisma__StakingPositionClient<$Result.GetResult<Prisma.$StakingPositionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StakingPositions.
     * @param {StakingPositionCreateManyArgs} args - Arguments to create many StakingPositions.
     * @example
     * // Create many StakingPositions
     * const stakingPosition = await prisma.stakingPosition.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StakingPositionCreateManyArgs>(args?: SelectSubset<T, StakingPositionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StakingPositions and returns the data saved in the database.
     * @param {StakingPositionCreateManyAndReturnArgs} args - Arguments to create many StakingPositions.
     * @example
     * // Create many StakingPositions
     * const stakingPosition = await prisma.stakingPosition.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StakingPositions and only return the `id`
     * const stakingPositionWithIdOnly = await prisma.stakingPosition.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StakingPositionCreateManyAndReturnArgs>(args?: SelectSubset<T, StakingPositionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StakingPositionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StakingPosition.
     * @param {StakingPositionDeleteArgs} args - Arguments to delete one StakingPosition.
     * @example
     * // Delete one StakingPosition
     * const StakingPosition = await prisma.stakingPosition.delete({
     *   where: {
     *     // ... filter to delete one StakingPosition
     *   }
     * })
     * 
     */
    delete<T extends StakingPositionDeleteArgs>(args: SelectSubset<T, StakingPositionDeleteArgs<ExtArgs>>): Prisma__StakingPositionClient<$Result.GetResult<Prisma.$StakingPositionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StakingPosition.
     * @param {StakingPositionUpdateArgs} args - Arguments to update one StakingPosition.
     * @example
     * // Update one StakingPosition
     * const stakingPosition = await prisma.stakingPosition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StakingPositionUpdateArgs>(args: SelectSubset<T, StakingPositionUpdateArgs<ExtArgs>>): Prisma__StakingPositionClient<$Result.GetResult<Prisma.$StakingPositionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StakingPositions.
     * @param {StakingPositionDeleteManyArgs} args - Arguments to filter StakingPositions to delete.
     * @example
     * // Delete a few StakingPositions
     * const { count } = await prisma.stakingPosition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StakingPositionDeleteManyArgs>(args?: SelectSubset<T, StakingPositionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StakingPositions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StakingPositionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StakingPositions
     * const stakingPosition = await prisma.stakingPosition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StakingPositionUpdateManyArgs>(args: SelectSubset<T, StakingPositionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StakingPositions and returns the data updated in the database.
     * @param {StakingPositionUpdateManyAndReturnArgs} args - Arguments to update many StakingPositions.
     * @example
     * // Update many StakingPositions
     * const stakingPosition = await prisma.stakingPosition.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StakingPositions and only return the `id`
     * const stakingPositionWithIdOnly = await prisma.stakingPosition.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StakingPositionUpdateManyAndReturnArgs>(args: SelectSubset<T, StakingPositionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StakingPositionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StakingPosition.
     * @param {StakingPositionUpsertArgs} args - Arguments to update or create a StakingPosition.
     * @example
     * // Update or create a StakingPosition
     * const stakingPosition = await prisma.stakingPosition.upsert({
     *   create: {
     *     // ... data to create a StakingPosition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StakingPosition we want to update
     *   }
     * })
     */
    upsert<T extends StakingPositionUpsertArgs>(args: SelectSubset<T, StakingPositionUpsertArgs<ExtArgs>>): Prisma__StakingPositionClient<$Result.GetResult<Prisma.$StakingPositionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StakingPositions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StakingPositionCountArgs} args - Arguments to filter StakingPositions to count.
     * @example
     * // Count the number of StakingPositions
     * const count = await prisma.stakingPosition.count({
     *   where: {
     *     // ... the filter for the StakingPositions we want to count
     *   }
     * })
    **/
    count<T extends StakingPositionCountArgs>(
      args?: Subset<T, StakingPositionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StakingPositionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StakingPosition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StakingPositionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StakingPositionAggregateArgs>(args: Subset<T, StakingPositionAggregateArgs>): Prisma.PrismaPromise<GetStakingPositionAggregateType<T>>

    /**
     * Group by StakingPosition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StakingPositionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StakingPositionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StakingPositionGroupByArgs['orderBy'] }
        : { orderBy?: StakingPositionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StakingPositionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStakingPositionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StakingPosition model
   */
  readonly fields: StakingPositionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StakingPosition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StakingPositionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pool<T extends StakingPoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StakingPoolDefaultArgs<ExtArgs>>): Prisma__StakingPoolClient<$Result.GetResult<Prisma.$StakingPoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    rewards<T extends StakingPosition$rewardsArgs<ExtArgs> = {}>(args?: Subset<T, StakingPosition$rewardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StakingRewardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StakingPosition model
   */
  interface StakingPositionFieldRefs {
    readonly id: FieldRef<"StakingPosition", 'String'>
    readonly userId: FieldRef<"StakingPosition", 'String'>
    readonly poolId: FieldRef<"StakingPosition", 'String'>
    readonly amount: FieldRef<"StakingPosition", 'Float'>
    readonly stakedAt: FieldRef<"StakingPosition", 'DateTime'>
    readonly unstakedAt: FieldRef<"StakingPosition", 'DateTime'>
    readonly lockupEndsAt: FieldRef<"StakingPosition", 'DateTime'>
    readonly isActive: FieldRef<"StakingPosition", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * StakingPosition findUnique
   */
  export type StakingPositionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakingPosition
     */
    select?: StakingPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakingPosition
     */
    omit?: StakingPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakingPositionInclude<ExtArgs> | null
    /**
     * Filter, which StakingPosition to fetch.
     */
    where: StakingPositionWhereUniqueInput
  }

  /**
   * StakingPosition findUniqueOrThrow
   */
  export type StakingPositionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakingPosition
     */
    select?: StakingPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakingPosition
     */
    omit?: StakingPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakingPositionInclude<ExtArgs> | null
    /**
     * Filter, which StakingPosition to fetch.
     */
    where: StakingPositionWhereUniqueInput
  }

  /**
   * StakingPosition findFirst
   */
  export type StakingPositionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakingPosition
     */
    select?: StakingPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakingPosition
     */
    omit?: StakingPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakingPositionInclude<ExtArgs> | null
    /**
     * Filter, which StakingPosition to fetch.
     */
    where?: StakingPositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StakingPositions to fetch.
     */
    orderBy?: StakingPositionOrderByWithRelationInput | StakingPositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StakingPositions.
     */
    cursor?: StakingPositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StakingPositions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StakingPositions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StakingPositions.
     */
    distinct?: StakingPositionScalarFieldEnum | StakingPositionScalarFieldEnum[]
  }

  /**
   * StakingPosition findFirstOrThrow
   */
  export type StakingPositionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakingPosition
     */
    select?: StakingPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakingPosition
     */
    omit?: StakingPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakingPositionInclude<ExtArgs> | null
    /**
     * Filter, which StakingPosition to fetch.
     */
    where?: StakingPositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StakingPositions to fetch.
     */
    orderBy?: StakingPositionOrderByWithRelationInput | StakingPositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StakingPositions.
     */
    cursor?: StakingPositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StakingPositions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StakingPositions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StakingPositions.
     */
    distinct?: StakingPositionScalarFieldEnum | StakingPositionScalarFieldEnum[]
  }

  /**
   * StakingPosition findMany
   */
  export type StakingPositionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakingPosition
     */
    select?: StakingPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakingPosition
     */
    omit?: StakingPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakingPositionInclude<ExtArgs> | null
    /**
     * Filter, which StakingPositions to fetch.
     */
    where?: StakingPositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StakingPositions to fetch.
     */
    orderBy?: StakingPositionOrderByWithRelationInput | StakingPositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StakingPositions.
     */
    cursor?: StakingPositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StakingPositions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StakingPositions.
     */
    skip?: number
    distinct?: StakingPositionScalarFieldEnum | StakingPositionScalarFieldEnum[]
  }

  /**
   * StakingPosition create
   */
  export type StakingPositionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakingPosition
     */
    select?: StakingPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakingPosition
     */
    omit?: StakingPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakingPositionInclude<ExtArgs> | null
    /**
     * The data needed to create a StakingPosition.
     */
    data: XOR<StakingPositionCreateInput, StakingPositionUncheckedCreateInput>
  }

  /**
   * StakingPosition createMany
   */
  export type StakingPositionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StakingPositions.
     */
    data: StakingPositionCreateManyInput | StakingPositionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StakingPosition createManyAndReturn
   */
  export type StakingPositionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakingPosition
     */
    select?: StakingPositionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StakingPosition
     */
    omit?: StakingPositionOmit<ExtArgs> | null
    /**
     * The data used to create many StakingPositions.
     */
    data: StakingPositionCreateManyInput | StakingPositionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakingPositionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StakingPosition update
   */
  export type StakingPositionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakingPosition
     */
    select?: StakingPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakingPosition
     */
    omit?: StakingPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakingPositionInclude<ExtArgs> | null
    /**
     * The data needed to update a StakingPosition.
     */
    data: XOR<StakingPositionUpdateInput, StakingPositionUncheckedUpdateInput>
    /**
     * Choose, which StakingPosition to update.
     */
    where: StakingPositionWhereUniqueInput
  }

  /**
   * StakingPosition updateMany
   */
  export type StakingPositionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StakingPositions.
     */
    data: XOR<StakingPositionUpdateManyMutationInput, StakingPositionUncheckedUpdateManyInput>
    /**
     * Filter which StakingPositions to update
     */
    where?: StakingPositionWhereInput
    /**
     * Limit how many StakingPositions to update.
     */
    limit?: number
  }

  /**
   * StakingPosition updateManyAndReturn
   */
  export type StakingPositionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakingPosition
     */
    select?: StakingPositionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StakingPosition
     */
    omit?: StakingPositionOmit<ExtArgs> | null
    /**
     * The data used to update StakingPositions.
     */
    data: XOR<StakingPositionUpdateManyMutationInput, StakingPositionUncheckedUpdateManyInput>
    /**
     * Filter which StakingPositions to update
     */
    where?: StakingPositionWhereInput
    /**
     * Limit how many StakingPositions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakingPositionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StakingPosition upsert
   */
  export type StakingPositionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakingPosition
     */
    select?: StakingPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakingPosition
     */
    omit?: StakingPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakingPositionInclude<ExtArgs> | null
    /**
     * The filter to search for the StakingPosition to update in case it exists.
     */
    where: StakingPositionWhereUniqueInput
    /**
     * In case the StakingPosition found by the `where` argument doesn't exist, create a new StakingPosition with this data.
     */
    create: XOR<StakingPositionCreateInput, StakingPositionUncheckedCreateInput>
    /**
     * In case the StakingPosition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StakingPositionUpdateInput, StakingPositionUncheckedUpdateInput>
  }

  /**
   * StakingPosition delete
   */
  export type StakingPositionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakingPosition
     */
    select?: StakingPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakingPosition
     */
    omit?: StakingPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakingPositionInclude<ExtArgs> | null
    /**
     * Filter which StakingPosition to delete.
     */
    where: StakingPositionWhereUniqueInput
  }

  /**
   * StakingPosition deleteMany
   */
  export type StakingPositionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StakingPositions to delete
     */
    where?: StakingPositionWhereInput
    /**
     * Limit how many StakingPositions to delete.
     */
    limit?: number
  }

  /**
   * StakingPosition.rewards
   */
  export type StakingPosition$rewardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakingReward
     */
    select?: StakingRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakingReward
     */
    omit?: StakingRewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakingRewardInclude<ExtArgs> | null
    where?: StakingRewardWhereInput
    orderBy?: StakingRewardOrderByWithRelationInput | StakingRewardOrderByWithRelationInput[]
    cursor?: StakingRewardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StakingRewardScalarFieldEnum | StakingRewardScalarFieldEnum[]
  }

  /**
   * StakingPosition without action
   */
  export type StakingPositionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakingPosition
     */
    select?: StakingPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakingPosition
     */
    omit?: StakingPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakingPositionInclude<ExtArgs> | null
  }


  /**
   * Model StakingReward
   */

  export type AggregateStakingReward = {
    _count: StakingRewardCountAggregateOutputType | null
    _avg: StakingRewardAvgAggregateOutputType | null
    _sum: StakingRewardSumAggregateOutputType | null
    _min: StakingRewardMinAggregateOutputType | null
    _max: StakingRewardMaxAggregateOutputType | null
  }

  export type StakingRewardAvgAggregateOutputType = {
    amount: number | null
  }

  export type StakingRewardSumAggregateOutputType = {
    amount: number | null
  }

  export type StakingRewardMinAggregateOutputType = {
    id: string | null
    userId: string | null
    poolId: string | null
    positionId: string | null
    amount: number | null
    rewardType: $Enums.StakingRewardType | null
    claimedAt: Date | null
    createdAt: Date | null
  }

  export type StakingRewardMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    poolId: string | null
    positionId: string | null
    amount: number | null
    rewardType: $Enums.StakingRewardType | null
    claimedAt: Date | null
    createdAt: Date | null
  }

  export type StakingRewardCountAggregateOutputType = {
    id: number
    userId: number
    poolId: number
    positionId: number
    amount: number
    rewardType: number
    claimedAt: number
    createdAt: number
    _all: number
  }


  export type StakingRewardAvgAggregateInputType = {
    amount?: true
  }

  export type StakingRewardSumAggregateInputType = {
    amount?: true
  }

  export type StakingRewardMinAggregateInputType = {
    id?: true
    userId?: true
    poolId?: true
    positionId?: true
    amount?: true
    rewardType?: true
    claimedAt?: true
    createdAt?: true
  }

  export type StakingRewardMaxAggregateInputType = {
    id?: true
    userId?: true
    poolId?: true
    positionId?: true
    amount?: true
    rewardType?: true
    claimedAt?: true
    createdAt?: true
  }

  export type StakingRewardCountAggregateInputType = {
    id?: true
    userId?: true
    poolId?: true
    positionId?: true
    amount?: true
    rewardType?: true
    claimedAt?: true
    createdAt?: true
    _all?: true
  }

  export type StakingRewardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StakingReward to aggregate.
     */
    where?: StakingRewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StakingRewards to fetch.
     */
    orderBy?: StakingRewardOrderByWithRelationInput | StakingRewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StakingRewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StakingRewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StakingRewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StakingRewards
    **/
    _count?: true | StakingRewardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StakingRewardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StakingRewardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StakingRewardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StakingRewardMaxAggregateInputType
  }

  export type GetStakingRewardAggregateType<T extends StakingRewardAggregateArgs> = {
        [P in keyof T & keyof AggregateStakingReward]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStakingReward[P]>
      : GetScalarType<T[P], AggregateStakingReward[P]>
  }




  export type StakingRewardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StakingRewardWhereInput
    orderBy?: StakingRewardOrderByWithAggregationInput | StakingRewardOrderByWithAggregationInput[]
    by: StakingRewardScalarFieldEnum[] | StakingRewardScalarFieldEnum
    having?: StakingRewardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StakingRewardCountAggregateInputType | true
    _avg?: StakingRewardAvgAggregateInputType
    _sum?: StakingRewardSumAggregateInputType
    _min?: StakingRewardMinAggregateInputType
    _max?: StakingRewardMaxAggregateInputType
  }

  export type StakingRewardGroupByOutputType = {
    id: string
    userId: string
    poolId: string
    positionId: string
    amount: number
    rewardType: $Enums.StakingRewardType
    claimedAt: Date | null
    createdAt: Date
    _count: StakingRewardCountAggregateOutputType | null
    _avg: StakingRewardAvgAggregateOutputType | null
    _sum: StakingRewardSumAggregateOutputType | null
    _min: StakingRewardMinAggregateOutputType | null
    _max: StakingRewardMaxAggregateOutputType | null
  }

  type GetStakingRewardGroupByPayload<T extends StakingRewardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StakingRewardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StakingRewardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StakingRewardGroupByOutputType[P]>
            : GetScalarType<T[P], StakingRewardGroupByOutputType[P]>
        }
      >
    >


  export type StakingRewardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    poolId?: boolean
    positionId?: boolean
    amount?: boolean
    rewardType?: boolean
    claimedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    pool?: boolean | StakingPoolDefaultArgs<ExtArgs>
    position?: boolean | StakingPositionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stakingReward"]>

  export type StakingRewardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    poolId?: boolean
    positionId?: boolean
    amount?: boolean
    rewardType?: boolean
    claimedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    pool?: boolean | StakingPoolDefaultArgs<ExtArgs>
    position?: boolean | StakingPositionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stakingReward"]>

  export type StakingRewardSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    poolId?: boolean
    positionId?: boolean
    amount?: boolean
    rewardType?: boolean
    claimedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    pool?: boolean | StakingPoolDefaultArgs<ExtArgs>
    position?: boolean | StakingPositionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stakingReward"]>

  export type StakingRewardSelectScalar = {
    id?: boolean
    userId?: boolean
    poolId?: boolean
    positionId?: boolean
    amount?: boolean
    rewardType?: boolean
    claimedAt?: boolean
    createdAt?: boolean
  }

  export type StakingRewardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "poolId" | "positionId" | "amount" | "rewardType" | "claimedAt" | "createdAt", ExtArgs["result"]["stakingReward"]>
  export type StakingRewardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    pool?: boolean | StakingPoolDefaultArgs<ExtArgs>
    position?: boolean | StakingPositionDefaultArgs<ExtArgs>
  }
  export type StakingRewardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    pool?: boolean | StakingPoolDefaultArgs<ExtArgs>
    position?: boolean | StakingPositionDefaultArgs<ExtArgs>
  }
  export type StakingRewardIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    pool?: boolean | StakingPoolDefaultArgs<ExtArgs>
    position?: boolean | StakingPositionDefaultArgs<ExtArgs>
  }

  export type $StakingRewardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StakingReward"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      pool: Prisma.$StakingPoolPayload<ExtArgs>
      position: Prisma.$StakingPositionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      poolId: string
      positionId: string
      amount: number
      rewardType: $Enums.StakingRewardType
      claimedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["stakingReward"]>
    composites: {}
  }

  type StakingRewardGetPayload<S extends boolean | null | undefined | StakingRewardDefaultArgs> = $Result.GetResult<Prisma.$StakingRewardPayload, S>

  type StakingRewardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StakingRewardFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StakingRewardCountAggregateInputType | true
    }

  export interface StakingRewardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StakingReward'], meta: { name: 'StakingReward' } }
    /**
     * Find zero or one StakingReward that matches the filter.
     * @param {StakingRewardFindUniqueArgs} args - Arguments to find a StakingReward
     * @example
     * // Get one StakingReward
     * const stakingReward = await prisma.stakingReward.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StakingRewardFindUniqueArgs>(args: SelectSubset<T, StakingRewardFindUniqueArgs<ExtArgs>>): Prisma__StakingRewardClient<$Result.GetResult<Prisma.$StakingRewardPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StakingReward that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StakingRewardFindUniqueOrThrowArgs} args - Arguments to find a StakingReward
     * @example
     * // Get one StakingReward
     * const stakingReward = await prisma.stakingReward.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StakingRewardFindUniqueOrThrowArgs>(args: SelectSubset<T, StakingRewardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StakingRewardClient<$Result.GetResult<Prisma.$StakingRewardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StakingReward that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StakingRewardFindFirstArgs} args - Arguments to find a StakingReward
     * @example
     * // Get one StakingReward
     * const stakingReward = await prisma.stakingReward.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StakingRewardFindFirstArgs>(args?: SelectSubset<T, StakingRewardFindFirstArgs<ExtArgs>>): Prisma__StakingRewardClient<$Result.GetResult<Prisma.$StakingRewardPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StakingReward that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StakingRewardFindFirstOrThrowArgs} args - Arguments to find a StakingReward
     * @example
     * // Get one StakingReward
     * const stakingReward = await prisma.stakingReward.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StakingRewardFindFirstOrThrowArgs>(args?: SelectSubset<T, StakingRewardFindFirstOrThrowArgs<ExtArgs>>): Prisma__StakingRewardClient<$Result.GetResult<Prisma.$StakingRewardPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StakingRewards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StakingRewardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StakingRewards
     * const stakingRewards = await prisma.stakingReward.findMany()
     * 
     * // Get first 10 StakingRewards
     * const stakingRewards = await prisma.stakingReward.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stakingRewardWithIdOnly = await prisma.stakingReward.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StakingRewardFindManyArgs>(args?: SelectSubset<T, StakingRewardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StakingRewardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StakingReward.
     * @param {StakingRewardCreateArgs} args - Arguments to create a StakingReward.
     * @example
     * // Create one StakingReward
     * const StakingReward = await prisma.stakingReward.create({
     *   data: {
     *     // ... data to create a StakingReward
     *   }
     * })
     * 
     */
    create<T extends StakingRewardCreateArgs>(args: SelectSubset<T, StakingRewardCreateArgs<ExtArgs>>): Prisma__StakingRewardClient<$Result.GetResult<Prisma.$StakingRewardPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StakingRewards.
     * @param {StakingRewardCreateManyArgs} args - Arguments to create many StakingRewards.
     * @example
     * // Create many StakingRewards
     * const stakingReward = await prisma.stakingReward.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StakingRewardCreateManyArgs>(args?: SelectSubset<T, StakingRewardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StakingRewards and returns the data saved in the database.
     * @param {StakingRewardCreateManyAndReturnArgs} args - Arguments to create many StakingRewards.
     * @example
     * // Create many StakingRewards
     * const stakingReward = await prisma.stakingReward.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StakingRewards and only return the `id`
     * const stakingRewardWithIdOnly = await prisma.stakingReward.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StakingRewardCreateManyAndReturnArgs>(args?: SelectSubset<T, StakingRewardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StakingRewardPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StakingReward.
     * @param {StakingRewardDeleteArgs} args - Arguments to delete one StakingReward.
     * @example
     * // Delete one StakingReward
     * const StakingReward = await prisma.stakingReward.delete({
     *   where: {
     *     // ... filter to delete one StakingReward
     *   }
     * })
     * 
     */
    delete<T extends StakingRewardDeleteArgs>(args: SelectSubset<T, StakingRewardDeleteArgs<ExtArgs>>): Prisma__StakingRewardClient<$Result.GetResult<Prisma.$StakingRewardPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StakingReward.
     * @param {StakingRewardUpdateArgs} args - Arguments to update one StakingReward.
     * @example
     * // Update one StakingReward
     * const stakingReward = await prisma.stakingReward.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StakingRewardUpdateArgs>(args: SelectSubset<T, StakingRewardUpdateArgs<ExtArgs>>): Prisma__StakingRewardClient<$Result.GetResult<Prisma.$StakingRewardPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StakingRewards.
     * @param {StakingRewardDeleteManyArgs} args - Arguments to filter StakingRewards to delete.
     * @example
     * // Delete a few StakingRewards
     * const { count } = await prisma.stakingReward.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StakingRewardDeleteManyArgs>(args?: SelectSubset<T, StakingRewardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StakingRewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StakingRewardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StakingRewards
     * const stakingReward = await prisma.stakingReward.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StakingRewardUpdateManyArgs>(args: SelectSubset<T, StakingRewardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StakingRewards and returns the data updated in the database.
     * @param {StakingRewardUpdateManyAndReturnArgs} args - Arguments to update many StakingRewards.
     * @example
     * // Update many StakingRewards
     * const stakingReward = await prisma.stakingReward.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StakingRewards and only return the `id`
     * const stakingRewardWithIdOnly = await prisma.stakingReward.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StakingRewardUpdateManyAndReturnArgs>(args: SelectSubset<T, StakingRewardUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StakingRewardPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StakingReward.
     * @param {StakingRewardUpsertArgs} args - Arguments to update or create a StakingReward.
     * @example
     * // Update or create a StakingReward
     * const stakingReward = await prisma.stakingReward.upsert({
     *   create: {
     *     // ... data to create a StakingReward
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StakingReward we want to update
     *   }
     * })
     */
    upsert<T extends StakingRewardUpsertArgs>(args: SelectSubset<T, StakingRewardUpsertArgs<ExtArgs>>): Prisma__StakingRewardClient<$Result.GetResult<Prisma.$StakingRewardPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StakingRewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StakingRewardCountArgs} args - Arguments to filter StakingRewards to count.
     * @example
     * // Count the number of StakingRewards
     * const count = await prisma.stakingReward.count({
     *   where: {
     *     // ... the filter for the StakingRewards we want to count
     *   }
     * })
    **/
    count<T extends StakingRewardCountArgs>(
      args?: Subset<T, StakingRewardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StakingRewardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StakingReward.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StakingRewardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StakingRewardAggregateArgs>(args: Subset<T, StakingRewardAggregateArgs>): Prisma.PrismaPromise<GetStakingRewardAggregateType<T>>

    /**
     * Group by StakingReward.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StakingRewardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StakingRewardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StakingRewardGroupByArgs['orderBy'] }
        : { orderBy?: StakingRewardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StakingRewardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStakingRewardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StakingReward model
   */
  readonly fields: StakingRewardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StakingReward.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StakingRewardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pool<T extends StakingPoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StakingPoolDefaultArgs<ExtArgs>>): Prisma__StakingPoolClient<$Result.GetResult<Prisma.$StakingPoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    position<T extends StakingPositionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StakingPositionDefaultArgs<ExtArgs>>): Prisma__StakingPositionClient<$Result.GetResult<Prisma.$StakingPositionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StakingReward model
   */
  interface StakingRewardFieldRefs {
    readonly id: FieldRef<"StakingReward", 'String'>
    readonly userId: FieldRef<"StakingReward", 'String'>
    readonly poolId: FieldRef<"StakingReward", 'String'>
    readonly positionId: FieldRef<"StakingReward", 'String'>
    readonly amount: FieldRef<"StakingReward", 'Float'>
    readonly rewardType: FieldRef<"StakingReward", 'StakingRewardType'>
    readonly claimedAt: FieldRef<"StakingReward", 'DateTime'>
    readonly createdAt: FieldRef<"StakingReward", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StakingReward findUnique
   */
  export type StakingRewardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakingReward
     */
    select?: StakingRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakingReward
     */
    omit?: StakingRewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakingRewardInclude<ExtArgs> | null
    /**
     * Filter, which StakingReward to fetch.
     */
    where: StakingRewardWhereUniqueInput
  }

  /**
   * StakingReward findUniqueOrThrow
   */
  export type StakingRewardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakingReward
     */
    select?: StakingRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakingReward
     */
    omit?: StakingRewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakingRewardInclude<ExtArgs> | null
    /**
     * Filter, which StakingReward to fetch.
     */
    where: StakingRewardWhereUniqueInput
  }

  /**
   * StakingReward findFirst
   */
  export type StakingRewardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakingReward
     */
    select?: StakingRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakingReward
     */
    omit?: StakingRewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakingRewardInclude<ExtArgs> | null
    /**
     * Filter, which StakingReward to fetch.
     */
    where?: StakingRewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StakingRewards to fetch.
     */
    orderBy?: StakingRewardOrderByWithRelationInput | StakingRewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StakingRewards.
     */
    cursor?: StakingRewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StakingRewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StakingRewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StakingRewards.
     */
    distinct?: StakingRewardScalarFieldEnum | StakingRewardScalarFieldEnum[]
  }

  /**
   * StakingReward findFirstOrThrow
   */
  export type StakingRewardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakingReward
     */
    select?: StakingRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakingReward
     */
    omit?: StakingRewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakingRewardInclude<ExtArgs> | null
    /**
     * Filter, which StakingReward to fetch.
     */
    where?: StakingRewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StakingRewards to fetch.
     */
    orderBy?: StakingRewardOrderByWithRelationInput | StakingRewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StakingRewards.
     */
    cursor?: StakingRewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StakingRewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StakingRewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StakingRewards.
     */
    distinct?: StakingRewardScalarFieldEnum | StakingRewardScalarFieldEnum[]
  }

  /**
   * StakingReward findMany
   */
  export type StakingRewardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakingReward
     */
    select?: StakingRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakingReward
     */
    omit?: StakingRewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakingRewardInclude<ExtArgs> | null
    /**
     * Filter, which StakingRewards to fetch.
     */
    where?: StakingRewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StakingRewards to fetch.
     */
    orderBy?: StakingRewardOrderByWithRelationInput | StakingRewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StakingRewards.
     */
    cursor?: StakingRewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StakingRewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StakingRewards.
     */
    skip?: number
    distinct?: StakingRewardScalarFieldEnum | StakingRewardScalarFieldEnum[]
  }

  /**
   * StakingReward create
   */
  export type StakingRewardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakingReward
     */
    select?: StakingRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakingReward
     */
    omit?: StakingRewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakingRewardInclude<ExtArgs> | null
    /**
     * The data needed to create a StakingReward.
     */
    data: XOR<StakingRewardCreateInput, StakingRewardUncheckedCreateInput>
  }

  /**
   * StakingReward createMany
   */
  export type StakingRewardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StakingRewards.
     */
    data: StakingRewardCreateManyInput | StakingRewardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StakingReward createManyAndReturn
   */
  export type StakingRewardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakingReward
     */
    select?: StakingRewardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StakingReward
     */
    omit?: StakingRewardOmit<ExtArgs> | null
    /**
     * The data used to create many StakingRewards.
     */
    data: StakingRewardCreateManyInput | StakingRewardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakingRewardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StakingReward update
   */
  export type StakingRewardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakingReward
     */
    select?: StakingRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakingReward
     */
    omit?: StakingRewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakingRewardInclude<ExtArgs> | null
    /**
     * The data needed to update a StakingReward.
     */
    data: XOR<StakingRewardUpdateInput, StakingRewardUncheckedUpdateInput>
    /**
     * Choose, which StakingReward to update.
     */
    where: StakingRewardWhereUniqueInput
  }

  /**
   * StakingReward updateMany
   */
  export type StakingRewardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StakingRewards.
     */
    data: XOR<StakingRewardUpdateManyMutationInput, StakingRewardUncheckedUpdateManyInput>
    /**
     * Filter which StakingRewards to update
     */
    where?: StakingRewardWhereInput
    /**
     * Limit how many StakingRewards to update.
     */
    limit?: number
  }

  /**
   * StakingReward updateManyAndReturn
   */
  export type StakingRewardUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakingReward
     */
    select?: StakingRewardSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StakingReward
     */
    omit?: StakingRewardOmit<ExtArgs> | null
    /**
     * The data used to update StakingRewards.
     */
    data: XOR<StakingRewardUpdateManyMutationInput, StakingRewardUncheckedUpdateManyInput>
    /**
     * Filter which StakingRewards to update
     */
    where?: StakingRewardWhereInput
    /**
     * Limit how many StakingRewards to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakingRewardIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StakingReward upsert
   */
  export type StakingRewardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakingReward
     */
    select?: StakingRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakingReward
     */
    omit?: StakingRewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakingRewardInclude<ExtArgs> | null
    /**
     * The filter to search for the StakingReward to update in case it exists.
     */
    where: StakingRewardWhereUniqueInput
    /**
     * In case the StakingReward found by the `where` argument doesn't exist, create a new StakingReward with this data.
     */
    create: XOR<StakingRewardCreateInput, StakingRewardUncheckedCreateInput>
    /**
     * In case the StakingReward was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StakingRewardUpdateInput, StakingRewardUncheckedUpdateInput>
  }

  /**
   * StakingReward delete
   */
  export type StakingRewardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakingReward
     */
    select?: StakingRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakingReward
     */
    omit?: StakingRewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakingRewardInclude<ExtArgs> | null
    /**
     * Filter which StakingReward to delete.
     */
    where: StakingRewardWhereUniqueInput
  }

  /**
   * StakingReward deleteMany
   */
  export type StakingRewardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StakingRewards to delete
     */
    where?: StakingRewardWhereInput
    /**
     * Limit how many StakingRewards to delete.
     */
    limit?: number
  }

  /**
   * StakingReward without action
   */
  export type StakingRewardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakingReward
     */
    select?: StakingRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakingReward
     */
    omit?: StakingRewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakingRewardInclude<ExtArgs> | null
  }


  /**
   * Model GovernanceProposal
   */

  export type AggregateGovernanceProposal = {
    _count: GovernanceProposalCountAggregateOutputType | null
    _avg: GovernanceProposalAvgAggregateOutputType | null
    _sum: GovernanceProposalSumAggregateOutputType | null
    _min: GovernanceProposalMinAggregateOutputType | null
    _max: GovernanceProposalMaxAggregateOutputType | null
  }

  export type GovernanceProposalAvgAggregateOutputType = {
    minQuorum: number | null
    minApproval: number | null
    totalVotes: number | null
    yesVotes: number | null
    noVotes: number | null
    abstainVotes: number | null
  }

  export type GovernanceProposalSumAggregateOutputType = {
    minQuorum: number | null
    minApproval: number | null
    totalVotes: number | null
    yesVotes: number | null
    noVotes: number | null
    abstainVotes: number | null
  }

  export type GovernanceProposalMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    proposalType: $Enums.ProposalType | null
    proposerId: string | null
    status: $Enums.GovernanceStatus | null
    votingStartsAt: Date | null
    votingEndsAt: Date | null
    executionDate: Date | null
    minQuorum: number | null
    minApproval: number | null
    totalVotes: number | null
    yesVotes: number | null
    noVotes: number | null
    abstainVotes: number | null
    isExecuted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GovernanceProposalMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    proposalType: $Enums.ProposalType | null
    proposerId: string | null
    status: $Enums.GovernanceStatus | null
    votingStartsAt: Date | null
    votingEndsAt: Date | null
    executionDate: Date | null
    minQuorum: number | null
    minApproval: number | null
    totalVotes: number | null
    yesVotes: number | null
    noVotes: number | null
    abstainVotes: number | null
    isExecuted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GovernanceProposalCountAggregateOutputType = {
    id: number
    title: number
    description: number
    proposalType: number
    proposerId: number
    status: number
    votingStartsAt: number
    votingEndsAt: number
    executionDate: number
    minQuorum: number
    minApproval: number
    totalVotes: number
    yesVotes: number
    noVotes: number
    abstainVotes: number
    isExecuted: number
    createdAt: number
    updatedAt: number
    parameters: number
    _all: number
  }


  export type GovernanceProposalAvgAggregateInputType = {
    minQuorum?: true
    minApproval?: true
    totalVotes?: true
    yesVotes?: true
    noVotes?: true
    abstainVotes?: true
  }

  export type GovernanceProposalSumAggregateInputType = {
    minQuorum?: true
    minApproval?: true
    totalVotes?: true
    yesVotes?: true
    noVotes?: true
    abstainVotes?: true
  }

  export type GovernanceProposalMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    proposalType?: true
    proposerId?: true
    status?: true
    votingStartsAt?: true
    votingEndsAt?: true
    executionDate?: true
    minQuorum?: true
    minApproval?: true
    totalVotes?: true
    yesVotes?: true
    noVotes?: true
    abstainVotes?: true
    isExecuted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GovernanceProposalMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    proposalType?: true
    proposerId?: true
    status?: true
    votingStartsAt?: true
    votingEndsAt?: true
    executionDate?: true
    minQuorum?: true
    minApproval?: true
    totalVotes?: true
    yesVotes?: true
    noVotes?: true
    abstainVotes?: true
    isExecuted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GovernanceProposalCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    proposalType?: true
    proposerId?: true
    status?: true
    votingStartsAt?: true
    votingEndsAt?: true
    executionDate?: true
    minQuorum?: true
    minApproval?: true
    totalVotes?: true
    yesVotes?: true
    noVotes?: true
    abstainVotes?: true
    isExecuted?: true
    createdAt?: true
    updatedAt?: true
    parameters?: true
    _all?: true
  }

  export type GovernanceProposalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GovernanceProposal to aggregate.
     */
    where?: GovernanceProposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GovernanceProposals to fetch.
     */
    orderBy?: GovernanceProposalOrderByWithRelationInput | GovernanceProposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GovernanceProposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GovernanceProposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GovernanceProposals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GovernanceProposals
    **/
    _count?: true | GovernanceProposalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GovernanceProposalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GovernanceProposalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GovernanceProposalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GovernanceProposalMaxAggregateInputType
  }

  export type GetGovernanceProposalAggregateType<T extends GovernanceProposalAggregateArgs> = {
        [P in keyof T & keyof AggregateGovernanceProposal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGovernanceProposal[P]>
      : GetScalarType<T[P], AggregateGovernanceProposal[P]>
  }




  export type GovernanceProposalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GovernanceProposalWhereInput
    orderBy?: GovernanceProposalOrderByWithAggregationInput | GovernanceProposalOrderByWithAggregationInput[]
    by: GovernanceProposalScalarFieldEnum[] | GovernanceProposalScalarFieldEnum
    having?: GovernanceProposalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GovernanceProposalCountAggregateInputType | true
    _avg?: GovernanceProposalAvgAggregateInputType
    _sum?: GovernanceProposalSumAggregateInputType
    _min?: GovernanceProposalMinAggregateInputType
    _max?: GovernanceProposalMaxAggregateInputType
  }

  export type GovernanceProposalGroupByOutputType = {
    id: string
    title: string
    description: string
    proposalType: $Enums.ProposalType
    proposerId: string
    status: $Enums.GovernanceStatus
    votingStartsAt: Date
    votingEndsAt: Date
    executionDate: Date | null
    minQuorum: number
    minApproval: number
    totalVotes: number
    yesVotes: number
    noVotes: number
    abstainVotes: number
    isExecuted: boolean
    createdAt: Date
    updatedAt: Date
    parameters: JsonValue | null
    _count: GovernanceProposalCountAggregateOutputType | null
    _avg: GovernanceProposalAvgAggregateOutputType | null
    _sum: GovernanceProposalSumAggregateOutputType | null
    _min: GovernanceProposalMinAggregateOutputType | null
    _max: GovernanceProposalMaxAggregateOutputType | null
  }

  type GetGovernanceProposalGroupByPayload<T extends GovernanceProposalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GovernanceProposalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GovernanceProposalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GovernanceProposalGroupByOutputType[P]>
            : GetScalarType<T[P], GovernanceProposalGroupByOutputType[P]>
        }
      >
    >


  export type GovernanceProposalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    proposalType?: boolean
    proposerId?: boolean
    status?: boolean
    votingStartsAt?: boolean
    votingEndsAt?: boolean
    executionDate?: boolean
    minQuorum?: boolean
    minApproval?: boolean
    totalVotes?: boolean
    yesVotes?: boolean
    noVotes?: boolean
    abstainVotes?: boolean
    isExecuted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parameters?: boolean
    proposer?: boolean | UserDefaultArgs<ExtArgs>
    votes?: boolean | GovernanceProposal$votesArgs<ExtArgs>
    _count?: boolean | GovernanceProposalCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["governanceProposal"]>

  export type GovernanceProposalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    proposalType?: boolean
    proposerId?: boolean
    status?: boolean
    votingStartsAt?: boolean
    votingEndsAt?: boolean
    executionDate?: boolean
    minQuorum?: boolean
    minApproval?: boolean
    totalVotes?: boolean
    yesVotes?: boolean
    noVotes?: boolean
    abstainVotes?: boolean
    isExecuted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parameters?: boolean
    proposer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["governanceProposal"]>

  export type GovernanceProposalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    proposalType?: boolean
    proposerId?: boolean
    status?: boolean
    votingStartsAt?: boolean
    votingEndsAt?: boolean
    executionDate?: boolean
    minQuorum?: boolean
    minApproval?: boolean
    totalVotes?: boolean
    yesVotes?: boolean
    noVotes?: boolean
    abstainVotes?: boolean
    isExecuted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parameters?: boolean
    proposer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["governanceProposal"]>

  export type GovernanceProposalSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    proposalType?: boolean
    proposerId?: boolean
    status?: boolean
    votingStartsAt?: boolean
    votingEndsAt?: boolean
    executionDate?: boolean
    minQuorum?: boolean
    minApproval?: boolean
    totalVotes?: boolean
    yesVotes?: boolean
    noVotes?: boolean
    abstainVotes?: boolean
    isExecuted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parameters?: boolean
  }

  export type GovernanceProposalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "proposalType" | "proposerId" | "status" | "votingStartsAt" | "votingEndsAt" | "executionDate" | "minQuorum" | "minApproval" | "totalVotes" | "yesVotes" | "noVotes" | "abstainVotes" | "isExecuted" | "createdAt" | "updatedAt" | "parameters", ExtArgs["result"]["governanceProposal"]>
  export type GovernanceProposalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proposer?: boolean | UserDefaultArgs<ExtArgs>
    votes?: boolean | GovernanceProposal$votesArgs<ExtArgs>
    _count?: boolean | GovernanceProposalCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GovernanceProposalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proposer?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GovernanceProposalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proposer?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $GovernanceProposalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GovernanceProposal"
    objects: {
      proposer: Prisma.$UserPayload<ExtArgs>
      votes: Prisma.$GovernanceVotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      proposalType: $Enums.ProposalType
      proposerId: string
      status: $Enums.GovernanceStatus
      votingStartsAt: Date
      votingEndsAt: Date
      executionDate: Date | null
      minQuorum: number
      minApproval: number
      totalVotes: number
      yesVotes: number
      noVotes: number
      abstainVotes: number
      isExecuted: boolean
      createdAt: Date
      updatedAt: Date
      parameters: Prisma.JsonValue | null
    }, ExtArgs["result"]["governanceProposal"]>
    composites: {}
  }

  type GovernanceProposalGetPayload<S extends boolean | null | undefined | GovernanceProposalDefaultArgs> = $Result.GetResult<Prisma.$GovernanceProposalPayload, S>

  type GovernanceProposalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GovernanceProposalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GovernanceProposalCountAggregateInputType | true
    }

  export interface GovernanceProposalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GovernanceProposal'], meta: { name: 'GovernanceProposal' } }
    /**
     * Find zero or one GovernanceProposal that matches the filter.
     * @param {GovernanceProposalFindUniqueArgs} args - Arguments to find a GovernanceProposal
     * @example
     * // Get one GovernanceProposal
     * const governanceProposal = await prisma.governanceProposal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GovernanceProposalFindUniqueArgs>(args: SelectSubset<T, GovernanceProposalFindUniqueArgs<ExtArgs>>): Prisma__GovernanceProposalClient<$Result.GetResult<Prisma.$GovernanceProposalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GovernanceProposal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GovernanceProposalFindUniqueOrThrowArgs} args - Arguments to find a GovernanceProposal
     * @example
     * // Get one GovernanceProposal
     * const governanceProposal = await prisma.governanceProposal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GovernanceProposalFindUniqueOrThrowArgs>(args: SelectSubset<T, GovernanceProposalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GovernanceProposalClient<$Result.GetResult<Prisma.$GovernanceProposalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GovernanceProposal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GovernanceProposalFindFirstArgs} args - Arguments to find a GovernanceProposal
     * @example
     * // Get one GovernanceProposal
     * const governanceProposal = await prisma.governanceProposal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GovernanceProposalFindFirstArgs>(args?: SelectSubset<T, GovernanceProposalFindFirstArgs<ExtArgs>>): Prisma__GovernanceProposalClient<$Result.GetResult<Prisma.$GovernanceProposalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GovernanceProposal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GovernanceProposalFindFirstOrThrowArgs} args - Arguments to find a GovernanceProposal
     * @example
     * // Get one GovernanceProposal
     * const governanceProposal = await prisma.governanceProposal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GovernanceProposalFindFirstOrThrowArgs>(args?: SelectSubset<T, GovernanceProposalFindFirstOrThrowArgs<ExtArgs>>): Prisma__GovernanceProposalClient<$Result.GetResult<Prisma.$GovernanceProposalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GovernanceProposals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GovernanceProposalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GovernanceProposals
     * const governanceProposals = await prisma.governanceProposal.findMany()
     * 
     * // Get first 10 GovernanceProposals
     * const governanceProposals = await prisma.governanceProposal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const governanceProposalWithIdOnly = await prisma.governanceProposal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GovernanceProposalFindManyArgs>(args?: SelectSubset<T, GovernanceProposalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GovernanceProposalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GovernanceProposal.
     * @param {GovernanceProposalCreateArgs} args - Arguments to create a GovernanceProposal.
     * @example
     * // Create one GovernanceProposal
     * const GovernanceProposal = await prisma.governanceProposal.create({
     *   data: {
     *     // ... data to create a GovernanceProposal
     *   }
     * })
     * 
     */
    create<T extends GovernanceProposalCreateArgs>(args: SelectSubset<T, GovernanceProposalCreateArgs<ExtArgs>>): Prisma__GovernanceProposalClient<$Result.GetResult<Prisma.$GovernanceProposalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GovernanceProposals.
     * @param {GovernanceProposalCreateManyArgs} args - Arguments to create many GovernanceProposals.
     * @example
     * // Create many GovernanceProposals
     * const governanceProposal = await prisma.governanceProposal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GovernanceProposalCreateManyArgs>(args?: SelectSubset<T, GovernanceProposalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GovernanceProposals and returns the data saved in the database.
     * @param {GovernanceProposalCreateManyAndReturnArgs} args - Arguments to create many GovernanceProposals.
     * @example
     * // Create many GovernanceProposals
     * const governanceProposal = await prisma.governanceProposal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GovernanceProposals and only return the `id`
     * const governanceProposalWithIdOnly = await prisma.governanceProposal.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GovernanceProposalCreateManyAndReturnArgs>(args?: SelectSubset<T, GovernanceProposalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GovernanceProposalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GovernanceProposal.
     * @param {GovernanceProposalDeleteArgs} args - Arguments to delete one GovernanceProposal.
     * @example
     * // Delete one GovernanceProposal
     * const GovernanceProposal = await prisma.governanceProposal.delete({
     *   where: {
     *     // ... filter to delete one GovernanceProposal
     *   }
     * })
     * 
     */
    delete<T extends GovernanceProposalDeleteArgs>(args: SelectSubset<T, GovernanceProposalDeleteArgs<ExtArgs>>): Prisma__GovernanceProposalClient<$Result.GetResult<Prisma.$GovernanceProposalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GovernanceProposal.
     * @param {GovernanceProposalUpdateArgs} args - Arguments to update one GovernanceProposal.
     * @example
     * // Update one GovernanceProposal
     * const governanceProposal = await prisma.governanceProposal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GovernanceProposalUpdateArgs>(args: SelectSubset<T, GovernanceProposalUpdateArgs<ExtArgs>>): Prisma__GovernanceProposalClient<$Result.GetResult<Prisma.$GovernanceProposalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GovernanceProposals.
     * @param {GovernanceProposalDeleteManyArgs} args - Arguments to filter GovernanceProposals to delete.
     * @example
     * // Delete a few GovernanceProposals
     * const { count } = await prisma.governanceProposal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GovernanceProposalDeleteManyArgs>(args?: SelectSubset<T, GovernanceProposalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GovernanceProposals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GovernanceProposalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GovernanceProposals
     * const governanceProposal = await prisma.governanceProposal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GovernanceProposalUpdateManyArgs>(args: SelectSubset<T, GovernanceProposalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GovernanceProposals and returns the data updated in the database.
     * @param {GovernanceProposalUpdateManyAndReturnArgs} args - Arguments to update many GovernanceProposals.
     * @example
     * // Update many GovernanceProposals
     * const governanceProposal = await prisma.governanceProposal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GovernanceProposals and only return the `id`
     * const governanceProposalWithIdOnly = await prisma.governanceProposal.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GovernanceProposalUpdateManyAndReturnArgs>(args: SelectSubset<T, GovernanceProposalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GovernanceProposalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GovernanceProposal.
     * @param {GovernanceProposalUpsertArgs} args - Arguments to update or create a GovernanceProposal.
     * @example
     * // Update or create a GovernanceProposal
     * const governanceProposal = await prisma.governanceProposal.upsert({
     *   create: {
     *     // ... data to create a GovernanceProposal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GovernanceProposal we want to update
     *   }
     * })
     */
    upsert<T extends GovernanceProposalUpsertArgs>(args: SelectSubset<T, GovernanceProposalUpsertArgs<ExtArgs>>): Prisma__GovernanceProposalClient<$Result.GetResult<Prisma.$GovernanceProposalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GovernanceProposals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GovernanceProposalCountArgs} args - Arguments to filter GovernanceProposals to count.
     * @example
     * // Count the number of GovernanceProposals
     * const count = await prisma.governanceProposal.count({
     *   where: {
     *     // ... the filter for the GovernanceProposals we want to count
     *   }
     * })
    **/
    count<T extends GovernanceProposalCountArgs>(
      args?: Subset<T, GovernanceProposalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GovernanceProposalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GovernanceProposal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GovernanceProposalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GovernanceProposalAggregateArgs>(args: Subset<T, GovernanceProposalAggregateArgs>): Prisma.PrismaPromise<GetGovernanceProposalAggregateType<T>>

    /**
     * Group by GovernanceProposal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GovernanceProposalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GovernanceProposalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GovernanceProposalGroupByArgs['orderBy'] }
        : { orderBy?: GovernanceProposalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GovernanceProposalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGovernanceProposalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GovernanceProposal model
   */
  readonly fields: GovernanceProposalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GovernanceProposal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GovernanceProposalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    proposer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    votes<T extends GovernanceProposal$votesArgs<ExtArgs> = {}>(args?: Subset<T, GovernanceProposal$votesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GovernanceVotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GovernanceProposal model
   */
  interface GovernanceProposalFieldRefs {
    readonly id: FieldRef<"GovernanceProposal", 'String'>
    readonly title: FieldRef<"GovernanceProposal", 'String'>
    readonly description: FieldRef<"GovernanceProposal", 'String'>
    readonly proposalType: FieldRef<"GovernanceProposal", 'ProposalType'>
    readonly proposerId: FieldRef<"GovernanceProposal", 'String'>
    readonly status: FieldRef<"GovernanceProposal", 'GovernanceStatus'>
    readonly votingStartsAt: FieldRef<"GovernanceProposal", 'DateTime'>
    readonly votingEndsAt: FieldRef<"GovernanceProposal", 'DateTime'>
    readonly executionDate: FieldRef<"GovernanceProposal", 'DateTime'>
    readonly minQuorum: FieldRef<"GovernanceProposal", 'Float'>
    readonly minApproval: FieldRef<"GovernanceProposal", 'Float'>
    readonly totalVotes: FieldRef<"GovernanceProposal", 'Float'>
    readonly yesVotes: FieldRef<"GovernanceProposal", 'Float'>
    readonly noVotes: FieldRef<"GovernanceProposal", 'Float'>
    readonly abstainVotes: FieldRef<"GovernanceProposal", 'Float'>
    readonly isExecuted: FieldRef<"GovernanceProposal", 'Boolean'>
    readonly createdAt: FieldRef<"GovernanceProposal", 'DateTime'>
    readonly updatedAt: FieldRef<"GovernanceProposal", 'DateTime'>
    readonly parameters: FieldRef<"GovernanceProposal", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * GovernanceProposal findUnique
   */
  export type GovernanceProposalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GovernanceProposal
     */
    select?: GovernanceProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GovernanceProposal
     */
    omit?: GovernanceProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GovernanceProposalInclude<ExtArgs> | null
    /**
     * Filter, which GovernanceProposal to fetch.
     */
    where: GovernanceProposalWhereUniqueInput
  }

  /**
   * GovernanceProposal findUniqueOrThrow
   */
  export type GovernanceProposalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GovernanceProposal
     */
    select?: GovernanceProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GovernanceProposal
     */
    omit?: GovernanceProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GovernanceProposalInclude<ExtArgs> | null
    /**
     * Filter, which GovernanceProposal to fetch.
     */
    where: GovernanceProposalWhereUniqueInput
  }

  /**
   * GovernanceProposal findFirst
   */
  export type GovernanceProposalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GovernanceProposal
     */
    select?: GovernanceProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GovernanceProposal
     */
    omit?: GovernanceProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GovernanceProposalInclude<ExtArgs> | null
    /**
     * Filter, which GovernanceProposal to fetch.
     */
    where?: GovernanceProposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GovernanceProposals to fetch.
     */
    orderBy?: GovernanceProposalOrderByWithRelationInput | GovernanceProposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GovernanceProposals.
     */
    cursor?: GovernanceProposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GovernanceProposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GovernanceProposals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GovernanceProposals.
     */
    distinct?: GovernanceProposalScalarFieldEnum | GovernanceProposalScalarFieldEnum[]
  }

  /**
   * GovernanceProposal findFirstOrThrow
   */
  export type GovernanceProposalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GovernanceProposal
     */
    select?: GovernanceProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GovernanceProposal
     */
    omit?: GovernanceProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GovernanceProposalInclude<ExtArgs> | null
    /**
     * Filter, which GovernanceProposal to fetch.
     */
    where?: GovernanceProposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GovernanceProposals to fetch.
     */
    orderBy?: GovernanceProposalOrderByWithRelationInput | GovernanceProposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GovernanceProposals.
     */
    cursor?: GovernanceProposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GovernanceProposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GovernanceProposals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GovernanceProposals.
     */
    distinct?: GovernanceProposalScalarFieldEnum | GovernanceProposalScalarFieldEnum[]
  }

  /**
   * GovernanceProposal findMany
   */
  export type GovernanceProposalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GovernanceProposal
     */
    select?: GovernanceProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GovernanceProposal
     */
    omit?: GovernanceProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GovernanceProposalInclude<ExtArgs> | null
    /**
     * Filter, which GovernanceProposals to fetch.
     */
    where?: GovernanceProposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GovernanceProposals to fetch.
     */
    orderBy?: GovernanceProposalOrderByWithRelationInput | GovernanceProposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GovernanceProposals.
     */
    cursor?: GovernanceProposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GovernanceProposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GovernanceProposals.
     */
    skip?: number
    distinct?: GovernanceProposalScalarFieldEnum | GovernanceProposalScalarFieldEnum[]
  }

  /**
   * GovernanceProposal create
   */
  export type GovernanceProposalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GovernanceProposal
     */
    select?: GovernanceProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GovernanceProposal
     */
    omit?: GovernanceProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GovernanceProposalInclude<ExtArgs> | null
    /**
     * The data needed to create a GovernanceProposal.
     */
    data: XOR<GovernanceProposalCreateInput, GovernanceProposalUncheckedCreateInput>
  }

  /**
   * GovernanceProposal createMany
   */
  export type GovernanceProposalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GovernanceProposals.
     */
    data: GovernanceProposalCreateManyInput | GovernanceProposalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GovernanceProposal createManyAndReturn
   */
  export type GovernanceProposalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GovernanceProposal
     */
    select?: GovernanceProposalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GovernanceProposal
     */
    omit?: GovernanceProposalOmit<ExtArgs> | null
    /**
     * The data used to create many GovernanceProposals.
     */
    data: GovernanceProposalCreateManyInput | GovernanceProposalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GovernanceProposalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GovernanceProposal update
   */
  export type GovernanceProposalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GovernanceProposal
     */
    select?: GovernanceProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GovernanceProposal
     */
    omit?: GovernanceProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GovernanceProposalInclude<ExtArgs> | null
    /**
     * The data needed to update a GovernanceProposal.
     */
    data: XOR<GovernanceProposalUpdateInput, GovernanceProposalUncheckedUpdateInput>
    /**
     * Choose, which GovernanceProposal to update.
     */
    where: GovernanceProposalWhereUniqueInput
  }

  /**
   * GovernanceProposal updateMany
   */
  export type GovernanceProposalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GovernanceProposals.
     */
    data: XOR<GovernanceProposalUpdateManyMutationInput, GovernanceProposalUncheckedUpdateManyInput>
    /**
     * Filter which GovernanceProposals to update
     */
    where?: GovernanceProposalWhereInput
    /**
     * Limit how many GovernanceProposals to update.
     */
    limit?: number
  }

  /**
   * GovernanceProposal updateManyAndReturn
   */
  export type GovernanceProposalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GovernanceProposal
     */
    select?: GovernanceProposalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GovernanceProposal
     */
    omit?: GovernanceProposalOmit<ExtArgs> | null
    /**
     * The data used to update GovernanceProposals.
     */
    data: XOR<GovernanceProposalUpdateManyMutationInput, GovernanceProposalUncheckedUpdateManyInput>
    /**
     * Filter which GovernanceProposals to update
     */
    where?: GovernanceProposalWhereInput
    /**
     * Limit how many GovernanceProposals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GovernanceProposalIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GovernanceProposal upsert
   */
  export type GovernanceProposalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GovernanceProposal
     */
    select?: GovernanceProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GovernanceProposal
     */
    omit?: GovernanceProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GovernanceProposalInclude<ExtArgs> | null
    /**
     * The filter to search for the GovernanceProposal to update in case it exists.
     */
    where: GovernanceProposalWhereUniqueInput
    /**
     * In case the GovernanceProposal found by the `where` argument doesn't exist, create a new GovernanceProposal with this data.
     */
    create: XOR<GovernanceProposalCreateInput, GovernanceProposalUncheckedCreateInput>
    /**
     * In case the GovernanceProposal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GovernanceProposalUpdateInput, GovernanceProposalUncheckedUpdateInput>
  }

  /**
   * GovernanceProposal delete
   */
  export type GovernanceProposalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GovernanceProposal
     */
    select?: GovernanceProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GovernanceProposal
     */
    omit?: GovernanceProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GovernanceProposalInclude<ExtArgs> | null
    /**
     * Filter which GovernanceProposal to delete.
     */
    where: GovernanceProposalWhereUniqueInput
  }

  /**
   * GovernanceProposal deleteMany
   */
  export type GovernanceProposalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GovernanceProposals to delete
     */
    where?: GovernanceProposalWhereInput
    /**
     * Limit how many GovernanceProposals to delete.
     */
    limit?: number
  }

  /**
   * GovernanceProposal.votes
   */
  export type GovernanceProposal$votesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GovernanceVote
     */
    select?: GovernanceVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GovernanceVote
     */
    omit?: GovernanceVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GovernanceVoteInclude<ExtArgs> | null
    where?: GovernanceVoteWhereInput
    orderBy?: GovernanceVoteOrderByWithRelationInput | GovernanceVoteOrderByWithRelationInput[]
    cursor?: GovernanceVoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GovernanceVoteScalarFieldEnum | GovernanceVoteScalarFieldEnum[]
  }

  /**
   * GovernanceProposal without action
   */
  export type GovernanceProposalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GovernanceProposal
     */
    select?: GovernanceProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GovernanceProposal
     */
    omit?: GovernanceProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GovernanceProposalInclude<ExtArgs> | null
  }


  /**
   * Model GovernanceVote
   */

  export type AggregateGovernanceVote = {
    _count: GovernanceVoteCountAggregateOutputType | null
    _avg: GovernanceVoteAvgAggregateOutputType | null
    _sum: GovernanceVoteSumAggregateOutputType | null
    _min: GovernanceVoteMinAggregateOutputType | null
    _max: GovernanceVoteMaxAggregateOutputType | null
  }

  export type GovernanceVoteAvgAggregateOutputType = {
    votingPower: number | null
  }

  export type GovernanceVoteSumAggregateOutputType = {
    votingPower: number | null
  }

  export type GovernanceVoteMinAggregateOutputType = {
    id: string | null
    proposalId: string | null
    userId: string | null
    voteChoice: $Enums.VoteChoice | null
    votingPower: number | null
    reason: string | null
    votedAt: Date | null
  }

  export type GovernanceVoteMaxAggregateOutputType = {
    id: string | null
    proposalId: string | null
    userId: string | null
    voteChoice: $Enums.VoteChoice | null
    votingPower: number | null
    reason: string | null
    votedAt: Date | null
  }

  export type GovernanceVoteCountAggregateOutputType = {
    id: number
    proposalId: number
    userId: number
    voteChoice: number
    votingPower: number
    reason: number
    votedAt: number
    _all: number
  }


  export type GovernanceVoteAvgAggregateInputType = {
    votingPower?: true
  }

  export type GovernanceVoteSumAggregateInputType = {
    votingPower?: true
  }

  export type GovernanceVoteMinAggregateInputType = {
    id?: true
    proposalId?: true
    userId?: true
    voteChoice?: true
    votingPower?: true
    reason?: true
    votedAt?: true
  }

  export type GovernanceVoteMaxAggregateInputType = {
    id?: true
    proposalId?: true
    userId?: true
    voteChoice?: true
    votingPower?: true
    reason?: true
    votedAt?: true
  }

  export type GovernanceVoteCountAggregateInputType = {
    id?: true
    proposalId?: true
    userId?: true
    voteChoice?: true
    votingPower?: true
    reason?: true
    votedAt?: true
    _all?: true
  }

  export type GovernanceVoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GovernanceVote to aggregate.
     */
    where?: GovernanceVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GovernanceVotes to fetch.
     */
    orderBy?: GovernanceVoteOrderByWithRelationInput | GovernanceVoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GovernanceVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GovernanceVotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GovernanceVotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GovernanceVotes
    **/
    _count?: true | GovernanceVoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GovernanceVoteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GovernanceVoteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GovernanceVoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GovernanceVoteMaxAggregateInputType
  }

  export type GetGovernanceVoteAggregateType<T extends GovernanceVoteAggregateArgs> = {
        [P in keyof T & keyof AggregateGovernanceVote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGovernanceVote[P]>
      : GetScalarType<T[P], AggregateGovernanceVote[P]>
  }




  export type GovernanceVoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GovernanceVoteWhereInput
    orderBy?: GovernanceVoteOrderByWithAggregationInput | GovernanceVoteOrderByWithAggregationInput[]
    by: GovernanceVoteScalarFieldEnum[] | GovernanceVoteScalarFieldEnum
    having?: GovernanceVoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GovernanceVoteCountAggregateInputType | true
    _avg?: GovernanceVoteAvgAggregateInputType
    _sum?: GovernanceVoteSumAggregateInputType
    _min?: GovernanceVoteMinAggregateInputType
    _max?: GovernanceVoteMaxAggregateInputType
  }

  export type GovernanceVoteGroupByOutputType = {
    id: string
    proposalId: string
    userId: string
    voteChoice: $Enums.VoteChoice
    votingPower: number
    reason: string | null
    votedAt: Date
    _count: GovernanceVoteCountAggregateOutputType | null
    _avg: GovernanceVoteAvgAggregateOutputType | null
    _sum: GovernanceVoteSumAggregateOutputType | null
    _min: GovernanceVoteMinAggregateOutputType | null
    _max: GovernanceVoteMaxAggregateOutputType | null
  }

  type GetGovernanceVoteGroupByPayload<T extends GovernanceVoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GovernanceVoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GovernanceVoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GovernanceVoteGroupByOutputType[P]>
            : GetScalarType<T[P], GovernanceVoteGroupByOutputType[P]>
        }
      >
    >


  export type GovernanceVoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    proposalId?: boolean
    userId?: boolean
    voteChoice?: boolean
    votingPower?: boolean
    reason?: boolean
    votedAt?: boolean
    proposal?: boolean | GovernanceProposalDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["governanceVote"]>

  export type GovernanceVoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    proposalId?: boolean
    userId?: boolean
    voteChoice?: boolean
    votingPower?: boolean
    reason?: boolean
    votedAt?: boolean
    proposal?: boolean | GovernanceProposalDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["governanceVote"]>

  export type GovernanceVoteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    proposalId?: boolean
    userId?: boolean
    voteChoice?: boolean
    votingPower?: boolean
    reason?: boolean
    votedAt?: boolean
    proposal?: boolean | GovernanceProposalDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["governanceVote"]>

  export type GovernanceVoteSelectScalar = {
    id?: boolean
    proposalId?: boolean
    userId?: boolean
    voteChoice?: boolean
    votingPower?: boolean
    reason?: boolean
    votedAt?: boolean
  }

  export type GovernanceVoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "proposalId" | "userId" | "voteChoice" | "votingPower" | "reason" | "votedAt", ExtArgs["result"]["governanceVote"]>
  export type GovernanceVoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proposal?: boolean | GovernanceProposalDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GovernanceVoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proposal?: boolean | GovernanceProposalDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GovernanceVoteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proposal?: boolean | GovernanceProposalDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $GovernanceVotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GovernanceVote"
    objects: {
      proposal: Prisma.$GovernanceProposalPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      proposalId: string
      userId: string
      voteChoice: $Enums.VoteChoice
      votingPower: number
      reason: string | null
      votedAt: Date
    }, ExtArgs["result"]["governanceVote"]>
    composites: {}
  }

  type GovernanceVoteGetPayload<S extends boolean | null | undefined | GovernanceVoteDefaultArgs> = $Result.GetResult<Prisma.$GovernanceVotePayload, S>

  type GovernanceVoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GovernanceVoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GovernanceVoteCountAggregateInputType | true
    }

  export interface GovernanceVoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GovernanceVote'], meta: { name: 'GovernanceVote' } }
    /**
     * Find zero or one GovernanceVote that matches the filter.
     * @param {GovernanceVoteFindUniqueArgs} args - Arguments to find a GovernanceVote
     * @example
     * // Get one GovernanceVote
     * const governanceVote = await prisma.governanceVote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GovernanceVoteFindUniqueArgs>(args: SelectSubset<T, GovernanceVoteFindUniqueArgs<ExtArgs>>): Prisma__GovernanceVoteClient<$Result.GetResult<Prisma.$GovernanceVotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GovernanceVote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GovernanceVoteFindUniqueOrThrowArgs} args - Arguments to find a GovernanceVote
     * @example
     * // Get one GovernanceVote
     * const governanceVote = await prisma.governanceVote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GovernanceVoteFindUniqueOrThrowArgs>(args: SelectSubset<T, GovernanceVoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GovernanceVoteClient<$Result.GetResult<Prisma.$GovernanceVotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GovernanceVote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GovernanceVoteFindFirstArgs} args - Arguments to find a GovernanceVote
     * @example
     * // Get one GovernanceVote
     * const governanceVote = await prisma.governanceVote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GovernanceVoteFindFirstArgs>(args?: SelectSubset<T, GovernanceVoteFindFirstArgs<ExtArgs>>): Prisma__GovernanceVoteClient<$Result.GetResult<Prisma.$GovernanceVotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GovernanceVote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GovernanceVoteFindFirstOrThrowArgs} args - Arguments to find a GovernanceVote
     * @example
     * // Get one GovernanceVote
     * const governanceVote = await prisma.governanceVote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GovernanceVoteFindFirstOrThrowArgs>(args?: SelectSubset<T, GovernanceVoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__GovernanceVoteClient<$Result.GetResult<Prisma.$GovernanceVotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GovernanceVotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GovernanceVoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GovernanceVotes
     * const governanceVotes = await prisma.governanceVote.findMany()
     * 
     * // Get first 10 GovernanceVotes
     * const governanceVotes = await prisma.governanceVote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const governanceVoteWithIdOnly = await prisma.governanceVote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GovernanceVoteFindManyArgs>(args?: SelectSubset<T, GovernanceVoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GovernanceVotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GovernanceVote.
     * @param {GovernanceVoteCreateArgs} args - Arguments to create a GovernanceVote.
     * @example
     * // Create one GovernanceVote
     * const GovernanceVote = await prisma.governanceVote.create({
     *   data: {
     *     // ... data to create a GovernanceVote
     *   }
     * })
     * 
     */
    create<T extends GovernanceVoteCreateArgs>(args: SelectSubset<T, GovernanceVoteCreateArgs<ExtArgs>>): Prisma__GovernanceVoteClient<$Result.GetResult<Prisma.$GovernanceVotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GovernanceVotes.
     * @param {GovernanceVoteCreateManyArgs} args - Arguments to create many GovernanceVotes.
     * @example
     * // Create many GovernanceVotes
     * const governanceVote = await prisma.governanceVote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GovernanceVoteCreateManyArgs>(args?: SelectSubset<T, GovernanceVoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GovernanceVotes and returns the data saved in the database.
     * @param {GovernanceVoteCreateManyAndReturnArgs} args - Arguments to create many GovernanceVotes.
     * @example
     * // Create many GovernanceVotes
     * const governanceVote = await prisma.governanceVote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GovernanceVotes and only return the `id`
     * const governanceVoteWithIdOnly = await prisma.governanceVote.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GovernanceVoteCreateManyAndReturnArgs>(args?: SelectSubset<T, GovernanceVoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GovernanceVotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GovernanceVote.
     * @param {GovernanceVoteDeleteArgs} args - Arguments to delete one GovernanceVote.
     * @example
     * // Delete one GovernanceVote
     * const GovernanceVote = await prisma.governanceVote.delete({
     *   where: {
     *     // ... filter to delete one GovernanceVote
     *   }
     * })
     * 
     */
    delete<T extends GovernanceVoteDeleteArgs>(args: SelectSubset<T, GovernanceVoteDeleteArgs<ExtArgs>>): Prisma__GovernanceVoteClient<$Result.GetResult<Prisma.$GovernanceVotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GovernanceVote.
     * @param {GovernanceVoteUpdateArgs} args - Arguments to update one GovernanceVote.
     * @example
     * // Update one GovernanceVote
     * const governanceVote = await prisma.governanceVote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GovernanceVoteUpdateArgs>(args: SelectSubset<T, GovernanceVoteUpdateArgs<ExtArgs>>): Prisma__GovernanceVoteClient<$Result.GetResult<Prisma.$GovernanceVotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GovernanceVotes.
     * @param {GovernanceVoteDeleteManyArgs} args - Arguments to filter GovernanceVotes to delete.
     * @example
     * // Delete a few GovernanceVotes
     * const { count } = await prisma.governanceVote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GovernanceVoteDeleteManyArgs>(args?: SelectSubset<T, GovernanceVoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GovernanceVotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GovernanceVoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GovernanceVotes
     * const governanceVote = await prisma.governanceVote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GovernanceVoteUpdateManyArgs>(args: SelectSubset<T, GovernanceVoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GovernanceVotes and returns the data updated in the database.
     * @param {GovernanceVoteUpdateManyAndReturnArgs} args - Arguments to update many GovernanceVotes.
     * @example
     * // Update many GovernanceVotes
     * const governanceVote = await prisma.governanceVote.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GovernanceVotes and only return the `id`
     * const governanceVoteWithIdOnly = await prisma.governanceVote.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GovernanceVoteUpdateManyAndReturnArgs>(args: SelectSubset<T, GovernanceVoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GovernanceVotePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GovernanceVote.
     * @param {GovernanceVoteUpsertArgs} args - Arguments to update or create a GovernanceVote.
     * @example
     * // Update or create a GovernanceVote
     * const governanceVote = await prisma.governanceVote.upsert({
     *   create: {
     *     // ... data to create a GovernanceVote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GovernanceVote we want to update
     *   }
     * })
     */
    upsert<T extends GovernanceVoteUpsertArgs>(args: SelectSubset<T, GovernanceVoteUpsertArgs<ExtArgs>>): Prisma__GovernanceVoteClient<$Result.GetResult<Prisma.$GovernanceVotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GovernanceVotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GovernanceVoteCountArgs} args - Arguments to filter GovernanceVotes to count.
     * @example
     * // Count the number of GovernanceVotes
     * const count = await prisma.governanceVote.count({
     *   where: {
     *     // ... the filter for the GovernanceVotes we want to count
     *   }
     * })
    **/
    count<T extends GovernanceVoteCountArgs>(
      args?: Subset<T, GovernanceVoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GovernanceVoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GovernanceVote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GovernanceVoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GovernanceVoteAggregateArgs>(args: Subset<T, GovernanceVoteAggregateArgs>): Prisma.PrismaPromise<GetGovernanceVoteAggregateType<T>>

    /**
     * Group by GovernanceVote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GovernanceVoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GovernanceVoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GovernanceVoteGroupByArgs['orderBy'] }
        : { orderBy?: GovernanceVoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GovernanceVoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGovernanceVoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GovernanceVote model
   */
  readonly fields: GovernanceVoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GovernanceVote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GovernanceVoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    proposal<T extends GovernanceProposalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GovernanceProposalDefaultArgs<ExtArgs>>): Prisma__GovernanceProposalClient<$Result.GetResult<Prisma.$GovernanceProposalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GovernanceVote model
   */
  interface GovernanceVoteFieldRefs {
    readonly id: FieldRef<"GovernanceVote", 'String'>
    readonly proposalId: FieldRef<"GovernanceVote", 'String'>
    readonly userId: FieldRef<"GovernanceVote", 'String'>
    readonly voteChoice: FieldRef<"GovernanceVote", 'VoteChoice'>
    readonly votingPower: FieldRef<"GovernanceVote", 'Float'>
    readonly reason: FieldRef<"GovernanceVote", 'String'>
    readonly votedAt: FieldRef<"GovernanceVote", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GovernanceVote findUnique
   */
  export type GovernanceVoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GovernanceVote
     */
    select?: GovernanceVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GovernanceVote
     */
    omit?: GovernanceVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GovernanceVoteInclude<ExtArgs> | null
    /**
     * Filter, which GovernanceVote to fetch.
     */
    where: GovernanceVoteWhereUniqueInput
  }

  /**
   * GovernanceVote findUniqueOrThrow
   */
  export type GovernanceVoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GovernanceVote
     */
    select?: GovernanceVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GovernanceVote
     */
    omit?: GovernanceVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GovernanceVoteInclude<ExtArgs> | null
    /**
     * Filter, which GovernanceVote to fetch.
     */
    where: GovernanceVoteWhereUniqueInput
  }

  /**
   * GovernanceVote findFirst
   */
  export type GovernanceVoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GovernanceVote
     */
    select?: GovernanceVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GovernanceVote
     */
    omit?: GovernanceVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GovernanceVoteInclude<ExtArgs> | null
    /**
     * Filter, which GovernanceVote to fetch.
     */
    where?: GovernanceVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GovernanceVotes to fetch.
     */
    orderBy?: GovernanceVoteOrderByWithRelationInput | GovernanceVoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GovernanceVotes.
     */
    cursor?: GovernanceVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GovernanceVotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GovernanceVotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GovernanceVotes.
     */
    distinct?: GovernanceVoteScalarFieldEnum | GovernanceVoteScalarFieldEnum[]
  }

  /**
   * GovernanceVote findFirstOrThrow
   */
  export type GovernanceVoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GovernanceVote
     */
    select?: GovernanceVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GovernanceVote
     */
    omit?: GovernanceVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GovernanceVoteInclude<ExtArgs> | null
    /**
     * Filter, which GovernanceVote to fetch.
     */
    where?: GovernanceVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GovernanceVotes to fetch.
     */
    orderBy?: GovernanceVoteOrderByWithRelationInput | GovernanceVoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GovernanceVotes.
     */
    cursor?: GovernanceVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GovernanceVotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GovernanceVotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GovernanceVotes.
     */
    distinct?: GovernanceVoteScalarFieldEnum | GovernanceVoteScalarFieldEnum[]
  }

  /**
   * GovernanceVote findMany
   */
  export type GovernanceVoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GovernanceVote
     */
    select?: GovernanceVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GovernanceVote
     */
    omit?: GovernanceVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GovernanceVoteInclude<ExtArgs> | null
    /**
     * Filter, which GovernanceVotes to fetch.
     */
    where?: GovernanceVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GovernanceVotes to fetch.
     */
    orderBy?: GovernanceVoteOrderByWithRelationInput | GovernanceVoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GovernanceVotes.
     */
    cursor?: GovernanceVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GovernanceVotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GovernanceVotes.
     */
    skip?: number
    distinct?: GovernanceVoteScalarFieldEnum | GovernanceVoteScalarFieldEnum[]
  }

  /**
   * GovernanceVote create
   */
  export type GovernanceVoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GovernanceVote
     */
    select?: GovernanceVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GovernanceVote
     */
    omit?: GovernanceVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GovernanceVoteInclude<ExtArgs> | null
    /**
     * The data needed to create a GovernanceVote.
     */
    data: XOR<GovernanceVoteCreateInput, GovernanceVoteUncheckedCreateInput>
  }

  /**
   * GovernanceVote createMany
   */
  export type GovernanceVoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GovernanceVotes.
     */
    data: GovernanceVoteCreateManyInput | GovernanceVoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GovernanceVote createManyAndReturn
   */
  export type GovernanceVoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GovernanceVote
     */
    select?: GovernanceVoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GovernanceVote
     */
    omit?: GovernanceVoteOmit<ExtArgs> | null
    /**
     * The data used to create many GovernanceVotes.
     */
    data: GovernanceVoteCreateManyInput | GovernanceVoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GovernanceVoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GovernanceVote update
   */
  export type GovernanceVoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GovernanceVote
     */
    select?: GovernanceVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GovernanceVote
     */
    omit?: GovernanceVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GovernanceVoteInclude<ExtArgs> | null
    /**
     * The data needed to update a GovernanceVote.
     */
    data: XOR<GovernanceVoteUpdateInput, GovernanceVoteUncheckedUpdateInput>
    /**
     * Choose, which GovernanceVote to update.
     */
    where: GovernanceVoteWhereUniqueInput
  }

  /**
   * GovernanceVote updateMany
   */
  export type GovernanceVoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GovernanceVotes.
     */
    data: XOR<GovernanceVoteUpdateManyMutationInput, GovernanceVoteUncheckedUpdateManyInput>
    /**
     * Filter which GovernanceVotes to update
     */
    where?: GovernanceVoteWhereInput
    /**
     * Limit how many GovernanceVotes to update.
     */
    limit?: number
  }

  /**
   * GovernanceVote updateManyAndReturn
   */
  export type GovernanceVoteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GovernanceVote
     */
    select?: GovernanceVoteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GovernanceVote
     */
    omit?: GovernanceVoteOmit<ExtArgs> | null
    /**
     * The data used to update GovernanceVotes.
     */
    data: XOR<GovernanceVoteUpdateManyMutationInput, GovernanceVoteUncheckedUpdateManyInput>
    /**
     * Filter which GovernanceVotes to update
     */
    where?: GovernanceVoteWhereInput
    /**
     * Limit how many GovernanceVotes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GovernanceVoteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GovernanceVote upsert
   */
  export type GovernanceVoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GovernanceVote
     */
    select?: GovernanceVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GovernanceVote
     */
    omit?: GovernanceVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GovernanceVoteInclude<ExtArgs> | null
    /**
     * The filter to search for the GovernanceVote to update in case it exists.
     */
    where: GovernanceVoteWhereUniqueInput
    /**
     * In case the GovernanceVote found by the `where` argument doesn't exist, create a new GovernanceVote with this data.
     */
    create: XOR<GovernanceVoteCreateInput, GovernanceVoteUncheckedCreateInput>
    /**
     * In case the GovernanceVote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GovernanceVoteUpdateInput, GovernanceVoteUncheckedUpdateInput>
  }

  /**
   * GovernanceVote delete
   */
  export type GovernanceVoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GovernanceVote
     */
    select?: GovernanceVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GovernanceVote
     */
    omit?: GovernanceVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GovernanceVoteInclude<ExtArgs> | null
    /**
     * Filter which GovernanceVote to delete.
     */
    where: GovernanceVoteWhereUniqueInput
  }

  /**
   * GovernanceVote deleteMany
   */
  export type GovernanceVoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GovernanceVotes to delete
     */
    where?: GovernanceVoteWhereInput
    /**
     * Limit how many GovernanceVotes to delete.
     */
    limit?: number
  }

  /**
   * GovernanceVote without action
   */
  export type GovernanceVoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GovernanceVote
     */
    select?: GovernanceVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GovernanceVote
     */
    omit?: GovernanceVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GovernanceVoteInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    username: 'username',
    firstName: 'firstName',
    lastName: 'lastName',
    avatar: 'avatar',
    passwordHash: 'passwordHash',
    emailVerified: 'emailVerified',
    eceBalance: 'eceBalance',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastActive: 'lastActive'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserSubscriptionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    plan: 'plan',
    status: 'status',
    currentPeriodStart: 'currentPeriodStart',
    currentPeriodEnd: 'currentPeriodEnd',
    cancelAtPeriodEnd: 'cancelAtPeriodEnd',
    stripeCustomerId: 'stripeCustomerId',
    stripeSubscriptionId: 'stripeSubscriptionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserSubscriptionScalarFieldEnum = (typeof UserSubscriptionScalarFieldEnum)[keyof typeof UserSubscriptionScalarFieldEnum]


  export const SubscriptionFeaturesScalarFieldEnum: {
    id: 'id',
    subscriptionId: 'subscriptionId',
    maxTrades: 'maxTrades',
    advancedAnalytics: 'advancedAnalytics',
    prioritySupport: 'prioritySupport',
    marketplaceAccess: 'marketplaceAccess',
    premiumListings: 'premiumListings',
    bulkOperations: 'bulkOperations',
    cryptoPayments: 'cryptoPayments',
    physicalCard: 'physicalCard',
    businessStipend: 'businessStipend',
    withdrawalLimit: 'withdrawalLimit'
  };

  export type SubscriptionFeaturesScalarFieldEnum = (typeof SubscriptionFeaturesScalarFieldEnum)[keyof typeof SubscriptionFeaturesScalarFieldEnum]


  export const SubscriptionUsageScalarFieldEnum: {
    id: 'id',
    subscriptionId: 'subscriptionId',
    tradesThisMonth: 'tradesThisMonth',
    listingsThisMonth: 'listingsThisMonth',
    stipendUsed: 'stipendUsed',
    lastResetAt: 'lastResetAt'
  };

  export type SubscriptionUsageScalarFieldEnum = (typeof SubscriptionUsageScalarFieldEnum)[keyof typeof SubscriptionUsageScalarFieldEnum]


  export const CardScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    category: 'category',
    rarity: 'rarity',
    company: 'company',
    currentPrice: 'currentPrice',
    historicalPrices: 'historicalPrices',
    imageUrl: 'imageUrl',
    metadata: 'metadata',
    stats: 'stats',
    ownerId: 'ownerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CardScalarFieldEnum = (typeof CardScalarFieldEnum)[keyof typeof CardScalarFieldEnum]


  export const MarketplaceListingScalarFieldEnum: {
    id: 'id',
    cardId: 'cardId',
    sellerId: 'sellerId',
    price: 'price',
    listingType: 'listingType',
    auctionEnd: 'auctionEnd',
    status: 'status',
    featured: 'featured',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MarketplaceListingScalarFieldEnum = (typeof MarketplaceListingScalarFieldEnum)[keyof typeof MarketplaceListingScalarFieldEnum]


  export const BidScalarFieldEnum: {
    id: 'id',
    listingId: 'listingId',
    bidderId: 'bidderId',
    cardId: 'cardId',
    amount: 'amount',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BidScalarFieldEnum = (typeof BidScalarFieldEnum)[keyof typeof BidScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    cardId: 'cardId',
    type: 'type',
    amount: 'amount',
    currency: 'currency',
    status: 'status',
    description: 'description',
    metadata: 'metadata',
    paymentMethod: 'paymentMethod',
    paymentId: 'paymentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const CryptoWalletScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    currency: 'currency',
    address: 'address',
    balance: 'balance',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CryptoWalletScalarFieldEnum = (typeof CryptoWalletScalarFieldEnum)[keyof typeof CryptoWalletScalarFieldEnum]


  export const PhysicalCardScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    cardNumber: 'cardNumber',
    expiryDate: 'expiryDate',
    cvv: 'cvv',
    status: 'status',
    appleWalletPassId: 'appleWalletPassId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PhysicalCardScalarFieldEnum = (typeof PhysicalCardScalarFieldEnum)[keyof typeof PhysicalCardScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    title: 'title',
    message: 'message',
    data: 'data',
    read: 'read',
    priority: 'priority',
    requiresSubscription: 'requiresSubscription',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const SocialFeedScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    content: 'content',
    data: 'data',
    likes: 'likes',
    comments: 'comments',
    shares: 'shares',
    visibility: 'visibility',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SocialFeedScalarFieldEnum = (typeof SocialFeedScalarFieldEnum)[keyof typeof SocialFeedScalarFieldEnum]


  export const FollowScalarFieldEnum: {
    id: 'id',
    followerId: 'followerId',
    followingId: 'followingId',
    createdAt: 'createdAt'
  };

  export type FollowScalarFieldEnum = (typeof FollowScalarFieldEnum)[keyof typeof FollowScalarFieldEnum]


  export const AppOrderScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    projectType: 'projectType',
    title: 'title',
    description: 'description',
    requirements: 'requirements',
    timeline: 'timeline',
    estimatedCost: 'estimatedCost',
    actualCost: 'actualCost',
    currency: 'currency',
    status: 'status',
    priority: 'priority',
    deliveryDate: 'deliveryDate',
    githubRepo: 'githubRepo',
    vercelLink: 'vercelLink',
    downloadLink: 'downloadLink',
    progressPercentage: 'progressPercentage',
    currentMilestone: 'currentMilestone',
    assignedAdminId: 'assignedAdminId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AppOrderScalarFieldEnum = (typeof AppOrderScalarFieldEnum)[keyof typeof AppOrderScalarFieldEnum]


  export const OrderRevisionScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    userId: 'userId',
    revisionNumber: 'revisionNumber',
    title: 'title',
    description: 'description',
    status: 'status',
    adminResponse: 'adminResponse',
    adminId: 'adminId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrderRevisionScalarFieldEnum = (typeof OrderRevisionScalarFieldEnum)[keyof typeof OrderRevisionScalarFieldEnum]


  export const OrderCommunicationScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    userId: 'userId',
    messageType: 'messageType',
    subject: 'subject',
    message: 'message',
    isFromAdmin: 'isFromAdmin',
    attachments: 'attachments',
    read: 'read',
    important: 'important',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrderCommunicationScalarFieldEnum = (typeof OrderCommunicationScalarFieldEnum)[keyof typeof OrderCommunicationScalarFieldEnum]


  export const OrderDeliverableScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    type: 'type',
    title: 'title',
    description: 'description',
    url: 'url',
    filePath: 'filePath',
    status: 'status',
    delivered: 'delivered',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrderDeliverableScalarFieldEnum = (typeof OrderDeliverableScalarFieldEnum)[keyof typeof OrderDeliverableScalarFieldEnum]


  export const BettingMarketScalarFieldEnum: {
    id: 'id',
    cardId: 'cardId',
    metricType: 'metricType',
    title: 'title',
    description: 'description',
    currentValue: 'currentValue',
    predictionTarget: 'predictionTarget',
    targetDirection: 'targetDirection',
    odds: 'odds',
    totalPot: 'totalPot',
    minimumBet: 'minimumBet',
    maximumBet: 'maximumBet',
    startTime: 'startTime',
    expiryDate: 'expiryDate',
    settlementDate: 'settlementDate',
    status: 'status',
    settled: 'settled',
    settledValue: 'settledValue',
    winningDirection: 'winningDirection',
    marketMakerFee: 'marketMakerFee',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BettingMarketScalarFieldEnum = (typeof BettingMarketScalarFieldEnum)[keyof typeof BettingMarketScalarFieldEnum]


  export const BettingPositionScalarFieldEnum: {
    id: 'id',
    marketId: 'marketId',
    userId: 'userId',
    position: 'position',
    amount: 'amount',
    odds: 'odds',
    potentialWinning: 'potentialWinning',
    pickGroupId: 'pickGroupId',
    multiplier: 'multiplier',
    powerPlay: 'powerPlay',
    status: 'status',
    settled: 'settled',
    won: 'won',
    payout: 'payout',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BettingPositionScalarFieldEnum = (typeof BettingPositionScalarFieldEnum)[keyof typeof BettingPositionScalarFieldEnum]


  export const MarketMetricsScalarFieldEnum: {
    id: 'id',
    cardId: 'cardId',
    marketId: 'marketId',
    revenue: 'revenue',
    userGrowth: 'userGrowth',
    valuation: 'valuation',
    marketCap: 'marketCap',
    quarterlyGrowth: 'quarterlyGrowth',
    userEngagement: 'userEngagement',
    productLaunches: 'productLaunches',
    competitorRank: 'competitorRank',
    sentimentScore: 'sentimentScore',
    trendingScore: 'trendingScore',
    socialMentions: 'socialMentions',
    recordDate: 'recordDate',
    dataSource: 'dataSource',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MarketMetricsScalarFieldEnum = (typeof MarketMetricsScalarFieldEnum)[keyof typeof MarketMetricsScalarFieldEnum]


  export const BettingPayoutScalarFieldEnum: {
    id: 'id',
    marketId: 'marketId',
    userId: 'userId',
    positionId: 'positionId',
    winnings: 'winnings',
    originalBet: 'originalBet',
    multiplier: 'multiplier',
    status: 'status',
    payoutDate: 'payoutDate',
    transactionId: 'transactionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BettingPayoutScalarFieldEnum = (typeof BettingPayoutScalarFieldEnum)[keyof typeof BettingPayoutScalarFieldEnum]


  export const CardAuctionScalarFieldEnum: {
    id: 'id',
    cardId: 'cardId',
    ownerId: 'ownerId',
    title: 'title',
    description: 'description',
    startPrice: 'startPrice',
    reservePrice: 'reservePrice',
    currentBid: 'currentBid',
    bidIncrement: 'bidIncrement',
    startTime: 'startTime',
    endTime: 'endTime',
    autoExtend: 'autoExtend',
    status: 'status',
    finalized: 'finalized',
    winnerId: 'winnerId',
    viewCount: 'viewCount',
    watcherCount: 'watcherCount',
    bidCount: 'bidCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CardAuctionScalarFieldEnum = (typeof CardAuctionScalarFieldEnum)[keyof typeof CardAuctionScalarFieldEnum]


  export const AuctionConditionsScalarFieldEnum: {
    id: 'id',
    auctionId: 'auctionId',
    proMembersOnly: 'proMembersOnly',
    minimumRating: 'minimumRating',
    geographicRestrictions: 'geographicRestrictions',
    minimumNetWorth: 'minimumNetWorth',
    verificationRequired: 'verificationRequired',
    minimumPortfolioValue: 'minimumPortfolioValue',
    minimumCardsOwned: 'minimumCardsOwned',
    industryRestrictions: 'industryRestrictions',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AuctionConditionsScalarFieldEnum = (typeof AuctionConditionsScalarFieldEnum)[keyof typeof AuctionConditionsScalarFieldEnum]


  export const AuctionBidScalarFieldEnum: {
    id: 'id',
    auctionId: 'auctionId',
    bidderId: 'bidderId',
    bidAmount: 'bidAmount',
    maxAutoBid: 'maxAutoBid',
    bidType: 'bidType',
    status: 'status',
    isWinning: 'isWinning',
    outbidNotified: 'outbidNotified',
    userAgent: 'userAgent',
    ipAddress: 'ipAddress',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AuctionBidScalarFieldEnum = (typeof AuctionBidScalarFieldEnum)[keyof typeof AuctionBidScalarFieldEnum]


  export const AuctionWatcherScalarFieldEnum: {
    id: 'id',
    auctionId: 'auctionId',
    userId: 'userId',
    bidNotifications: 'bidNotifications',
    endingNotifications: 'endingNotifications',
    priceAlerts: 'priceAlerts',
    alertThreshold: 'alertThreshold',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AuctionWatcherScalarFieldEnum = (typeof AuctionWatcherScalarFieldEnum)[keyof typeof AuctionWatcherScalarFieldEnum]


  export const AuctionHistoryScalarFieldEnum: {
    id: 'id',
    cardId: 'cardId',
    auctionId: 'auctionId',
    salePrice: 'salePrice',
    sellerId: 'sellerId',
    buyerId: 'buyerId',
    saleType: 'saleType',
    marketTrends: 'marketTrends',
    priceHistory: 'priceHistory',
    daysSinceListing: 'daysSinceListing',
    numberOfBids: 'numberOfBids',
    highestBid: 'highestBid',
    saleDate: 'saleDate',
    createdAt: 'createdAt'
  };

  export type AuctionHistoryScalarFieldEnum = (typeof AuctionHistoryScalarFieldEnum)[keyof typeof AuctionHistoryScalarFieldEnum]


  export const MABattleScalarFieldEnum: {
    id: 'id',
    initiatorCardId: 'initiatorCardId',
    targetCardId: 'targetCardId',
    initiatorUserId: 'initiatorUserId',
    targetUserId: 'targetUserId',
    battleType: 'battleType',
    title: 'title',
    description: 'description',
    stakes: 'stakes',
    timeline: 'timeline',
    votingPeriod: 'votingPeriod',
    status: 'status',
    resolved: 'resolved',
    viewCount: 'viewCount',
    participantCount: 'participantCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MABattleScalarFieldEnum = (typeof MABattleScalarFieldEnum)[keyof typeof MABattleScalarFieldEnum]


  export const BattleProposalScalarFieldEnum: {
    id: 'id',
    battleId: 'battleId',
    proposerId: 'proposerId',
    proposalType: 'proposalType',
    title: 'title',
    description: 'description',
    terms: 'terms',
    valuation: 'valuation',
    paymentStructure: 'paymentStructure',
    timeline: 'timeline',
    synergies: 'synergies',
    conditions: 'conditions',
    contingencies: 'contingencies',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BattleProposalScalarFieldEnum = (typeof BattleProposalScalarFieldEnum)[keyof typeof BattleProposalScalarFieldEnum]


  export const BattleVotingScalarFieldEnum: {
    id: 'id',
    battleId: 'battleId',
    proposalId: 'proposalId',
    voterId: 'voterId',
    vote: 'vote',
    voteWeight: 'voteWeight',
    reasoning: 'reasoning',
    confidence: 'confidence',
    eceStaked: 'eceStaked',
    expertRating: 'expertRating',
    portfolioValue: 'portfolioValue',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BattleVotingScalarFieldEnum = (typeof BattleVotingScalarFieldEnum)[keyof typeof BattleVotingScalarFieldEnum]


  export const BattleOutcomeScalarFieldEnum: {
    id: 'id',
    battleId: 'battleId',
    winningBattleId: 'winningBattleId',
    winner: 'winner',
    winningProposalId: 'winningProposalId',
    finalTerms: 'finalTerms',
    finalValuation: 'finalValuation',
    implementation: 'implementation',
    stakeholdersPayouts: 'stakeholdersPayouts',
    tokenRewards: 'tokenRewards',
    completionDate: 'completionDate',
    realWorldImpact: 'realWorldImpact',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BattleOutcomeScalarFieldEnum = (typeof BattleOutcomeScalarFieldEnum)[keyof typeof BattleOutcomeScalarFieldEnum]


  export const StakingPoolScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    poolType: 'poolType',
    totalStaked: 'totalStaked',
    totalRewards: 'totalRewards',
    apy: 'apy',
    minStakeAmount: 'minStakeAmount',
    lockupPeriod: 'lockupPeriod',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StakingPoolScalarFieldEnum = (typeof StakingPoolScalarFieldEnum)[keyof typeof StakingPoolScalarFieldEnum]


  export const StakingPositionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    poolId: 'poolId',
    amount: 'amount',
    stakedAt: 'stakedAt',
    unstakedAt: 'unstakedAt',
    lockupEndsAt: 'lockupEndsAt',
    isActive: 'isActive'
  };

  export type StakingPositionScalarFieldEnum = (typeof StakingPositionScalarFieldEnum)[keyof typeof StakingPositionScalarFieldEnum]


  export const StakingRewardScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    poolId: 'poolId',
    positionId: 'positionId',
    amount: 'amount',
    rewardType: 'rewardType',
    claimedAt: 'claimedAt',
    createdAt: 'createdAt'
  };

  export type StakingRewardScalarFieldEnum = (typeof StakingRewardScalarFieldEnum)[keyof typeof StakingRewardScalarFieldEnum]


  export const GovernanceProposalScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    proposalType: 'proposalType',
    proposerId: 'proposerId',
    status: 'status',
    votingStartsAt: 'votingStartsAt',
    votingEndsAt: 'votingEndsAt',
    executionDate: 'executionDate',
    minQuorum: 'minQuorum',
    minApproval: 'minApproval',
    totalVotes: 'totalVotes',
    yesVotes: 'yesVotes',
    noVotes: 'noVotes',
    abstainVotes: 'abstainVotes',
    isExecuted: 'isExecuted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    parameters: 'parameters'
  };

  export type GovernanceProposalScalarFieldEnum = (typeof GovernanceProposalScalarFieldEnum)[keyof typeof GovernanceProposalScalarFieldEnum]


  export const GovernanceVoteScalarFieldEnum: {
    id: 'id',
    proposalId: 'proposalId',
    userId: 'userId',
    voteChoice: 'voteChoice',
    votingPower: 'votingPower',
    reason: 'reason',
    votedAt: 'votedAt'
  };

  export type GovernanceVoteScalarFieldEnum = (typeof GovernanceVoteScalarFieldEnum)[keyof typeof GovernanceVoteScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'SubscriptionPlan'
   */
  export type EnumSubscriptionPlanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionPlan'>
    


  /**
   * Reference to a field of type 'SubscriptionPlan[]'
   */
  export type ListEnumSubscriptionPlanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionPlan[]'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus'
   */
  export type EnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus[]'
   */
  export type ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'CardCategory'
   */
  export type EnumCardCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CardCategory'>
    


  /**
   * Reference to a field of type 'CardCategory[]'
   */
  export type ListEnumCardCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CardCategory[]'>
    


  /**
   * Reference to a field of type 'CardRarity'
   */
  export type EnumCardRarityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CardRarity'>
    


  /**
   * Reference to a field of type 'CardRarity[]'
   */
  export type ListEnumCardRarityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CardRarity[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'ListingType'
   */
  export type EnumListingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ListingType'>
    


  /**
   * Reference to a field of type 'ListingType[]'
   */
  export type ListEnumListingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ListingType[]'>
    


  /**
   * Reference to a field of type 'ListingStatus'
   */
  export type EnumListingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ListingStatus'>
    


  /**
   * Reference to a field of type 'ListingStatus[]'
   */
  export type ListEnumListingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ListingStatus[]'>
    


  /**
   * Reference to a field of type 'BidStatus'
   */
  export type EnumBidStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BidStatus'>
    


  /**
   * Reference to a field of type 'BidStatus[]'
   */
  export type ListEnumBidStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BidStatus[]'>
    


  /**
   * Reference to a field of type 'TransactionType'
   */
  export type EnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType'>
    


  /**
   * Reference to a field of type 'TransactionType[]'
   */
  export type ListEnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType[]'>
    


  /**
   * Reference to a field of type 'TransactionStatus'
   */
  export type EnumTransactionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionStatus'>
    


  /**
   * Reference to a field of type 'TransactionStatus[]'
   */
  export type ListEnumTransactionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionStatus[]'>
    


  /**
   * Reference to a field of type 'PhysicalCardStatus'
   */
  export type EnumPhysicalCardStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PhysicalCardStatus'>
    


  /**
   * Reference to a field of type 'PhysicalCardStatus[]'
   */
  export type ListEnumPhysicalCardStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PhysicalCardStatus[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'NotificationPriority'
   */
  export type EnumNotificationPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationPriority'>
    


  /**
   * Reference to a field of type 'NotificationPriority[]'
   */
  export type ListEnumNotificationPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationPriority[]'>
    


  /**
   * Reference to a field of type 'SocialFeedType'
   */
  export type EnumSocialFeedTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SocialFeedType'>
    


  /**
   * Reference to a field of type 'SocialFeedType[]'
   */
  export type ListEnumSocialFeedTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SocialFeedType[]'>
    


  /**
   * Reference to a field of type 'SocialVisibility'
   */
  export type EnumSocialVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SocialVisibility'>
    


  /**
   * Reference to a field of type 'SocialVisibility[]'
   */
  export type ListEnumSocialVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SocialVisibility[]'>
    


  /**
   * Reference to a field of type 'ProjectType'
   */
  export type EnumProjectTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectType'>
    


  /**
   * Reference to a field of type 'ProjectType[]'
   */
  export type ListEnumProjectTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectType[]'>
    


  /**
   * Reference to a field of type 'OrderTimeline'
   */
  export type EnumOrderTimelineFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderTimeline'>
    


  /**
   * Reference to a field of type 'OrderTimeline[]'
   */
  export type ListEnumOrderTimelineFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderTimeline[]'>
    


  /**
   * Reference to a field of type 'OrderStatus'
   */
  export type EnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus'>
    


  /**
   * Reference to a field of type 'OrderStatus[]'
   */
  export type ListEnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus[]'>
    


  /**
   * Reference to a field of type 'OrderPriority'
   */
  export type EnumOrderPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderPriority'>
    


  /**
   * Reference to a field of type 'OrderPriority[]'
   */
  export type ListEnumOrderPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderPriority[]'>
    


  /**
   * Reference to a field of type 'RevisionStatus'
   */
  export type EnumRevisionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RevisionStatus'>
    


  /**
   * Reference to a field of type 'RevisionStatus[]'
   */
  export type ListEnumRevisionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RevisionStatus[]'>
    


  /**
   * Reference to a field of type 'CommunicationType'
   */
  export type EnumCommunicationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CommunicationType'>
    


  /**
   * Reference to a field of type 'CommunicationType[]'
   */
  export type ListEnumCommunicationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CommunicationType[]'>
    


  /**
   * Reference to a field of type 'DeliverableType'
   */
  export type EnumDeliverableTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeliverableType'>
    


  /**
   * Reference to a field of type 'DeliverableType[]'
   */
  export type ListEnumDeliverableTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeliverableType[]'>
    


  /**
   * Reference to a field of type 'DeliverableStatus'
   */
  export type EnumDeliverableStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeliverableStatus'>
    


  /**
   * Reference to a field of type 'DeliverableStatus[]'
   */
  export type ListEnumDeliverableStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeliverableStatus[]'>
    


  /**
   * Reference to a field of type 'MarketMetricType'
   */
  export type EnumMarketMetricTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MarketMetricType'>
    


  /**
   * Reference to a field of type 'MarketMetricType[]'
   */
  export type ListEnumMarketMetricTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MarketMetricType[]'>
    


  /**
   * Reference to a field of type 'PredictionDirection'
   */
  export type EnumPredictionDirectionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PredictionDirection'>
    


  /**
   * Reference to a field of type 'PredictionDirection[]'
   */
  export type ListEnumPredictionDirectionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PredictionDirection[]'>
    


  /**
   * Reference to a field of type 'MarketStatus'
   */
  export type EnumMarketStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MarketStatus'>
    


  /**
   * Reference to a field of type 'MarketStatus[]'
   */
  export type ListEnumMarketStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MarketStatus[]'>
    


  /**
   * Reference to a field of type 'PositionStatus'
   */
  export type EnumPositionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PositionStatus'>
    


  /**
   * Reference to a field of type 'PositionStatus[]'
   */
  export type ListEnumPositionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PositionStatus[]'>
    


  /**
   * Reference to a field of type 'PayoutStatus'
   */
  export type EnumPayoutStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PayoutStatus'>
    


  /**
   * Reference to a field of type 'PayoutStatus[]'
   */
  export type ListEnumPayoutStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PayoutStatus[]'>
    


  /**
   * Reference to a field of type 'AuctionStatus'
   */
  export type EnumAuctionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuctionStatus'>
    


  /**
   * Reference to a field of type 'AuctionStatus[]'
   */
  export type ListEnumAuctionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuctionStatus[]'>
    


  /**
   * Reference to a field of type 'BidType'
   */
  export type EnumBidTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BidType'>
    


  /**
   * Reference to a field of type 'BidType[]'
   */
  export type ListEnumBidTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BidType[]'>
    


  /**
   * Reference to a field of type 'AuctionBidStatus'
   */
  export type EnumAuctionBidStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuctionBidStatus'>
    


  /**
   * Reference to a field of type 'AuctionBidStatus[]'
   */
  export type ListEnumAuctionBidStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuctionBidStatus[]'>
    


  /**
   * Reference to a field of type 'SaleType'
   */
  export type EnumSaleTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SaleType'>
    


  /**
   * Reference to a field of type 'SaleType[]'
   */
  export type ListEnumSaleTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SaleType[]'>
    


  /**
   * Reference to a field of type 'BattleType'
   */
  export type EnumBattleTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BattleType'>
    


  /**
   * Reference to a field of type 'BattleType[]'
   */
  export type ListEnumBattleTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BattleType[]'>
    


  /**
   * Reference to a field of type 'BattleStatus'
   */
  export type EnumBattleStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BattleStatus'>
    


  /**
   * Reference to a field of type 'BattleStatus[]'
   */
  export type ListEnumBattleStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BattleStatus[]'>
    


  /**
   * Reference to a field of type 'ProposalType'
   */
  export type EnumProposalTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProposalType'>
    


  /**
   * Reference to a field of type 'ProposalType[]'
   */
  export type ListEnumProposalTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProposalType[]'>
    


  /**
   * Reference to a field of type 'ProposalStatus'
   */
  export type EnumProposalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProposalStatus'>
    


  /**
   * Reference to a field of type 'ProposalStatus[]'
   */
  export type ListEnumProposalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProposalStatus[]'>
    


  /**
   * Reference to a field of type 'VoteDirection'
   */
  export type EnumVoteDirectionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VoteDirection'>
    


  /**
   * Reference to a field of type 'VoteDirection[]'
   */
  export type ListEnumVoteDirectionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VoteDirection[]'>
    


  /**
   * Reference to a field of type 'BattleWinner'
   */
  export type EnumBattleWinnerFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BattleWinner'>
    


  /**
   * Reference to a field of type 'BattleWinner[]'
   */
  export type ListEnumBattleWinnerFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BattleWinner[]'>
    


  /**
   * Reference to a field of type 'StakingPoolType'
   */
  export type EnumStakingPoolTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StakingPoolType'>
    


  /**
   * Reference to a field of type 'StakingPoolType[]'
   */
  export type ListEnumStakingPoolTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StakingPoolType[]'>
    


  /**
   * Reference to a field of type 'StakingRewardType'
   */
  export type EnumStakingRewardTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StakingRewardType'>
    


  /**
   * Reference to a field of type 'StakingRewardType[]'
   */
  export type ListEnumStakingRewardTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StakingRewardType[]'>
    


  /**
   * Reference to a field of type 'GovernanceStatus'
   */
  export type EnumGovernanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GovernanceStatus'>
    


  /**
   * Reference to a field of type 'GovernanceStatus[]'
   */
  export type ListEnumGovernanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GovernanceStatus[]'>
    


  /**
   * Reference to a field of type 'VoteChoice'
   */
  export type EnumVoteChoiceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VoteChoice'>
    


  /**
   * Reference to a field of type 'VoteChoice[]'
   */
  export type ListEnumVoteChoiceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VoteChoice[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    avatar?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    eceBalance?: FloatFilter<"User"> | number
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastActive?: DateTimeFilter<"User"> | Date | string
    subscription?: XOR<UserSubscriptionNullableScalarRelationFilter, UserSubscriptionWhereInput> | null
    cryptoWallets?: CryptoWalletListRelationFilter
    physicalCard?: XOR<PhysicalCardNullableScalarRelationFilter, PhysicalCardWhereInput> | null
    ownedCards?: CardListRelationFilter
    tradingHistory?: TransactionListRelationFilter
    bids?: BidListRelationFilter
    listings?: MarketplaceListingListRelationFilter
    appOrders?: AppOrderListRelationFilter
    orderRevisions?: OrderRevisionListRelationFilter
    orderCommunications?: OrderCommunicationListRelationFilter
    bettingPositions?: BettingPositionListRelationFilter
    bettingPayouts?: BettingPayoutListRelationFilter
    ownedAuctions?: CardAuctionListRelationFilter
    wonAuctions?: CardAuctionListRelationFilter
    placedAuctionBids?: AuctionBidListRelationFilter
    watchedAuctions?: AuctionWatcherListRelationFilter
    initiatedMABattles?: MABattleListRelationFilter
    targetedMABattles?: MABattleListRelationFilter
    battleProposals?: BattleProposalListRelationFilter
    battleVotes?: BattleVotingListRelationFilter
    stakingPositions?: StakingPositionListRelationFilter
    stakingRewards?: StakingRewardListRelationFilter
    governanceProposals?: GovernanceProposalListRelationFilter
    governanceVotes?: GovernanceVoteListRelationFilter
    notifications?: NotificationListRelationFilter
    socialFeeds?: SocialFeedListRelationFilter
    followers?: FollowListRelationFilter
    following?: FollowListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    passwordHash?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    eceBalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastActive?: SortOrder
    subscription?: UserSubscriptionOrderByWithRelationInput
    cryptoWallets?: CryptoWalletOrderByRelationAggregateInput
    physicalCard?: PhysicalCardOrderByWithRelationInput
    ownedCards?: CardOrderByRelationAggregateInput
    tradingHistory?: TransactionOrderByRelationAggregateInput
    bids?: BidOrderByRelationAggregateInput
    listings?: MarketplaceListingOrderByRelationAggregateInput
    appOrders?: AppOrderOrderByRelationAggregateInput
    orderRevisions?: OrderRevisionOrderByRelationAggregateInput
    orderCommunications?: OrderCommunicationOrderByRelationAggregateInput
    bettingPositions?: BettingPositionOrderByRelationAggregateInput
    bettingPayouts?: BettingPayoutOrderByRelationAggregateInput
    ownedAuctions?: CardAuctionOrderByRelationAggregateInput
    wonAuctions?: CardAuctionOrderByRelationAggregateInput
    placedAuctionBids?: AuctionBidOrderByRelationAggregateInput
    watchedAuctions?: AuctionWatcherOrderByRelationAggregateInput
    initiatedMABattles?: MABattleOrderByRelationAggregateInput
    targetedMABattles?: MABattleOrderByRelationAggregateInput
    battleProposals?: BattleProposalOrderByRelationAggregateInput
    battleVotes?: BattleVotingOrderByRelationAggregateInput
    stakingPositions?: StakingPositionOrderByRelationAggregateInput
    stakingRewards?: StakingRewardOrderByRelationAggregateInput
    governanceProposals?: GovernanceProposalOrderByRelationAggregateInput
    governanceVotes?: GovernanceVoteOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    socialFeeds?: SocialFeedOrderByRelationAggregateInput
    followers?: FollowOrderByRelationAggregateInput
    following?: FollowOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    avatar?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    eceBalance?: FloatFilter<"User"> | number
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastActive?: DateTimeFilter<"User"> | Date | string
    subscription?: XOR<UserSubscriptionNullableScalarRelationFilter, UserSubscriptionWhereInput> | null
    cryptoWallets?: CryptoWalletListRelationFilter
    physicalCard?: XOR<PhysicalCardNullableScalarRelationFilter, PhysicalCardWhereInput> | null
    ownedCards?: CardListRelationFilter
    tradingHistory?: TransactionListRelationFilter
    bids?: BidListRelationFilter
    listings?: MarketplaceListingListRelationFilter
    appOrders?: AppOrderListRelationFilter
    orderRevisions?: OrderRevisionListRelationFilter
    orderCommunications?: OrderCommunicationListRelationFilter
    bettingPositions?: BettingPositionListRelationFilter
    bettingPayouts?: BettingPayoutListRelationFilter
    ownedAuctions?: CardAuctionListRelationFilter
    wonAuctions?: CardAuctionListRelationFilter
    placedAuctionBids?: AuctionBidListRelationFilter
    watchedAuctions?: AuctionWatcherListRelationFilter
    initiatedMABattles?: MABattleListRelationFilter
    targetedMABattles?: MABattleListRelationFilter
    battleProposals?: BattleProposalListRelationFilter
    battleVotes?: BattleVotingListRelationFilter
    stakingPositions?: StakingPositionListRelationFilter
    stakingRewards?: StakingRewardListRelationFilter
    governanceProposals?: GovernanceProposalListRelationFilter
    governanceVotes?: GovernanceVoteListRelationFilter
    notifications?: NotificationListRelationFilter
    socialFeeds?: SocialFeedListRelationFilter
    followers?: FollowListRelationFilter
    following?: FollowListRelationFilter
  }, "id" | "email" | "username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    passwordHash?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    eceBalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastActive?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatar?: StringNullableWithAggregatesFilter<"User"> | string | null
    passwordHash?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    eceBalance?: FloatWithAggregatesFilter<"User"> | number
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    lastActive?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type UserSubscriptionWhereInput = {
    AND?: UserSubscriptionWhereInput | UserSubscriptionWhereInput[]
    OR?: UserSubscriptionWhereInput[]
    NOT?: UserSubscriptionWhereInput | UserSubscriptionWhereInput[]
    id?: StringFilter<"UserSubscription"> | string
    userId?: StringFilter<"UserSubscription"> | string
    plan?: EnumSubscriptionPlanFilter<"UserSubscription"> | $Enums.SubscriptionPlan
    status?: EnumSubscriptionStatusFilter<"UserSubscription"> | $Enums.SubscriptionStatus
    currentPeriodStart?: DateTimeFilter<"UserSubscription"> | Date | string
    currentPeriodEnd?: DateTimeFilter<"UserSubscription"> | Date | string
    cancelAtPeriodEnd?: BoolFilter<"UserSubscription"> | boolean
    stripeCustomerId?: StringNullableFilter<"UserSubscription"> | string | null
    stripeSubscriptionId?: StringNullableFilter<"UserSubscription"> | string | null
    createdAt?: DateTimeFilter<"UserSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"UserSubscription"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    features?: XOR<SubscriptionFeaturesNullableScalarRelationFilter, SubscriptionFeaturesWhereInput> | null
    usage?: XOR<SubscriptionUsageNullableScalarRelationFilter, SubscriptionUsageWhereInput> | null
  }

  export type UserSubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    features?: SubscriptionFeaturesOrderByWithRelationInput
    usage?: SubscriptionUsageOrderByWithRelationInput
  }

  export type UserSubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserSubscriptionWhereInput | UserSubscriptionWhereInput[]
    OR?: UserSubscriptionWhereInput[]
    NOT?: UserSubscriptionWhereInput | UserSubscriptionWhereInput[]
    plan?: EnumSubscriptionPlanFilter<"UserSubscription"> | $Enums.SubscriptionPlan
    status?: EnumSubscriptionStatusFilter<"UserSubscription"> | $Enums.SubscriptionStatus
    currentPeriodStart?: DateTimeFilter<"UserSubscription"> | Date | string
    currentPeriodEnd?: DateTimeFilter<"UserSubscription"> | Date | string
    cancelAtPeriodEnd?: BoolFilter<"UserSubscription"> | boolean
    stripeCustomerId?: StringNullableFilter<"UserSubscription"> | string | null
    stripeSubscriptionId?: StringNullableFilter<"UserSubscription"> | string | null
    createdAt?: DateTimeFilter<"UserSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"UserSubscription"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    features?: XOR<SubscriptionFeaturesNullableScalarRelationFilter, SubscriptionFeaturesWhereInput> | null
    usage?: XOR<SubscriptionUsageNullableScalarRelationFilter, SubscriptionUsageWhereInput> | null
  }, "id" | "userId">

  export type UserSubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserSubscriptionCountOrderByAggregateInput
    _max?: UserSubscriptionMaxOrderByAggregateInput
    _min?: UserSubscriptionMinOrderByAggregateInput
  }

  export type UserSubscriptionScalarWhereWithAggregatesInput = {
    AND?: UserSubscriptionScalarWhereWithAggregatesInput | UserSubscriptionScalarWhereWithAggregatesInput[]
    OR?: UserSubscriptionScalarWhereWithAggregatesInput[]
    NOT?: UserSubscriptionScalarWhereWithAggregatesInput | UserSubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserSubscription"> | string
    userId?: StringWithAggregatesFilter<"UserSubscription"> | string
    plan?: EnumSubscriptionPlanWithAggregatesFilter<"UserSubscription"> | $Enums.SubscriptionPlan
    status?: EnumSubscriptionStatusWithAggregatesFilter<"UserSubscription"> | $Enums.SubscriptionStatus
    currentPeriodStart?: DateTimeWithAggregatesFilter<"UserSubscription"> | Date | string
    currentPeriodEnd?: DateTimeWithAggregatesFilter<"UserSubscription"> | Date | string
    cancelAtPeriodEnd?: BoolWithAggregatesFilter<"UserSubscription"> | boolean
    stripeCustomerId?: StringNullableWithAggregatesFilter<"UserSubscription"> | string | null
    stripeSubscriptionId?: StringNullableWithAggregatesFilter<"UserSubscription"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserSubscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserSubscription"> | Date | string
  }

  export type SubscriptionFeaturesWhereInput = {
    AND?: SubscriptionFeaturesWhereInput | SubscriptionFeaturesWhereInput[]
    OR?: SubscriptionFeaturesWhereInput[]
    NOT?: SubscriptionFeaturesWhereInput | SubscriptionFeaturesWhereInput[]
    id?: StringFilter<"SubscriptionFeatures"> | string
    subscriptionId?: StringFilter<"SubscriptionFeatures"> | string
    maxTrades?: IntFilter<"SubscriptionFeatures"> | number
    advancedAnalytics?: BoolFilter<"SubscriptionFeatures"> | boolean
    prioritySupport?: BoolFilter<"SubscriptionFeatures"> | boolean
    marketplaceAccess?: BoolFilter<"SubscriptionFeatures"> | boolean
    premiumListings?: BoolFilter<"SubscriptionFeatures"> | boolean
    bulkOperations?: BoolFilter<"SubscriptionFeatures"> | boolean
    cryptoPayments?: BoolFilter<"SubscriptionFeatures"> | boolean
    physicalCard?: BoolFilter<"SubscriptionFeatures"> | boolean
    businessStipend?: FloatFilter<"SubscriptionFeatures"> | number
    withdrawalLimit?: FloatFilter<"SubscriptionFeatures"> | number
    subscription?: XOR<UserSubscriptionScalarRelationFilter, UserSubscriptionWhereInput>
  }

  export type SubscriptionFeaturesOrderByWithRelationInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    maxTrades?: SortOrder
    advancedAnalytics?: SortOrder
    prioritySupport?: SortOrder
    marketplaceAccess?: SortOrder
    premiumListings?: SortOrder
    bulkOperations?: SortOrder
    cryptoPayments?: SortOrder
    physicalCard?: SortOrder
    businessStipend?: SortOrder
    withdrawalLimit?: SortOrder
    subscription?: UserSubscriptionOrderByWithRelationInput
  }

  export type SubscriptionFeaturesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    subscriptionId?: string
    AND?: SubscriptionFeaturesWhereInput | SubscriptionFeaturesWhereInput[]
    OR?: SubscriptionFeaturesWhereInput[]
    NOT?: SubscriptionFeaturesWhereInput | SubscriptionFeaturesWhereInput[]
    maxTrades?: IntFilter<"SubscriptionFeatures"> | number
    advancedAnalytics?: BoolFilter<"SubscriptionFeatures"> | boolean
    prioritySupport?: BoolFilter<"SubscriptionFeatures"> | boolean
    marketplaceAccess?: BoolFilter<"SubscriptionFeatures"> | boolean
    premiumListings?: BoolFilter<"SubscriptionFeatures"> | boolean
    bulkOperations?: BoolFilter<"SubscriptionFeatures"> | boolean
    cryptoPayments?: BoolFilter<"SubscriptionFeatures"> | boolean
    physicalCard?: BoolFilter<"SubscriptionFeatures"> | boolean
    businessStipend?: FloatFilter<"SubscriptionFeatures"> | number
    withdrawalLimit?: FloatFilter<"SubscriptionFeatures"> | number
    subscription?: XOR<UserSubscriptionScalarRelationFilter, UserSubscriptionWhereInput>
  }, "id" | "subscriptionId">

  export type SubscriptionFeaturesOrderByWithAggregationInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    maxTrades?: SortOrder
    advancedAnalytics?: SortOrder
    prioritySupport?: SortOrder
    marketplaceAccess?: SortOrder
    premiumListings?: SortOrder
    bulkOperations?: SortOrder
    cryptoPayments?: SortOrder
    physicalCard?: SortOrder
    businessStipend?: SortOrder
    withdrawalLimit?: SortOrder
    _count?: SubscriptionFeaturesCountOrderByAggregateInput
    _avg?: SubscriptionFeaturesAvgOrderByAggregateInput
    _max?: SubscriptionFeaturesMaxOrderByAggregateInput
    _min?: SubscriptionFeaturesMinOrderByAggregateInput
    _sum?: SubscriptionFeaturesSumOrderByAggregateInput
  }

  export type SubscriptionFeaturesScalarWhereWithAggregatesInput = {
    AND?: SubscriptionFeaturesScalarWhereWithAggregatesInput | SubscriptionFeaturesScalarWhereWithAggregatesInput[]
    OR?: SubscriptionFeaturesScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionFeaturesScalarWhereWithAggregatesInput | SubscriptionFeaturesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SubscriptionFeatures"> | string
    subscriptionId?: StringWithAggregatesFilter<"SubscriptionFeatures"> | string
    maxTrades?: IntWithAggregatesFilter<"SubscriptionFeatures"> | number
    advancedAnalytics?: BoolWithAggregatesFilter<"SubscriptionFeatures"> | boolean
    prioritySupport?: BoolWithAggregatesFilter<"SubscriptionFeatures"> | boolean
    marketplaceAccess?: BoolWithAggregatesFilter<"SubscriptionFeatures"> | boolean
    premiumListings?: BoolWithAggregatesFilter<"SubscriptionFeatures"> | boolean
    bulkOperations?: BoolWithAggregatesFilter<"SubscriptionFeatures"> | boolean
    cryptoPayments?: BoolWithAggregatesFilter<"SubscriptionFeatures"> | boolean
    physicalCard?: BoolWithAggregatesFilter<"SubscriptionFeatures"> | boolean
    businessStipend?: FloatWithAggregatesFilter<"SubscriptionFeatures"> | number
    withdrawalLimit?: FloatWithAggregatesFilter<"SubscriptionFeatures"> | number
  }

  export type SubscriptionUsageWhereInput = {
    AND?: SubscriptionUsageWhereInput | SubscriptionUsageWhereInput[]
    OR?: SubscriptionUsageWhereInput[]
    NOT?: SubscriptionUsageWhereInput | SubscriptionUsageWhereInput[]
    id?: StringFilter<"SubscriptionUsage"> | string
    subscriptionId?: StringFilter<"SubscriptionUsage"> | string
    tradesThisMonth?: IntFilter<"SubscriptionUsage"> | number
    listingsThisMonth?: IntFilter<"SubscriptionUsage"> | number
    stipendUsed?: FloatFilter<"SubscriptionUsage"> | number
    lastResetAt?: DateTimeFilter<"SubscriptionUsage"> | Date | string
    subscription?: XOR<UserSubscriptionScalarRelationFilter, UserSubscriptionWhereInput>
  }

  export type SubscriptionUsageOrderByWithRelationInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    tradesThisMonth?: SortOrder
    listingsThisMonth?: SortOrder
    stipendUsed?: SortOrder
    lastResetAt?: SortOrder
    subscription?: UserSubscriptionOrderByWithRelationInput
  }

  export type SubscriptionUsageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    subscriptionId?: string
    AND?: SubscriptionUsageWhereInput | SubscriptionUsageWhereInput[]
    OR?: SubscriptionUsageWhereInput[]
    NOT?: SubscriptionUsageWhereInput | SubscriptionUsageWhereInput[]
    tradesThisMonth?: IntFilter<"SubscriptionUsage"> | number
    listingsThisMonth?: IntFilter<"SubscriptionUsage"> | number
    stipendUsed?: FloatFilter<"SubscriptionUsage"> | number
    lastResetAt?: DateTimeFilter<"SubscriptionUsage"> | Date | string
    subscription?: XOR<UserSubscriptionScalarRelationFilter, UserSubscriptionWhereInput>
  }, "id" | "subscriptionId">

  export type SubscriptionUsageOrderByWithAggregationInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    tradesThisMonth?: SortOrder
    listingsThisMonth?: SortOrder
    stipendUsed?: SortOrder
    lastResetAt?: SortOrder
    _count?: SubscriptionUsageCountOrderByAggregateInput
    _avg?: SubscriptionUsageAvgOrderByAggregateInput
    _max?: SubscriptionUsageMaxOrderByAggregateInput
    _min?: SubscriptionUsageMinOrderByAggregateInput
    _sum?: SubscriptionUsageSumOrderByAggregateInput
  }

  export type SubscriptionUsageScalarWhereWithAggregatesInput = {
    AND?: SubscriptionUsageScalarWhereWithAggregatesInput | SubscriptionUsageScalarWhereWithAggregatesInput[]
    OR?: SubscriptionUsageScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionUsageScalarWhereWithAggregatesInput | SubscriptionUsageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SubscriptionUsage"> | string
    subscriptionId?: StringWithAggregatesFilter<"SubscriptionUsage"> | string
    tradesThisMonth?: IntWithAggregatesFilter<"SubscriptionUsage"> | number
    listingsThisMonth?: IntWithAggregatesFilter<"SubscriptionUsage"> | number
    stipendUsed?: FloatWithAggregatesFilter<"SubscriptionUsage"> | number
    lastResetAt?: DateTimeWithAggregatesFilter<"SubscriptionUsage"> | Date | string
  }

  export type CardWhereInput = {
    AND?: CardWhereInput | CardWhereInput[]
    OR?: CardWhereInput[]
    NOT?: CardWhereInput | CardWhereInput[]
    id?: StringFilter<"Card"> | string
    name?: StringFilter<"Card"> | string
    description?: StringNullableFilter<"Card"> | string | null
    category?: EnumCardCategoryFilter<"Card"> | $Enums.CardCategory
    rarity?: EnumCardRarityFilter<"Card"> | $Enums.CardRarity
    company?: StringNullableFilter<"Card"> | string | null
    currentPrice?: FloatFilter<"Card"> | number
    historicalPrices?: JsonNullableFilter<"Card">
    imageUrl?: StringNullableFilter<"Card"> | string | null
    metadata?: JsonNullableFilter<"Card">
    stats?: JsonNullableFilter<"Card">
    ownerId?: StringFilter<"Card"> | string
    createdAt?: DateTimeFilter<"Card"> | Date | string
    updatedAt?: DateTimeFilter<"Card"> | Date | string
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    listing?: XOR<MarketplaceListingNullableScalarRelationFilter, MarketplaceListingWhereInput> | null
    bids?: BidListRelationFilter
    transactions?: TransactionListRelationFilter
    bettingMarkets?: BettingMarketListRelationFilter
    marketMetrics?: MarketMetricsListRelationFilter
    auction?: XOR<CardAuctionNullableScalarRelationFilter, CardAuctionWhereInput> | null
    auctionHistory?: AuctionHistoryListRelationFilter
    initiatedBattles?: MABattleListRelationFilter
    targetedBattles?: MABattleListRelationFilter
  }

  export type CardOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    rarity?: SortOrder
    company?: SortOrderInput | SortOrder
    currentPrice?: SortOrder
    historicalPrices?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    stats?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    owner?: UserOrderByWithRelationInput
    listing?: MarketplaceListingOrderByWithRelationInput
    bids?: BidOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
    bettingMarkets?: BettingMarketOrderByRelationAggregateInput
    marketMetrics?: MarketMetricsOrderByRelationAggregateInput
    auction?: CardAuctionOrderByWithRelationInput
    auctionHistory?: AuctionHistoryOrderByRelationAggregateInput
    initiatedBattles?: MABattleOrderByRelationAggregateInput
    targetedBattles?: MABattleOrderByRelationAggregateInput
  }

  export type CardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CardWhereInput | CardWhereInput[]
    OR?: CardWhereInput[]
    NOT?: CardWhereInput | CardWhereInput[]
    name?: StringFilter<"Card"> | string
    description?: StringNullableFilter<"Card"> | string | null
    category?: EnumCardCategoryFilter<"Card"> | $Enums.CardCategory
    rarity?: EnumCardRarityFilter<"Card"> | $Enums.CardRarity
    company?: StringNullableFilter<"Card"> | string | null
    currentPrice?: FloatFilter<"Card"> | number
    historicalPrices?: JsonNullableFilter<"Card">
    imageUrl?: StringNullableFilter<"Card"> | string | null
    metadata?: JsonNullableFilter<"Card">
    stats?: JsonNullableFilter<"Card">
    ownerId?: StringFilter<"Card"> | string
    createdAt?: DateTimeFilter<"Card"> | Date | string
    updatedAt?: DateTimeFilter<"Card"> | Date | string
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    listing?: XOR<MarketplaceListingNullableScalarRelationFilter, MarketplaceListingWhereInput> | null
    bids?: BidListRelationFilter
    transactions?: TransactionListRelationFilter
    bettingMarkets?: BettingMarketListRelationFilter
    marketMetrics?: MarketMetricsListRelationFilter
    auction?: XOR<CardAuctionNullableScalarRelationFilter, CardAuctionWhereInput> | null
    auctionHistory?: AuctionHistoryListRelationFilter
    initiatedBattles?: MABattleListRelationFilter
    targetedBattles?: MABattleListRelationFilter
  }, "id">

  export type CardOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    rarity?: SortOrder
    company?: SortOrderInput | SortOrder
    currentPrice?: SortOrder
    historicalPrices?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    stats?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CardCountOrderByAggregateInput
    _avg?: CardAvgOrderByAggregateInput
    _max?: CardMaxOrderByAggregateInput
    _min?: CardMinOrderByAggregateInput
    _sum?: CardSumOrderByAggregateInput
  }

  export type CardScalarWhereWithAggregatesInput = {
    AND?: CardScalarWhereWithAggregatesInput | CardScalarWhereWithAggregatesInput[]
    OR?: CardScalarWhereWithAggregatesInput[]
    NOT?: CardScalarWhereWithAggregatesInput | CardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Card"> | string
    name?: StringWithAggregatesFilter<"Card"> | string
    description?: StringNullableWithAggregatesFilter<"Card"> | string | null
    category?: EnumCardCategoryWithAggregatesFilter<"Card"> | $Enums.CardCategory
    rarity?: EnumCardRarityWithAggregatesFilter<"Card"> | $Enums.CardRarity
    company?: StringNullableWithAggregatesFilter<"Card"> | string | null
    currentPrice?: FloatWithAggregatesFilter<"Card"> | number
    historicalPrices?: JsonNullableWithAggregatesFilter<"Card">
    imageUrl?: StringNullableWithAggregatesFilter<"Card"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Card">
    stats?: JsonNullableWithAggregatesFilter<"Card">
    ownerId?: StringWithAggregatesFilter<"Card"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Card"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Card"> | Date | string
  }

  export type MarketplaceListingWhereInput = {
    AND?: MarketplaceListingWhereInput | MarketplaceListingWhereInput[]
    OR?: MarketplaceListingWhereInput[]
    NOT?: MarketplaceListingWhereInput | MarketplaceListingWhereInput[]
    id?: StringFilter<"MarketplaceListing"> | string
    cardId?: StringFilter<"MarketplaceListing"> | string
    sellerId?: StringFilter<"MarketplaceListing"> | string
    price?: FloatFilter<"MarketplaceListing"> | number
    listingType?: EnumListingTypeFilter<"MarketplaceListing"> | $Enums.ListingType
    auctionEnd?: DateTimeNullableFilter<"MarketplaceListing"> | Date | string | null
    status?: EnumListingStatusFilter<"MarketplaceListing"> | $Enums.ListingStatus
    featured?: BoolFilter<"MarketplaceListing"> | boolean
    createdAt?: DateTimeFilter<"MarketplaceListing"> | Date | string
    updatedAt?: DateTimeFilter<"MarketplaceListing"> | Date | string
    card?: XOR<CardScalarRelationFilter, CardWhereInput>
    seller?: XOR<UserScalarRelationFilter, UserWhereInput>
    bids?: BidListRelationFilter
  }

  export type MarketplaceListingOrderByWithRelationInput = {
    id?: SortOrder
    cardId?: SortOrder
    sellerId?: SortOrder
    price?: SortOrder
    listingType?: SortOrder
    auctionEnd?: SortOrderInput | SortOrder
    status?: SortOrder
    featured?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    card?: CardOrderByWithRelationInput
    seller?: UserOrderByWithRelationInput
    bids?: BidOrderByRelationAggregateInput
  }

  export type MarketplaceListingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    cardId?: string
    AND?: MarketplaceListingWhereInput | MarketplaceListingWhereInput[]
    OR?: MarketplaceListingWhereInput[]
    NOT?: MarketplaceListingWhereInput | MarketplaceListingWhereInput[]
    sellerId?: StringFilter<"MarketplaceListing"> | string
    price?: FloatFilter<"MarketplaceListing"> | number
    listingType?: EnumListingTypeFilter<"MarketplaceListing"> | $Enums.ListingType
    auctionEnd?: DateTimeNullableFilter<"MarketplaceListing"> | Date | string | null
    status?: EnumListingStatusFilter<"MarketplaceListing"> | $Enums.ListingStatus
    featured?: BoolFilter<"MarketplaceListing"> | boolean
    createdAt?: DateTimeFilter<"MarketplaceListing"> | Date | string
    updatedAt?: DateTimeFilter<"MarketplaceListing"> | Date | string
    card?: XOR<CardScalarRelationFilter, CardWhereInput>
    seller?: XOR<UserScalarRelationFilter, UserWhereInput>
    bids?: BidListRelationFilter
  }, "id" | "cardId">

  export type MarketplaceListingOrderByWithAggregationInput = {
    id?: SortOrder
    cardId?: SortOrder
    sellerId?: SortOrder
    price?: SortOrder
    listingType?: SortOrder
    auctionEnd?: SortOrderInput | SortOrder
    status?: SortOrder
    featured?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MarketplaceListingCountOrderByAggregateInput
    _avg?: MarketplaceListingAvgOrderByAggregateInput
    _max?: MarketplaceListingMaxOrderByAggregateInput
    _min?: MarketplaceListingMinOrderByAggregateInput
    _sum?: MarketplaceListingSumOrderByAggregateInput
  }

  export type MarketplaceListingScalarWhereWithAggregatesInput = {
    AND?: MarketplaceListingScalarWhereWithAggregatesInput | MarketplaceListingScalarWhereWithAggregatesInput[]
    OR?: MarketplaceListingScalarWhereWithAggregatesInput[]
    NOT?: MarketplaceListingScalarWhereWithAggregatesInput | MarketplaceListingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MarketplaceListing"> | string
    cardId?: StringWithAggregatesFilter<"MarketplaceListing"> | string
    sellerId?: StringWithAggregatesFilter<"MarketplaceListing"> | string
    price?: FloatWithAggregatesFilter<"MarketplaceListing"> | number
    listingType?: EnumListingTypeWithAggregatesFilter<"MarketplaceListing"> | $Enums.ListingType
    auctionEnd?: DateTimeNullableWithAggregatesFilter<"MarketplaceListing"> | Date | string | null
    status?: EnumListingStatusWithAggregatesFilter<"MarketplaceListing"> | $Enums.ListingStatus
    featured?: BoolWithAggregatesFilter<"MarketplaceListing"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"MarketplaceListing"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MarketplaceListing"> | Date | string
  }

  export type BidWhereInput = {
    AND?: BidWhereInput | BidWhereInput[]
    OR?: BidWhereInput[]
    NOT?: BidWhereInput | BidWhereInput[]
    id?: StringFilter<"Bid"> | string
    listingId?: StringFilter<"Bid"> | string
    bidderId?: StringFilter<"Bid"> | string
    cardId?: StringFilter<"Bid"> | string
    amount?: FloatFilter<"Bid"> | number
    status?: EnumBidStatusFilter<"Bid"> | $Enums.BidStatus
    createdAt?: DateTimeFilter<"Bid"> | Date | string
    updatedAt?: DateTimeFilter<"Bid"> | Date | string
    listing?: XOR<MarketplaceListingScalarRelationFilter, MarketplaceListingWhereInput>
    bidder?: XOR<UserScalarRelationFilter, UserWhereInput>
    card?: XOR<CardScalarRelationFilter, CardWhereInput>
  }

  export type BidOrderByWithRelationInput = {
    id?: SortOrder
    listingId?: SortOrder
    bidderId?: SortOrder
    cardId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    listing?: MarketplaceListingOrderByWithRelationInput
    bidder?: UserOrderByWithRelationInput
    card?: CardOrderByWithRelationInput
  }

  export type BidWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BidWhereInput | BidWhereInput[]
    OR?: BidWhereInput[]
    NOT?: BidWhereInput | BidWhereInput[]
    listingId?: StringFilter<"Bid"> | string
    bidderId?: StringFilter<"Bid"> | string
    cardId?: StringFilter<"Bid"> | string
    amount?: FloatFilter<"Bid"> | number
    status?: EnumBidStatusFilter<"Bid"> | $Enums.BidStatus
    createdAt?: DateTimeFilter<"Bid"> | Date | string
    updatedAt?: DateTimeFilter<"Bid"> | Date | string
    listing?: XOR<MarketplaceListingScalarRelationFilter, MarketplaceListingWhereInput>
    bidder?: XOR<UserScalarRelationFilter, UserWhereInput>
    card?: XOR<CardScalarRelationFilter, CardWhereInput>
  }, "id">

  export type BidOrderByWithAggregationInput = {
    id?: SortOrder
    listingId?: SortOrder
    bidderId?: SortOrder
    cardId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BidCountOrderByAggregateInput
    _avg?: BidAvgOrderByAggregateInput
    _max?: BidMaxOrderByAggregateInput
    _min?: BidMinOrderByAggregateInput
    _sum?: BidSumOrderByAggregateInput
  }

  export type BidScalarWhereWithAggregatesInput = {
    AND?: BidScalarWhereWithAggregatesInput | BidScalarWhereWithAggregatesInput[]
    OR?: BidScalarWhereWithAggregatesInput[]
    NOT?: BidScalarWhereWithAggregatesInput | BidScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Bid"> | string
    listingId?: StringWithAggregatesFilter<"Bid"> | string
    bidderId?: StringWithAggregatesFilter<"Bid"> | string
    cardId?: StringWithAggregatesFilter<"Bid"> | string
    amount?: FloatWithAggregatesFilter<"Bid"> | number
    status?: EnumBidStatusWithAggregatesFilter<"Bid"> | $Enums.BidStatus
    createdAt?: DateTimeWithAggregatesFilter<"Bid"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Bid"> | Date | string
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: StringFilter<"Transaction"> | string
    userId?: StringFilter<"Transaction"> | string
    cardId?: StringNullableFilter<"Transaction"> | string | null
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    amount?: FloatFilter<"Transaction"> | number
    currency?: StringFilter<"Transaction"> | string
    status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    description?: StringNullableFilter<"Transaction"> | string | null
    metadata?: JsonNullableFilter<"Transaction">
    paymentMethod?: StringNullableFilter<"Transaction"> | string | null
    paymentId?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    card?: XOR<CardNullableScalarRelationFilter, CardWhereInput> | null
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    cardId?: SortOrderInput | SortOrder
    type?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    description?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    paymentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    card?: CardOrderByWithRelationInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    userId?: StringFilter<"Transaction"> | string
    cardId?: StringNullableFilter<"Transaction"> | string | null
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    amount?: FloatFilter<"Transaction"> | number
    currency?: StringFilter<"Transaction"> | string
    status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    description?: StringNullableFilter<"Transaction"> | string | null
    metadata?: JsonNullableFilter<"Transaction">
    paymentMethod?: StringNullableFilter<"Transaction"> | string | null
    paymentId?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    card?: XOR<CardNullableScalarRelationFilter, CardWhereInput> | null
  }, "id">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    cardId?: SortOrderInput | SortOrder
    type?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    description?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    paymentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transaction"> | string
    userId?: StringWithAggregatesFilter<"Transaction"> | string
    cardId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    type?: EnumTransactionTypeWithAggregatesFilter<"Transaction"> | $Enums.TransactionType
    amount?: FloatWithAggregatesFilter<"Transaction"> | number
    currency?: StringWithAggregatesFilter<"Transaction"> | string
    status?: EnumTransactionStatusWithAggregatesFilter<"Transaction"> | $Enums.TransactionStatus
    description?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Transaction">
    paymentMethod?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    paymentId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
  }

  export type CryptoWalletWhereInput = {
    AND?: CryptoWalletWhereInput | CryptoWalletWhereInput[]
    OR?: CryptoWalletWhereInput[]
    NOT?: CryptoWalletWhereInput | CryptoWalletWhereInput[]
    id?: StringFilter<"CryptoWallet"> | string
    userId?: StringFilter<"CryptoWallet"> | string
    currency?: StringFilter<"CryptoWallet"> | string
    address?: StringFilter<"CryptoWallet"> | string
    balance?: FloatFilter<"CryptoWallet"> | number
    createdAt?: DateTimeFilter<"CryptoWallet"> | Date | string
    updatedAt?: DateTimeFilter<"CryptoWallet"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CryptoWalletOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    currency?: SortOrder
    address?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type CryptoWalletWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_currency?: CryptoWalletUserIdCurrencyCompoundUniqueInput
    AND?: CryptoWalletWhereInput | CryptoWalletWhereInput[]
    OR?: CryptoWalletWhereInput[]
    NOT?: CryptoWalletWhereInput | CryptoWalletWhereInput[]
    userId?: StringFilter<"CryptoWallet"> | string
    currency?: StringFilter<"CryptoWallet"> | string
    address?: StringFilter<"CryptoWallet"> | string
    balance?: FloatFilter<"CryptoWallet"> | number
    createdAt?: DateTimeFilter<"CryptoWallet"> | Date | string
    updatedAt?: DateTimeFilter<"CryptoWallet"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_currency">

  export type CryptoWalletOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    currency?: SortOrder
    address?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CryptoWalletCountOrderByAggregateInput
    _avg?: CryptoWalletAvgOrderByAggregateInput
    _max?: CryptoWalletMaxOrderByAggregateInput
    _min?: CryptoWalletMinOrderByAggregateInput
    _sum?: CryptoWalletSumOrderByAggregateInput
  }

  export type CryptoWalletScalarWhereWithAggregatesInput = {
    AND?: CryptoWalletScalarWhereWithAggregatesInput | CryptoWalletScalarWhereWithAggregatesInput[]
    OR?: CryptoWalletScalarWhereWithAggregatesInput[]
    NOT?: CryptoWalletScalarWhereWithAggregatesInput | CryptoWalletScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CryptoWallet"> | string
    userId?: StringWithAggregatesFilter<"CryptoWallet"> | string
    currency?: StringWithAggregatesFilter<"CryptoWallet"> | string
    address?: StringWithAggregatesFilter<"CryptoWallet"> | string
    balance?: FloatWithAggregatesFilter<"CryptoWallet"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CryptoWallet"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CryptoWallet"> | Date | string
  }

  export type PhysicalCardWhereInput = {
    AND?: PhysicalCardWhereInput | PhysicalCardWhereInput[]
    OR?: PhysicalCardWhereInput[]
    NOT?: PhysicalCardWhereInput | PhysicalCardWhereInput[]
    id?: StringFilter<"PhysicalCard"> | string
    userId?: StringFilter<"PhysicalCard"> | string
    cardNumber?: StringFilter<"PhysicalCard"> | string
    expiryDate?: StringFilter<"PhysicalCard"> | string
    cvv?: StringFilter<"PhysicalCard"> | string
    status?: EnumPhysicalCardStatusFilter<"PhysicalCard"> | $Enums.PhysicalCardStatus
    appleWalletPassId?: StringNullableFilter<"PhysicalCard"> | string | null
    createdAt?: DateTimeFilter<"PhysicalCard"> | Date | string
    updatedAt?: DateTimeFilter<"PhysicalCard"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PhysicalCardOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    cardNumber?: SortOrder
    expiryDate?: SortOrder
    cvv?: SortOrder
    status?: SortOrder
    appleWalletPassId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PhysicalCardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    cardNumber?: string
    AND?: PhysicalCardWhereInput | PhysicalCardWhereInput[]
    OR?: PhysicalCardWhereInput[]
    NOT?: PhysicalCardWhereInput | PhysicalCardWhereInput[]
    expiryDate?: StringFilter<"PhysicalCard"> | string
    cvv?: StringFilter<"PhysicalCard"> | string
    status?: EnumPhysicalCardStatusFilter<"PhysicalCard"> | $Enums.PhysicalCardStatus
    appleWalletPassId?: StringNullableFilter<"PhysicalCard"> | string | null
    createdAt?: DateTimeFilter<"PhysicalCard"> | Date | string
    updatedAt?: DateTimeFilter<"PhysicalCard"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId" | "cardNumber">

  export type PhysicalCardOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    cardNumber?: SortOrder
    expiryDate?: SortOrder
    cvv?: SortOrder
    status?: SortOrder
    appleWalletPassId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PhysicalCardCountOrderByAggregateInput
    _max?: PhysicalCardMaxOrderByAggregateInput
    _min?: PhysicalCardMinOrderByAggregateInput
  }

  export type PhysicalCardScalarWhereWithAggregatesInput = {
    AND?: PhysicalCardScalarWhereWithAggregatesInput | PhysicalCardScalarWhereWithAggregatesInput[]
    OR?: PhysicalCardScalarWhereWithAggregatesInput[]
    NOT?: PhysicalCardScalarWhereWithAggregatesInput | PhysicalCardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PhysicalCard"> | string
    userId?: StringWithAggregatesFilter<"PhysicalCard"> | string
    cardNumber?: StringWithAggregatesFilter<"PhysicalCard"> | string
    expiryDate?: StringWithAggregatesFilter<"PhysicalCard"> | string
    cvv?: StringWithAggregatesFilter<"PhysicalCard"> | string
    status?: EnumPhysicalCardStatusWithAggregatesFilter<"PhysicalCard"> | $Enums.PhysicalCardStatus
    appleWalletPassId?: StringNullableWithAggregatesFilter<"PhysicalCard"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PhysicalCard"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PhysicalCard"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    data?: JsonNullableFilter<"Notification">
    read?: BoolFilter<"Notification"> | boolean
    priority?: EnumNotificationPriorityFilter<"Notification"> | $Enums.NotificationPriority
    requiresSubscription?: EnumSubscriptionPlanNullableFilter<"Notification"> | $Enums.SubscriptionPlan | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    data?: SortOrderInput | SortOrder
    read?: SortOrder
    priority?: SortOrder
    requiresSubscription?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    data?: JsonNullableFilter<"Notification">
    read?: BoolFilter<"Notification"> | boolean
    priority?: EnumNotificationPriorityFilter<"Notification"> | $Enums.NotificationPriority
    requiresSubscription?: EnumSubscriptionPlanNullableFilter<"Notification"> | $Enums.SubscriptionPlan | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    data?: SortOrderInput | SortOrder
    read?: SortOrder
    priority?: SortOrder
    requiresSubscription?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    data?: JsonNullableWithAggregatesFilter<"Notification">
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    priority?: EnumNotificationPriorityWithAggregatesFilter<"Notification"> | $Enums.NotificationPriority
    requiresSubscription?: EnumSubscriptionPlanNullableWithAggregatesFilter<"Notification"> | $Enums.SubscriptionPlan | null
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type SocialFeedWhereInput = {
    AND?: SocialFeedWhereInput | SocialFeedWhereInput[]
    OR?: SocialFeedWhereInput[]
    NOT?: SocialFeedWhereInput | SocialFeedWhereInput[]
    id?: StringFilter<"SocialFeed"> | string
    userId?: StringFilter<"SocialFeed"> | string
    type?: EnumSocialFeedTypeFilter<"SocialFeed"> | $Enums.SocialFeedType
    content?: StringFilter<"SocialFeed"> | string
    data?: JsonNullableFilter<"SocialFeed">
    likes?: IntFilter<"SocialFeed"> | number
    comments?: IntFilter<"SocialFeed"> | number
    shares?: IntFilter<"SocialFeed"> | number
    visibility?: EnumSocialVisibilityFilter<"SocialFeed"> | $Enums.SocialVisibility
    createdAt?: DateTimeFilter<"SocialFeed"> | Date | string
    updatedAt?: DateTimeFilter<"SocialFeed"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SocialFeedOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    data?: SortOrderInput | SortOrder
    likes?: SortOrder
    comments?: SortOrder
    shares?: SortOrder
    visibility?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SocialFeedWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SocialFeedWhereInput | SocialFeedWhereInput[]
    OR?: SocialFeedWhereInput[]
    NOT?: SocialFeedWhereInput | SocialFeedWhereInput[]
    userId?: StringFilter<"SocialFeed"> | string
    type?: EnumSocialFeedTypeFilter<"SocialFeed"> | $Enums.SocialFeedType
    content?: StringFilter<"SocialFeed"> | string
    data?: JsonNullableFilter<"SocialFeed">
    likes?: IntFilter<"SocialFeed"> | number
    comments?: IntFilter<"SocialFeed"> | number
    shares?: IntFilter<"SocialFeed"> | number
    visibility?: EnumSocialVisibilityFilter<"SocialFeed"> | $Enums.SocialVisibility
    createdAt?: DateTimeFilter<"SocialFeed"> | Date | string
    updatedAt?: DateTimeFilter<"SocialFeed"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type SocialFeedOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    data?: SortOrderInput | SortOrder
    likes?: SortOrder
    comments?: SortOrder
    shares?: SortOrder
    visibility?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SocialFeedCountOrderByAggregateInput
    _avg?: SocialFeedAvgOrderByAggregateInput
    _max?: SocialFeedMaxOrderByAggregateInput
    _min?: SocialFeedMinOrderByAggregateInput
    _sum?: SocialFeedSumOrderByAggregateInput
  }

  export type SocialFeedScalarWhereWithAggregatesInput = {
    AND?: SocialFeedScalarWhereWithAggregatesInput | SocialFeedScalarWhereWithAggregatesInput[]
    OR?: SocialFeedScalarWhereWithAggregatesInput[]
    NOT?: SocialFeedScalarWhereWithAggregatesInput | SocialFeedScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SocialFeed"> | string
    userId?: StringWithAggregatesFilter<"SocialFeed"> | string
    type?: EnumSocialFeedTypeWithAggregatesFilter<"SocialFeed"> | $Enums.SocialFeedType
    content?: StringWithAggregatesFilter<"SocialFeed"> | string
    data?: JsonNullableWithAggregatesFilter<"SocialFeed">
    likes?: IntWithAggregatesFilter<"SocialFeed"> | number
    comments?: IntWithAggregatesFilter<"SocialFeed"> | number
    shares?: IntWithAggregatesFilter<"SocialFeed"> | number
    visibility?: EnumSocialVisibilityWithAggregatesFilter<"SocialFeed"> | $Enums.SocialVisibility
    createdAt?: DateTimeWithAggregatesFilter<"SocialFeed"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SocialFeed"> | Date | string
  }

  export type FollowWhereInput = {
    AND?: FollowWhereInput | FollowWhereInput[]
    OR?: FollowWhereInput[]
    NOT?: FollowWhereInput | FollowWhereInput[]
    id?: StringFilter<"Follow"> | string
    followerId?: StringFilter<"Follow"> | string
    followingId?: StringFilter<"Follow"> | string
    createdAt?: DateTimeFilter<"Follow"> | Date | string
    follower?: XOR<UserScalarRelationFilter, UserWhereInput>
    following?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type FollowOrderByWithRelationInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingId?: SortOrder
    createdAt?: SortOrder
    follower?: UserOrderByWithRelationInput
    following?: UserOrderByWithRelationInput
  }

  export type FollowWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    followerId_followingId?: FollowFollowerIdFollowingIdCompoundUniqueInput
    AND?: FollowWhereInput | FollowWhereInput[]
    OR?: FollowWhereInput[]
    NOT?: FollowWhereInput | FollowWhereInput[]
    followerId?: StringFilter<"Follow"> | string
    followingId?: StringFilter<"Follow"> | string
    createdAt?: DateTimeFilter<"Follow"> | Date | string
    follower?: XOR<UserScalarRelationFilter, UserWhereInput>
    following?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "followerId_followingId">

  export type FollowOrderByWithAggregationInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingId?: SortOrder
    createdAt?: SortOrder
    _count?: FollowCountOrderByAggregateInput
    _max?: FollowMaxOrderByAggregateInput
    _min?: FollowMinOrderByAggregateInput
  }

  export type FollowScalarWhereWithAggregatesInput = {
    AND?: FollowScalarWhereWithAggregatesInput | FollowScalarWhereWithAggregatesInput[]
    OR?: FollowScalarWhereWithAggregatesInput[]
    NOT?: FollowScalarWhereWithAggregatesInput | FollowScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Follow"> | string
    followerId?: StringWithAggregatesFilter<"Follow"> | string
    followingId?: StringWithAggregatesFilter<"Follow"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Follow"> | Date | string
  }

  export type AppOrderWhereInput = {
    AND?: AppOrderWhereInput | AppOrderWhereInput[]
    OR?: AppOrderWhereInput[]
    NOT?: AppOrderWhereInput | AppOrderWhereInput[]
    id?: StringFilter<"AppOrder"> | string
    userId?: StringFilter<"AppOrder"> | string
    projectType?: EnumProjectTypeFilter<"AppOrder"> | $Enums.ProjectType
    title?: StringFilter<"AppOrder"> | string
    description?: StringFilter<"AppOrder"> | string
    requirements?: JsonNullableFilter<"AppOrder">
    timeline?: EnumOrderTimelineFilter<"AppOrder"> | $Enums.OrderTimeline
    estimatedCost?: FloatFilter<"AppOrder"> | number
    actualCost?: FloatNullableFilter<"AppOrder"> | number | null
    currency?: StringFilter<"AppOrder"> | string
    status?: EnumOrderStatusFilter<"AppOrder"> | $Enums.OrderStatus
    priority?: EnumOrderPriorityFilter<"AppOrder"> | $Enums.OrderPriority
    deliveryDate?: DateTimeNullableFilter<"AppOrder"> | Date | string | null
    githubRepo?: StringNullableFilter<"AppOrder"> | string | null
    vercelLink?: StringNullableFilter<"AppOrder"> | string | null
    downloadLink?: StringNullableFilter<"AppOrder"> | string | null
    progressPercentage?: IntFilter<"AppOrder"> | number
    currentMilestone?: StringNullableFilter<"AppOrder"> | string | null
    assignedAdminId?: StringNullableFilter<"AppOrder"> | string | null
    createdAt?: DateTimeFilter<"AppOrder"> | Date | string
    updatedAt?: DateTimeFilter<"AppOrder"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    revisions?: OrderRevisionListRelationFilter
    communications?: OrderCommunicationListRelationFilter
    deliverables?: OrderDeliverableListRelationFilter
  }

  export type AppOrderOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    projectType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    requirements?: SortOrderInput | SortOrder
    timeline?: SortOrder
    estimatedCost?: SortOrder
    actualCost?: SortOrderInput | SortOrder
    currency?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    deliveryDate?: SortOrderInput | SortOrder
    githubRepo?: SortOrderInput | SortOrder
    vercelLink?: SortOrderInput | SortOrder
    downloadLink?: SortOrderInput | SortOrder
    progressPercentage?: SortOrder
    currentMilestone?: SortOrderInput | SortOrder
    assignedAdminId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    revisions?: OrderRevisionOrderByRelationAggregateInput
    communications?: OrderCommunicationOrderByRelationAggregateInput
    deliverables?: OrderDeliverableOrderByRelationAggregateInput
  }

  export type AppOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AppOrderWhereInput | AppOrderWhereInput[]
    OR?: AppOrderWhereInput[]
    NOT?: AppOrderWhereInput | AppOrderWhereInput[]
    userId?: StringFilter<"AppOrder"> | string
    projectType?: EnumProjectTypeFilter<"AppOrder"> | $Enums.ProjectType
    title?: StringFilter<"AppOrder"> | string
    description?: StringFilter<"AppOrder"> | string
    requirements?: JsonNullableFilter<"AppOrder">
    timeline?: EnumOrderTimelineFilter<"AppOrder"> | $Enums.OrderTimeline
    estimatedCost?: FloatFilter<"AppOrder"> | number
    actualCost?: FloatNullableFilter<"AppOrder"> | number | null
    currency?: StringFilter<"AppOrder"> | string
    status?: EnumOrderStatusFilter<"AppOrder"> | $Enums.OrderStatus
    priority?: EnumOrderPriorityFilter<"AppOrder"> | $Enums.OrderPriority
    deliveryDate?: DateTimeNullableFilter<"AppOrder"> | Date | string | null
    githubRepo?: StringNullableFilter<"AppOrder"> | string | null
    vercelLink?: StringNullableFilter<"AppOrder"> | string | null
    downloadLink?: StringNullableFilter<"AppOrder"> | string | null
    progressPercentage?: IntFilter<"AppOrder"> | number
    currentMilestone?: StringNullableFilter<"AppOrder"> | string | null
    assignedAdminId?: StringNullableFilter<"AppOrder"> | string | null
    createdAt?: DateTimeFilter<"AppOrder"> | Date | string
    updatedAt?: DateTimeFilter<"AppOrder"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    revisions?: OrderRevisionListRelationFilter
    communications?: OrderCommunicationListRelationFilter
    deliverables?: OrderDeliverableListRelationFilter
  }, "id">

  export type AppOrderOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    projectType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    requirements?: SortOrderInput | SortOrder
    timeline?: SortOrder
    estimatedCost?: SortOrder
    actualCost?: SortOrderInput | SortOrder
    currency?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    deliveryDate?: SortOrderInput | SortOrder
    githubRepo?: SortOrderInput | SortOrder
    vercelLink?: SortOrderInput | SortOrder
    downloadLink?: SortOrderInput | SortOrder
    progressPercentage?: SortOrder
    currentMilestone?: SortOrderInput | SortOrder
    assignedAdminId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AppOrderCountOrderByAggregateInput
    _avg?: AppOrderAvgOrderByAggregateInput
    _max?: AppOrderMaxOrderByAggregateInput
    _min?: AppOrderMinOrderByAggregateInput
    _sum?: AppOrderSumOrderByAggregateInput
  }

  export type AppOrderScalarWhereWithAggregatesInput = {
    AND?: AppOrderScalarWhereWithAggregatesInput | AppOrderScalarWhereWithAggregatesInput[]
    OR?: AppOrderScalarWhereWithAggregatesInput[]
    NOT?: AppOrderScalarWhereWithAggregatesInput | AppOrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AppOrder"> | string
    userId?: StringWithAggregatesFilter<"AppOrder"> | string
    projectType?: EnumProjectTypeWithAggregatesFilter<"AppOrder"> | $Enums.ProjectType
    title?: StringWithAggregatesFilter<"AppOrder"> | string
    description?: StringWithAggregatesFilter<"AppOrder"> | string
    requirements?: JsonNullableWithAggregatesFilter<"AppOrder">
    timeline?: EnumOrderTimelineWithAggregatesFilter<"AppOrder"> | $Enums.OrderTimeline
    estimatedCost?: FloatWithAggregatesFilter<"AppOrder"> | number
    actualCost?: FloatNullableWithAggregatesFilter<"AppOrder"> | number | null
    currency?: StringWithAggregatesFilter<"AppOrder"> | string
    status?: EnumOrderStatusWithAggregatesFilter<"AppOrder"> | $Enums.OrderStatus
    priority?: EnumOrderPriorityWithAggregatesFilter<"AppOrder"> | $Enums.OrderPriority
    deliveryDate?: DateTimeNullableWithAggregatesFilter<"AppOrder"> | Date | string | null
    githubRepo?: StringNullableWithAggregatesFilter<"AppOrder"> | string | null
    vercelLink?: StringNullableWithAggregatesFilter<"AppOrder"> | string | null
    downloadLink?: StringNullableWithAggregatesFilter<"AppOrder"> | string | null
    progressPercentage?: IntWithAggregatesFilter<"AppOrder"> | number
    currentMilestone?: StringNullableWithAggregatesFilter<"AppOrder"> | string | null
    assignedAdminId?: StringNullableWithAggregatesFilter<"AppOrder"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AppOrder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AppOrder"> | Date | string
  }

  export type OrderRevisionWhereInput = {
    AND?: OrderRevisionWhereInput | OrderRevisionWhereInput[]
    OR?: OrderRevisionWhereInput[]
    NOT?: OrderRevisionWhereInput | OrderRevisionWhereInput[]
    id?: StringFilter<"OrderRevision"> | string
    orderId?: StringFilter<"OrderRevision"> | string
    userId?: StringFilter<"OrderRevision"> | string
    revisionNumber?: IntFilter<"OrderRevision"> | number
    title?: StringFilter<"OrderRevision"> | string
    description?: StringFilter<"OrderRevision"> | string
    status?: EnumRevisionStatusFilter<"OrderRevision"> | $Enums.RevisionStatus
    adminResponse?: StringNullableFilter<"OrderRevision"> | string | null
    adminId?: StringNullableFilter<"OrderRevision"> | string | null
    createdAt?: DateTimeFilter<"OrderRevision"> | Date | string
    updatedAt?: DateTimeFilter<"OrderRevision"> | Date | string
    order?: XOR<AppOrderScalarRelationFilter, AppOrderWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type OrderRevisionOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    userId?: SortOrder
    revisionNumber?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    adminResponse?: SortOrderInput | SortOrder
    adminId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    order?: AppOrderOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type OrderRevisionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderRevisionWhereInput | OrderRevisionWhereInput[]
    OR?: OrderRevisionWhereInput[]
    NOT?: OrderRevisionWhereInput | OrderRevisionWhereInput[]
    orderId?: StringFilter<"OrderRevision"> | string
    userId?: StringFilter<"OrderRevision"> | string
    revisionNumber?: IntFilter<"OrderRevision"> | number
    title?: StringFilter<"OrderRevision"> | string
    description?: StringFilter<"OrderRevision"> | string
    status?: EnumRevisionStatusFilter<"OrderRevision"> | $Enums.RevisionStatus
    adminResponse?: StringNullableFilter<"OrderRevision"> | string | null
    adminId?: StringNullableFilter<"OrderRevision"> | string | null
    createdAt?: DateTimeFilter<"OrderRevision"> | Date | string
    updatedAt?: DateTimeFilter<"OrderRevision"> | Date | string
    order?: XOR<AppOrderScalarRelationFilter, AppOrderWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type OrderRevisionOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    userId?: SortOrder
    revisionNumber?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    adminResponse?: SortOrderInput | SortOrder
    adminId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrderRevisionCountOrderByAggregateInput
    _avg?: OrderRevisionAvgOrderByAggregateInput
    _max?: OrderRevisionMaxOrderByAggregateInput
    _min?: OrderRevisionMinOrderByAggregateInput
    _sum?: OrderRevisionSumOrderByAggregateInput
  }

  export type OrderRevisionScalarWhereWithAggregatesInput = {
    AND?: OrderRevisionScalarWhereWithAggregatesInput | OrderRevisionScalarWhereWithAggregatesInput[]
    OR?: OrderRevisionScalarWhereWithAggregatesInput[]
    NOT?: OrderRevisionScalarWhereWithAggregatesInput | OrderRevisionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrderRevision"> | string
    orderId?: StringWithAggregatesFilter<"OrderRevision"> | string
    userId?: StringWithAggregatesFilter<"OrderRevision"> | string
    revisionNumber?: IntWithAggregatesFilter<"OrderRevision"> | number
    title?: StringWithAggregatesFilter<"OrderRevision"> | string
    description?: StringWithAggregatesFilter<"OrderRevision"> | string
    status?: EnumRevisionStatusWithAggregatesFilter<"OrderRevision"> | $Enums.RevisionStatus
    adminResponse?: StringNullableWithAggregatesFilter<"OrderRevision"> | string | null
    adminId?: StringNullableWithAggregatesFilter<"OrderRevision"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"OrderRevision"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OrderRevision"> | Date | string
  }

  export type OrderCommunicationWhereInput = {
    AND?: OrderCommunicationWhereInput | OrderCommunicationWhereInput[]
    OR?: OrderCommunicationWhereInput[]
    NOT?: OrderCommunicationWhereInput | OrderCommunicationWhereInput[]
    id?: StringFilter<"OrderCommunication"> | string
    orderId?: StringFilter<"OrderCommunication"> | string
    userId?: StringFilter<"OrderCommunication"> | string
    messageType?: EnumCommunicationTypeFilter<"OrderCommunication"> | $Enums.CommunicationType
    subject?: StringNullableFilter<"OrderCommunication"> | string | null
    message?: StringFilter<"OrderCommunication"> | string
    isFromAdmin?: BoolFilter<"OrderCommunication"> | boolean
    attachments?: JsonNullableFilter<"OrderCommunication">
    read?: BoolFilter<"OrderCommunication"> | boolean
    important?: BoolFilter<"OrderCommunication"> | boolean
    createdAt?: DateTimeFilter<"OrderCommunication"> | Date | string
    updatedAt?: DateTimeFilter<"OrderCommunication"> | Date | string
    order?: XOR<AppOrderScalarRelationFilter, AppOrderWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type OrderCommunicationOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    userId?: SortOrder
    messageType?: SortOrder
    subject?: SortOrderInput | SortOrder
    message?: SortOrder
    isFromAdmin?: SortOrder
    attachments?: SortOrderInput | SortOrder
    read?: SortOrder
    important?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    order?: AppOrderOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type OrderCommunicationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderCommunicationWhereInput | OrderCommunicationWhereInput[]
    OR?: OrderCommunicationWhereInput[]
    NOT?: OrderCommunicationWhereInput | OrderCommunicationWhereInput[]
    orderId?: StringFilter<"OrderCommunication"> | string
    userId?: StringFilter<"OrderCommunication"> | string
    messageType?: EnumCommunicationTypeFilter<"OrderCommunication"> | $Enums.CommunicationType
    subject?: StringNullableFilter<"OrderCommunication"> | string | null
    message?: StringFilter<"OrderCommunication"> | string
    isFromAdmin?: BoolFilter<"OrderCommunication"> | boolean
    attachments?: JsonNullableFilter<"OrderCommunication">
    read?: BoolFilter<"OrderCommunication"> | boolean
    important?: BoolFilter<"OrderCommunication"> | boolean
    createdAt?: DateTimeFilter<"OrderCommunication"> | Date | string
    updatedAt?: DateTimeFilter<"OrderCommunication"> | Date | string
    order?: XOR<AppOrderScalarRelationFilter, AppOrderWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type OrderCommunicationOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    userId?: SortOrder
    messageType?: SortOrder
    subject?: SortOrderInput | SortOrder
    message?: SortOrder
    isFromAdmin?: SortOrder
    attachments?: SortOrderInput | SortOrder
    read?: SortOrder
    important?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrderCommunicationCountOrderByAggregateInput
    _max?: OrderCommunicationMaxOrderByAggregateInput
    _min?: OrderCommunicationMinOrderByAggregateInput
  }

  export type OrderCommunicationScalarWhereWithAggregatesInput = {
    AND?: OrderCommunicationScalarWhereWithAggregatesInput | OrderCommunicationScalarWhereWithAggregatesInput[]
    OR?: OrderCommunicationScalarWhereWithAggregatesInput[]
    NOT?: OrderCommunicationScalarWhereWithAggregatesInput | OrderCommunicationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrderCommunication"> | string
    orderId?: StringWithAggregatesFilter<"OrderCommunication"> | string
    userId?: StringWithAggregatesFilter<"OrderCommunication"> | string
    messageType?: EnumCommunicationTypeWithAggregatesFilter<"OrderCommunication"> | $Enums.CommunicationType
    subject?: StringNullableWithAggregatesFilter<"OrderCommunication"> | string | null
    message?: StringWithAggregatesFilter<"OrderCommunication"> | string
    isFromAdmin?: BoolWithAggregatesFilter<"OrderCommunication"> | boolean
    attachments?: JsonNullableWithAggregatesFilter<"OrderCommunication">
    read?: BoolWithAggregatesFilter<"OrderCommunication"> | boolean
    important?: BoolWithAggregatesFilter<"OrderCommunication"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"OrderCommunication"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OrderCommunication"> | Date | string
  }

  export type OrderDeliverableWhereInput = {
    AND?: OrderDeliverableWhereInput | OrderDeliverableWhereInput[]
    OR?: OrderDeliverableWhereInput[]
    NOT?: OrderDeliverableWhereInput | OrderDeliverableWhereInput[]
    id?: StringFilter<"OrderDeliverable"> | string
    orderId?: StringFilter<"OrderDeliverable"> | string
    type?: EnumDeliverableTypeFilter<"OrderDeliverable"> | $Enums.DeliverableType
    title?: StringFilter<"OrderDeliverable"> | string
    description?: StringNullableFilter<"OrderDeliverable"> | string | null
    url?: StringNullableFilter<"OrderDeliverable"> | string | null
    filePath?: StringNullableFilter<"OrderDeliverable"> | string | null
    status?: EnumDeliverableStatusFilter<"OrderDeliverable"> | $Enums.DeliverableStatus
    delivered?: BoolFilter<"OrderDeliverable"> | boolean
    createdAt?: DateTimeFilter<"OrderDeliverable"> | Date | string
    updatedAt?: DateTimeFilter<"OrderDeliverable"> | Date | string
    order?: XOR<AppOrderScalarRelationFilter, AppOrderWhereInput>
  }

  export type OrderDeliverableOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    filePath?: SortOrderInput | SortOrder
    status?: SortOrder
    delivered?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    order?: AppOrderOrderByWithRelationInput
  }

  export type OrderDeliverableWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderDeliverableWhereInput | OrderDeliverableWhereInput[]
    OR?: OrderDeliverableWhereInput[]
    NOT?: OrderDeliverableWhereInput | OrderDeliverableWhereInput[]
    orderId?: StringFilter<"OrderDeliverable"> | string
    type?: EnumDeliverableTypeFilter<"OrderDeliverable"> | $Enums.DeliverableType
    title?: StringFilter<"OrderDeliverable"> | string
    description?: StringNullableFilter<"OrderDeliverable"> | string | null
    url?: StringNullableFilter<"OrderDeliverable"> | string | null
    filePath?: StringNullableFilter<"OrderDeliverable"> | string | null
    status?: EnumDeliverableStatusFilter<"OrderDeliverable"> | $Enums.DeliverableStatus
    delivered?: BoolFilter<"OrderDeliverable"> | boolean
    createdAt?: DateTimeFilter<"OrderDeliverable"> | Date | string
    updatedAt?: DateTimeFilter<"OrderDeliverable"> | Date | string
    order?: XOR<AppOrderScalarRelationFilter, AppOrderWhereInput>
  }, "id">

  export type OrderDeliverableOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    filePath?: SortOrderInput | SortOrder
    status?: SortOrder
    delivered?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrderDeliverableCountOrderByAggregateInput
    _max?: OrderDeliverableMaxOrderByAggregateInput
    _min?: OrderDeliverableMinOrderByAggregateInput
  }

  export type OrderDeliverableScalarWhereWithAggregatesInput = {
    AND?: OrderDeliverableScalarWhereWithAggregatesInput | OrderDeliverableScalarWhereWithAggregatesInput[]
    OR?: OrderDeliverableScalarWhereWithAggregatesInput[]
    NOT?: OrderDeliverableScalarWhereWithAggregatesInput | OrderDeliverableScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrderDeliverable"> | string
    orderId?: StringWithAggregatesFilter<"OrderDeliverable"> | string
    type?: EnumDeliverableTypeWithAggregatesFilter<"OrderDeliverable"> | $Enums.DeliverableType
    title?: StringWithAggregatesFilter<"OrderDeliverable"> | string
    description?: StringNullableWithAggregatesFilter<"OrderDeliverable"> | string | null
    url?: StringNullableWithAggregatesFilter<"OrderDeliverable"> | string | null
    filePath?: StringNullableWithAggregatesFilter<"OrderDeliverable"> | string | null
    status?: EnumDeliverableStatusWithAggregatesFilter<"OrderDeliverable"> | $Enums.DeliverableStatus
    delivered?: BoolWithAggregatesFilter<"OrderDeliverable"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"OrderDeliverable"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OrderDeliverable"> | Date | string
  }

  export type BettingMarketWhereInput = {
    AND?: BettingMarketWhereInput | BettingMarketWhereInput[]
    OR?: BettingMarketWhereInput[]
    NOT?: BettingMarketWhereInput | BettingMarketWhereInput[]
    id?: StringFilter<"BettingMarket"> | string
    cardId?: StringFilter<"BettingMarket"> | string
    metricType?: EnumMarketMetricTypeFilter<"BettingMarket"> | $Enums.MarketMetricType
    title?: StringFilter<"BettingMarket"> | string
    description?: StringFilter<"BettingMarket"> | string
    currentValue?: FloatFilter<"BettingMarket"> | number
    predictionTarget?: FloatFilter<"BettingMarket"> | number
    targetDirection?: EnumPredictionDirectionFilter<"BettingMarket"> | $Enums.PredictionDirection
    odds?: FloatFilter<"BettingMarket"> | number
    totalPot?: FloatFilter<"BettingMarket"> | number
    minimumBet?: FloatFilter<"BettingMarket"> | number
    maximumBet?: FloatNullableFilter<"BettingMarket"> | number | null
    startTime?: DateTimeFilter<"BettingMarket"> | Date | string
    expiryDate?: DateTimeFilter<"BettingMarket"> | Date | string
    settlementDate?: DateTimeNullableFilter<"BettingMarket"> | Date | string | null
    status?: EnumMarketStatusFilter<"BettingMarket"> | $Enums.MarketStatus
    settled?: BoolFilter<"BettingMarket"> | boolean
    settledValue?: FloatNullableFilter<"BettingMarket"> | number | null
    winningDirection?: EnumPredictionDirectionNullableFilter<"BettingMarket"> | $Enums.PredictionDirection | null
    marketMakerFee?: FloatFilter<"BettingMarket"> | number
    createdBy?: StringNullableFilter<"BettingMarket"> | string | null
    createdAt?: DateTimeFilter<"BettingMarket"> | Date | string
    updatedAt?: DateTimeFilter<"BettingMarket"> | Date | string
    card?: XOR<CardScalarRelationFilter, CardWhereInput>
    positions?: BettingPositionListRelationFilter
    payouts?: BettingPayoutListRelationFilter
    metrics?: MarketMetricsListRelationFilter
  }

  export type BettingMarketOrderByWithRelationInput = {
    id?: SortOrder
    cardId?: SortOrder
    metricType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    currentValue?: SortOrder
    predictionTarget?: SortOrder
    targetDirection?: SortOrder
    odds?: SortOrder
    totalPot?: SortOrder
    minimumBet?: SortOrder
    maximumBet?: SortOrderInput | SortOrder
    startTime?: SortOrder
    expiryDate?: SortOrder
    settlementDate?: SortOrderInput | SortOrder
    status?: SortOrder
    settled?: SortOrder
    settledValue?: SortOrderInput | SortOrder
    winningDirection?: SortOrderInput | SortOrder
    marketMakerFee?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    card?: CardOrderByWithRelationInput
    positions?: BettingPositionOrderByRelationAggregateInput
    payouts?: BettingPayoutOrderByRelationAggregateInput
    metrics?: MarketMetricsOrderByRelationAggregateInput
  }

  export type BettingMarketWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BettingMarketWhereInput | BettingMarketWhereInput[]
    OR?: BettingMarketWhereInput[]
    NOT?: BettingMarketWhereInput | BettingMarketWhereInput[]
    cardId?: StringFilter<"BettingMarket"> | string
    metricType?: EnumMarketMetricTypeFilter<"BettingMarket"> | $Enums.MarketMetricType
    title?: StringFilter<"BettingMarket"> | string
    description?: StringFilter<"BettingMarket"> | string
    currentValue?: FloatFilter<"BettingMarket"> | number
    predictionTarget?: FloatFilter<"BettingMarket"> | number
    targetDirection?: EnumPredictionDirectionFilter<"BettingMarket"> | $Enums.PredictionDirection
    odds?: FloatFilter<"BettingMarket"> | number
    totalPot?: FloatFilter<"BettingMarket"> | number
    minimumBet?: FloatFilter<"BettingMarket"> | number
    maximumBet?: FloatNullableFilter<"BettingMarket"> | number | null
    startTime?: DateTimeFilter<"BettingMarket"> | Date | string
    expiryDate?: DateTimeFilter<"BettingMarket"> | Date | string
    settlementDate?: DateTimeNullableFilter<"BettingMarket"> | Date | string | null
    status?: EnumMarketStatusFilter<"BettingMarket"> | $Enums.MarketStatus
    settled?: BoolFilter<"BettingMarket"> | boolean
    settledValue?: FloatNullableFilter<"BettingMarket"> | number | null
    winningDirection?: EnumPredictionDirectionNullableFilter<"BettingMarket"> | $Enums.PredictionDirection | null
    marketMakerFee?: FloatFilter<"BettingMarket"> | number
    createdBy?: StringNullableFilter<"BettingMarket"> | string | null
    createdAt?: DateTimeFilter<"BettingMarket"> | Date | string
    updatedAt?: DateTimeFilter<"BettingMarket"> | Date | string
    card?: XOR<CardScalarRelationFilter, CardWhereInput>
    positions?: BettingPositionListRelationFilter
    payouts?: BettingPayoutListRelationFilter
    metrics?: MarketMetricsListRelationFilter
  }, "id">

  export type BettingMarketOrderByWithAggregationInput = {
    id?: SortOrder
    cardId?: SortOrder
    metricType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    currentValue?: SortOrder
    predictionTarget?: SortOrder
    targetDirection?: SortOrder
    odds?: SortOrder
    totalPot?: SortOrder
    minimumBet?: SortOrder
    maximumBet?: SortOrderInput | SortOrder
    startTime?: SortOrder
    expiryDate?: SortOrder
    settlementDate?: SortOrderInput | SortOrder
    status?: SortOrder
    settled?: SortOrder
    settledValue?: SortOrderInput | SortOrder
    winningDirection?: SortOrderInput | SortOrder
    marketMakerFee?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BettingMarketCountOrderByAggregateInput
    _avg?: BettingMarketAvgOrderByAggregateInput
    _max?: BettingMarketMaxOrderByAggregateInput
    _min?: BettingMarketMinOrderByAggregateInput
    _sum?: BettingMarketSumOrderByAggregateInput
  }

  export type BettingMarketScalarWhereWithAggregatesInput = {
    AND?: BettingMarketScalarWhereWithAggregatesInput | BettingMarketScalarWhereWithAggregatesInput[]
    OR?: BettingMarketScalarWhereWithAggregatesInput[]
    NOT?: BettingMarketScalarWhereWithAggregatesInput | BettingMarketScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BettingMarket"> | string
    cardId?: StringWithAggregatesFilter<"BettingMarket"> | string
    metricType?: EnumMarketMetricTypeWithAggregatesFilter<"BettingMarket"> | $Enums.MarketMetricType
    title?: StringWithAggregatesFilter<"BettingMarket"> | string
    description?: StringWithAggregatesFilter<"BettingMarket"> | string
    currentValue?: FloatWithAggregatesFilter<"BettingMarket"> | number
    predictionTarget?: FloatWithAggregatesFilter<"BettingMarket"> | number
    targetDirection?: EnumPredictionDirectionWithAggregatesFilter<"BettingMarket"> | $Enums.PredictionDirection
    odds?: FloatWithAggregatesFilter<"BettingMarket"> | number
    totalPot?: FloatWithAggregatesFilter<"BettingMarket"> | number
    minimumBet?: FloatWithAggregatesFilter<"BettingMarket"> | number
    maximumBet?: FloatNullableWithAggregatesFilter<"BettingMarket"> | number | null
    startTime?: DateTimeWithAggregatesFilter<"BettingMarket"> | Date | string
    expiryDate?: DateTimeWithAggregatesFilter<"BettingMarket"> | Date | string
    settlementDate?: DateTimeNullableWithAggregatesFilter<"BettingMarket"> | Date | string | null
    status?: EnumMarketStatusWithAggregatesFilter<"BettingMarket"> | $Enums.MarketStatus
    settled?: BoolWithAggregatesFilter<"BettingMarket"> | boolean
    settledValue?: FloatNullableWithAggregatesFilter<"BettingMarket"> | number | null
    winningDirection?: EnumPredictionDirectionNullableWithAggregatesFilter<"BettingMarket"> | $Enums.PredictionDirection | null
    marketMakerFee?: FloatWithAggregatesFilter<"BettingMarket"> | number
    createdBy?: StringNullableWithAggregatesFilter<"BettingMarket"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BettingMarket"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BettingMarket"> | Date | string
  }

  export type BettingPositionWhereInput = {
    AND?: BettingPositionWhereInput | BettingPositionWhereInput[]
    OR?: BettingPositionWhereInput[]
    NOT?: BettingPositionWhereInput | BettingPositionWhereInput[]
    id?: StringFilter<"BettingPosition"> | string
    marketId?: StringFilter<"BettingPosition"> | string
    userId?: StringFilter<"BettingPosition"> | string
    position?: EnumPredictionDirectionFilter<"BettingPosition"> | $Enums.PredictionDirection
    amount?: FloatFilter<"BettingPosition"> | number
    odds?: FloatFilter<"BettingPosition"> | number
    potentialWinning?: FloatFilter<"BettingPosition"> | number
    pickGroupId?: StringNullableFilter<"BettingPosition"> | string | null
    multiplier?: FloatFilter<"BettingPosition"> | number
    powerPlay?: BoolFilter<"BettingPosition"> | boolean
    status?: EnumPositionStatusFilter<"BettingPosition"> | $Enums.PositionStatus
    settled?: BoolFilter<"BettingPosition"> | boolean
    won?: BoolNullableFilter<"BettingPosition"> | boolean | null
    payout?: FloatNullableFilter<"BettingPosition"> | number | null
    createdAt?: DateTimeFilter<"BettingPosition"> | Date | string
    updatedAt?: DateTimeFilter<"BettingPosition"> | Date | string
    market?: XOR<BettingMarketScalarRelationFilter, BettingMarketWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type BettingPositionOrderByWithRelationInput = {
    id?: SortOrder
    marketId?: SortOrder
    userId?: SortOrder
    position?: SortOrder
    amount?: SortOrder
    odds?: SortOrder
    potentialWinning?: SortOrder
    pickGroupId?: SortOrderInput | SortOrder
    multiplier?: SortOrder
    powerPlay?: SortOrder
    status?: SortOrder
    settled?: SortOrder
    won?: SortOrderInput | SortOrder
    payout?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    market?: BettingMarketOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type BettingPositionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BettingPositionWhereInput | BettingPositionWhereInput[]
    OR?: BettingPositionWhereInput[]
    NOT?: BettingPositionWhereInput | BettingPositionWhereInput[]
    marketId?: StringFilter<"BettingPosition"> | string
    userId?: StringFilter<"BettingPosition"> | string
    position?: EnumPredictionDirectionFilter<"BettingPosition"> | $Enums.PredictionDirection
    amount?: FloatFilter<"BettingPosition"> | number
    odds?: FloatFilter<"BettingPosition"> | number
    potentialWinning?: FloatFilter<"BettingPosition"> | number
    pickGroupId?: StringNullableFilter<"BettingPosition"> | string | null
    multiplier?: FloatFilter<"BettingPosition"> | number
    powerPlay?: BoolFilter<"BettingPosition"> | boolean
    status?: EnumPositionStatusFilter<"BettingPosition"> | $Enums.PositionStatus
    settled?: BoolFilter<"BettingPosition"> | boolean
    won?: BoolNullableFilter<"BettingPosition"> | boolean | null
    payout?: FloatNullableFilter<"BettingPosition"> | number | null
    createdAt?: DateTimeFilter<"BettingPosition"> | Date | string
    updatedAt?: DateTimeFilter<"BettingPosition"> | Date | string
    market?: XOR<BettingMarketScalarRelationFilter, BettingMarketWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type BettingPositionOrderByWithAggregationInput = {
    id?: SortOrder
    marketId?: SortOrder
    userId?: SortOrder
    position?: SortOrder
    amount?: SortOrder
    odds?: SortOrder
    potentialWinning?: SortOrder
    pickGroupId?: SortOrderInput | SortOrder
    multiplier?: SortOrder
    powerPlay?: SortOrder
    status?: SortOrder
    settled?: SortOrder
    won?: SortOrderInput | SortOrder
    payout?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BettingPositionCountOrderByAggregateInput
    _avg?: BettingPositionAvgOrderByAggregateInput
    _max?: BettingPositionMaxOrderByAggregateInput
    _min?: BettingPositionMinOrderByAggregateInput
    _sum?: BettingPositionSumOrderByAggregateInput
  }

  export type BettingPositionScalarWhereWithAggregatesInput = {
    AND?: BettingPositionScalarWhereWithAggregatesInput | BettingPositionScalarWhereWithAggregatesInput[]
    OR?: BettingPositionScalarWhereWithAggregatesInput[]
    NOT?: BettingPositionScalarWhereWithAggregatesInput | BettingPositionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BettingPosition"> | string
    marketId?: StringWithAggregatesFilter<"BettingPosition"> | string
    userId?: StringWithAggregatesFilter<"BettingPosition"> | string
    position?: EnumPredictionDirectionWithAggregatesFilter<"BettingPosition"> | $Enums.PredictionDirection
    amount?: FloatWithAggregatesFilter<"BettingPosition"> | number
    odds?: FloatWithAggregatesFilter<"BettingPosition"> | number
    potentialWinning?: FloatWithAggregatesFilter<"BettingPosition"> | number
    pickGroupId?: StringNullableWithAggregatesFilter<"BettingPosition"> | string | null
    multiplier?: FloatWithAggregatesFilter<"BettingPosition"> | number
    powerPlay?: BoolWithAggregatesFilter<"BettingPosition"> | boolean
    status?: EnumPositionStatusWithAggregatesFilter<"BettingPosition"> | $Enums.PositionStatus
    settled?: BoolWithAggregatesFilter<"BettingPosition"> | boolean
    won?: BoolNullableWithAggregatesFilter<"BettingPosition"> | boolean | null
    payout?: FloatNullableWithAggregatesFilter<"BettingPosition"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"BettingPosition"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BettingPosition"> | Date | string
  }

  export type MarketMetricsWhereInput = {
    AND?: MarketMetricsWhereInput | MarketMetricsWhereInput[]
    OR?: MarketMetricsWhereInput[]
    NOT?: MarketMetricsWhereInput | MarketMetricsWhereInput[]
    id?: StringFilter<"MarketMetrics"> | string
    cardId?: StringFilter<"MarketMetrics"> | string
    marketId?: StringNullableFilter<"MarketMetrics"> | string | null
    revenue?: FloatNullableFilter<"MarketMetrics"> | number | null
    userGrowth?: FloatNullableFilter<"MarketMetrics"> | number | null
    valuation?: FloatNullableFilter<"MarketMetrics"> | number | null
    marketCap?: FloatNullableFilter<"MarketMetrics"> | number | null
    quarterlyGrowth?: FloatNullableFilter<"MarketMetrics"> | number | null
    userEngagement?: FloatNullableFilter<"MarketMetrics"> | number | null
    productLaunches?: IntNullableFilter<"MarketMetrics"> | number | null
    competitorRank?: IntNullableFilter<"MarketMetrics"> | number | null
    sentimentScore?: FloatNullableFilter<"MarketMetrics"> | number | null
    trendingScore?: FloatNullableFilter<"MarketMetrics"> | number | null
    socialMentions?: IntNullableFilter<"MarketMetrics"> | number | null
    recordDate?: DateTimeFilter<"MarketMetrics"> | Date | string
    dataSource?: StringNullableFilter<"MarketMetrics"> | string | null
    createdAt?: DateTimeFilter<"MarketMetrics"> | Date | string
    updatedAt?: DateTimeFilter<"MarketMetrics"> | Date | string
    card?: XOR<CardScalarRelationFilter, CardWhereInput>
    market?: XOR<BettingMarketNullableScalarRelationFilter, BettingMarketWhereInput> | null
  }

  export type MarketMetricsOrderByWithRelationInput = {
    id?: SortOrder
    cardId?: SortOrder
    marketId?: SortOrderInput | SortOrder
    revenue?: SortOrderInput | SortOrder
    userGrowth?: SortOrderInput | SortOrder
    valuation?: SortOrderInput | SortOrder
    marketCap?: SortOrderInput | SortOrder
    quarterlyGrowth?: SortOrderInput | SortOrder
    userEngagement?: SortOrderInput | SortOrder
    productLaunches?: SortOrderInput | SortOrder
    competitorRank?: SortOrderInput | SortOrder
    sentimentScore?: SortOrderInput | SortOrder
    trendingScore?: SortOrderInput | SortOrder
    socialMentions?: SortOrderInput | SortOrder
    recordDate?: SortOrder
    dataSource?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    card?: CardOrderByWithRelationInput
    market?: BettingMarketOrderByWithRelationInput
  }

  export type MarketMetricsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MarketMetricsWhereInput | MarketMetricsWhereInput[]
    OR?: MarketMetricsWhereInput[]
    NOT?: MarketMetricsWhereInput | MarketMetricsWhereInput[]
    cardId?: StringFilter<"MarketMetrics"> | string
    marketId?: StringNullableFilter<"MarketMetrics"> | string | null
    revenue?: FloatNullableFilter<"MarketMetrics"> | number | null
    userGrowth?: FloatNullableFilter<"MarketMetrics"> | number | null
    valuation?: FloatNullableFilter<"MarketMetrics"> | number | null
    marketCap?: FloatNullableFilter<"MarketMetrics"> | number | null
    quarterlyGrowth?: FloatNullableFilter<"MarketMetrics"> | number | null
    userEngagement?: FloatNullableFilter<"MarketMetrics"> | number | null
    productLaunches?: IntNullableFilter<"MarketMetrics"> | number | null
    competitorRank?: IntNullableFilter<"MarketMetrics"> | number | null
    sentimentScore?: FloatNullableFilter<"MarketMetrics"> | number | null
    trendingScore?: FloatNullableFilter<"MarketMetrics"> | number | null
    socialMentions?: IntNullableFilter<"MarketMetrics"> | number | null
    recordDate?: DateTimeFilter<"MarketMetrics"> | Date | string
    dataSource?: StringNullableFilter<"MarketMetrics"> | string | null
    createdAt?: DateTimeFilter<"MarketMetrics"> | Date | string
    updatedAt?: DateTimeFilter<"MarketMetrics"> | Date | string
    card?: XOR<CardScalarRelationFilter, CardWhereInput>
    market?: XOR<BettingMarketNullableScalarRelationFilter, BettingMarketWhereInput> | null
  }, "id">

  export type MarketMetricsOrderByWithAggregationInput = {
    id?: SortOrder
    cardId?: SortOrder
    marketId?: SortOrderInput | SortOrder
    revenue?: SortOrderInput | SortOrder
    userGrowth?: SortOrderInput | SortOrder
    valuation?: SortOrderInput | SortOrder
    marketCap?: SortOrderInput | SortOrder
    quarterlyGrowth?: SortOrderInput | SortOrder
    userEngagement?: SortOrderInput | SortOrder
    productLaunches?: SortOrderInput | SortOrder
    competitorRank?: SortOrderInput | SortOrder
    sentimentScore?: SortOrderInput | SortOrder
    trendingScore?: SortOrderInput | SortOrder
    socialMentions?: SortOrderInput | SortOrder
    recordDate?: SortOrder
    dataSource?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MarketMetricsCountOrderByAggregateInput
    _avg?: MarketMetricsAvgOrderByAggregateInput
    _max?: MarketMetricsMaxOrderByAggregateInput
    _min?: MarketMetricsMinOrderByAggregateInput
    _sum?: MarketMetricsSumOrderByAggregateInput
  }

  export type MarketMetricsScalarWhereWithAggregatesInput = {
    AND?: MarketMetricsScalarWhereWithAggregatesInput | MarketMetricsScalarWhereWithAggregatesInput[]
    OR?: MarketMetricsScalarWhereWithAggregatesInput[]
    NOT?: MarketMetricsScalarWhereWithAggregatesInput | MarketMetricsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MarketMetrics"> | string
    cardId?: StringWithAggregatesFilter<"MarketMetrics"> | string
    marketId?: StringNullableWithAggregatesFilter<"MarketMetrics"> | string | null
    revenue?: FloatNullableWithAggregatesFilter<"MarketMetrics"> | number | null
    userGrowth?: FloatNullableWithAggregatesFilter<"MarketMetrics"> | number | null
    valuation?: FloatNullableWithAggregatesFilter<"MarketMetrics"> | number | null
    marketCap?: FloatNullableWithAggregatesFilter<"MarketMetrics"> | number | null
    quarterlyGrowth?: FloatNullableWithAggregatesFilter<"MarketMetrics"> | number | null
    userEngagement?: FloatNullableWithAggregatesFilter<"MarketMetrics"> | number | null
    productLaunches?: IntNullableWithAggregatesFilter<"MarketMetrics"> | number | null
    competitorRank?: IntNullableWithAggregatesFilter<"MarketMetrics"> | number | null
    sentimentScore?: FloatNullableWithAggregatesFilter<"MarketMetrics"> | number | null
    trendingScore?: FloatNullableWithAggregatesFilter<"MarketMetrics"> | number | null
    socialMentions?: IntNullableWithAggregatesFilter<"MarketMetrics"> | number | null
    recordDate?: DateTimeWithAggregatesFilter<"MarketMetrics"> | Date | string
    dataSource?: StringNullableWithAggregatesFilter<"MarketMetrics"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MarketMetrics"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MarketMetrics"> | Date | string
  }

  export type BettingPayoutWhereInput = {
    AND?: BettingPayoutWhereInput | BettingPayoutWhereInput[]
    OR?: BettingPayoutWhereInput[]
    NOT?: BettingPayoutWhereInput | BettingPayoutWhereInput[]
    id?: StringFilter<"BettingPayout"> | string
    marketId?: StringFilter<"BettingPayout"> | string
    userId?: StringFilter<"BettingPayout"> | string
    positionId?: StringFilter<"BettingPayout"> | string
    winnings?: FloatFilter<"BettingPayout"> | number
    originalBet?: FloatFilter<"BettingPayout"> | number
    multiplier?: FloatFilter<"BettingPayout"> | number
    status?: EnumPayoutStatusFilter<"BettingPayout"> | $Enums.PayoutStatus
    payoutDate?: DateTimeNullableFilter<"BettingPayout"> | Date | string | null
    transactionId?: StringNullableFilter<"BettingPayout"> | string | null
    createdAt?: DateTimeFilter<"BettingPayout"> | Date | string
    updatedAt?: DateTimeFilter<"BettingPayout"> | Date | string
    market?: XOR<BettingMarketScalarRelationFilter, BettingMarketWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type BettingPayoutOrderByWithRelationInput = {
    id?: SortOrder
    marketId?: SortOrder
    userId?: SortOrder
    positionId?: SortOrder
    winnings?: SortOrder
    originalBet?: SortOrder
    multiplier?: SortOrder
    status?: SortOrder
    payoutDate?: SortOrderInput | SortOrder
    transactionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    market?: BettingMarketOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type BettingPayoutWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BettingPayoutWhereInput | BettingPayoutWhereInput[]
    OR?: BettingPayoutWhereInput[]
    NOT?: BettingPayoutWhereInput | BettingPayoutWhereInput[]
    marketId?: StringFilter<"BettingPayout"> | string
    userId?: StringFilter<"BettingPayout"> | string
    positionId?: StringFilter<"BettingPayout"> | string
    winnings?: FloatFilter<"BettingPayout"> | number
    originalBet?: FloatFilter<"BettingPayout"> | number
    multiplier?: FloatFilter<"BettingPayout"> | number
    status?: EnumPayoutStatusFilter<"BettingPayout"> | $Enums.PayoutStatus
    payoutDate?: DateTimeNullableFilter<"BettingPayout"> | Date | string | null
    transactionId?: StringNullableFilter<"BettingPayout"> | string | null
    createdAt?: DateTimeFilter<"BettingPayout"> | Date | string
    updatedAt?: DateTimeFilter<"BettingPayout"> | Date | string
    market?: XOR<BettingMarketScalarRelationFilter, BettingMarketWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type BettingPayoutOrderByWithAggregationInput = {
    id?: SortOrder
    marketId?: SortOrder
    userId?: SortOrder
    positionId?: SortOrder
    winnings?: SortOrder
    originalBet?: SortOrder
    multiplier?: SortOrder
    status?: SortOrder
    payoutDate?: SortOrderInput | SortOrder
    transactionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BettingPayoutCountOrderByAggregateInput
    _avg?: BettingPayoutAvgOrderByAggregateInput
    _max?: BettingPayoutMaxOrderByAggregateInput
    _min?: BettingPayoutMinOrderByAggregateInput
    _sum?: BettingPayoutSumOrderByAggregateInput
  }

  export type BettingPayoutScalarWhereWithAggregatesInput = {
    AND?: BettingPayoutScalarWhereWithAggregatesInput | BettingPayoutScalarWhereWithAggregatesInput[]
    OR?: BettingPayoutScalarWhereWithAggregatesInput[]
    NOT?: BettingPayoutScalarWhereWithAggregatesInput | BettingPayoutScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BettingPayout"> | string
    marketId?: StringWithAggregatesFilter<"BettingPayout"> | string
    userId?: StringWithAggregatesFilter<"BettingPayout"> | string
    positionId?: StringWithAggregatesFilter<"BettingPayout"> | string
    winnings?: FloatWithAggregatesFilter<"BettingPayout"> | number
    originalBet?: FloatWithAggregatesFilter<"BettingPayout"> | number
    multiplier?: FloatWithAggregatesFilter<"BettingPayout"> | number
    status?: EnumPayoutStatusWithAggregatesFilter<"BettingPayout"> | $Enums.PayoutStatus
    payoutDate?: DateTimeNullableWithAggregatesFilter<"BettingPayout"> | Date | string | null
    transactionId?: StringNullableWithAggregatesFilter<"BettingPayout"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BettingPayout"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BettingPayout"> | Date | string
  }

  export type CardAuctionWhereInput = {
    AND?: CardAuctionWhereInput | CardAuctionWhereInput[]
    OR?: CardAuctionWhereInput[]
    NOT?: CardAuctionWhereInput | CardAuctionWhereInput[]
    id?: StringFilter<"CardAuction"> | string
    cardId?: StringFilter<"CardAuction"> | string
    ownerId?: StringFilter<"CardAuction"> | string
    title?: StringFilter<"CardAuction"> | string
    description?: StringNullableFilter<"CardAuction"> | string | null
    startPrice?: FloatFilter<"CardAuction"> | number
    reservePrice?: FloatNullableFilter<"CardAuction"> | number | null
    currentBid?: FloatNullableFilter<"CardAuction"> | number | null
    bidIncrement?: FloatFilter<"CardAuction"> | number
    startTime?: DateTimeFilter<"CardAuction"> | Date | string
    endTime?: DateTimeFilter<"CardAuction"> | Date | string
    autoExtend?: BoolFilter<"CardAuction"> | boolean
    status?: EnumAuctionStatusFilter<"CardAuction"> | $Enums.AuctionStatus
    finalized?: BoolFilter<"CardAuction"> | boolean
    winnerId?: StringNullableFilter<"CardAuction"> | string | null
    viewCount?: IntFilter<"CardAuction"> | number
    watcherCount?: IntFilter<"CardAuction"> | number
    bidCount?: IntFilter<"CardAuction"> | number
    createdAt?: DateTimeFilter<"CardAuction"> | Date | string
    updatedAt?: DateTimeFilter<"CardAuction"> | Date | string
    card?: XOR<CardScalarRelationFilter, CardWhereInput>
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    conditions?: XOR<AuctionConditionsNullableScalarRelationFilter, AuctionConditionsWhereInput> | null
    winner?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    bids?: AuctionBidListRelationFilter
    watchers?: AuctionWatcherListRelationFilter
    history?: AuctionHistoryListRelationFilter
  }

  export type CardAuctionOrderByWithRelationInput = {
    id?: SortOrder
    cardId?: SortOrder
    ownerId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    startPrice?: SortOrder
    reservePrice?: SortOrderInput | SortOrder
    currentBid?: SortOrderInput | SortOrder
    bidIncrement?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    autoExtend?: SortOrder
    status?: SortOrder
    finalized?: SortOrder
    winnerId?: SortOrderInput | SortOrder
    viewCount?: SortOrder
    watcherCount?: SortOrder
    bidCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    card?: CardOrderByWithRelationInput
    owner?: UserOrderByWithRelationInput
    conditions?: AuctionConditionsOrderByWithRelationInput
    winner?: UserOrderByWithRelationInput
    bids?: AuctionBidOrderByRelationAggregateInput
    watchers?: AuctionWatcherOrderByRelationAggregateInput
    history?: AuctionHistoryOrderByRelationAggregateInput
  }

  export type CardAuctionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    cardId?: string
    AND?: CardAuctionWhereInput | CardAuctionWhereInput[]
    OR?: CardAuctionWhereInput[]
    NOT?: CardAuctionWhereInput | CardAuctionWhereInput[]
    ownerId?: StringFilter<"CardAuction"> | string
    title?: StringFilter<"CardAuction"> | string
    description?: StringNullableFilter<"CardAuction"> | string | null
    startPrice?: FloatFilter<"CardAuction"> | number
    reservePrice?: FloatNullableFilter<"CardAuction"> | number | null
    currentBid?: FloatNullableFilter<"CardAuction"> | number | null
    bidIncrement?: FloatFilter<"CardAuction"> | number
    startTime?: DateTimeFilter<"CardAuction"> | Date | string
    endTime?: DateTimeFilter<"CardAuction"> | Date | string
    autoExtend?: BoolFilter<"CardAuction"> | boolean
    status?: EnumAuctionStatusFilter<"CardAuction"> | $Enums.AuctionStatus
    finalized?: BoolFilter<"CardAuction"> | boolean
    winnerId?: StringNullableFilter<"CardAuction"> | string | null
    viewCount?: IntFilter<"CardAuction"> | number
    watcherCount?: IntFilter<"CardAuction"> | number
    bidCount?: IntFilter<"CardAuction"> | number
    createdAt?: DateTimeFilter<"CardAuction"> | Date | string
    updatedAt?: DateTimeFilter<"CardAuction"> | Date | string
    card?: XOR<CardScalarRelationFilter, CardWhereInput>
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    conditions?: XOR<AuctionConditionsNullableScalarRelationFilter, AuctionConditionsWhereInput> | null
    winner?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    bids?: AuctionBidListRelationFilter
    watchers?: AuctionWatcherListRelationFilter
    history?: AuctionHistoryListRelationFilter
  }, "id" | "cardId">

  export type CardAuctionOrderByWithAggregationInput = {
    id?: SortOrder
    cardId?: SortOrder
    ownerId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    startPrice?: SortOrder
    reservePrice?: SortOrderInput | SortOrder
    currentBid?: SortOrderInput | SortOrder
    bidIncrement?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    autoExtend?: SortOrder
    status?: SortOrder
    finalized?: SortOrder
    winnerId?: SortOrderInput | SortOrder
    viewCount?: SortOrder
    watcherCount?: SortOrder
    bidCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CardAuctionCountOrderByAggregateInput
    _avg?: CardAuctionAvgOrderByAggregateInput
    _max?: CardAuctionMaxOrderByAggregateInput
    _min?: CardAuctionMinOrderByAggregateInput
    _sum?: CardAuctionSumOrderByAggregateInput
  }

  export type CardAuctionScalarWhereWithAggregatesInput = {
    AND?: CardAuctionScalarWhereWithAggregatesInput | CardAuctionScalarWhereWithAggregatesInput[]
    OR?: CardAuctionScalarWhereWithAggregatesInput[]
    NOT?: CardAuctionScalarWhereWithAggregatesInput | CardAuctionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CardAuction"> | string
    cardId?: StringWithAggregatesFilter<"CardAuction"> | string
    ownerId?: StringWithAggregatesFilter<"CardAuction"> | string
    title?: StringWithAggregatesFilter<"CardAuction"> | string
    description?: StringNullableWithAggregatesFilter<"CardAuction"> | string | null
    startPrice?: FloatWithAggregatesFilter<"CardAuction"> | number
    reservePrice?: FloatNullableWithAggregatesFilter<"CardAuction"> | number | null
    currentBid?: FloatNullableWithAggregatesFilter<"CardAuction"> | number | null
    bidIncrement?: FloatWithAggregatesFilter<"CardAuction"> | number
    startTime?: DateTimeWithAggregatesFilter<"CardAuction"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"CardAuction"> | Date | string
    autoExtend?: BoolWithAggregatesFilter<"CardAuction"> | boolean
    status?: EnumAuctionStatusWithAggregatesFilter<"CardAuction"> | $Enums.AuctionStatus
    finalized?: BoolWithAggregatesFilter<"CardAuction"> | boolean
    winnerId?: StringNullableWithAggregatesFilter<"CardAuction"> | string | null
    viewCount?: IntWithAggregatesFilter<"CardAuction"> | number
    watcherCount?: IntWithAggregatesFilter<"CardAuction"> | number
    bidCount?: IntWithAggregatesFilter<"CardAuction"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CardAuction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CardAuction"> | Date | string
  }

  export type AuctionConditionsWhereInput = {
    AND?: AuctionConditionsWhereInput | AuctionConditionsWhereInput[]
    OR?: AuctionConditionsWhereInput[]
    NOT?: AuctionConditionsWhereInput | AuctionConditionsWhereInput[]
    id?: StringFilter<"AuctionConditions"> | string
    auctionId?: StringFilter<"AuctionConditions"> | string
    proMembersOnly?: BoolFilter<"AuctionConditions"> | boolean
    minimumRating?: FloatNullableFilter<"AuctionConditions"> | number | null
    geographicRestrictions?: StringNullableListFilter<"AuctionConditions">
    minimumNetWorth?: FloatNullableFilter<"AuctionConditions"> | number | null
    verificationRequired?: BoolFilter<"AuctionConditions"> | boolean
    minimumPortfolioValue?: FloatNullableFilter<"AuctionConditions"> | number | null
    minimumCardsOwned?: IntNullableFilter<"AuctionConditions"> | number | null
    industryRestrictions?: StringNullableListFilter<"AuctionConditions">
    createdAt?: DateTimeFilter<"AuctionConditions"> | Date | string
    updatedAt?: DateTimeFilter<"AuctionConditions"> | Date | string
    auction?: XOR<CardAuctionScalarRelationFilter, CardAuctionWhereInput>
  }

  export type AuctionConditionsOrderByWithRelationInput = {
    id?: SortOrder
    auctionId?: SortOrder
    proMembersOnly?: SortOrder
    minimumRating?: SortOrderInput | SortOrder
    geographicRestrictions?: SortOrder
    minimumNetWorth?: SortOrderInput | SortOrder
    verificationRequired?: SortOrder
    minimumPortfolioValue?: SortOrderInput | SortOrder
    minimumCardsOwned?: SortOrderInput | SortOrder
    industryRestrictions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    auction?: CardAuctionOrderByWithRelationInput
  }

  export type AuctionConditionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    auctionId?: string
    AND?: AuctionConditionsWhereInput | AuctionConditionsWhereInput[]
    OR?: AuctionConditionsWhereInput[]
    NOT?: AuctionConditionsWhereInput | AuctionConditionsWhereInput[]
    proMembersOnly?: BoolFilter<"AuctionConditions"> | boolean
    minimumRating?: FloatNullableFilter<"AuctionConditions"> | number | null
    geographicRestrictions?: StringNullableListFilter<"AuctionConditions">
    minimumNetWorth?: FloatNullableFilter<"AuctionConditions"> | number | null
    verificationRequired?: BoolFilter<"AuctionConditions"> | boolean
    minimumPortfolioValue?: FloatNullableFilter<"AuctionConditions"> | number | null
    minimumCardsOwned?: IntNullableFilter<"AuctionConditions"> | number | null
    industryRestrictions?: StringNullableListFilter<"AuctionConditions">
    createdAt?: DateTimeFilter<"AuctionConditions"> | Date | string
    updatedAt?: DateTimeFilter<"AuctionConditions"> | Date | string
    auction?: XOR<CardAuctionScalarRelationFilter, CardAuctionWhereInput>
  }, "id" | "auctionId">

  export type AuctionConditionsOrderByWithAggregationInput = {
    id?: SortOrder
    auctionId?: SortOrder
    proMembersOnly?: SortOrder
    minimumRating?: SortOrderInput | SortOrder
    geographicRestrictions?: SortOrder
    minimumNetWorth?: SortOrderInput | SortOrder
    verificationRequired?: SortOrder
    minimumPortfolioValue?: SortOrderInput | SortOrder
    minimumCardsOwned?: SortOrderInput | SortOrder
    industryRestrictions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AuctionConditionsCountOrderByAggregateInput
    _avg?: AuctionConditionsAvgOrderByAggregateInput
    _max?: AuctionConditionsMaxOrderByAggregateInput
    _min?: AuctionConditionsMinOrderByAggregateInput
    _sum?: AuctionConditionsSumOrderByAggregateInput
  }

  export type AuctionConditionsScalarWhereWithAggregatesInput = {
    AND?: AuctionConditionsScalarWhereWithAggregatesInput | AuctionConditionsScalarWhereWithAggregatesInput[]
    OR?: AuctionConditionsScalarWhereWithAggregatesInput[]
    NOT?: AuctionConditionsScalarWhereWithAggregatesInput | AuctionConditionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuctionConditions"> | string
    auctionId?: StringWithAggregatesFilter<"AuctionConditions"> | string
    proMembersOnly?: BoolWithAggregatesFilter<"AuctionConditions"> | boolean
    minimumRating?: FloatNullableWithAggregatesFilter<"AuctionConditions"> | number | null
    geographicRestrictions?: StringNullableListFilter<"AuctionConditions">
    minimumNetWorth?: FloatNullableWithAggregatesFilter<"AuctionConditions"> | number | null
    verificationRequired?: BoolWithAggregatesFilter<"AuctionConditions"> | boolean
    minimumPortfolioValue?: FloatNullableWithAggregatesFilter<"AuctionConditions"> | number | null
    minimumCardsOwned?: IntNullableWithAggregatesFilter<"AuctionConditions"> | number | null
    industryRestrictions?: StringNullableListFilter<"AuctionConditions">
    createdAt?: DateTimeWithAggregatesFilter<"AuctionConditions"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AuctionConditions"> | Date | string
  }

  export type AuctionBidWhereInput = {
    AND?: AuctionBidWhereInput | AuctionBidWhereInput[]
    OR?: AuctionBidWhereInput[]
    NOT?: AuctionBidWhereInput | AuctionBidWhereInput[]
    id?: StringFilter<"AuctionBid"> | string
    auctionId?: StringFilter<"AuctionBid"> | string
    bidderId?: StringFilter<"AuctionBid"> | string
    bidAmount?: FloatFilter<"AuctionBid"> | number
    maxAutoBid?: FloatNullableFilter<"AuctionBid"> | number | null
    bidType?: EnumBidTypeFilter<"AuctionBid"> | $Enums.BidType
    status?: EnumAuctionBidStatusFilter<"AuctionBid"> | $Enums.AuctionBidStatus
    isWinning?: BoolFilter<"AuctionBid"> | boolean
    outbidNotified?: BoolFilter<"AuctionBid"> | boolean
    userAgent?: StringNullableFilter<"AuctionBid"> | string | null
    ipAddress?: StringNullableFilter<"AuctionBid"> | string | null
    createdAt?: DateTimeFilter<"AuctionBid"> | Date | string
    updatedAt?: DateTimeFilter<"AuctionBid"> | Date | string
    auction?: XOR<CardAuctionScalarRelationFilter, CardAuctionWhereInput>
    bidder?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AuctionBidOrderByWithRelationInput = {
    id?: SortOrder
    auctionId?: SortOrder
    bidderId?: SortOrder
    bidAmount?: SortOrder
    maxAutoBid?: SortOrderInput | SortOrder
    bidType?: SortOrder
    status?: SortOrder
    isWinning?: SortOrder
    outbidNotified?: SortOrder
    userAgent?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    auction?: CardAuctionOrderByWithRelationInput
    bidder?: UserOrderByWithRelationInput
  }

  export type AuctionBidWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuctionBidWhereInput | AuctionBidWhereInput[]
    OR?: AuctionBidWhereInput[]
    NOT?: AuctionBidWhereInput | AuctionBidWhereInput[]
    auctionId?: StringFilter<"AuctionBid"> | string
    bidderId?: StringFilter<"AuctionBid"> | string
    bidAmount?: FloatFilter<"AuctionBid"> | number
    maxAutoBid?: FloatNullableFilter<"AuctionBid"> | number | null
    bidType?: EnumBidTypeFilter<"AuctionBid"> | $Enums.BidType
    status?: EnumAuctionBidStatusFilter<"AuctionBid"> | $Enums.AuctionBidStatus
    isWinning?: BoolFilter<"AuctionBid"> | boolean
    outbidNotified?: BoolFilter<"AuctionBid"> | boolean
    userAgent?: StringNullableFilter<"AuctionBid"> | string | null
    ipAddress?: StringNullableFilter<"AuctionBid"> | string | null
    createdAt?: DateTimeFilter<"AuctionBid"> | Date | string
    updatedAt?: DateTimeFilter<"AuctionBid"> | Date | string
    auction?: XOR<CardAuctionScalarRelationFilter, CardAuctionWhereInput>
    bidder?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AuctionBidOrderByWithAggregationInput = {
    id?: SortOrder
    auctionId?: SortOrder
    bidderId?: SortOrder
    bidAmount?: SortOrder
    maxAutoBid?: SortOrderInput | SortOrder
    bidType?: SortOrder
    status?: SortOrder
    isWinning?: SortOrder
    outbidNotified?: SortOrder
    userAgent?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AuctionBidCountOrderByAggregateInput
    _avg?: AuctionBidAvgOrderByAggregateInput
    _max?: AuctionBidMaxOrderByAggregateInput
    _min?: AuctionBidMinOrderByAggregateInput
    _sum?: AuctionBidSumOrderByAggregateInput
  }

  export type AuctionBidScalarWhereWithAggregatesInput = {
    AND?: AuctionBidScalarWhereWithAggregatesInput | AuctionBidScalarWhereWithAggregatesInput[]
    OR?: AuctionBidScalarWhereWithAggregatesInput[]
    NOT?: AuctionBidScalarWhereWithAggregatesInput | AuctionBidScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuctionBid"> | string
    auctionId?: StringWithAggregatesFilter<"AuctionBid"> | string
    bidderId?: StringWithAggregatesFilter<"AuctionBid"> | string
    bidAmount?: FloatWithAggregatesFilter<"AuctionBid"> | number
    maxAutoBid?: FloatNullableWithAggregatesFilter<"AuctionBid"> | number | null
    bidType?: EnumBidTypeWithAggregatesFilter<"AuctionBid"> | $Enums.BidType
    status?: EnumAuctionBidStatusWithAggregatesFilter<"AuctionBid"> | $Enums.AuctionBidStatus
    isWinning?: BoolWithAggregatesFilter<"AuctionBid"> | boolean
    outbidNotified?: BoolWithAggregatesFilter<"AuctionBid"> | boolean
    userAgent?: StringNullableWithAggregatesFilter<"AuctionBid"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"AuctionBid"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuctionBid"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AuctionBid"> | Date | string
  }

  export type AuctionWatcherWhereInput = {
    AND?: AuctionWatcherWhereInput | AuctionWatcherWhereInput[]
    OR?: AuctionWatcherWhereInput[]
    NOT?: AuctionWatcherWhereInput | AuctionWatcherWhereInput[]
    id?: StringFilter<"AuctionWatcher"> | string
    auctionId?: StringFilter<"AuctionWatcher"> | string
    userId?: StringFilter<"AuctionWatcher"> | string
    bidNotifications?: BoolFilter<"AuctionWatcher"> | boolean
    endingNotifications?: BoolFilter<"AuctionWatcher"> | boolean
    priceAlerts?: BoolFilter<"AuctionWatcher"> | boolean
    alertThreshold?: FloatNullableFilter<"AuctionWatcher"> | number | null
    createdAt?: DateTimeFilter<"AuctionWatcher"> | Date | string
    updatedAt?: DateTimeFilter<"AuctionWatcher"> | Date | string
    auction?: XOR<CardAuctionScalarRelationFilter, CardAuctionWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AuctionWatcherOrderByWithRelationInput = {
    id?: SortOrder
    auctionId?: SortOrder
    userId?: SortOrder
    bidNotifications?: SortOrder
    endingNotifications?: SortOrder
    priceAlerts?: SortOrder
    alertThreshold?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    auction?: CardAuctionOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type AuctionWatcherWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    auctionId_userId?: AuctionWatcherAuctionIdUserIdCompoundUniqueInput
    AND?: AuctionWatcherWhereInput | AuctionWatcherWhereInput[]
    OR?: AuctionWatcherWhereInput[]
    NOT?: AuctionWatcherWhereInput | AuctionWatcherWhereInput[]
    auctionId?: StringFilter<"AuctionWatcher"> | string
    userId?: StringFilter<"AuctionWatcher"> | string
    bidNotifications?: BoolFilter<"AuctionWatcher"> | boolean
    endingNotifications?: BoolFilter<"AuctionWatcher"> | boolean
    priceAlerts?: BoolFilter<"AuctionWatcher"> | boolean
    alertThreshold?: FloatNullableFilter<"AuctionWatcher"> | number | null
    createdAt?: DateTimeFilter<"AuctionWatcher"> | Date | string
    updatedAt?: DateTimeFilter<"AuctionWatcher"> | Date | string
    auction?: XOR<CardAuctionScalarRelationFilter, CardAuctionWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "auctionId_userId">

  export type AuctionWatcherOrderByWithAggregationInput = {
    id?: SortOrder
    auctionId?: SortOrder
    userId?: SortOrder
    bidNotifications?: SortOrder
    endingNotifications?: SortOrder
    priceAlerts?: SortOrder
    alertThreshold?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AuctionWatcherCountOrderByAggregateInput
    _avg?: AuctionWatcherAvgOrderByAggregateInput
    _max?: AuctionWatcherMaxOrderByAggregateInput
    _min?: AuctionWatcherMinOrderByAggregateInput
    _sum?: AuctionWatcherSumOrderByAggregateInput
  }

  export type AuctionWatcherScalarWhereWithAggregatesInput = {
    AND?: AuctionWatcherScalarWhereWithAggregatesInput | AuctionWatcherScalarWhereWithAggregatesInput[]
    OR?: AuctionWatcherScalarWhereWithAggregatesInput[]
    NOT?: AuctionWatcherScalarWhereWithAggregatesInput | AuctionWatcherScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuctionWatcher"> | string
    auctionId?: StringWithAggregatesFilter<"AuctionWatcher"> | string
    userId?: StringWithAggregatesFilter<"AuctionWatcher"> | string
    bidNotifications?: BoolWithAggregatesFilter<"AuctionWatcher"> | boolean
    endingNotifications?: BoolWithAggregatesFilter<"AuctionWatcher"> | boolean
    priceAlerts?: BoolWithAggregatesFilter<"AuctionWatcher"> | boolean
    alertThreshold?: FloatNullableWithAggregatesFilter<"AuctionWatcher"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"AuctionWatcher"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AuctionWatcher"> | Date | string
  }

  export type AuctionHistoryWhereInput = {
    AND?: AuctionHistoryWhereInput | AuctionHistoryWhereInput[]
    OR?: AuctionHistoryWhereInput[]
    NOT?: AuctionHistoryWhereInput | AuctionHistoryWhereInput[]
    id?: StringFilter<"AuctionHistory"> | string
    cardId?: StringFilter<"AuctionHistory"> | string
    auctionId?: StringNullableFilter<"AuctionHistory"> | string | null
    salePrice?: FloatFilter<"AuctionHistory"> | number
    sellerId?: StringFilter<"AuctionHistory"> | string
    buyerId?: StringFilter<"AuctionHistory"> | string
    saleType?: EnumSaleTypeFilter<"AuctionHistory"> | $Enums.SaleType
    marketTrends?: JsonNullableFilter<"AuctionHistory">
    priceHistory?: JsonNullableFilter<"AuctionHistory">
    daysSinceListing?: IntNullableFilter<"AuctionHistory"> | number | null
    numberOfBids?: IntNullableFilter<"AuctionHistory"> | number | null
    highestBid?: FloatNullableFilter<"AuctionHistory"> | number | null
    saleDate?: DateTimeFilter<"AuctionHistory"> | Date | string
    createdAt?: DateTimeFilter<"AuctionHistory"> | Date | string
    card?: XOR<CardScalarRelationFilter, CardWhereInput>
    auction?: XOR<CardAuctionNullableScalarRelationFilter, CardAuctionWhereInput> | null
  }

  export type AuctionHistoryOrderByWithRelationInput = {
    id?: SortOrder
    cardId?: SortOrder
    auctionId?: SortOrderInput | SortOrder
    salePrice?: SortOrder
    sellerId?: SortOrder
    buyerId?: SortOrder
    saleType?: SortOrder
    marketTrends?: SortOrderInput | SortOrder
    priceHistory?: SortOrderInput | SortOrder
    daysSinceListing?: SortOrderInput | SortOrder
    numberOfBids?: SortOrderInput | SortOrder
    highestBid?: SortOrderInput | SortOrder
    saleDate?: SortOrder
    createdAt?: SortOrder
    card?: CardOrderByWithRelationInput
    auction?: CardAuctionOrderByWithRelationInput
  }

  export type AuctionHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuctionHistoryWhereInput | AuctionHistoryWhereInput[]
    OR?: AuctionHistoryWhereInput[]
    NOT?: AuctionHistoryWhereInput | AuctionHistoryWhereInput[]
    cardId?: StringFilter<"AuctionHistory"> | string
    auctionId?: StringNullableFilter<"AuctionHistory"> | string | null
    salePrice?: FloatFilter<"AuctionHistory"> | number
    sellerId?: StringFilter<"AuctionHistory"> | string
    buyerId?: StringFilter<"AuctionHistory"> | string
    saleType?: EnumSaleTypeFilter<"AuctionHistory"> | $Enums.SaleType
    marketTrends?: JsonNullableFilter<"AuctionHistory">
    priceHistory?: JsonNullableFilter<"AuctionHistory">
    daysSinceListing?: IntNullableFilter<"AuctionHistory"> | number | null
    numberOfBids?: IntNullableFilter<"AuctionHistory"> | number | null
    highestBid?: FloatNullableFilter<"AuctionHistory"> | number | null
    saleDate?: DateTimeFilter<"AuctionHistory"> | Date | string
    createdAt?: DateTimeFilter<"AuctionHistory"> | Date | string
    card?: XOR<CardScalarRelationFilter, CardWhereInput>
    auction?: XOR<CardAuctionNullableScalarRelationFilter, CardAuctionWhereInput> | null
  }, "id">

  export type AuctionHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    cardId?: SortOrder
    auctionId?: SortOrderInput | SortOrder
    salePrice?: SortOrder
    sellerId?: SortOrder
    buyerId?: SortOrder
    saleType?: SortOrder
    marketTrends?: SortOrderInput | SortOrder
    priceHistory?: SortOrderInput | SortOrder
    daysSinceListing?: SortOrderInput | SortOrder
    numberOfBids?: SortOrderInput | SortOrder
    highestBid?: SortOrderInput | SortOrder
    saleDate?: SortOrder
    createdAt?: SortOrder
    _count?: AuctionHistoryCountOrderByAggregateInput
    _avg?: AuctionHistoryAvgOrderByAggregateInput
    _max?: AuctionHistoryMaxOrderByAggregateInput
    _min?: AuctionHistoryMinOrderByAggregateInput
    _sum?: AuctionHistorySumOrderByAggregateInput
  }

  export type AuctionHistoryScalarWhereWithAggregatesInput = {
    AND?: AuctionHistoryScalarWhereWithAggregatesInput | AuctionHistoryScalarWhereWithAggregatesInput[]
    OR?: AuctionHistoryScalarWhereWithAggregatesInput[]
    NOT?: AuctionHistoryScalarWhereWithAggregatesInput | AuctionHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuctionHistory"> | string
    cardId?: StringWithAggregatesFilter<"AuctionHistory"> | string
    auctionId?: StringNullableWithAggregatesFilter<"AuctionHistory"> | string | null
    salePrice?: FloatWithAggregatesFilter<"AuctionHistory"> | number
    sellerId?: StringWithAggregatesFilter<"AuctionHistory"> | string
    buyerId?: StringWithAggregatesFilter<"AuctionHistory"> | string
    saleType?: EnumSaleTypeWithAggregatesFilter<"AuctionHistory"> | $Enums.SaleType
    marketTrends?: JsonNullableWithAggregatesFilter<"AuctionHistory">
    priceHistory?: JsonNullableWithAggregatesFilter<"AuctionHistory">
    daysSinceListing?: IntNullableWithAggregatesFilter<"AuctionHistory"> | number | null
    numberOfBids?: IntNullableWithAggregatesFilter<"AuctionHistory"> | number | null
    highestBid?: FloatNullableWithAggregatesFilter<"AuctionHistory"> | number | null
    saleDate?: DateTimeWithAggregatesFilter<"AuctionHistory"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"AuctionHistory"> | Date | string
  }

  export type MABattleWhereInput = {
    AND?: MABattleWhereInput | MABattleWhereInput[]
    OR?: MABattleWhereInput[]
    NOT?: MABattleWhereInput | MABattleWhereInput[]
    id?: StringFilter<"MABattle"> | string
    initiatorCardId?: StringFilter<"MABattle"> | string
    targetCardId?: StringFilter<"MABattle"> | string
    initiatorUserId?: StringFilter<"MABattle"> | string
    targetUserId?: StringNullableFilter<"MABattle"> | string | null
    battleType?: EnumBattleTypeFilter<"MABattle"> | $Enums.BattleType
    title?: StringFilter<"MABattle"> | string
    description?: StringFilter<"MABattle"> | string
    stakes?: FloatFilter<"MABattle"> | number
    timeline?: DateTimeFilter<"MABattle"> | Date | string
    votingPeriod?: DateTimeFilter<"MABattle"> | Date | string
    status?: EnumBattleStatusFilter<"MABattle"> | $Enums.BattleStatus
    resolved?: BoolFilter<"MABattle"> | boolean
    viewCount?: IntFilter<"MABattle"> | number
    participantCount?: IntFilter<"MABattle"> | number
    createdAt?: DateTimeFilter<"MABattle"> | Date | string
    updatedAt?: DateTimeFilter<"MABattle"> | Date | string
    initiatorCard?: XOR<CardScalarRelationFilter, CardWhereInput>
    targetCard?: XOR<CardScalarRelationFilter, CardWhereInput>
    initiator?: XOR<UserScalarRelationFilter, UserWhereInput>
    target?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    winner?: XOR<BattleOutcomeNullableScalarRelationFilter, BattleOutcomeWhereInput> | null
    proposals?: BattleProposalListRelationFilter
    votes?: BattleVotingListRelationFilter
    outcomes?: BattleOutcomeListRelationFilter
  }

  export type MABattleOrderByWithRelationInput = {
    id?: SortOrder
    initiatorCardId?: SortOrder
    targetCardId?: SortOrder
    initiatorUserId?: SortOrder
    targetUserId?: SortOrderInput | SortOrder
    battleType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    stakes?: SortOrder
    timeline?: SortOrder
    votingPeriod?: SortOrder
    status?: SortOrder
    resolved?: SortOrder
    viewCount?: SortOrder
    participantCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    initiatorCard?: CardOrderByWithRelationInput
    targetCard?: CardOrderByWithRelationInput
    initiator?: UserOrderByWithRelationInput
    target?: UserOrderByWithRelationInput
    winner?: BattleOutcomeOrderByWithRelationInput
    proposals?: BattleProposalOrderByRelationAggregateInput
    votes?: BattleVotingOrderByRelationAggregateInput
    outcomes?: BattleOutcomeOrderByRelationAggregateInput
  }

  export type MABattleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MABattleWhereInput | MABattleWhereInput[]
    OR?: MABattleWhereInput[]
    NOT?: MABattleWhereInput | MABattleWhereInput[]
    initiatorCardId?: StringFilter<"MABattle"> | string
    targetCardId?: StringFilter<"MABattle"> | string
    initiatorUserId?: StringFilter<"MABattle"> | string
    targetUserId?: StringNullableFilter<"MABattle"> | string | null
    battleType?: EnumBattleTypeFilter<"MABattle"> | $Enums.BattleType
    title?: StringFilter<"MABattle"> | string
    description?: StringFilter<"MABattle"> | string
    stakes?: FloatFilter<"MABattle"> | number
    timeline?: DateTimeFilter<"MABattle"> | Date | string
    votingPeriod?: DateTimeFilter<"MABattle"> | Date | string
    status?: EnumBattleStatusFilter<"MABattle"> | $Enums.BattleStatus
    resolved?: BoolFilter<"MABattle"> | boolean
    viewCount?: IntFilter<"MABattle"> | number
    participantCount?: IntFilter<"MABattle"> | number
    createdAt?: DateTimeFilter<"MABattle"> | Date | string
    updatedAt?: DateTimeFilter<"MABattle"> | Date | string
    initiatorCard?: XOR<CardScalarRelationFilter, CardWhereInput>
    targetCard?: XOR<CardScalarRelationFilter, CardWhereInput>
    initiator?: XOR<UserScalarRelationFilter, UserWhereInput>
    target?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    winner?: XOR<BattleOutcomeNullableScalarRelationFilter, BattleOutcomeWhereInput> | null
    proposals?: BattleProposalListRelationFilter
    votes?: BattleVotingListRelationFilter
    outcomes?: BattleOutcomeListRelationFilter
  }, "id">

  export type MABattleOrderByWithAggregationInput = {
    id?: SortOrder
    initiatorCardId?: SortOrder
    targetCardId?: SortOrder
    initiatorUserId?: SortOrder
    targetUserId?: SortOrderInput | SortOrder
    battleType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    stakes?: SortOrder
    timeline?: SortOrder
    votingPeriod?: SortOrder
    status?: SortOrder
    resolved?: SortOrder
    viewCount?: SortOrder
    participantCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MABattleCountOrderByAggregateInput
    _avg?: MABattleAvgOrderByAggregateInput
    _max?: MABattleMaxOrderByAggregateInput
    _min?: MABattleMinOrderByAggregateInput
    _sum?: MABattleSumOrderByAggregateInput
  }

  export type MABattleScalarWhereWithAggregatesInput = {
    AND?: MABattleScalarWhereWithAggregatesInput | MABattleScalarWhereWithAggregatesInput[]
    OR?: MABattleScalarWhereWithAggregatesInput[]
    NOT?: MABattleScalarWhereWithAggregatesInput | MABattleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MABattle"> | string
    initiatorCardId?: StringWithAggregatesFilter<"MABattle"> | string
    targetCardId?: StringWithAggregatesFilter<"MABattle"> | string
    initiatorUserId?: StringWithAggregatesFilter<"MABattle"> | string
    targetUserId?: StringNullableWithAggregatesFilter<"MABattle"> | string | null
    battleType?: EnumBattleTypeWithAggregatesFilter<"MABattle"> | $Enums.BattleType
    title?: StringWithAggregatesFilter<"MABattle"> | string
    description?: StringWithAggregatesFilter<"MABattle"> | string
    stakes?: FloatWithAggregatesFilter<"MABattle"> | number
    timeline?: DateTimeWithAggregatesFilter<"MABattle"> | Date | string
    votingPeriod?: DateTimeWithAggregatesFilter<"MABattle"> | Date | string
    status?: EnumBattleStatusWithAggregatesFilter<"MABattle"> | $Enums.BattleStatus
    resolved?: BoolWithAggregatesFilter<"MABattle"> | boolean
    viewCount?: IntWithAggregatesFilter<"MABattle"> | number
    participantCount?: IntWithAggregatesFilter<"MABattle"> | number
    createdAt?: DateTimeWithAggregatesFilter<"MABattle"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MABattle"> | Date | string
  }

  export type BattleProposalWhereInput = {
    AND?: BattleProposalWhereInput | BattleProposalWhereInput[]
    OR?: BattleProposalWhereInput[]
    NOT?: BattleProposalWhereInput | BattleProposalWhereInput[]
    id?: StringFilter<"BattleProposal"> | string
    battleId?: StringFilter<"BattleProposal"> | string
    proposerId?: StringFilter<"BattleProposal"> | string
    proposalType?: EnumProposalTypeFilter<"BattleProposal"> | $Enums.ProposalType
    title?: StringFilter<"BattleProposal"> | string
    description?: StringFilter<"BattleProposal"> | string
    terms?: JsonFilter<"BattleProposal">
    valuation?: FloatFilter<"BattleProposal"> | number
    paymentStructure?: JsonFilter<"BattleProposal">
    timeline?: JsonFilter<"BattleProposal">
    synergies?: JsonFilter<"BattleProposal">
    conditions?: JsonFilter<"BattleProposal">
    contingencies?: JsonFilter<"BattleProposal">
    status?: EnumProposalStatusFilter<"BattleProposal"> | $Enums.ProposalStatus
    createdAt?: DateTimeFilter<"BattleProposal"> | Date | string
    updatedAt?: DateTimeFilter<"BattleProposal"> | Date | string
    battle?: XOR<MABattleScalarRelationFilter, MABattleWhereInput>
    proposer?: XOR<UserScalarRelationFilter, UserWhereInput>
    votes?: BattleVotingListRelationFilter
  }

  export type BattleProposalOrderByWithRelationInput = {
    id?: SortOrder
    battleId?: SortOrder
    proposerId?: SortOrder
    proposalType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    terms?: SortOrder
    valuation?: SortOrder
    paymentStructure?: SortOrder
    timeline?: SortOrder
    synergies?: SortOrder
    conditions?: SortOrder
    contingencies?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    battle?: MABattleOrderByWithRelationInput
    proposer?: UserOrderByWithRelationInput
    votes?: BattleVotingOrderByRelationAggregateInput
  }

  export type BattleProposalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BattleProposalWhereInput | BattleProposalWhereInput[]
    OR?: BattleProposalWhereInput[]
    NOT?: BattleProposalWhereInput | BattleProposalWhereInput[]
    battleId?: StringFilter<"BattleProposal"> | string
    proposerId?: StringFilter<"BattleProposal"> | string
    proposalType?: EnumProposalTypeFilter<"BattleProposal"> | $Enums.ProposalType
    title?: StringFilter<"BattleProposal"> | string
    description?: StringFilter<"BattleProposal"> | string
    terms?: JsonFilter<"BattleProposal">
    valuation?: FloatFilter<"BattleProposal"> | number
    paymentStructure?: JsonFilter<"BattleProposal">
    timeline?: JsonFilter<"BattleProposal">
    synergies?: JsonFilter<"BattleProposal">
    conditions?: JsonFilter<"BattleProposal">
    contingencies?: JsonFilter<"BattleProposal">
    status?: EnumProposalStatusFilter<"BattleProposal"> | $Enums.ProposalStatus
    createdAt?: DateTimeFilter<"BattleProposal"> | Date | string
    updatedAt?: DateTimeFilter<"BattleProposal"> | Date | string
    battle?: XOR<MABattleScalarRelationFilter, MABattleWhereInput>
    proposer?: XOR<UserScalarRelationFilter, UserWhereInput>
    votes?: BattleVotingListRelationFilter
  }, "id">

  export type BattleProposalOrderByWithAggregationInput = {
    id?: SortOrder
    battleId?: SortOrder
    proposerId?: SortOrder
    proposalType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    terms?: SortOrder
    valuation?: SortOrder
    paymentStructure?: SortOrder
    timeline?: SortOrder
    synergies?: SortOrder
    conditions?: SortOrder
    contingencies?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BattleProposalCountOrderByAggregateInput
    _avg?: BattleProposalAvgOrderByAggregateInput
    _max?: BattleProposalMaxOrderByAggregateInput
    _min?: BattleProposalMinOrderByAggregateInput
    _sum?: BattleProposalSumOrderByAggregateInput
  }

  export type BattleProposalScalarWhereWithAggregatesInput = {
    AND?: BattleProposalScalarWhereWithAggregatesInput | BattleProposalScalarWhereWithAggregatesInput[]
    OR?: BattleProposalScalarWhereWithAggregatesInput[]
    NOT?: BattleProposalScalarWhereWithAggregatesInput | BattleProposalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BattleProposal"> | string
    battleId?: StringWithAggregatesFilter<"BattleProposal"> | string
    proposerId?: StringWithAggregatesFilter<"BattleProposal"> | string
    proposalType?: EnumProposalTypeWithAggregatesFilter<"BattleProposal"> | $Enums.ProposalType
    title?: StringWithAggregatesFilter<"BattleProposal"> | string
    description?: StringWithAggregatesFilter<"BattleProposal"> | string
    terms?: JsonWithAggregatesFilter<"BattleProposal">
    valuation?: FloatWithAggregatesFilter<"BattleProposal"> | number
    paymentStructure?: JsonWithAggregatesFilter<"BattleProposal">
    timeline?: JsonWithAggregatesFilter<"BattleProposal">
    synergies?: JsonWithAggregatesFilter<"BattleProposal">
    conditions?: JsonWithAggregatesFilter<"BattleProposal">
    contingencies?: JsonWithAggregatesFilter<"BattleProposal">
    status?: EnumProposalStatusWithAggregatesFilter<"BattleProposal"> | $Enums.ProposalStatus
    createdAt?: DateTimeWithAggregatesFilter<"BattleProposal"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BattleProposal"> | Date | string
  }

  export type BattleVotingWhereInput = {
    AND?: BattleVotingWhereInput | BattleVotingWhereInput[]
    OR?: BattleVotingWhereInput[]
    NOT?: BattleVotingWhereInput | BattleVotingWhereInput[]
    id?: StringFilter<"BattleVoting"> | string
    battleId?: StringFilter<"BattleVoting"> | string
    proposalId?: StringNullableFilter<"BattleVoting"> | string | null
    voterId?: StringFilter<"BattleVoting"> | string
    vote?: EnumVoteDirectionFilter<"BattleVoting"> | $Enums.VoteDirection
    voteWeight?: FloatFilter<"BattleVoting"> | number
    reasoning?: StringNullableFilter<"BattleVoting"> | string | null
    confidence?: FloatNullableFilter<"BattleVoting"> | number | null
    eceStaked?: FloatNullableFilter<"BattleVoting"> | number | null
    expertRating?: FloatNullableFilter<"BattleVoting"> | number | null
    portfolioValue?: FloatNullableFilter<"BattleVoting"> | number | null
    createdAt?: DateTimeFilter<"BattleVoting"> | Date | string
    updatedAt?: DateTimeFilter<"BattleVoting"> | Date | string
    battle?: XOR<MABattleScalarRelationFilter, MABattleWhereInput>
    proposal?: XOR<BattleProposalNullableScalarRelationFilter, BattleProposalWhereInput> | null
    voter?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type BattleVotingOrderByWithRelationInput = {
    id?: SortOrder
    battleId?: SortOrder
    proposalId?: SortOrderInput | SortOrder
    voterId?: SortOrder
    vote?: SortOrder
    voteWeight?: SortOrder
    reasoning?: SortOrderInput | SortOrder
    confidence?: SortOrderInput | SortOrder
    eceStaked?: SortOrderInput | SortOrder
    expertRating?: SortOrderInput | SortOrder
    portfolioValue?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    battle?: MABattleOrderByWithRelationInput
    proposal?: BattleProposalOrderByWithRelationInput
    voter?: UserOrderByWithRelationInput
  }

  export type BattleVotingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    battleId_proposalId_voterId?: BattleVotingBattleIdProposalIdVoterIdCompoundUniqueInput
    AND?: BattleVotingWhereInput | BattleVotingWhereInput[]
    OR?: BattleVotingWhereInput[]
    NOT?: BattleVotingWhereInput | BattleVotingWhereInput[]
    battleId?: StringFilter<"BattleVoting"> | string
    proposalId?: StringNullableFilter<"BattleVoting"> | string | null
    voterId?: StringFilter<"BattleVoting"> | string
    vote?: EnumVoteDirectionFilter<"BattleVoting"> | $Enums.VoteDirection
    voteWeight?: FloatFilter<"BattleVoting"> | number
    reasoning?: StringNullableFilter<"BattleVoting"> | string | null
    confidence?: FloatNullableFilter<"BattleVoting"> | number | null
    eceStaked?: FloatNullableFilter<"BattleVoting"> | number | null
    expertRating?: FloatNullableFilter<"BattleVoting"> | number | null
    portfolioValue?: FloatNullableFilter<"BattleVoting"> | number | null
    createdAt?: DateTimeFilter<"BattleVoting"> | Date | string
    updatedAt?: DateTimeFilter<"BattleVoting"> | Date | string
    battle?: XOR<MABattleScalarRelationFilter, MABattleWhereInput>
    proposal?: XOR<BattleProposalNullableScalarRelationFilter, BattleProposalWhereInput> | null
    voter?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "battleId_proposalId_voterId">

  export type BattleVotingOrderByWithAggregationInput = {
    id?: SortOrder
    battleId?: SortOrder
    proposalId?: SortOrderInput | SortOrder
    voterId?: SortOrder
    vote?: SortOrder
    voteWeight?: SortOrder
    reasoning?: SortOrderInput | SortOrder
    confidence?: SortOrderInput | SortOrder
    eceStaked?: SortOrderInput | SortOrder
    expertRating?: SortOrderInput | SortOrder
    portfolioValue?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BattleVotingCountOrderByAggregateInput
    _avg?: BattleVotingAvgOrderByAggregateInput
    _max?: BattleVotingMaxOrderByAggregateInput
    _min?: BattleVotingMinOrderByAggregateInput
    _sum?: BattleVotingSumOrderByAggregateInput
  }

  export type BattleVotingScalarWhereWithAggregatesInput = {
    AND?: BattleVotingScalarWhereWithAggregatesInput | BattleVotingScalarWhereWithAggregatesInput[]
    OR?: BattleVotingScalarWhereWithAggregatesInput[]
    NOT?: BattleVotingScalarWhereWithAggregatesInput | BattleVotingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BattleVoting"> | string
    battleId?: StringWithAggregatesFilter<"BattleVoting"> | string
    proposalId?: StringNullableWithAggregatesFilter<"BattleVoting"> | string | null
    voterId?: StringWithAggregatesFilter<"BattleVoting"> | string
    vote?: EnumVoteDirectionWithAggregatesFilter<"BattleVoting"> | $Enums.VoteDirection
    voteWeight?: FloatWithAggregatesFilter<"BattleVoting"> | number
    reasoning?: StringNullableWithAggregatesFilter<"BattleVoting"> | string | null
    confidence?: FloatNullableWithAggregatesFilter<"BattleVoting"> | number | null
    eceStaked?: FloatNullableWithAggregatesFilter<"BattleVoting"> | number | null
    expertRating?: FloatNullableWithAggregatesFilter<"BattleVoting"> | number | null
    portfolioValue?: FloatNullableWithAggregatesFilter<"BattleVoting"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"BattleVoting"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BattleVoting"> | Date | string
  }

  export type BattleOutcomeWhereInput = {
    AND?: BattleOutcomeWhereInput | BattleOutcomeWhereInput[]
    OR?: BattleOutcomeWhereInput[]
    NOT?: BattleOutcomeWhereInput | BattleOutcomeWhereInput[]
    id?: StringFilter<"BattleOutcome"> | string
    battleId?: StringFilter<"BattleOutcome"> | string
    winningBattleId?: StringNullableFilter<"BattleOutcome"> | string | null
    winner?: EnumBattleWinnerFilter<"BattleOutcome"> | $Enums.BattleWinner
    winningProposalId?: StringNullableFilter<"BattleOutcome"> | string | null
    finalTerms?: JsonFilter<"BattleOutcome">
    finalValuation?: FloatFilter<"BattleOutcome"> | number
    implementation?: JsonFilter<"BattleOutcome">
    stakeholdersPayouts?: JsonFilter<"BattleOutcome">
    tokenRewards?: JsonFilter<"BattleOutcome">
    completionDate?: DateTimeNullableFilter<"BattleOutcome"> | Date | string | null
    realWorldImpact?: StringNullableFilter<"BattleOutcome"> | string | null
    createdAt?: DateTimeFilter<"BattleOutcome"> | Date | string
    updatedAt?: DateTimeFilter<"BattleOutcome"> | Date | string
    battle?: XOR<MABattleScalarRelationFilter, MABattleWhereInput>
    winningBattle?: XOR<MABattleNullableScalarRelationFilter, MABattleWhereInput> | null
  }

  export type BattleOutcomeOrderByWithRelationInput = {
    id?: SortOrder
    battleId?: SortOrder
    winningBattleId?: SortOrderInput | SortOrder
    winner?: SortOrder
    winningProposalId?: SortOrderInput | SortOrder
    finalTerms?: SortOrder
    finalValuation?: SortOrder
    implementation?: SortOrder
    stakeholdersPayouts?: SortOrder
    tokenRewards?: SortOrder
    completionDate?: SortOrderInput | SortOrder
    realWorldImpact?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    battle?: MABattleOrderByWithRelationInput
    winningBattle?: MABattleOrderByWithRelationInput
  }

  export type BattleOutcomeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    battleId?: string
    winningBattleId?: string
    AND?: BattleOutcomeWhereInput | BattleOutcomeWhereInput[]
    OR?: BattleOutcomeWhereInput[]
    NOT?: BattleOutcomeWhereInput | BattleOutcomeWhereInput[]
    winner?: EnumBattleWinnerFilter<"BattleOutcome"> | $Enums.BattleWinner
    winningProposalId?: StringNullableFilter<"BattleOutcome"> | string | null
    finalTerms?: JsonFilter<"BattleOutcome">
    finalValuation?: FloatFilter<"BattleOutcome"> | number
    implementation?: JsonFilter<"BattleOutcome">
    stakeholdersPayouts?: JsonFilter<"BattleOutcome">
    tokenRewards?: JsonFilter<"BattleOutcome">
    completionDate?: DateTimeNullableFilter<"BattleOutcome"> | Date | string | null
    realWorldImpact?: StringNullableFilter<"BattleOutcome"> | string | null
    createdAt?: DateTimeFilter<"BattleOutcome"> | Date | string
    updatedAt?: DateTimeFilter<"BattleOutcome"> | Date | string
    battle?: XOR<MABattleScalarRelationFilter, MABattleWhereInput>
    winningBattle?: XOR<MABattleNullableScalarRelationFilter, MABattleWhereInput> | null
  }, "id" | "battleId" | "winningBattleId">

  export type BattleOutcomeOrderByWithAggregationInput = {
    id?: SortOrder
    battleId?: SortOrder
    winningBattleId?: SortOrderInput | SortOrder
    winner?: SortOrder
    winningProposalId?: SortOrderInput | SortOrder
    finalTerms?: SortOrder
    finalValuation?: SortOrder
    implementation?: SortOrder
    stakeholdersPayouts?: SortOrder
    tokenRewards?: SortOrder
    completionDate?: SortOrderInput | SortOrder
    realWorldImpact?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BattleOutcomeCountOrderByAggregateInput
    _avg?: BattleOutcomeAvgOrderByAggregateInput
    _max?: BattleOutcomeMaxOrderByAggregateInput
    _min?: BattleOutcomeMinOrderByAggregateInput
    _sum?: BattleOutcomeSumOrderByAggregateInput
  }

  export type BattleOutcomeScalarWhereWithAggregatesInput = {
    AND?: BattleOutcomeScalarWhereWithAggregatesInput | BattleOutcomeScalarWhereWithAggregatesInput[]
    OR?: BattleOutcomeScalarWhereWithAggregatesInput[]
    NOT?: BattleOutcomeScalarWhereWithAggregatesInput | BattleOutcomeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BattleOutcome"> | string
    battleId?: StringWithAggregatesFilter<"BattleOutcome"> | string
    winningBattleId?: StringNullableWithAggregatesFilter<"BattleOutcome"> | string | null
    winner?: EnumBattleWinnerWithAggregatesFilter<"BattleOutcome"> | $Enums.BattleWinner
    winningProposalId?: StringNullableWithAggregatesFilter<"BattleOutcome"> | string | null
    finalTerms?: JsonWithAggregatesFilter<"BattleOutcome">
    finalValuation?: FloatWithAggregatesFilter<"BattleOutcome"> | number
    implementation?: JsonWithAggregatesFilter<"BattleOutcome">
    stakeholdersPayouts?: JsonWithAggregatesFilter<"BattleOutcome">
    tokenRewards?: JsonWithAggregatesFilter<"BattleOutcome">
    completionDate?: DateTimeNullableWithAggregatesFilter<"BattleOutcome"> | Date | string | null
    realWorldImpact?: StringNullableWithAggregatesFilter<"BattleOutcome"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BattleOutcome"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BattleOutcome"> | Date | string
  }

  export type StakingPoolWhereInput = {
    AND?: StakingPoolWhereInput | StakingPoolWhereInput[]
    OR?: StakingPoolWhereInput[]
    NOT?: StakingPoolWhereInput | StakingPoolWhereInput[]
    id?: StringFilter<"StakingPool"> | string
    name?: StringFilter<"StakingPool"> | string
    description?: StringNullableFilter<"StakingPool"> | string | null
    poolType?: EnumStakingPoolTypeFilter<"StakingPool"> | $Enums.StakingPoolType
    totalStaked?: FloatFilter<"StakingPool"> | number
    totalRewards?: FloatFilter<"StakingPool"> | number
    apy?: FloatFilter<"StakingPool"> | number
    minStakeAmount?: FloatFilter<"StakingPool"> | number
    lockupPeriod?: IntFilter<"StakingPool"> | number
    isActive?: BoolFilter<"StakingPool"> | boolean
    createdAt?: DateTimeFilter<"StakingPool"> | Date | string
    updatedAt?: DateTimeFilter<"StakingPool"> | Date | string
    stakes?: StakingPositionListRelationFilter
    rewards?: StakingRewardListRelationFilter
  }

  export type StakingPoolOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    poolType?: SortOrder
    totalStaked?: SortOrder
    totalRewards?: SortOrder
    apy?: SortOrder
    minStakeAmount?: SortOrder
    lockupPeriod?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    stakes?: StakingPositionOrderByRelationAggregateInput
    rewards?: StakingRewardOrderByRelationAggregateInput
  }

  export type StakingPoolWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StakingPoolWhereInput | StakingPoolWhereInput[]
    OR?: StakingPoolWhereInput[]
    NOT?: StakingPoolWhereInput | StakingPoolWhereInput[]
    name?: StringFilter<"StakingPool"> | string
    description?: StringNullableFilter<"StakingPool"> | string | null
    poolType?: EnumStakingPoolTypeFilter<"StakingPool"> | $Enums.StakingPoolType
    totalStaked?: FloatFilter<"StakingPool"> | number
    totalRewards?: FloatFilter<"StakingPool"> | number
    apy?: FloatFilter<"StakingPool"> | number
    minStakeAmount?: FloatFilter<"StakingPool"> | number
    lockupPeriod?: IntFilter<"StakingPool"> | number
    isActive?: BoolFilter<"StakingPool"> | boolean
    createdAt?: DateTimeFilter<"StakingPool"> | Date | string
    updatedAt?: DateTimeFilter<"StakingPool"> | Date | string
    stakes?: StakingPositionListRelationFilter
    rewards?: StakingRewardListRelationFilter
  }, "id">

  export type StakingPoolOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    poolType?: SortOrder
    totalStaked?: SortOrder
    totalRewards?: SortOrder
    apy?: SortOrder
    minStakeAmount?: SortOrder
    lockupPeriod?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StakingPoolCountOrderByAggregateInput
    _avg?: StakingPoolAvgOrderByAggregateInput
    _max?: StakingPoolMaxOrderByAggregateInput
    _min?: StakingPoolMinOrderByAggregateInput
    _sum?: StakingPoolSumOrderByAggregateInput
  }

  export type StakingPoolScalarWhereWithAggregatesInput = {
    AND?: StakingPoolScalarWhereWithAggregatesInput | StakingPoolScalarWhereWithAggregatesInput[]
    OR?: StakingPoolScalarWhereWithAggregatesInput[]
    NOT?: StakingPoolScalarWhereWithAggregatesInput | StakingPoolScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StakingPool"> | string
    name?: StringWithAggregatesFilter<"StakingPool"> | string
    description?: StringNullableWithAggregatesFilter<"StakingPool"> | string | null
    poolType?: EnumStakingPoolTypeWithAggregatesFilter<"StakingPool"> | $Enums.StakingPoolType
    totalStaked?: FloatWithAggregatesFilter<"StakingPool"> | number
    totalRewards?: FloatWithAggregatesFilter<"StakingPool"> | number
    apy?: FloatWithAggregatesFilter<"StakingPool"> | number
    minStakeAmount?: FloatWithAggregatesFilter<"StakingPool"> | number
    lockupPeriod?: IntWithAggregatesFilter<"StakingPool"> | number
    isActive?: BoolWithAggregatesFilter<"StakingPool"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"StakingPool"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StakingPool"> | Date | string
  }

  export type StakingPositionWhereInput = {
    AND?: StakingPositionWhereInput | StakingPositionWhereInput[]
    OR?: StakingPositionWhereInput[]
    NOT?: StakingPositionWhereInput | StakingPositionWhereInput[]
    id?: StringFilter<"StakingPosition"> | string
    userId?: StringFilter<"StakingPosition"> | string
    poolId?: StringFilter<"StakingPosition"> | string
    amount?: FloatFilter<"StakingPosition"> | number
    stakedAt?: DateTimeFilter<"StakingPosition"> | Date | string
    unstakedAt?: DateTimeNullableFilter<"StakingPosition"> | Date | string | null
    lockupEndsAt?: DateTimeNullableFilter<"StakingPosition"> | Date | string | null
    isActive?: BoolFilter<"StakingPosition"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    pool?: XOR<StakingPoolScalarRelationFilter, StakingPoolWhereInput>
    rewards?: StakingRewardListRelationFilter
  }

  export type StakingPositionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    poolId?: SortOrder
    amount?: SortOrder
    stakedAt?: SortOrder
    unstakedAt?: SortOrderInput | SortOrder
    lockupEndsAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    user?: UserOrderByWithRelationInput
    pool?: StakingPoolOrderByWithRelationInput
    rewards?: StakingRewardOrderByRelationAggregateInput
  }

  export type StakingPositionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StakingPositionWhereInput | StakingPositionWhereInput[]
    OR?: StakingPositionWhereInput[]
    NOT?: StakingPositionWhereInput | StakingPositionWhereInput[]
    userId?: StringFilter<"StakingPosition"> | string
    poolId?: StringFilter<"StakingPosition"> | string
    amount?: FloatFilter<"StakingPosition"> | number
    stakedAt?: DateTimeFilter<"StakingPosition"> | Date | string
    unstakedAt?: DateTimeNullableFilter<"StakingPosition"> | Date | string | null
    lockupEndsAt?: DateTimeNullableFilter<"StakingPosition"> | Date | string | null
    isActive?: BoolFilter<"StakingPosition"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    pool?: XOR<StakingPoolScalarRelationFilter, StakingPoolWhereInput>
    rewards?: StakingRewardListRelationFilter
  }, "id">

  export type StakingPositionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    poolId?: SortOrder
    amount?: SortOrder
    stakedAt?: SortOrder
    unstakedAt?: SortOrderInput | SortOrder
    lockupEndsAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    _count?: StakingPositionCountOrderByAggregateInput
    _avg?: StakingPositionAvgOrderByAggregateInput
    _max?: StakingPositionMaxOrderByAggregateInput
    _min?: StakingPositionMinOrderByAggregateInput
    _sum?: StakingPositionSumOrderByAggregateInput
  }

  export type StakingPositionScalarWhereWithAggregatesInput = {
    AND?: StakingPositionScalarWhereWithAggregatesInput | StakingPositionScalarWhereWithAggregatesInput[]
    OR?: StakingPositionScalarWhereWithAggregatesInput[]
    NOT?: StakingPositionScalarWhereWithAggregatesInput | StakingPositionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StakingPosition"> | string
    userId?: StringWithAggregatesFilter<"StakingPosition"> | string
    poolId?: StringWithAggregatesFilter<"StakingPosition"> | string
    amount?: FloatWithAggregatesFilter<"StakingPosition"> | number
    stakedAt?: DateTimeWithAggregatesFilter<"StakingPosition"> | Date | string
    unstakedAt?: DateTimeNullableWithAggregatesFilter<"StakingPosition"> | Date | string | null
    lockupEndsAt?: DateTimeNullableWithAggregatesFilter<"StakingPosition"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"StakingPosition"> | boolean
  }

  export type StakingRewardWhereInput = {
    AND?: StakingRewardWhereInput | StakingRewardWhereInput[]
    OR?: StakingRewardWhereInput[]
    NOT?: StakingRewardWhereInput | StakingRewardWhereInput[]
    id?: StringFilter<"StakingReward"> | string
    userId?: StringFilter<"StakingReward"> | string
    poolId?: StringFilter<"StakingReward"> | string
    positionId?: StringFilter<"StakingReward"> | string
    amount?: FloatFilter<"StakingReward"> | number
    rewardType?: EnumStakingRewardTypeFilter<"StakingReward"> | $Enums.StakingRewardType
    claimedAt?: DateTimeNullableFilter<"StakingReward"> | Date | string | null
    createdAt?: DateTimeFilter<"StakingReward"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    pool?: XOR<StakingPoolScalarRelationFilter, StakingPoolWhereInput>
    position?: XOR<StakingPositionScalarRelationFilter, StakingPositionWhereInput>
  }

  export type StakingRewardOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    poolId?: SortOrder
    positionId?: SortOrder
    amount?: SortOrder
    rewardType?: SortOrder
    claimedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    pool?: StakingPoolOrderByWithRelationInput
    position?: StakingPositionOrderByWithRelationInput
  }

  export type StakingRewardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StakingRewardWhereInput | StakingRewardWhereInput[]
    OR?: StakingRewardWhereInput[]
    NOT?: StakingRewardWhereInput | StakingRewardWhereInput[]
    userId?: StringFilter<"StakingReward"> | string
    poolId?: StringFilter<"StakingReward"> | string
    positionId?: StringFilter<"StakingReward"> | string
    amount?: FloatFilter<"StakingReward"> | number
    rewardType?: EnumStakingRewardTypeFilter<"StakingReward"> | $Enums.StakingRewardType
    claimedAt?: DateTimeNullableFilter<"StakingReward"> | Date | string | null
    createdAt?: DateTimeFilter<"StakingReward"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    pool?: XOR<StakingPoolScalarRelationFilter, StakingPoolWhereInput>
    position?: XOR<StakingPositionScalarRelationFilter, StakingPositionWhereInput>
  }, "id">

  export type StakingRewardOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    poolId?: SortOrder
    positionId?: SortOrder
    amount?: SortOrder
    rewardType?: SortOrder
    claimedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: StakingRewardCountOrderByAggregateInput
    _avg?: StakingRewardAvgOrderByAggregateInput
    _max?: StakingRewardMaxOrderByAggregateInput
    _min?: StakingRewardMinOrderByAggregateInput
    _sum?: StakingRewardSumOrderByAggregateInput
  }

  export type StakingRewardScalarWhereWithAggregatesInput = {
    AND?: StakingRewardScalarWhereWithAggregatesInput | StakingRewardScalarWhereWithAggregatesInput[]
    OR?: StakingRewardScalarWhereWithAggregatesInput[]
    NOT?: StakingRewardScalarWhereWithAggregatesInput | StakingRewardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StakingReward"> | string
    userId?: StringWithAggregatesFilter<"StakingReward"> | string
    poolId?: StringWithAggregatesFilter<"StakingReward"> | string
    positionId?: StringWithAggregatesFilter<"StakingReward"> | string
    amount?: FloatWithAggregatesFilter<"StakingReward"> | number
    rewardType?: EnumStakingRewardTypeWithAggregatesFilter<"StakingReward"> | $Enums.StakingRewardType
    claimedAt?: DateTimeNullableWithAggregatesFilter<"StakingReward"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"StakingReward"> | Date | string
  }

  export type GovernanceProposalWhereInput = {
    AND?: GovernanceProposalWhereInput | GovernanceProposalWhereInput[]
    OR?: GovernanceProposalWhereInput[]
    NOT?: GovernanceProposalWhereInput | GovernanceProposalWhereInput[]
    id?: StringFilter<"GovernanceProposal"> | string
    title?: StringFilter<"GovernanceProposal"> | string
    description?: StringFilter<"GovernanceProposal"> | string
    proposalType?: EnumProposalTypeFilter<"GovernanceProposal"> | $Enums.ProposalType
    proposerId?: StringFilter<"GovernanceProposal"> | string
    status?: EnumGovernanceStatusFilter<"GovernanceProposal"> | $Enums.GovernanceStatus
    votingStartsAt?: DateTimeFilter<"GovernanceProposal"> | Date | string
    votingEndsAt?: DateTimeFilter<"GovernanceProposal"> | Date | string
    executionDate?: DateTimeNullableFilter<"GovernanceProposal"> | Date | string | null
    minQuorum?: FloatFilter<"GovernanceProposal"> | number
    minApproval?: FloatFilter<"GovernanceProposal"> | number
    totalVotes?: FloatFilter<"GovernanceProposal"> | number
    yesVotes?: FloatFilter<"GovernanceProposal"> | number
    noVotes?: FloatFilter<"GovernanceProposal"> | number
    abstainVotes?: FloatFilter<"GovernanceProposal"> | number
    isExecuted?: BoolFilter<"GovernanceProposal"> | boolean
    createdAt?: DateTimeFilter<"GovernanceProposal"> | Date | string
    updatedAt?: DateTimeFilter<"GovernanceProposal"> | Date | string
    parameters?: JsonNullableFilter<"GovernanceProposal">
    proposer?: XOR<UserScalarRelationFilter, UserWhereInput>
    votes?: GovernanceVoteListRelationFilter
  }

  export type GovernanceProposalOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    proposalType?: SortOrder
    proposerId?: SortOrder
    status?: SortOrder
    votingStartsAt?: SortOrder
    votingEndsAt?: SortOrder
    executionDate?: SortOrderInput | SortOrder
    minQuorum?: SortOrder
    minApproval?: SortOrder
    totalVotes?: SortOrder
    yesVotes?: SortOrder
    noVotes?: SortOrder
    abstainVotes?: SortOrder
    isExecuted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parameters?: SortOrderInput | SortOrder
    proposer?: UserOrderByWithRelationInput
    votes?: GovernanceVoteOrderByRelationAggregateInput
  }

  export type GovernanceProposalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GovernanceProposalWhereInput | GovernanceProposalWhereInput[]
    OR?: GovernanceProposalWhereInput[]
    NOT?: GovernanceProposalWhereInput | GovernanceProposalWhereInput[]
    title?: StringFilter<"GovernanceProposal"> | string
    description?: StringFilter<"GovernanceProposal"> | string
    proposalType?: EnumProposalTypeFilter<"GovernanceProposal"> | $Enums.ProposalType
    proposerId?: StringFilter<"GovernanceProposal"> | string
    status?: EnumGovernanceStatusFilter<"GovernanceProposal"> | $Enums.GovernanceStatus
    votingStartsAt?: DateTimeFilter<"GovernanceProposal"> | Date | string
    votingEndsAt?: DateTimeFilter<"GovernanceProposal"> | Date | string
    executionDate?: DateTimeNullableFilter<"GovernanceProposal"> | Date | string | null
    minQuorum?: FloatFilter<"GovernanceProposal"> | number
    minApproval?: FloatFilter<"GovernanceProposal"> | number
    totalVotes?: FloatFilter<"GovernanceProposal"> | number
    yesVotes?: FloatFilter<"GovernanceProposal"> | number
    noVotes?: FloatFilter<"GovernanceProposal"> | number
    abstainVotes?: FloatFilter<"GovernanceProposal"> | number
    isExecuted?: BoolFilter<"GovernanceProposal"> | boolean
    createdAt?: DateTimeFilter<"GovernanceProposal"> | Date | string
    updatedAt?: DateTimeFilter<"GovernanceProposal"> | Date | string
    parameters?: JsonNullableFilter<"GovernanceProposal">
    proposer?: XOR<UserScalarRelationFilter, UserWhereInput>
    votes?: GovernanceVoteListRelationFilter
  }, "id">

  export type GovernanceProposalOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    proposalType?: SortOrder
    proposerId?: SortOrder
    status?: SortOrder
    votingStartsAt?: SortOrder
    votingEndsAt?: SortOrder
    executionDate?: SortOrderInput | SortOrder
    minQuorum?: SortOrder
    minApproval?: SortOrder
    totalVotes?: SortOrder
    yesVotes?: SortOrder
    noVotes?: SortOrder
    abstainVotes?: SortOrder
    isExecuted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parameters?: SortOrderInput | SortOrder
    _count?: GovernanceProposalCountOrderByAggregateInput
    _avg?: GovernanceProposalAvgOrderByAggregateInput
    _max?: GovernanceProposalMaxOrderByAggregateInput
    _min?: GovernanceProposalMinOrderByAggregateInput
    _sum?: GovernanceProposalSumOrderByAggregateInput
  }

  export type GovernanceProposalScalarWhereWithAggregatesInput = {
    AND?: GovernanceProposalScalarWhereWithAggregatesInput | GovernanceProposalScalarWhereWithAggregatesInput[]
    OR?: GovernanceProposalScalarWhereWithAggregatesInput[]
    NOT?: GovernanceProposalScalarWhereWithAggregatesInput | GovernanceProposalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GovernanceProposal"> | string
    title?: StringWithAggregatesFilter<"GovernanceProposal"> | string
    description?: StringWithAggregatesFilter<"GovernanceProposal"> | string
    proposalType?: EnumProposalTypeWithAggregatesFilter<"GovernanceProposal"> | $Enums.ProposalType
    proposerId?: StringWithAggregatesFilter<"GovernanceProposal"> | string
    status?: EnumGovernanceStatusWithAggregatesFilter<"GovernanceProposal"> | $Enums.GovernanceStatus
    votingStartsAt?: DateTimeWithAggregatesFilter<"GovernanceProposal"> | Date | string
    votingEndsAt?: DateTimeWithAggregatesFilter<"GovernanceProposal"> | Date | string
    executionDate?: DateTimeNullableWithAggregatesFilter<"GovernanceProposal"> | Date | string | null
    minQuorum?: FloatWithAggregatesFilter<"GovernanceProposal"> | number
    minApproval?: FloatWithAggregatesFilter<"GovernanceProposal"> | number
    totalVotes?: FloatWithAggregatesFilter<"GovernanceProposal"> | number
    yesVotes?: FloatWithAggregatesFilter<"GovernanceProposal"> | number
    noVotes?: FloatWithAggregatesFilter<"GovernanceProposal"> | number
    abstainVotes?: FloatWithAggregatesFilter<"GovernanceProposal"> | number
    isExecuted?: BoolWithAggregatesFilter<"GovernanceProposal"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"GovernanceProposal"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GovernanceProposal"> | Date | string
    parameters?: JsonNullableWithAggregatesFilter<"GovernanceProposal">
  }

  export type GovernanceVoteWhereInput = {
    AND?: GovernanceVoteWhereInput | GovernanceVoteWhereInput[]
    OR?: GovernanceVoteWhereInput[]
    NOT?: GovernanceVoteWhereInput | GovernanceVoteWhereInput[]
    id?: StringFilter<"GovernanceVote"> | string
    proposalId?: StringFilter<"GovernanceVote"> | string
    userId?: StringFilter<"GovernanceVote"> | string
    voteChoice?: EnumVoteChoiceFilter<"GovernanceVote"> | $Enums.VoteChoice
    votingPower?: FloatFilter<"GovernanceVote"> | number
    reason?: StringNullableFilter<"GovernanceVote"> | string | null
    votedAt?: DateTimeFilter<"GovernanceVote"> | Date | string
    proposal?: XOR<GovernanceProposalScalarRelationFilter, GovernanceProposalWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type GovernanceVoteOrderByWithRelationInput = {
    id?: SortOrder
    proposalId?: SortOrder
    userId?: SortOrder
    voteChoice?: SortOrder
    votingPower?: SortOrder
    reason?: SortOrderInput | SortOrder
    votedAt?: SortOrder
    proposal?: GovernanceProposalOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type GovernanceVoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    proposalId_userId?: GovernanceVoteProposalIdUserIdCompoundUniqueInput
    AND?: GovernanceVoteWhereInput | GovernanceVoteWhereInput[]
    OR?: GovernanceVoteWhereInput[]
    NOT?: GovernanceVoteWhereInput | GovernanceVoteWhereInput[]
    proposalId?: StringFilter<"GovernanceVote"> | string
    userId?: StringFilter<"GovernanceVote"> | string
    voteChoice?: EnumVoteChoiceFilter<"GovernanceVote"> | $Enums.VoteChoice
    votingPower?: FloatFilter<"GovernanceVote"> | number
    reason?: StringNullableFilter<"GovernanceVote"> | string | null
    votedAt?: DateTimeFilter<"GovernanceVote"> | Date | string
    proposal?: XOR<GovernanceProposalScalarRelationFilter, GovernanceProposalWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "proposalId_userId">

  export type GovernanceVoteOrderByWithAggregationInput = {
    id?: SortOrder
    proposalId?: SortOrder
    userId?: SortOrder
    voteChoice?: SortOrder
    votingPower?: SortOrder
    reason?: SortOrderInput | SortOrder
    votedAt?: SortOrder
    _count?: GovernanceVoteCountOrderByAggregateInput
    _avg?: GovernanceVoteAvgOrderByAggregateInput
    _max?: GovernanceVoteMaxOrderByAggregateInput
    _min?: GovernanceVoteMinOrderByAggregateInput
    _sum?: GovernanceVoteSumOrderByAggregateInput
  }

  export type GovernanceVoteScalarWhereWithAggregatesInput = {
    AND?: GovernanceVoteScalarWhereWithAggregatesInput | GovernanceVoteScalarWhereWithAggregatesInput[]
    OR?: GovernanceVoteScalarWhereWithAggregatesInput[]
    NOT?: GovernanceVoteScalarWhereWithAggregatesInput | GovernanceVoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GovernanceVote"> | string
    proposalId?: StringWithAggregatesFilter<"GovernanceVote"> | string
    userId?: StringWithAggregatesFilter<"GovernanceVote"> | string
    voteChoice?: EnumVoteChoiceWithAggregatesFilter<"GovernanceVote"> | $Enums.VoteChoice
    votingPower?: FloatWithAggregatesFilter<"GovernanceVote"> | number
    reason?: StringNullableWithAggregatesFilter<"GovernanceVote"> | string | null
    votedAt?: DateTimeWithAggregatesFilter<"GovernanceVote"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    passwordHash?: string | null
    emailVerified?: Date | string | null
    eceBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string
    subscription?: UserSubscriptionCreateNestedOneWithoutUserInput
    cryptoWallets?: CryptoWalletCreateNestedManyWithoutUserInput
    physicalCard?: PhysicalCardCreateNestedOneWithoutUserInput
    ownedCards?: CardCreateNestedManyWithoutOwnerInput
    tradingHistory?: TransactionCreateNestedManyWithoutUserInput
    bids?: BidCreateNestedManyWithoutBidderInput
    listings?: MarketplaceListingCreateNestedManyWithoutSellerInput
    appOrders?: AppOrderCreateNestedManyWithoutUserInput
    orderRevisions?: OrderRevisionCreateNestedManyWithoutUserInput
    orderCommunications?: OrderCommunicationCreateNestedManyWithoutUserInput
    bettingPositions?: BettingPositionCreateNestedManyWithoutUserInput
    bettingPayouts?: BettingPayoutCreateNestedManyWithoutUserInput
    ownedAuctions?: CardAuctionCreateNestedManyWithoutOwnerInput
    wonAuctions?: CardAuctionCreateNestedManyWithoutWinnerInput
    placedAuctionBids?: AuctionBidCreateNestedManyWithoutBidderInput
    watchedAuctions?: AuctionWatcherCreateNestedManyWithoutUserInput
    initiatedMABattles?: MABattleCreateNestedManyWithoutInitiatorInput
    targetedMABattles?: MABattleCreateNestedManyWithoutTargetInput
    battleProposals?: BattleProposalCreateNestedManyWithoutProposerInput
    battleVotes?: BattleVotingCreateNestedManyWithoutVoterInput
    stakingPositions?: StakingPositionCreateNestedManyWithoutUserInput
    stakingRewards?: StakingRewardCreateNestedManyWithoutUserInput
    governanceProposals?: GovernanceProposalCreateNestedManyWithoutProposerInput
    governanceVotes?: GovernanceVoteCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    socialFeeds?: SocialFeedCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    passwordHash?: string | null
    emailVerified?: Date | string | null
    eceBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string
    subscription?: UserSubscriptionUncheckedCreateNestedOneWithoutUserInput
    cryptoWallets?: CryptoWalletUncheckedCreateNestedManyWithoutUserInput
    physicalCard?: PhysicalCardUncheckedCreateNestedOneWithoutUserInput
    ownedCards?: CardUncheckedCreateNestedManyWithoutOwnerInput
    tradingHistory?: TransactionUncheckedCreateNestedManyWithoutUserInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderInput
    listings?: MarketplaceListingUncheckedCreateNestedManyWithoutSellerInput
    appOrders?: AppOrderUncheckedCreateNestedManyWithoutUserInput
    orderRevisions?: OrderRevisionUncheckedCreateNestedManyWithoutUserInput
    orderCommunications?: OrderCommunicationUncheckedCreateNestedManyWithoutUserInput
    bettingPositions?: BettingPositionUncheckedCreateNestedManyWithoutUserInput
    bettingPayouts?: BettingPayoutUncheckedCreateNestedManyWithoutUserInput
    ownedAuctions?: CardAuctionUncheckedCreateNestedManyWithoutOwnerInput
    wonAuctions?: CardAuctionUncheckedCreateNestedManyWithoutWinnerInput
    placedAuctionBids?: AuctionBidUncheckedCreateNestedManyWithoutBidderInput
    watchedAuctions?: AuctionWatcherUncheckedCreateNestedManyWithoutUserInput
    initiatedMABattles?: MABattleUncheckedCreateNestedManyWithoutInitiatorInput
    targetedMABattles?: MABattleUncheckedCreateNestedManyWithoutTargetInput
    battleProposals?: BattleProposalUncheckedCreateNestedManyWithoutProposerInput
    battleVotes?: BattleVotingUncheckedCreateNestedManyWithoutVoterInput
    stakingPositions?: StakingPositionUncheckedCreateNestedManyWithoutUserInput
    stakingRewards?: StakingRewardUncheckedCreateNestedManyWithoutUserInput
    governanceProposals?: GovernanceProposalUncheckedCreateNestedManyWithoutProposerInput
    governanceVotes?: GovernanceVoteUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    socialFeeds?: SocialFeedUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eceBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: UserSubscriptionUpdateOneWithoutUserNestedInput
    cryptoWallets?: CryptoWalletUpdateManyWithoutUserNestedInput
    physicalCard?: PhysicalCardUpdateOneWithoutUserNestedInput
    ownedCards?: CardUpdateManyWithoutOwnerNestedInput
    tradingHistory?: TransactionUpdateManyWithoutUserNestedInput
    bids?: BidUpdateManyWithoutBidderNestedInput
    listings?: MarketplaceListingUpdateManyWithoutSellerNestedInput
    appOrders?: AppOrderUpdateManyWithoutUserNestedInput
    orderRevisions?: OrderRevisionUpdateManyWithoutUserNestedInput
    orderCommunications?: OrderCommunicationUpdateManyWithoutUserNestedInput
    bettingPositions?: BettingPositionUpdateManyWithoutUserNestedInput
    bettingPayouts?: BettingPayoutUpdateManyWithoutUserNestedInput
    ownedAuctions?: CardAuctionUpdateManyWithoutOwnerNestedInput
    wonAuctions?: CardAuctionUpdateManyWithoutWinnerNestedInput
    placedAuctionBids?: AuctionBidUpdateManyWithoutBidderNestedInput
    watchedAuctions?: AuctionWatcherUpdateManyWithoutUserNestedInput
    initiatedMABattles?: MABattleUpdateManyWithoutInitiatorNestedInput
    targetedMABattles?: MABattleUpdateManyWithoutTargetNestedInput
    battleProposals?: BattleProposalUpdateManyWithoutProposerNestedInput
    battleVotes?: BattleVotingUpdateManyWithoutVoterNestedInput
    stakingPositions?: StakingPositionUpdateManyWithoutUserNestedInput
    stakingRewards?: StakingRewardUpdateManyWithoutUserNestedInput
    governanceProposals?: GovernanceProposalUpdateManyWithoutProposerNestedInput
    governanceVotes?: GovernanceVoteUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    socialFeeds?: SocialFeedUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eceBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: UserSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    cryptoWallets?: CryptoWalletUncheckedUpdateManyWithoutUserNestedInput
    physicalCard?: PhysicalCardUncheckedUpdateOneWithoutUserNestedInput
    ownedCards?: CardUncheckedUpdateManyWithoutOwnerNestedInput
    tradingHistory?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderNestedInput
    listings?: MarketplaceListingUncheckedUpdateManyWithoutSellerNestedInput
    appOrders?: AppOrderUncheckedUpdateManyWithoutUserNestedInput
    orderRevisions?: OrderRevisionUncheckedUpdateManyWithoutUserNestedInput
    orderCommunications?: OrderCommunicationUncheckedUpdateManyWithoutUserNestedInput
    bettingPositions?: BettingPositionUncheckedUpdateManyWithoutUserNestedInput
    bettingPayouts?: BettingPayoutUncheckedUpdateManyWithoutUserNestedInput
    ownedAuctions?: CardAuctionUncheckedUpdateManyWithoutOwnerNestedInput
    wonAuctions?: CardAuctionUncheckedUpdateManyWithoutWinnerNestedInput
    placedAuctionBids?: AuctionBidUncheckedUpdateManyWithoutBidderNestedInput
    watchedAuctions?: AuctionWatcherUncheckedUpdateManyWithoutUserNestedInput
    initiatedMABattles?: MABattleUncheckedUpdateManyWithoutInitiatorNestedInput
    targetedMABattles?: MABattleUncheckedUpdateManyWithoutTargetNestedInput
    battleProposals?: BattleProposalUncheckedUpdateManyWithoutProposerNestedInput
    battleVotes?: BattleVotingUncheckedUpdateManyWithoutVoterNestedInput
    stakingPositions?: StakingPositionUncheckedUpdateManyWithoutUserNestedInput
    stakingRewards?: StakingRewardUncheckedUpdateManyWithoutUserNestedInput
    governanceProposals?: GovernanceProposalUncheckedUpdateManyWithoutProposerNestedInput
    governanceVotes?: GovernanceVoteUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    socialFeeds?: SocialFeedUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    passwordHash?: string | null
    emailVerified?: Date | string | null
    eceBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eceBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eceBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSubscriptionCreateInput = {
    id?: string
    plan?: $Enums.SubscriptionPlan
    status?: $Enums.SubscriptionStatus
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSubscriptionInput
    features?: SubscriptionFeaturesCreateNestedOneWithoutSubscriptionInput
    usage?: SubscriptionUsageCreateNestedOneWithoutSubscriptionInput
  }

  export type UserSubscriptionUncheckedCreateInput = {
    id?: string
    userId: string
    plan?: $Enums.SubscriptionPlan
    status?: $Enums.SubscriptionStatus
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: SubscriptionFeaturesUncheckedCreateNestedOneWithoutSubscriptionInput
    usage?: SubscriptionUsageUncheckedCreateNestedOneWithoutSubscriptionInput
  }

  export type UserSubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSubscriptionNestedInput
    features?: SubscriptionFeaturesUpdateOneWithoutSubscriptionNestedInput
    usage?: SubscriptionUsageUpdateOneWithoutSubscriptionNestedInput
  }

  export type UserSubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: SubscriptionFeaturesUncheckedUpdateOneWithoutSubscriptionNestedInput
    usage?: SubscriptionUsageUncheckedUpdateOneWithoutSubscriptionNestedInput
  }

  export type UserSubscriptionCreateManyInput = {
    id?: string
    userId: string
    plan?: $Enums.SubscriptionPlan
    status?: $Enums.SubscriptionStatus
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionFeaturesCreateInput = {
    id?: string
    maxTrades?: number
    advancedAnalytics?: boolean
    prioritySupport?: boolean
    marketplaceAccess?: boolean
    premiumListings?: boolean
    bulkOperations?: boolean
    cryptoPayments?: boolean
    physicalCard?: boolean
    businessStipend?: number
    withdrawalLimit?: number
    subscription: UserSubscriptionCreateNestedOneWithoutFeaturesInput
  }

  export type SubscriptionFeaturesUncheckedCreateInput = {
    id?: string
    subscriptionId: string
    maxTrades?: number
    advancedAnalytics?: boolean
    prioritySupport?: boolean
    marketplaceAccess?: boolean
    premiumListings?: boolean
    bulkOperations?: boolean
    cryptoPayments?: boolean
    physicalCard?: boolean
    businessStipend?: number
    withdrawalLimit?: number
  }

  export type SubscriptionFeaturesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    maxTrades?: IntFieldUpdateOperationsInput | number
    advancedAnalytics?: BoolFieldUpdateOperationsInput | boolean
    prioritySupport?: BoolFieldUpdateOperationsInput | boolean
    marketplaceAccess?: BoolFieldUpdateOperationsInput | boolean
    premiumListings?: BoolFieldUpdateOperationsInput | boolean
    bulkOperations?: BoolFieldUpdateOperationsInput | boolean
    cryptoPayments?: BoolFieldUpdateOperationsInput | boolean
    physicalCard?: BoolFieldUpdateOperationsInput | boolean
    businessStipend?: FloatFieldUpdateOperationsInput | number
    withdrawalLimit?: FloatFieldUpdateOperationsInput | number
    subscription?: UserSubscriptionUpdateOneRequiredWithoutFeaturesNestedInput
  }

  export type SubscriptionFeaturesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    maxTrades?: IntFieldUpdateOperationsInput | number
    advancedAnalytics?: BoolFieldUpdateOperationsInput | boolean
    prioritySupport?: BoolFieldUpdateOperationsInput | boolean
    marketplaceAccess?: BoolFieldUpdateOperationsInput | boolean
    premiumListings?: BoolFieldUpdateOperationsInput | boolean
    bulkOperations?: BoolFieldUpdateOperationsInput | boolean
    cryptoPayments?: BoolFieldUpdateOperationsInput | boolean
    physicalCard?: BoolFieldUpdateOperationsInput | boolean
    businessStipend?: FloatFieldUpdateOperationsInput | number
    withdrawalLimit?: FloatFieldUpdateOperationsInput | number
  }

  export type SubscriptionFeaturesCreateManyInput = {
    id?: string
    subscriptionId: string
    maxTrades?: number
    advancedAnalytics?: boolean
    prioritySupport?: boolean
    marketplaceAccess?: boolean
    premiumListings?: boolean
    bulkOperations?: boolean
    cryptoPayments?: boolean
    physicalCard?: boolean
    businessStipend?: number
    withdrawalLimit?: number
  }

  export type SubscriptionFeaturesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    maxTrades?: IntFieldUpdateOperationsInput | number
    advancedAnalytics?: BoolFieldUpdateOperationsInput | boolean
    prioritySupport?: BoolFieldUpdateOperationsInput | boolean
    marketplaceAccess?: BoolFieldUpdateOperationsInput | boolean
    premiumListings?: BoolFieldUpdateOperationsInput | boolean
    bulkOperations?: BoolFieldUpdateOperationsInput | boolean
    cryptoPayments?: BoolFieldUpdateOperationsInput | boolean
    physicalCard?: BoolFieldUpdateOperationsInput | boolean
    businessStipend?: FloatFieldUpdateOperationsInput | number
    withdrawalLimit?: FloatFieldUpdateOperationsInput | number
  }

  export type SubscriptionFeaturesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    maxTrades?: IntFieldUpdateOperationsInput | number
    advancedAnalytics?: BoolFieldUpdateOperationsInput | boolean
    prioritySupport?: BoolFieldUpdateOperationsInput | boolean
    marketplaceAccess?: BoolFieldUpdateOperationsInput | boolean
    premiumListings?: BoolFieldUpdateOperationsInput | boolean
    bulkOperations?: BoolFieldUpdateOperationsInput | boolean
    cryptoPayments?: BoolFieldUpdateOperationsInput | boolean
    physicalCard?: BoolFieldUpdateOperationsInput | boolean
    businessStipend?: FloatFieldUpdateOperationsInput | number
    withdrawalLimit?: FloatFieldUpdateOperationsInput | number
  }

  export type SubscriptionUsageCreateInput = {
    id?: string
    tradesThisMonth?: number
    listingsThisMonth?: number
    stipendUsed?: number
    lastResetAt?: Date | string
    subscription: UserSubscriptionCreateNestedOneWithoutUsageInput
  }

  export type SubscriptionUsageUncheckedCreateInput = {
    id?: string
    subscriptionId: string
    tradesThisMonth?: number
    listingsThisMonth?: number
    stipendUsed?: number
    lastResetAt?: Date | string
  }

  export type SubscriptionUsageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tradesThisMonth?: IntFieldUpdateOperationsInput | number
    listingsThisMonth?: IntFieldUpdateOperationsInput | number
    stipendUsed?: FloatFieldUpdateOperationsInput | number
    lastResetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: UserSubscriptionUpdateOneRequiredWithoutUsageNestedInput
  }

  export type SubscriptionUsageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    tradesThisMonth?: IntFieldUpdateOperationsInput | number
    listingsThisMonth?: IntFieldUpdateOperationsInput | number
    stipendUsed?: FloatFieldUpdateOperationsInput | number
    lastResetAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUsageCreateManyInput = {
    id?: string
    subscriptionId: string
    tradesThisMonth?: number
    listingsThisMonth?: number
    stipendUsed?: number
    lastResetAt?: Date | string
  }

  export type SubscriptionUsageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tradesThisMonth?: IntFieldUpdateOperationsInput | number
    listingsThisMonth?: IntFieldUpdateOperationsInput | number
    stipendUsed?: FloatFieldUpdateOperationsInput | number
    lastResetAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUsageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    tradesThisMonth?: IntFieldUpdateOperationsInput | number
    listingsThisMonth?: IntFieldUpdateOperationsInput | number
    stipendUsed?: FloatFieldUpdateOperationsInput | number
    lastResetAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CardCreateInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.CardCategory
    rarity: $Enums.CardRarity
    company?: string | null
    currentPrice: number
    historicalPrices?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    stats?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedCardsInput
    listing?: MarketplaceListingCreateNestedOneWithoutCardInput
    bids?: BidCreateNestedManyWithoutCardInput
    transactions?: TransactionCreateNestedManyWithoutCardInput
    bettingMarkets?: BettingMarketCreateNestedManyWithoutCardInput
    marketMetrics?: MarketMetricsCreateNestedManyWithoutCardInput
    auction?: CardAuctionCreateNestedOneWithoutCardInput
    auctionHistory?: AuctionHistoryCreateNestedManyWithoutCardInput
    initiatedBattles?: MABattleCreateNestedManyWithoutInitiatorCardInput
    targetedBattles?: MABattleCreateNestedManyWithoutTargetCardInput
  }

  export type CardUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.CardCategory
    rarity: $Enums.CardRarity
    company?: string | null
    currentPrice: number
    historicalPrices?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    stats?: NullableJsonNullValueInput | InputJsonValue
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    listing?: MarketplaceListingUncheckedCreateNestedOneWithoutCardInput
    bids?: BidUncheckedCreateNestedManyWithoutCardInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCardInput
    bettingMarkets?: BettingMarketUncheckedCreateNestedManyWithoutCardInput
    marketMetrics?: MarketMetricsUncheckedCreateNestedManyWithoutCardInput
    auction?: CardAuctionUncheckedCreateNestedOneWithoutCardInput
    auctionHistory?: AuctionHistoryUncheckedCreateNestedManyWithoutCardInput
    initiatedBattles?: MABattleUncheckedCreateNestedManyWithoutInitiatorCardInput
    targetedBattles?: MABattleUncheckedCreateNestedManyWithoutTargetCardInput
  }

  export type CardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCardCategoryFieldUpdateOperationsInput | $Enums.CardCategory
    rarity?: EnumCardRarityFieldUpdateOperationsInput | $Enums.CardRarity
    company?: NullableStringFieldUpdateOperationsInput | string | null
    currentPrice?: FloatFieldUpdateOperationsInput | number
    historicalPrices?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    stats?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedCardsNestedInput
    listing?: MarketplaceListingUpdateOneWithoutCardNestedInput
    bids?: BidUpdateManyWithoutCardNestedInput
    transactions?: TransactionUpdateManyWithoutCardNestedInput
    bettingMarkets?: BettingMarketUpdateManyWithoutCardNestedInput
    marketMetrics?: MarketMetricsUpdateManyWithoutCardNestedInput
    auction?: CardAuctionUpdateOneWithoutCardNestedInput
    auctionHistory?: AuctionHistoryUpdateManyWithoutCardNestedInput
    initiatedBattles?: MABattleUpdateManyWithoutInitiatorCardNestedInput
    targetedBattles?: MABattleUpdateManyWithoutTargetCardNestedInput
  }

  export type CardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCardCategoryFieldUpdateOperationsInput | $Enums.CardCategory
    rarity?: EnumCardRarityFieldUpdateOperationsInput | $Enums.CardRarity
    company?: NullableStringFieldUpdateOperationsInput | string | null
    currentPrice?: FloatFieldUpdateOperationsInput | number
    historicalPrices?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    stats?: NullableJsonNullValueInput | InputJsonValue
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listing?: MarketplaceListingUncheckedUpdateOneWithoutCardNestedInput
    bids?: BidUncheckedUpdateManyWithoutCardNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCardNestedInput
    bettingMarkets?: BettingMarketUncheckedUpdateManyWithoutCardNestedInput
    marketMetrics?: MarketMetricsUncheckedUpdateManyWithoutCardNestedInput
    auction?: CardAuctionUncheckedUpdateOneWithoutCardNestedInput
    auctionHistory?: AuctionHistoryUncheckedUpdateManyWithoutCardNestedInput
    initiatedBattles?: MABattleUncheckedUpdateManyWithoutInitiatorCardNestedInput
    targetedBattles?: MABattleUncheckedUpdateManyWithoutTargetCardNestedInput
  }

  export type CardCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.CardCategory
    rarity: $Enums.CardRarity
    company?: string | null
    currentPrice: number
    historicalPrices?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    stats?: NullableJsonNullValueInput | InputJsonValue
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCardCategoryFieldUpdateOperationsInput | $Enums.CardCategory
    rarity?: EnumCardRarityFieldUpdateOperationsInput | $Enums.CardRarity
    company?: NullableStringFieldUpdateOperationsInput | string | null
    currentPrice?: FloatFieldUpdateOperationsInput | number
    historicalPrices?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    stats?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCardCategoryFieldUpdateOperationsInput | $Enums.CardCategory
    rarity?: EnumCardRarityFieldUpdateOperationsInput | $Enums.CardRarity
    company?: NullableStringFieldUpdateOperationsInput | string | null
    currentPrice?: FloatFieldUpdateOperationsInput | number
    historicalPrices?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    stats?: NullableJsonNullValueInput | InputJsonValue
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketplaceListingCreateInput = {
    id?: string
    price: number
    listingType?: $Enums.ListingType
    auctionEnd?: Date | string | null
    status?: $Enums.ListingStatus
    featured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    card: CardCreateNestedOneWithoutListingInput
    seller: UserCreateNestedOneWithoutListingsInput
    bids?: BidCreateNestedManyWithoutListingInput
  }

  export type MarketplaceListingUncheckedCreateInput = {
    id?: string
    cardId: string
    sellerId: string
    price: number
    listingType?: $Enums.ListingType
    auctionEnd?: Date | string | null
    status?: $Enums.ListingStatus
    featured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bids?: BidUncheckedCreateNestedManyWithoutListingInput
  }

  export type MarketplaceListingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    listingType?: EnumListingTypeFieldUpdateOperationsInput | $Enums.ListingType
    auctionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    featured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    card?: CardUpdateOneRequiredWithoutListingNestedInput
    seller?: UserUpdateOneRequiredWithoutListingsNestedInput
    bids?: BidUpdateManyWithoutListingNestedInput
  }

  export type MarketplaceListingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    listingType?: EnumListingTypeFieldUpdateOperationsInput | $Enums.ListingType
    auctionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    featured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bids?: BidUncheckedUpdateManyWithoutListingNestedInput
  }

  export type MarketplaceListingCreateManyInput = {
    id?: string
    cardId: string
    sellerId: string
    price: number
    listingType?: $Enums.ListingType
    auctionEnd?: Date | string | null
    status?: $Enums.ListingStatus
    featured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketplaceListingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    listingType?: EnumListingTypeFieldUpdateOperationsInput | $Enums.ListingType
    auctionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    featured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketplaceListingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    listingType?: EnumListingTypeFieldUpdateOperationsInput | $Enums.ListingType
    auctionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    featured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BidCreateInput = {
    id?: string
    amount: number
    status?: $Enums.BidStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    listing: MarketplaceListingCreateNestedOneWithoutBidsInput
    bidder: UserCreateNestedOneWithoutBidsInput
    card: CardCreateNestedOneWithoutBidsInput
  }

  export type BidUncheckedCreateInput = {
    id?: string
    listingId: string
    bidderId: string
    cardId: string
    amount: number
    status?: $Enums.BidStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BidUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumBidStatusFieldUpdateOperationsInput | $Enums.BidStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listing?: MarketplaceListingUpdateOneRequiredWithoutBidsNestedInput
    bidder?: UserUpdateOneRequiredWithoutBidsNestedInput
    card?: CardUpdateOneRequiredWithoutBidsNestedInput
  }

  export type BidUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    bidderId?: StringFieldUpdateOperationsInput | string
    cardId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumBidStatusFieldUpdateOperationsInput | $Enums.BidStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BidCreateManyInput = {
    id?: string
    listingId: string
    bidderId: string
    cardId: string
    amount: number
    status?: $Enums.BidStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BidUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumBidStatusFieldUpdateOperationsInput | $Enums.BidStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BidUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    bidderId?: StringFieldUpdateOperationsInput | string
    cardId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumBidStatusFieldUpdateOperationsInput | $Enums.BidStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateInput = {
    id?: string
    type: $Enums.TransactionType
    amount: number
    currency?: string
    status?: $Enums.TransactionStatus
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: string | null
    paymentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTradingHistoryInput
    card?: CardCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: string
    userId: string
    cardId?: string | null
    type: $Enums.TransactionType
    amount: number
    currency?: string
    status?: $Enums.TransactionStatus
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: string | null
    paymentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTradingHistoryNestedInput
    card?: CardUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cardId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateManyInput = {
    id?: string
    userId: string
    cardId?: string | null
    type: $Enums.TransactionType
    amount: number
    currency?: string
    status?: $Enums.TransactionStatus
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: string | null
    paymentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cardId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CryptoWalletCreateInput = {
    id?: string
    currency: string
    address: string
    balance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCryptoWalletsInput
  }

  export type CryptoWalletUncheckedCreateInput = {
    id?: string
    userId: string
    currency: string
    address: string
    balance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CryptoWalletUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCryptoWalletsNestedInput
  }

  export type CryptoWalletUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CryptoWalletCreateManyInput = {
    id?: string
    userId: string
    currency: string
    address: string
    balance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CryptoWalletUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CryptoWalletUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhysicalCardCreateInput = {
    id?: string
    cardNumber: string
    expiryDate: string
    cvv: string
    status?: $Enums.PhysicalCardStatus
    appleWalletPassId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPhysicalCardInput
  }

  export type PhysicalCardUncheckedCreateInput = {
    id?: string
    userId: string
    cardNumber: string
    expiryDate: string
    cvv: string
    status?: $Enums.PhysicalCardStatus
    appleWalletPassId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PhysicalCardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardNumber?: StringFieldUpdateOperationsInput | string
    expiryDate?: StringFieldUpdateOperationsInput | string
    cvv?: StringFieldUpdateOperationsInput | string
    status?: EnumPhysicalCardStatusFieldUpdateOperationsInput | $Enums.PhysicalCardStatus
    appleWalletPassId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPhysicalCardNestedInput
  }

  export type PhysicalCardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cardNumber?: StringFieldUpdateOperationsInput | string
    expiryDate?: StringFieldUpdateOperationsInput | string
    cvv?: StringFieldUpdateOperationsInput | string
    status?: EnumPhysicalCardStatusFieldUpdateOperationsInput | $Enums.PhysicalCardStatus
    appleWalletPassId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhysicalCardCreateManyInput = {
    id?: string
    userId: string
    cardNumber: string
    expiryDate: string
    cvv: string
    status?: $Enums.PhysicalCardStatus
    appleWalletPassId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PhysicalCardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardNumber?: StringFieldUpdateOperationsInput | string
    expiryDate?: StringFieldUpdateOperationsInput | string
    cvv?: StringFieldUpdateOperationsInput | string
    status?: EnumPhysicalCardStatusFieldUpdateOperationsInput | $Enums.PhysicalCardStatus
    appleWalletPassId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhysicalCardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cardNumber?: StringFieldUpdateOperationsInput | string
    expiryDate?: StringFieldUpdateOperationsInput | string
    cvv?: StringFieldUpdateOperationsInput | string
    status?: EnumPhysicalCardStatusFieldUpdateOperationsInput | $Enums.PhysicalCardStatus
    appleWalletPassId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    priority?: $Enums.NotificationPriority
    requiresSubscription?: $Enums.SubscriptionPlan | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    type: $Enums.NotificationType
    title: string
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    priority?: $Enums.NotificationPriority
    requiresSubscription?: $Enums.SubscriptionPlan | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    requiresSubscription?: NullableEnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    requiresSubscription?: NullableEnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    type: $Enums.NotificationType
    title: string
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    priority?: $Enums.NotificationPriority
    requiresSubscription?: $Enums.SubscriptionPlan | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    requiresSubscription?: NullableEnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    requiresSubscription?: NullableEnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialFeedCreateInput = {
    id?: string
    type: $Enums.SocialFeedType
    content: string
    data?: NullableJsonNullValueInput | InputJsonValue
    likes?: number
    comments?: number
    shares?: number
    visibility?: $Enums.SocialVisibility
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSocialFeedsInput
  }

  export type SocialFeedUncheckedCreateInput = {
    id?: string
    userId: string
    type: $Enums.SocialFeedType
    content: string
    data?: NullableJsonNullValueInput | InputJsonValue
    likes?: number
    comments?: number
    shares?: number
    visibility?: $Enums.SocialVisibility
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SocialFeedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSocialFeedTypeFieldUpdateOperationsInput | $Enums.SocialFeedType
    content?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    likes?: IntFieldUpdateOperationsInput | number
    comments?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    visibility?: EnumSocialVisibilityFieldUpdateOperationsInput | $Enums.SocialVisibility
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSocialFeedsNestedInput
  }

  export type SocialFeedUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumSocialFeedTypeFieldUpdateOperationsInput | $Enums.SocialFeedType
    content?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    likes?: IntFieldUpdateOperationsInput | number
    comments?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    visibility?: EnumSocialVisibilityFieldUpdateOperationsInput | $Enums.SocialVisibility
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialFeedCreateManyInput = {
    id?: string
    userId: string
    type: $Enums.SocialFeedType
    content: string
    data?: NullableJsonNullValueInput | InputJsonValue
    likes?: number
    comments?: number
    shares?: number
    visibility?: $Enums.SocialVisibility
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SocialFeedUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSocialFeedTypeFieldUpdateOperationsInput | $Enums.SocialFeedType
    content?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    likes?: IntFieldUpdateOperationsInput | number
    comments?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    visibility?: EnumSocialVisibilityFieldUpdateOperationsInput | $Enums.SocialVisibility
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialFeedUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumSocialFeedTypeFieldUpdateOperationsInput | $Enums.SocialFeedType
    content?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    likes?: IntFieldUpdateOperationsInput | number
    comments?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    visibility?: EnumSocialVisibilityFieldUpdateOperationsInput | $Enums.SocialVisibility
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowCreateInput = {
    id?: string
    createdAt?: Date | string
    follower: UserCreateNestedOneWithoutFollowersInput
    following: UserCreateNestedOneWithoutFollowingInput
  }

  export type FollowUncheckedCreateInput = {
    id?: string
    followerId: string
    followingId: string
    createdAt?: Date | string
  }

  export type FollowUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    follower?: UserUpdateOneRequiredWithoutFollowersNestedInput
    following?: UserUpdateOneRequiredWithoutFollowingNestedInput
  }

  export type FollowUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    followerId?: StringFieldUpdateOperationsInput | string
    followingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowCreateManyInput = {
    id?: string
    followerId: string
    followingId: string
    createdAt?: Date | string
  }

  export type FollowUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    followerId?: StringFieldUpdateOperationsInput | string
    followingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppOrderCreateInput = {
    id?: string
    projectType: $Enums.ProjectType
    title: string
    description: string
    requirements?: NullableJsonNullValueInput | InputJsonValue
    timeline: $Enums.OrderTimeline
    estimatedCost: number
    actualCost?: number | null
    currency?: string
    status?: $Enums.OrderStatus
    priority?: $Enums.OrderPriority
    deliveryDate?: Date | string | null
    githubRepo?: string | null
    vercelLink?: string | null
    downloadLink?: string | null
    progressPercentage?: number
    currentMilestone?: string | null
    assignedAdminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAppOrdersInput
    revisions?: OrderRevisionCreateNestedManyWithoutOrderInput
    communications?: OrderCommunicationCreateNestedManyWithoutOrderInput
    deliverables?: OrderDeliverableCreateNestedManyWithoutOrderInput
  }

  export type AppOrderUncheckedCreateInput = {
    id?: string
    userId: string
    projectType: $Enums.ProjectType
    title: string
    description: string
    requirements?: NullableJsonNullValueInput | InputJsonValue
    timeline: $Enums.OrderTimeline
    estimatedCost: number
    actualCost?: number | null
    currency?: string
    status?: $Enums.OrderStatus
    priority?: $Enums.OrderPriority
    deliveryDate?: Date | string | null
    githubRepo?: string | null
    vercelLink?: string | null
    downloadLink?: string | null
    progressPercentage?: number
    currentMilestone?: string | null
    assignedAdminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    revisions?: OrderRevisionUncheckedCreateNestedManyWithoutOrderInput
    communications?: OrderCommunicationUncheckedCreateNestedManyWithoutOrderInput
    deliverables?: OrderDeliverableUncheckedCreateNestedManyWithoutOrderInput
  }

  export type AppOrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectType?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requirements?: NullableJsonNullValueInput | InputJsonValue
    timeline?: EnumOrderTimelineFieldUpdateOperationsInput | $Enums.OrderTimeline
    estimatedCost?: FloatFieldUpdateOperationsInput | number
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    priority?: EnumOrderPriorityFieldUpdateOperationsInput | $Enums.OrderPriority
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    githubRepo?: NullableStringFieldUpdateOperationsInput | string | null
    vercelLink?: NullableStringFieldUpdateOperationsInput | string | null
    downloadLink?: NullableStringFieldUpdateOperationsInput | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
    currentMilestone?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAppOrdersNestedInput
    revisions?: OrderRevisionUpdateManyWithoutOrderNestedInput
    communications?: OrderCommunicationUpdateManyWithoutOrderNestedInput
    deliverables?: OrderDeliverableUpdateManyWithoutOrderNestedInput
  }

  export type AppOrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    projectType?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requirements?: NullableJsonNullValueInput | InputJsonValue
    timeline?: EnumOrderTimelineFieldUpdateOperationsInput | $Enums.OrderTimeline
    estimatedCost?: FloatFieldUpdateOperationsInput | number
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    priority?: EnumOrderPriorityFieldUpdateOperationsInput | $Enums.OrderPriority
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    githubRepo?: NullableStringFieldUpdateOperationsInput | string | null
    vercelLink?: NullableStringFieldUpdateOperationsInput | string | null
    downloadLink?: NullableStringFieldUpdateOperationsInput | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
    currentMilestone?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revisions?: OrderRevisionUncheckedUpdateManyWithoutOrderNestedInput
    communications?: OrderCommunicationUncheckedUpdateManyWithoutOrderNestedInput
    deliverables?: OrderDeliverableUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type AppOrderCreateManyInput = {
    id?: string
    userId: string
    projectType: $Enums.ProjectType
    title: string
    description: string
    requirements?: NullableJsonNullValueInput | InputJsonValue
    timeline: $Enums.OrderTimeline
    estimatedCost: number
    actualCost?: number | null
    currency?: string
    status?: $Enums.OrderStatus
    priority?: $Enums.OrderPriority
    deliveryDate?: Date | string | null
    githubRepo?: string | null
    vercelLink?: string | null
    downloadLink?: string | null
    progressPercentage?: number
    currentMilestone?: string | null
    assignedAdminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppOrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectType?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requirements?: NullableJsonNullValueInput | InputJsonValue
    timeline?: EnumOrderTimelineFieldUpdateOperationsInput | $Enums.OrderTimeline
    estimatedCost?: FloatFieldUpdateOperationsInput | number
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    priority?: EnumOrderPriorityFieldUpdateOperationsInput | $Enums.OrderPriority
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    githubRepo?: NullableStringFieldUpdateOperationsInput | string | null
    vercelLink?: NullableStringFieldUpdateOperationsInput | string | null
    downloadLink?: NullableStringFieldUpdateOperationsInput | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
    currentMilestone?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppOrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    projectType?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requirements?: NullableJsonNullValueInput | InputJsonValue
    timeline?: EnumOrderTimelineFieldUpdateOperationsInput | $Enums.OrderTimeline
    estimatedCost?: FloatFieldUpdateOperationsInput | number
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    priority?: EnumOrderPriorityFieldUpdateOperationsInput | $Enums.OrderPriority
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    githubRepo?: NullableStringFieldUpdateOperationsInput | string | null
    vercelLink?: NullableStringFieldUpdateOperationsInput | string | null
    downloadLink?: NullableStringFieldUpdateOperationsInput | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
    currentMilestone?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderRevisionCreateInput = {
    id?: string
    revisionNumber: number
    title: string
    description: string
    status?: $Enums.RevisionStatus
    adminResponse?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order: AppOrderCreateNestedOneWithoutRevisionsInput
    user: UserCreateNestedOneWithoutOrderRevisionsInput
  }

  export type OrderRevisionUncheckedCreateInput = {
    id?: string
    orderId: string
    userId: string
    revisionNumber: number
    title: string
    description: string
    status?: $Enums.RevisionStatus
    adminResponse?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderRevisionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    revisionNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumRevisionStatusFieldUpdateOperationsInput | $Enums.RevisionStatus
    adminResponse?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: AppOrderUpdateOneRequiredWithoutRevisionsNestedInput
    user?: UserUpdateOneRequiredWithoutOrderRevisionsNestedInput
  }

  export type OrderRevisionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    revisionNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumRevisionStatusFieldUpdateOperationsInput | $Enums.RevisionStatus
    adminResponse?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderRevisionCreateManyInput = {
    id?: string
    orderId: string
    userId: string
    revisionNumber: number
    title: string
    description: string
    status?: $Enums.RevisionStatus
    adminResponse?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderRevisionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    revisionNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumRevisionStatusFieldUpdateOperationsInput | $Enums.RevisionStatus
    adminResponse?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderRevisionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    revisionNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumRevisionStatusFieldUpdateOperationsInput | $Enums.RevisionStatus
    adminResponse?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCommunicationCreateInput = {
    id?: string
    messageType: $Enums.CommunicationType
    subject?: string | null
    message: string
    isFromAdmin?: boolean
    attachments?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    important?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    order: AppOrderCreateNestedOneWithoutCommunicationsInput
    user: UserCreateNestedOneWithoutOrderCommunicationsInput
  }

  export type OrderCommunicationUncheckedCreateInput = {
    id?: string
    orderId: string
    userId: string
    messageType: $Enums.CommunicationType
    subject?: string | null
    message: string
    isFromAdmin?: boolean
    attachments?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    important?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCommunicationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageType?: EnumCommunicationTypeFieldUpdateOperationsInput | $Enums.CommunicationType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    isFromAdmin?: BoolFieldUpdateOperationsInput | boolean
    attachments?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    important?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: AppOrderUpdateOneRequiredWithoutCommunicationsNestedInput
    user?: UserUpdateOneRequiredWithoutOrderCommunicationsNestedInput
  }

  export type OrderCommunicationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    messageType?: EnumCommunicationTypeFieldUpdateOperationsInput | $Enums.CommunicationType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    isFromAdmin?: BoolFieldUpdateOperationsInput | boolean
    attachments?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    important?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCommunicationCreateManyInput = {
    id?: string
    orderId: string
    userId: string
    messageType: $Enums.CommunicationType
    subject?: string | null
    message: string
    isFromAdmin?: boolean
    attachments?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    important?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCommunicationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageType?: EnumCommunicationTypeFieldUpdateOperationsInput | $Enums.CommunicationType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    isFromAdmin?: BoolFieldUpdateOperationsInput | boolean
    attachments?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    important?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCommunicationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    messageType?: EnumCommunicationTypeFieldUpdateOperationsInput | $Enums.CommunicationType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    isFromAdmin?: BoolFieldUpdateOperationsInput | boolean
    attachments?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    important?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderDeliverableCreateInput = {
    id?: string
    type: $Enums.DeliverableType
    title: string
    description?: string | null
    url?: string | null
    filePath?: string | null
    status?: $Enums.DeliverableStatus
    delivered?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    order: AppOrderCreateNestedOneWithoutDeliverablesInput
  }

  export type OrderDeliverableUncheckedCreateInput = {
    id?: string
    orderId: string
    type: $Enums.DeliverableType
    title: string
    description?: string | null
    url?: string | null
    filePath?: string | null
    status?: $Enums.DeliverableStatus
    delivered?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderDeliverableUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDeliverableTypeFieldUpdateOperationsInput | $Enums.DeliverableType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeliverableStatusFieldUpdateOperationsInput | $Enums.DeliverableStatus
    delivered?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: AppOrderUpdateOneRequiredWithoutDeliverablesNestedInput
  }

  export type OrderDeliverableUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    type?: EnumDeliverableTypeFieldUpdateOperationsInput | $Enums.DeliverableType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeliverableStatusFieldUpdateOperationsInput | $Enums.DeliverableStatus
    delivered?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderDeliverableCreateManyInput = {
    id?: string
    orderId: string
    type: $Enums.DeliverableType
    title: string
    description?: string | null
    url?: string | null
    filePath?: string | null
    status?: $Enums.DeliverableStatus
    delivered?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderDeliverableUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDeliverableTypeFieldUpdateOperationsInput | $Enums.DeliverableType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeliverableStatusFieldUpdateOperationsInput | $Enums.DeliverableStatus
    delivered?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderDeliverableUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    type?: EnumDeliverableTypeFieldUpdateOperationsInput | $Enums.DeliverableType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeliverableStatusFieldUpdateOperationsInput | $Enums.DeliverableStatus
    delivered?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BettingMarketCreateInput = {
    id?: string
    metricType: $Enums.MarketMetricType
    title: string
    description: string
    currentValue: number
    predictionTarget: number
    targetDirection: $Enums.PredictionDirection
    odds?: number
    totalPot?: number
    minimumBet?: number
    maximumBet?: number | null
    startTime?: Date | string
    expiryDate: Date | string
    settlementDate?: Date | string | null
    status?: $Enums.MarketStatus
    settled?: boolean
    settledValue?: number | null
    winningDirection?: $Enums.PredictionDirection | null
    marketMakerFee?: number
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    card: CardCreateNestedOneWithoutBettingMarketsInput
    positions?: BettingPositionCreateNestedManyWithoutMarketInput
    payouts?: BettingPayoutCreateNestedManyWithoutMarketInput
    metrics?: MarketMetricsCreateNestedManyWithoutMarketInput
  }

  export type BettingMarketUncheckedCreateInput = {
    id?: string
    cardId: string
    metricType: $Enums.MarketMetricType
    title: string
    description: string
    currentValue: number
    predictionTarget: number
    targetDirection: $Enums.PredictionDirection
    odds?: number
    totalPot?: number
    minimumBet?: number
    maximumBet?: number | null
    startTime?: Date | string
    expiryDate: Date | string
    settlementDate?: Date | string | null
    status?: $Enums.MarketStatus
    settled?: boolean
    settledValue?: number | null
    winningDirection?: $Enums.PredictionDirection | null
    marketMakerFee?: number
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    positions?: BettingPositionUncheckedCreateNestedManyWithoutMarketInput
    payouts?: BettingPayoutUncheckedCreateNestedManyWithoutMarketInput
    metrics?: MarketMetricsUncheckedCreateNestedManyWithoutMarketInput
  }

  export type BettingMarketUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    metricType?: EnumMarketMetricTypeFieldUpdateOperationsInput | $Enums.MarketMetricType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    currentValue?: FloatFieldUpdateOperationsInput | number
    predictionTarget?: FloatFieldUpdateOperationsInput | number
    targetDirection?: EnumPredictionDirectionFieldUpdateOperationsInput | $Enums.PredictionDirection
    odds?: FloatFieldUpdateOperationsInput | number
    totalPot?: FloatFieldUpdateOperationsInput | number
    minimumBet?: FloatFieldUpdateOperationsInput | number
    maximumBet?: NullableFloatFieldUpdateOperationsInput | number | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    settlementDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMarketStatusFieldUpdateOperationsInput | $Enums.MarketStatus
    settled?: BoolFieldUpdateOperationsInput | boolean
    settledValue?: NullableFloatFieldUpdateOperationsInput | number | null
    winningDirection?: NullableEnumPredictionDirectionFieldUpdateOperationsInput | $Enums.PredictionDirection | null
    marketMakerFee?: FloatFieldUpdateOperationsInput | number
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    card?: CardUpdateOneRequiredWithoutBettingMarketsNestedInput
    positions?: BettingPositionUpdateManyWithoutMarketNestedInput
    payouts?: BettingPayoutUpdateManyWithoutMarketNestedInput
    metrics?: MarketMetricsUpdateManyWithoutMarketNestedInput
  }

  export type BettingMarketUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardId?: StringFieldUpdateOperationsInput | string
    metricType?: EnumMarketMetricTypeFieldUpdateOperationsInput | $Enums.MarketMetricType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    currentValue?: FloatFieldUpdateOperationsInput | number
    predictionTarget?: FloatFieldUpdateOperationsInput | number
    targetDirection?: EnumPredictionDirectionFieldUpdateOperationsInput | $Enums.PredictionDirection
    odds?: FloatFieldUpdateOperationsInput | number
    totalPot?: FloatFieldUpdateOperationsInput | number
    minimumBet?: FloatFieldUpdateOperationsInput | number
    maximumBet?: NullableFloatFieldUpdateOperationsInput | number | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    settlementDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMarketStatusFieldUpdateOperationsInput | $Enums.MarketStatus
    settled?: BoolFieldUpdateOperationsInput | boolean
    settledValue?: NullableFloatFieldUpdateOperationsInput | number | null
    winningDirection?: NullableEnumPredictionDirectionFieldUpdateOperationsInput | $Enums.PredictionDirection | null
    marketMakerFee?: FloatFieldUpdateOperationsInput | number
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    positions?: BettingPositionUncheckedUpdateManyWithoutMarketNestedInput
    payouts?: BettingPayoutUncheckedUpdateManyWithoutMarketNestedInput
    metrics?: MarketMetricsUncheckedUpdateManyWithoutMarketNestedInput
  }

  export type BettingMarketCreateManyInput = {
    id?: string
    cardId: string
    metricType: $Enums.MarketMetricType
    title: string
    description: string
    currentValue: number
    predictionTarget: number
    targetDirection: $Enums.PredictionDirection
    odds?: number
    totalPot?: number
    minimumBet?: number
    maximumBet?: number | null
    startTime?: Date | string
    expiryDate: Date | string
    settlementDate?: Date | string | null
    status?: $Enums.MarketStatus
    settled?: boolean
    settledValue?: number | null
    winningDirection?: $Enums.PredictionDirection | null
    marketMakerFee?: number
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BettingMarketUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    metricType?: EnumMarketMetricTypeFieldUpdateOperationsInput | $Enums.MarketMetricType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    currentValue?: FloatFieldUpdateOperationsInput | number
    predictionTarget?: FloatFieldUpdateOperationsInput | number
    targetDirection?: EnumPredictionDirectionFieldUpdateOperationsInput | $Enums.PredictionDirection
    odds?: FloatFieldUpdateOperationsInput | number
    totalPot?: FloatFieldUpdateOperationsInput | number
    minimumBet?: FloatFieldUpdateOperationsInput | number
    maximumBet?: NullableFloatFieldUpdateOperationsInput | number | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    settlementDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMarketStatusFieldUpdateOperationsInput | $Enums.MarketStatus
    settled?: BoolFieldUpdateOperationsInput | boolean
    settledValue?: NullableFloatFieldUpdateOperationsInput | number | null
    winningDirection?: NullableEnumPredictionDirectionFieldUpdateOperationsInput | $Enums.PredictionDirection | null
    marketMakerFee?: FloatFieldUpdateOperationsInput | number
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BettingMarketUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardId?: StringFieldUpdateOperationsInput | string
    metricType?: EnumMarketMetricTypeFieldUpdateOperationsInput | $Enums.MarketMetricType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    currentValue?: FloatFieldUpdateOperationsInput | number
    predictionTarget?: FloatFieldUpdateOperationsInput | number
    targetDirection?: EnumPredictionDirectionFieldUpdateOperationsInput | $Enums.PredictionDirection
    odds?: FloatFieldUpdateOperationsInput | number
    totalPot?: FloatFieldUpdateOperationsInput | number
    minimumBet?: FloatFieldUpdateOperationsInput | number
    maximumBet?: NullableFloatFieldUpdateOperationsInput | number | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    settlementDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMarketStatusFieldUpdateOperationsInput | $Enums.MarketStatus
    settled?: BoolFieldUpdateOperationsInput | boolean
    settledValue?: NullableFloatFieldUpdateOperationsInput | number | null
    winningDirection?: NullableEnumPredictionDirectionFieldUpdateOperationsInput | $Enums.PredictionDirection | null
    marketMakerFee?: FloatFieldUpdateOperationsInput | number
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BettingPositionCreateInput = {
    id?: string
    position: $Enums.PredictionDirection
    amount: number
    odds: number
    potentialWinning: number
    pickGroupId?: string | null
    multiplier?: number
    powerPlay?: boolean
    status?: $Enums.PositionStatus
    settled?: boolean
    won?: boolean | null
    payout?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    market: BettingMarketCreateNestedOneWithoutPositionsInput
    user: UserCreateNestedOneWithoutBettingPositionsInput
  }

  export type BettingPositionUncheckedCreateInput = {
    id?: string
    marketId: string
    userId: string
    position: $Enums.PredictionDirection
    amount: number
    odds: number
    potentialWinning: number
    pickGroupId?: string | null
    multiplier?: number
    powerPlay?: boolean
    status?: $Enums.PositionStatus
    settled?: boolean
    won?: boolean | null
    payout?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BettingPositionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: EnumPredictionDirectionFieldUpdateOperationsInput | $Enums.PredictionDirection
    amount?: FloatFieldUpdateOperationsInput | number
    odds?: FloatFieldUpdateOperationsInput | number
    potentialWinning?: FloatFieldUpdateOperationsInput | number
    pickGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    multiplier?: FloatFieldUpdateOperationsInput | number
    powerPlay?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumPositionStatusFieldUpdateOperationsInput | $Enums.PositionStatus
    settled?: BoolFieldUpdateOperationsInput | boolean
    won?: NullableBoolFieldUpdateOperationsInput | boolean | null
    payout?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    market?: BettingMarketUpdateOneRequiredWithoutPositionsNestedInput
    user?: UserUpdateOneRequiredWithoutBettingPositionsNestedInput
  }

  export type BettingPositionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    marketId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    position?: EnumPredictionDirectionFieldUpdateOperationsInput | $Enums.PredictionDirection
    amount?: FloatFieldUpdateOperationsInput | number
    odds?: FloatFieldUpdateOperationsInput | number
    potentialWinning?: FloatFieldUpdateOperationsInput | number
    pickGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    multiplier?: FloatFieldUpdateOperationsInput | number
    powerPlay?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumPositionStatusFieldUpdateOperationsInput | $Enums.PositionStatus
    settled?: BoolFieldUpdateOperationsInput | boolean
    won?: NullableBoolFieldUpdateOperationsInput | boolean | null
    payout?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BettingPositionCreateManyInput = {
    id?: string
    marketId: string
    userId: string
    position: $Enums.PredictionDirection
    amount: number
    odds: number
    potentialWinning: number
    pickGroupId?: string | null
    multiplier?: number
    powerPlay?: boolean
    status?: $Enums.PositionStatus
    settled?: boolean
    won?: boolean | null
    payout?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BettingPositionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: EnumPredictionDirectionFieldUpdateOperationsInput | $Enums.PredictionDirection
    amount?: FloatFieldUpdateOperationsInput | number
    odds?: FloatFieldUpdateOperationsInput | number
    potentialWinning?: FloatFieldUpdateOperationsInput | number
    pickGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    multiplier?: FloatFieldUpdateOperationsInput | number
    powerPlay?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumPositionStatusFieldUpdateOperationsInput | $Enums.PositionStatus
    settled?: BoolFieldUpdateOperationsInput | boolean
    won?: NullableBoolFieldUpdateOperationsInput | boolean | null
    payout?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BettingPositionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    marketId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    position?: EnumPredictionDirectionFieldUpdateOperationsInput | $Enums.PredictionDirection
    amount?: FloatFieldUpdateOperationsInput | number
    odds?: FloatFieldUpdateOperationsInput | number
    potentialWinning?: FloatFieldUpdateOperationsInput | number
    pickGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    multiplier?: FloatFieldUpdateOperationsInput | number
    powerPlay?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumPositionStatusFieldUpdateOperationsInput | $Enums.PositionStatus
    settled?: BoolFieldUpdateOperationsInput | boolean
    won?: NullableBoolFieldUpdateOperationsInput | boolean | null
    payout?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketMetricsCreateInput = {
    id?: string
    revenue?: number | null
    userGrowth?: number | null
    valuation?: number | null
    marketCap?: number | null
    quarterlyGrowth?: number | null
    userEngagement?: number | null
    productLaunches?: number | null
    competitorRank?: number | null
    sentimentScore?: number | null
    trendingScore?: number | null
    socialMentions?: number | null
    recordDate?: Date | string
    dataSource?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    card: CardCreateNestedOneWithoutMarketMetricsInput
    market?: BettingMarketCreateNestedOneWithoutMetricsInput
  }

  export type MarketMetricsUncheckedCreateInput = {
    id?: string
    cardId: string
    marketId?: string | null
    revenue?: number | null
    userGrowth?: number | null
    valuation?: number | null
    marketCap?: number | null
    quarterlyGrowth?: number | null
    userEngagement?: number | null
    productLaunches?: number | null
    competitorRank?: number | null
    sentimentScore?: number | null
    trendingScore?: number | null
    socialMentions?: number | null
    recordDate?: Date | string
    dataSource?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketMetricsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    userGrowth?: NullableFloatFieldUpdateOperationsInput | number | null
    valuation?: NullableFloatFieldUpdateOperationsInput | number | null
    marketCap?: NullableFloatFieldUpdateOperationsInput | number | null
    quarterlyGrowth?: NullableFloatFieldUpdateOperationsInput | number | null
    userEngagement?: NullableFloatFieldUpdateOperationsInput | number | null
    productLaunches?: NullableIntFieldUpdateOperationsInput | number | null
    competitorRank?: NullableIntFieldUpdateOperationsInput | number | null
    sentimentScore?: NullableFloatFieldUpdateOperationsInput | number | null
    trendingScore?: NullableFloatFieldUpdateOperationsInput | number | null
    socialMentions?: NullableIntFieldUpdateOperationsInput | number | null
    recordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dataSource?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    card?: CardUpdateOneRequiredWithoutMarketMetricsNestedInput
    market?: BettingMarketUpdateOneWithoutMetricsNestedInput
  }

  export type MarketMetricsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardId?: StringFieldUpdateOperationsInput | string
    marketId?: NullableStringFieldUpdateOperationsInput | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    userGrowth?: NullableFloatFieldUpdateOperationsInput | number | null
    valuation?: NullableFloatFieldUpdateOperationsInput | number | null
    marketCap?: NullableFloatFieldUpdateOperationsInput | number | null
    quarterlyGrowth?: NullableFloatFieldUpdateOperationsInput | number | null
    userEngagement?: NullableFloatFieldUpdateOperationsInput | number | null
    productLaunches?: NullableIntFieldUpdateOperationsInput | number | null
    competitorRank?: NullableIntFieldUpdateOperationsInput | number | null
    sentimentScore?: NullableFloatFieldUpdateOperationsInput | number | null
    trendingScore?: NullableFloatFieldUpdateOperationsInput | number | null
    socialMentions?: NullableIntFieldUpdateOperationsInput | number | null
    recordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dataSource?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketMetricsCreateManyInput = {
    id?: string
    cardId: string
    marketId?: string | null
    revenue?: number | null
    userGrowth?: number | null
    valuation?: number | null
    marketCap?: number | null
    quarterlyGrowth?: number | null
    userEngagement?: number | null
    productLaunches?: number | null
    competitorRank?: number | null
    sentimentScore?: number | null
    trendingScore?: number | null
    socialMentions?: number | null
    recordDate?: Date | string
    dataSource?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketMetricsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    userGrowth?: NullableFloatFieldUpdateOperationsInput | number | null
    valuation?: NullableFloatFieldUpdateOperationsInput | number | null
    marketCap?: NullableFloatFieldUpdateOperationsInput | number | null
    quarterlyGrowth?: NullableFloatFieldUpdateOperationsInput | number | null
    userEngagement?: NullableFloatFieldUpdateOperationsInput | number | null
    productLaunches?: NullableIntFieldUpdateOperationsInput | number | null
    competitorRank?: NullableIntFieldUpdateOperationsInput | number | null
    sentimentScore?: NullableFloatFieldUpdateOperationsInput | number | null
    trendingScore?: NullableFloatFieldUpdateOperationsInput | number | null
    socialMentions?: NullableIntFieldUpdateOperationsInput | number | null
    recordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dataSource?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketMetricsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardId?: StringFieldUpdateOperationsInput | string
    marketId?: NullableStringFieldUpdateOperationsInput | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    userGrowth?: NullableFloatFieldUpdateOperationsInput | number | null
    valuation?: NullableFloatFieldUpdateOperationsInput | number | null
    marketCap?: NullableFloatFieldUpdateOperationsInput | number | null
    quarterlyGrowth?: NullableFloatFieldUpdateOperationsInput | number | null
    userEngagement?: NullableFloatFieldUpdateOperationsInput | number | null
    productLaunches?: NullableIntFieldUpdateOperationsInput | number | null
    competitorRank?: NullableIntFieldUpdateOperationsInput | number | null
    sentimentScore?: NullableFloatFieldUpdateOperationsInput | number | null
    trendingScore?: NullableFloatFieldUpdateOperationsInput | number | null
    socialMentions?: NullableIntFieldUpdateOperationsInput | number | null
    recordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dataSource?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BettingPayoutCreateInput = {
    id?: string
    positionId: string
    winnings: number
    originalBet: number
    multiplier: number
    status?: $Enums.PayoutStatus
    payoutDate?: Date | string | null
    transactionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    market: BettingMarketCreateNestedOneWithoutPayoutsInput
    user: UserCreateNestedOneWithoutBettingPayoutsInput
  }

  export type BettingPayoutUncheckedCreateInput = {
    id?: string
    marketId: string
    userId: string
    positionId: string
    winnings: number
    originalBet: number
    multiplier: number
    status?: $Enums.PayoutStatus
    payoutDate?: Date | string | null
    transactionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BettingPayoutUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    positionId?: StringFieldUpdateOperationsInput | string
    winnings?: FloatFieldUpdateOperationsInput | number
    originalBet?: FloatFieldUpdateOperationsInput | number
    multiplier?: FloatFieldUpdateOperationsInput | number
    status?: EnumPayoutStatusFieldUpdateOperationsInput | $Enums.PayoutStatus
    payoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    market?: BettingMarketUpdateOneRequiredWithoutPayoutsNestedInput
    user?: UserUpdateOneRequiredWithoutBettingPayoutsNestedInput
  }

  export type BettingPayoutUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    marketId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    positionId?: StringFieldUpdateOperationsInput | string
    winnings?: FloatFieldUpdateOperationsInput | number
    originalBet?: FloatFieldUpdateOperationsInput | number
    multiplier?: FloatFieldUpdateOperationsInput | number
    status?: EnumPayoutStatusFieldUpdateOperationsInput | $Enums.PayoutStatus
    payoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BettingPayoutCreateManyInput = {
    id?: string
    marketId: string
    userId: string
    positionId: string
    winnings: number
    originalBet: number
    multiplier: number
    status?: $Enums.PayoutStatus
    payoutDate?: Date | string | null
    transactionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BettingPayoutUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    positionId?: StringFieldUpdateOperationsInput | string
    winnings?: FloatFieldUpdateOperationsInput | number
    originalBet?: FloatFieldUpdateOperationsInput | number
    multiplier?: FloatFieldUpdateOperationsInput | number
    status?: EnumPayoutStatusFieldUpdateOperationsInput | $Enums.PayoutStatus
    payoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BettingPayoutUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    marketId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    positionId?: StringFieldUpdateOperationsInput | string
    winnings?: FloatFieldUpdateOperationsInput | number
    originalBet?: FloatFieldUpdateOperationsInput | number
    multiplier?: FloatFieldUpdateOperationsInput | number
    status?: EnumPayoutStatusFieldUpdateOperationsInput | $Enums.PayoutStatus
    payoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CardAuctionCreateInput = {
    id?: string
    title: string
    description?: string | null
    startPrice: number
    reservePrice?: number | null
    currentBid?: number | null
    bidIncrement?: number
    startTime?: Date | string
    endTime: Date | string
    autoExtend?: boolean
    status?: $Enums.AuctionStatus
    finalized?: boolean
    viewCount?: number
    watcherCount?: number
    bidCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    card: CardCreateNestedOneWithoutAuctionInput
    owner: UserCreateNestedOneWithoutOwnedAuctionsInput
    conditions?: AuctionConditionsCreateNestedOneWithoutAuctionInput
    winner?: UserCreateNestedOneWithoutWonAuctionsInput
    bids?: AuctionBidCreateNestedManyWithoutAuctionInput
    watchers?: AuctionWatcherCreateNestedManyWithoutAuctionInput
    history?: AuctionHistoryCreateNestedManyWithoutAuctionInput
  }

  export type CardAuctionUncheckedCreateInput = {
    id?: string
    cardId: string
    ownerId: string
    title: string
    description?: string | null
    startPrice: number
    reservePrice?: number | null
    currentBid?: number | null
    bidIncrement?: number
    startTime?: Date | string
    endTime: Date | string
    autoExtend?: boolean
    status?: $Enums.AuctionStatus
    finalized?: boolean
    winnerId?: string | null
    viewCount?: number
    watcherCount?: number
    bidCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    conditions?: AuctionConditionsUncheckedCreateNestedOneWithoutAuctionInput
    bids?: AuctionBidUncheckedCreateNestedManyWithoutAuctionInput
    watchers?: AuctionWatcherUncheckedCreateNestedManyWithoutAuctionInput
    history?: AuctionHistoryUncheckedCreateNestedManyWithoutAuctionInput
  }

  export type CardAuctionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startPrice?: FloatFieldUpdateOperationsInput | number
    reservePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currentBid?: NullableFloatFieldUpdateOperationsInput | number | null
    bidIncrement?: FloatFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    autoExtend?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAuctionStatusFieldUpdateOperationsInput | $Enums.AuctionStatus
    finalized?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    watcherCount?: IntFieldUpdateOperationsInput | number
    bidCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    card?: CardUpdateOneRequiredWithoutAuctionNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedAuctionsNestedInput
    conditions?: AuctionConditionsUpdateOneWithoutAuctionNestedInput
    winner?: UserUpdateOneWithoutWonAuctionsNestedInput
    bids?: AuctionBidUpdateManyWithoutAuctionNestedInput
    watchers?: AuctionWatcherUpdateManyWithoutAuctionNestedInput
    history?: AuctionHistoryUpdateManyWithoutAuctionNestedInput
  }

  export type CardAuctionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startPrice?: FloatFieldUpdateOperationsInput | number
    reservePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currentBid?: NullableFloatFieldUpdateOperationsInput | number | null
    bidIncrement?: FloatFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    autoExtend?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAuctionStatusFieldUpdateOperationsInput | $Enums.AuctionStatus
    finalized?: BoolFieldUpdateOperationsInput | boolean
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    watcherCount?: IntFieldUpdateOperationsInput | number
    bidCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conditions?: AuctionConditionsUncheckedUpdateOneWithoutAuctionNestedInput
    bids?: AuctionBidUncheckedUpdateManyWithoutAuctionNestedInput
    watchers?: AuctionWatcherUncheckedUpdateManyWithoutAuctionNestedInput
    history?: AuctionHistoryUncheckedUpdateManyWithoutAuctionNestedInput
  }

  export type CardAuctionCreateManyInput = {
    id?: string
    cardId: string
    ownerId: string
    title: string
    description?: string | null
    startPrice: number
    reservePrice?: number | null
    currentBid?: number | null
    bidIncrement?: number
    startTime?: Date | string
    endTime: Date | string
    autoExtend?: boolean
    status?: $Enums.AuctionStatus
    finalized?: boolean
    winnerId?: string | null
    viewCount?: number
    watcherCount?: number
    bidCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CardAuctionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startPrice?: FloatFieldUpdateOperationsInput | number
    reservePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currentBid?: NullableFloatFieldUpdateOperationsInput | number | null
    bidIncrement?: FloatFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    autoExtend?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAuctionStatusFieldUpdateOperationsInput | $Enums.AuctionStatus
    finalized?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    watcherCount?: IntFieldUpdateOperationsInput | number
    bidCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CardAuctionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startPrice?: FloatFieldUpdateOperationsInput | number
    reservePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currentBid?: NullableFloatFieldUpdateOperationsInput | number | null
    bidIncrement?: FloatFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    autoExtend?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAuctionStatusFieldUpdateOperationsInput | $Enums.AuctionStatus
    finalized?: BoolFieldUpdateOperationsInput | boolean
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    watcherCount?: IntFieldUpdateOperationsInput | number
    bidCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuctionConditionsCreateInput = {
    id?: string
    proMembersOnly?: boolean
    minimumRating?: number | null
    geographicRestrictions?: AuctionConditionsCreategeographicRestrictionsInput | string[]
    minimumNetWorth?: number | null
    verificationRequired?: boolean
    minimumPortfolioValue?: number | null
    minimumCardsOwned?: number | null
    industryRestrictions?: AuctionConditionsCreateindustryRestrictionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    auction: CardAuctionCreateNestedOneWithoutConditionsInput
  }

  export type AuctionConditionsUncheckedCreateInput = {
    id?: string
    auctionId: string
    proMembersOnly?: boolean
    minimumRating?: number | null
    geographicRestrictions?: AuctionConditionsCreategeographicRestrictionsInput | string[]
    minimumNetWorth?: number | null
    verificationRequired?: boolean
    minimumPortfolioValue?: number | null
    minimumCardsOwned?: number | null
    industryRestrictions?: AuctionConditionsCreateindustryRestrictionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuctionConditionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    proMembersOnly?: BoolFieldUpdateOperationsInput | boolean
    minimumRating?: NullableFloatFieldUpdateOperationsInput | number | null
    geographicRestrictions?: AuctionConditionsUpdategeographicRestrictionsInput | string[]
    minimumNetWorth?: NullableFloatFieldUpdateOperationsInput | number | null
    verificationRequired?: BoolFieldUpdateOperationsInput | boolean
    minimumPortfolioValue?: NullableFloatFieldUpdateOperationsInput | number | null
    minimumCardsOwned?: NullableIntFieldUpdateOperationsInput | number | null
    industryRestrictions?: AuctionConditionsUpdateindustryRestrictionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auction?: CardAuctionUpdateOneRequiredWithoutConditionsNestedInput
  }

  export type AuctionConditionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    auctionId?: StringFieldUpdateOperationsInput | string
    proMembersOnly?: BoolFieldUpdateOperationsInput | boolean
    minimumRating?: NullableFloatFieldUpdateOperationsInput | number | null
    geographicRestrictions?: AuctionConditionsUpdategeographicRestrictionsInput | string[]
    minimumNetWorth?: NullableFloatFieldUpdateOperationsInput | number | null
    verificationRequired?: BoolFieldUpdateOperationsInput | boolean
    minimumPortfolioValue?: NullableFloatFieldUpdateOperationsInput | number | null
    minimumCardsOwned?: NullableIntFieldUpdateOperationsInput | number | null
    industryRestrictions?: AuctionConditionsUpdateindustryRestrictionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuctionConditionsCreateManyInput = {
    id?: string
    auctionId: string
    proMembersOnly?: boolean
    minimumRating?: number | null
    geographicRestrictions?: AuctionConditionsCreategeographicRestrictionsInput | string[]
    minimumNetWorth?: number | null
    verificationRequired?: boolean
    minimumPortfolioValue?: number | null
    minimumCardsOwned?: number | null
    industryRestrictions?: AuctionConditionsCreateindustryRestrictionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuctionConditionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    proMembersOnly?: BoolFieldUpdateOperationsInput | boolean
    minimumRating?: NullableFloatFieldUpdateOperationsInput | number | null
    geographicRestrictions?: AuctionConditionsUpdategeographicRestrictionsInput | string[]
    minimumNetWorth?: NullableFloatFieldUpdateOperationsInput | number | null
    verificationRequired?: BoolFieldUpdateOperationsInput | boolean
    minimumPortfolioValue?: NullableFloatFieldUpdateOperationsInput | number | null
    minimumCardsOwned?: NullableIntFieldUpdateOperationsInput | number | null
    industryRestrictions?: AuctionConditionsUpdateindustryRestrictionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuctionConditionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    auctionId?: StringFieldUpdateOperationsInput | string
    proMembersOnly?: BoolFieldUpdateOperationsInput | boolean
    minimumRating?: NullableFloatFieldUpdateOperationsInput | number | null
    geographicRestrictions?: AuctionConditionsUpdategeographicRestrictionsInput | string[]
    minimumNetWorth?: NullableFloatFieldUpdateOperationsInput | number | null
    verificationRequired?: BoolFieldUpdateOperationsInput | boolean
    minimumPortfolioValue?: NullableFloatFieldUpdateOperationsInput | number | null
    minimumCardsOwned?: NullableIntFieldUpdateOperationsInput | number | null
    industryRestrictions?: AuctionConditionsUpdateindustryRestrictionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuctionBidCreateInput = {
    id?: string
    bidAmount: number
    maxAutoBid?: number | null
    bidType?: $Enums.BidType
    status?: $Enums.AuctionBidStatus
    isWinning?: boolean
    outbidNotified?: boolean
    userAgent?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auction: CardAuctionCreateNestedOneWithoutBidsInput
    bidder: UserCreateNestedOneWithoutPlacedAuctionBidsInput
  }

  export type AuctionBidUncheckedCreateInput = {
    id?: string
    auctionId: string
    bidderId: string
    bidAmount: number
    maxAutoBid?: number | null
    bidType?: $Enums.BidType
    status?: $Enums.AuctionBidStatus
    isWinning?: boolean
    outbidNotified?: boolean
    userAgent?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuctionBidUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bidAmount?: FloatFieldUpdateOperationsInput | number
    maxAutoBid?: NullableFloatFieldUpdateOperationsInput | number | null
    bidType?: EnumBidTypeFieldUpdateOperationsInput | $Enums.BidType
    status?: EnumAuctionBidStatusFieldUpdateOperationsInput | $Enums.AuctionBidStatus
    isWinning?: BoolFieldUpdateOperationsInput | boolean
    outbidNotified?: BoolFieldUpdateOperationsInput | boolean
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auction?: CardAuctionUpdateOneRequiredWithoutBidsNestedInput
    bidder?: UserUpdateOneRequiredWithoutPlacedAuctionBidsNestedInput
  }

  export type AuctionBidUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    auctionId?: StringFieldUpdateOperationsInput | string
    bidderId?: StringFieldUpdateOperationsInput | string
    bidAmount?: FloatFieldUpdateOperationsInput | number
    maxAutoBid?: NullableFloatFieldUpdateOperationsInput | number | null
    bidType?: EnumBidTypeFieldUpdateOperationsInput | $Enums.BidType
    status?: EnumAuctionBidStatusFieldUpdateOperationsInput | $Enums.AuctionBidStatus
    isWinning?: BoolFieldUpdateOperationsInput | boolean
    outbidNotified?: BoolFieldUpdateOperationsInput | boolean
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuctionBidCreateManyInput = {
    id?: string
    auctionId: string
    bidderId: string
    bidAmount: number
    maxAutoBid?: number | null
    bidType?: $Enums.BidType
    status?: $Enums.AuctionBidStatus
    isWinning?: boolean
    outbidNotified?: boolean
    userAgent?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuctionBidUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bidAmount?: FloatFieldUpdateOperationsInput | number
    maxAutoBid?: NullableFloatFieldUpdateOperationsInput | number | null
    bidType?: EnumBidTypeFieldUpdateOperationsInput | $Enums.BidType
    status?: EnumAuctionBidStatusFieldUpdateOperationsInput | $Enums.AuctionBidStatus
    isWinning?: BoolFieldUpdateOperationsInput | boolean
    outbidNotified?: BoolFieldUpdateOperationsInput | boolean
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuctionBidUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    auctionId?: StringFieldUpdateOperationsInput | string
    bidderId?: StringFieldUpdateOperationsInput | string
    bidAmount?: FloatFieldUpdateOperationsInput | number
    maxAutoBid?: NullableFloatFieldUpdateOperationsInput | number | null
    bidType?: EnumBidTypeFieldUpdateOperationsInput | $Enums.BidType
    status?: EnumAuctionBidStatusFieldUpdateOperationsInput | $Enums.AuctionBidStatus
    isWinning?: BoolFieldUpdateOperationsInput | boolean
    outbidNotified?: BoolFieldUpdateOperationsInput | boolean
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuctionWatcherCreateInput = {
    id?: string
    bidNotifications?: boolean
    endingNotifications?: boolean
    priceAlerts?: boolean
    alertThreshold?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auction: CardAuctionCreateNestedOneWithoutWatchersInput
    user: UserCreateNestedOneWithoutWatchedAuctionsInput
  }

  export type AuctionWatcherUncheckedCreateInput = {
    id?: string
    auctionId: string
    userId: string
    bidNotifications?: boolean
    endingNotifications?: boolean
    priceAlerts?: boolean
    alertThreshold?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuctionWatcherUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bidNotifications?: BoolFieldUpdateOperationsInput | boolean
    endingNotifications?: BoolFieldUpdateOperationsInput | boolean
    priceAlerts?: BoolFieldUpdateOperationsInput | boolean
    alertThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auction?: CardAuctionUpdateOneRequiredWithoutWatchersNestedInput
    user?: UserUpdateOneRequiredWithoutWatchedAuctionsNestedInput
  }

  export type AuctionWatcherUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    auctionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bidNotifications?: BoolFieldUpdateOperationsInput | boolean
    endingNotifications?: BoolFieldUpdateOperationsInput | boolean
    priceAlerts?: BoolFieldUpdateOperationsInput | boolean
    alertThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuctionWatcherCreateManyInput = {
    id?: string
    auctionId: string
    userId: string
    bidNotifications?: boolean
    endingNotifications?: boolean
    priceAlerts?: boolean
    alertThreshold?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuctionWatcherUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bidNotifications?: BoolFieldUpdateOperationsInput | boolean
    endingNotifications?: BoolFieldUpdateOperationsInput | boolean
    priceAlerts?: BoolFieldUpdateOperationsInput | boolean
    alertThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuctionWatcherUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    auctionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bidNotifications?: BoolFieldUpdateOperationsInput | boolean
    endingNotifications?: BoolFieldUpdateOperationsInput | boolean
    priceAlerts?: BoolFieldUpdateOperationsInput | boolean
    alertThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuctionHistoryCreateInput = {
    id?: string
    salePrice: number
    sellerId: string
    buyerId: string
    saleType: $Enums.SaleType
    marketTrends?: NullableJsonNullValueInput | InputJsonValue
    priceHistory?: NullableJsonNullValueInput | InputJsonValue
    daysSinceListing?: number | null
    numberOfBids?: number | null
    highestBid?: number | null
    saleDate?: Date | string
    createdAt?: Date | string
    card: CardCreateNestedOneWithoutAuctionHistoryInput
    auction?: CardAuctionCreateNestedOneWithoutHistoryInput
  }

  export type AuctionHistoryUncheckedCreateInput = {
    id?: string
    cardId: string
    auctionId?: string | null
    salePrice: number
    sellerId: string
    buyerId: string
    saleType: $Enums.SaleType
    marketTrends?: NullableJsonNullValueInput | InputJsonValue
    priceHistory?: NullableJsonNullValueInput | InputJsonValue
    daysSinceListing?: number | null
    numberOfBids?: number | null
    highestBid?: number | null
    saleDate?: Date | string
    createdAt?: Date | string
  }

  export type AuctionHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    salePrice?: FloatFieldUpdateOperationsInput | number
    sellerId?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    saleType?: EnumSaleTypeFieldUpdateOperationsInput | $Enums.SaleType
    marketTrends?: NullableJsonNullValueInput | InputJsonValue
    priceHistory?: NullableJsonNullValueInput | InputJsonValue
    daysSinceListing?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBids?: NullableIntFieldUpdateOperationsInput | number | null
    highestBid?: NullableFloatFieldUpdateOperationsInput | number | null
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    card?: CardUpdateOneRequiredWithoutAuctionHistoryNestedInput
    auction?: CardAuctionUpdateOneWithoutHistoryNestedInput
  }

  export type AuctionHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardId?: StringFieldUpdateOperationsInput | string
    auctionId?: NullableStringFieldUpdateOperationsInput | string | null
    salePrice?: FloatFieldUpdateOperationsInput | number
    sellerId?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    saleType?: EnumSaleTypeFieldUpdateOperationsInput | $Enums.SaleType
    marketTrends?: NullableJsonNullValueInput | InputJsonValue
    priceHistory?: NullableJsonNullValueInput | InputJsonValue
    daysSinceListing?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBids?: NullableIntFieldUpdateOperationsInput | number | null
    highestBid?: NullableFloatFieldUpdateOperationsInput | number | null
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuctionHistoryCreateManyInput = {
    id?: string
    cardId: string
    auctionId?: string | null
    salePrice: number
    sellerId: string
    buyerId: string
    saleType: $Enums.SaleType
    marketTrends?: NullableJsonNullValueInput | InputJsonValue
    priceHistory?: NullableJsonNullValueInput | InputJsonValue
    daysSinceListing?: number | null
    numberOfBids?: number | null
    highestBid?: number | null
    saleDate?: Date | string
    createdAt?: Date | string
  }

  export type AuctionHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    salePrice?: FloatFieldUpdateOperationsInput | number
    sellerId?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    saleType?: EnumSaleTypeFieldUpdateOperationsInput | $Enums.SaleType
    marketTrends?: NullableJsonNullValueInput | InputJsonValue
    priceHistory?: NullableJsonNullValueInput | InputJsonValue
    daysSinceListing?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBids?: NullableIntFieldUpdateOperationsInput | number | null
    highestBid?: NullableFloatFieldUpdateOperationsInput | number | null
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuctionHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardId?: StringFieldUpdateOperationsInput | string
    auctionId?: NullableStringFieldUpdateOperationsInput | string | null
    salePrice?: FloatFieldUpdateOperationsInput | number
    sellerId?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    saleType?: EnumSaleTypeFieldUpdateOperationsInput | $Enums.SaleType
    marketTrends?: NullableJsonNullValueInput | InputJsonValue
    priceHistory?: NullableJsonNullValueInput | InputJsonValue
    daysSinceListing?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBids?: NullableIntFieldUpdateOperationsInput | number | null
    highestBid?: NullableFloatFieldUpdateOperationsInput | number | null
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MABattleCreateInput = {
    id?: string
    battleType: $Enums.BattleType
    title: string
    description: string
    stakes: number
    timeline: Date | string
    votingPeriod: Date | string
    status?: $Enums.BattleStatus
    resolved?: boolean
    viewCount?: number
    participantCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    initiatorCard: CardCreateNestedOneWithoutInitiatedBattlesInput
    targetCard: CardCreateNestedOneWithoutTargetedBattlesInput
    initiator: UserCreateNestedOneWithoutInitiatedMABattlesInput
    target?: UserCreateNestedOneWithoutTargetedMABattlesInput
    winner?: BattleOutcomeCreateNestedOneWithoutWinningBattleInput
    proposals?: BattleProposalCreateNestedManyWithoutBattleInput
    votes?: BattleVotingCreateNestedManyWithoutBattleInput
    outcomes?: BattleOutcomeCreateNestedManyWithoutBattleInput
  }

  export type MABattleUncheckedCreateInput = {
    id?: string
    initiatorCardId: string
    targetCardId: string
    initiatorUserId: string
    targetUserId?: string | null
    battleType: $Enums.BattleType
    title: string
    description: string
    stakes: number
    timeline: Date | string
    votingPeriod: Date | string
    status?: $Enums.BattleStatus
    resolved?: boolean
    viewCount?: number
    participantCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    winner?: BattleOutcomeUncheckedCreateNestedOneWithoutWinningBattleInput
    proposals?: BattleProposalUncheckedCreateNestedManyWithoutBattleInput
    votes?: BattleVotingUncheckedCreateNestedManyWithoutBattleInput
    outcomes?: BattleOutcomeUncheckedCreateNestedManyWithoutBattleInput
  }

  export type MABattleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    battleType?: EnumBattleTypeFieldUpdateOperationsInput | $Enums.BattleType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    stakes?: FloatFieldUpdateOperationsInput | number
    timeline?: DateTimeFieldUpdateOperationsInput | Date | string
    votingPeriod?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBattleStatusFieldUpdateOperationsInput | $Enums.BattleStatus
    resolved?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    participantCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    initiatorCard?: CardUpdateOneRequiredWithoutInitiatedBattlesNestedInput
    targetCard?: CardUpdateOneRequiredWithoutTargetedBattlesNestedInput
    initiator?: UserUpdateOneRequiredWithoutInitiatedMABattlesNestedInput
    target?: UserUpdateOneWithoutTargetedMABattlesNestedInput
    winner?: BattleOutcomeUpdateOneWithoutWinningBattleNestedInput
    proposals?: BattleProposalUpdateManyWithoutBattleNestedInput
    votes?: BattleVotingUpdateManyWithoutBattleNestedInput
    outcomes?: BattleOutcomeUpdateManyWithoutBattleNestedInput
  }

  export type MABattleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    initiatorCardId?: StringFieldUpdateOperationsInput | string
    targetCardId?: StringFieldUpdateOperationsInput | string
    initiatorUserId?: StringFieldUpdateOperationsInput | string
    targetUserId?: NullableStringFieldUpdateOperationsInput | string | null
    battleType?: EnumBattleTypeFieldUpdateOperationsInput | $Enums.BattleType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    stakes?: FloatFieldUpdateOperationsInput | number
    timeline?: DateTimeFieldUpdateOperationsInput | Date | string
    votingPeriod?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBattleStatusFieldUpdateOperationsInput | $Enums.BattleStatus
    resolved?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    participantCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    winner?: BattleOutcomeUncheckedUpdateOneWithoutWinningBattleNestedInput
    proposals?: BattleProposalUncheckedUpdateManyWithoutBattleNestedInput
    votes?: BattleVotingUncheckedUpdateManyWithoutBattleNestedInput
    outcomes?: BattleOutcomeUncheckedUpdateManyWithoutBattleNestedInput
  }

  export type MABattleCreateManyInput = {
    id?: string
    initiatorCardId: string
    targetCardId: string
    initiatorUserId: string
    targetUserId?: string | null
    battleType: $Enums.BattleType
    title: string
    description: string
    stakes: number
    timeline: Date | string
    votingPeriod: Date | string
    status?: $Enums.BattleStatus
    resolved?: boolean
    viewCount?: number
    participantCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MABattleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    battleType?: EnumBattleTypeFieldUpdateOperationsInput | $Enums.BattleType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    stakes?: FloatFieldUpdateOperationsInput | number
    timeline?: DateTimeFieldUpdateOperationsInput | Date | string
    votingPeriod?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBattleStatusFieldUpdateOperationsInput | $Enums.BattleStatus
    resolved?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    participantCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MABattleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    initiatorCardId?: StringFieldUpdateOperationsInput | string
    targetCardId?: StringFieldUpdateOperationsInput | string
    initiatorUserId?: StringFieldUpdateOperationsInput | string
    targetUserId?: NullableStringFieldUpdateOperationsInput | string | null
    battleType?: EnumBattleTypeFieldUpdateOperationsInput | $Enums.BattleType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    stakes?: FloatFieldUpdateOperationsInput | number
    timeline?: DateTimeFieldUpdateOperationsInput | Date | string
    votingPeriod?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBattleStatusFieldUpdateOperationsInput | $Enums.BattleStatus
    resolved?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    participantCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BattleProposalCreateInput = {
    id?: string
    proposalType: $Enums.ProposalType
    title: string
    description: string
    terms: JsonNullValueInput | InputJsonValue
    valuation: number
    paymentStructure: JsonNullValueInput | InputJsonValue
    timeline: JsonNullValueInput | InputJsonValue
    synergies: JsonNullValueInput | InputJsonValue
    conditions: JsonNullValueInput | InputJsonValue
    contingencies: JsonNullValueInput | InputJsonValue
    status?: $Enums.ProposalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    battle: MABattleCreateNestedOneWithoutProposalsInput
    proposer: UserCreateNestedOneWithoutBattleProposalsInput
    votes?: BattleVotingCreateNestedManyWithoutProposalInput
  }

  export type BattleProposalUncheckedCreateInput = {
    id?: string
    battleId: string
    proposerId: string
    proposalType: $Enums.ProposalType
    title: string
    description: string
    terms: JsonNullValueInput | InputJsonValue
    valuation: number
    paymentStructure: JsonNullValueInput | InputJsonValue
    timeline: JsonNullValueInput | InputJsonValue
    synergies: JsonNullValueInput | InputJsonValue
    conditions: JsonNullValueInput | InputJsonValue
    contingencies: JsonNullValueInput | InputJsonValue
    status?: $Enums.ProposalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: BattleVotingUncheckedCreateNestedManyWithoutProposalInput
  }

  export type BattleProposalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposalType?: EnumProposalTypeFieldUpdateOperationsInput | $Enums.ProposalType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    terms?: JsonNullValueInput | InputJsonValue
    valuation?: FloatFieldUpdateOperationsInput | number
    paymentStructure?: JsonNullValueInput | InputJsonValue
    timeline?: JsonNullValueInput | InputJsonValue
    synergies?: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    contingencies?: JsonNullValueInput | InputJsonValue
    status?: EnumProposalStatusFieldUpdateOperationsInput | $Enums.ProposalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    battle?: MABattleUpdateOneRequiredWithoutProposalsNestedInput
    proposer?: UserUpdateOneRequiredWithoutBattleProposalsNestedInput
    votes?: BattleVotingUpdateManyWithoutProposalNestedInput
  }

  export type BattleProposalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    battleId?: StringFieldUpdateOperationsInput | string
    proposerId?: StringFieldUpdateOperationsInput | string
    proposalType?: EnumProposalTypeFieldUpdateOperationsInput | $Enums.ProposalType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    terms?: JsonNullValueInput | InputJsonValue
    valuation?: FloatFieldUpdateOperationsInput | number
    paymentStructure?: JsonNullValueInput | InputJsonValue
    timeline?: JsonNullValueInput | InputJsonValue
    synergies?: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    contingencies?: JsonNullValueInput | InputJsonValue
    status?: EnumProposalStatusFieldUpdateOperationsInput | $Enums.ProposalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: BattleVotingUncheckedUpdateManyWithoutProposalNestedInput
  }

  export type BattleProposalCreateManyInput = {
    id?: string
    battleId: string
    proposerId: string
    proposalType: $Enums.ProposalType
    title: string
    description: string
    terms: JsonNullValueInput | InputJsonValue
    valuation: number
    paymentStructure: JsonNullValueInput | InputJsonValue
    timeline: JsonNullValueInput | InputJsonValue
    synergies: JsonNullValueInput | InputJsonValue
    conditions: JsonNullValueInput | InputJsonValue
    contingencies: JsonNullValueInput | InputJsonValue
    status?: $Enums.ProposalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BattleProposalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposalType?: EnumProposalTypeFieldUpdateOperationsInput | $Enums.ProposalType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    terms?: JsonNullValueInput | InputJsonValue
    valuation?: FloatFieldUpdateOperationsInput | number
    paymentStructure?: JsonNullValueInput | InputJsonValue
    timeline?: JsonNullValueInput | InputJsonValue
    synergies?: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    contingencies?: JsonNullValueInput | InputJsonValue
    status?: EnumProposalStatusFieldUpdateOperationsInput | $Enums.ProposalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BattleProposalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    battleId?: StringFieldUpdateOperationsInput | string
    proposerId?: StringFieldUpdateOperationsInput | string
    proposalType?: EnumProposalTypeFieldUpdateOperationsInput | $Enums.ProposalType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    terms?: JsonNullValueInput | InputJsonValue
    valuation?: FloatFieldUpdateOperationsInput | number
    paymentStructure?: JsonNullValueInput | InputJsonValue
    timeline?: JsonNullValueInput | InputJsonValue
    synergies?: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    contingencies?: JsonNullValueInput | InputJsonValue
    status?: EnumProposalStatusFieldUpdateOperationsInput | $Enums.ProposalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BattleVotingCreateInput = {
    id?: string
    vote: $Enums.VoteDirection
    voteWeight: number
    reasoning?: string | null
    confidence?: number | null
    eceStaked?: number | null
    expertRating?: number | null
    portfolioValue?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    battle: MABattleCreateNestedOneWithoutVotesInput
    proposal?: BattleProposalCreateNestedOneWithoutVotesInput
    voter: UserCreateNestedOneWithoutBattleVotesInput
  }

  export type BattleVotingUncheckedCreateInput = {
    id?: string
    battleId: string
    proposalId?: string | null
    voterId: string
    vote: $Enums.VoteDirection
    voteWeight: number
    reasoning?: string | null
    confidence?: number | null
    eceStaked?: number | null
    expertRating?: number | null
    portfolioValue?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BattleVotingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vote?: EnumVoteDirectionFieldUpdateOperationsInput | $Enums.VoteDirection
    voteWeight?: FloatFieldUpdateOperationsInput | number
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    eceStaked?: NullableFloatFieldUpdateOperationsInput | number | null
    expertRating?: NullableFloatFieldUpdateOperationsInput | number | null
    portfolioValue?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    battle?: MABattleUpdateOneRequiredWithoutVotesNestedInput
    proposal?: BattleProposalUpdateOneWithoutVotesNestedInput
    voter?: UserUpdateOneRequiredWithoutBattleVotesNestedInput
  }

  export type BattleVotingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    battleId?: StringFieldUpdateOperationsInput | string
    proposalId?: NullableStringFieldUpdateOperationsInput | string | null
    voterId?: StringFieldUpdateOperationsInput | string
    vote?: EnumVoteDirectionFieldUpdateOperationsInput | $Enums.VoteDirection
    voteWeight?: FloatFieldUpdateOperationsInput | number
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    eceStaked?: NullableFloatFieldUpdateOperationsInput | number | null
    expertRating?: NullableFloatFieldUpdateOperationsInput | number | null
    portfolioValue?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BattleVotingCreateManyInput = {
    id?: string
    battleId: string
    proposalId?: string | null
    voterId: string
    vote: $Enums.VoteDirection
    voteWeight: number
    reasoning?: string | null
    confidence?: number | null
    eceStaked?: number | null
    expertRating?: number | null
    portfolioValue?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BattleVotingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    vote?: EnumVoteDirectionFieldUpdateOperationsInput | $Enums.VoteDirection
    voteWeight?: FloatFieldUpdateOperationsInput | number
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    eceStaked?: NullableFloatFieldUpdateOperationsInput | number | null
    expertRating?: NullableFloatFieldUpdateOperationsInput | number | null
    portfolioValue?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BattleVotingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    battleId?: StringFieldUpdateOperationsInput | string
    proposalId?: NullableStringFieldUpdateOperationsInput | string | null
    voterId?: StringFieldUpdateOperationsInput | string
    vote?: EnumVoteDirectionFieldUpdateOperationsInput | $Enums.VoteDirection
    voteWeight?: FloatFieldUpdateOperationsInput | number
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    eceStaked?: NullableFloatFieldUpdateOperationsInput | number | null
    expertRating?: NullableFloatFieldUpdateOperationsInput | number | null
    portfolioValue?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BattleOutcomeCreateInput = {
    id?: string
    winner: $Enums.BattleWinner
    winningProposalId?: string | null
    finalTerms: JsonNullValueInput | InputJsonValue
    finalValuation: number
    implementation: JsonNullValueInput | InputJsonValue
    stakeholdersPayouts: JsonNullValueInput | InputJsonValue
    tokenRewards: JsonNullValueInput | InputJsonValue
    completionDate?: Date | string | null
    realWorldImpact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    battle: MABattleCreateNestedOneWithoutOutcomesInput
    winningBattle?: MABattleCreateNestedOneWithoutWinnerInput
  }

  export type BattleOutcomeUncheckedCreateInput = {
    id?: string
    battleId: string
    winningBattleId?: string | null
    winner: $Enums.BattleWinner
    winningProposalId?: string | null
    finalTerms: JsonNullValueInput | InputJsonValue
    finalValuation: number
    implementation: JsonNullValueInput | InputJsonValue
    stakeholdersPayouts: JsonNullValueInput | InputJsonValue
    tokenRewards: JsonNullValueInput | InputJsonValue
    completionDate?: Date | string | null
    realWorldImpact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BattleOutcomeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    winner?: EnumBattleWinnerFieldUpdateOperationsInput | $Enums.BattleWinner
    winningProposalId?: NullableStringFieldUpdateOperationsInput | string | null
    finalTerms?: JsonNullValueInput | InputJsonValue
    finalValuation?: FloatFieldUpdateOperationsInput | number
    implementation?: JsonNullValueInput | InputJsonValue
    stakeholdersPayouts?: JsonNullValueInput | InputJsonValue
    tokenRewards?: JsonNullValueInput | InputJsonValue
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    realWorldImpact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    battle?: MABattleUpdateOneRequiredWithoutOutcomesNestedInput
    winningBattle?: MABattleUpdateOneWithoutWinnerNestedInput
  }

  export type BattleOutcomeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    battleId?: StringFieldUpdateOperationsInput | string
    winningBattleId?: NullableStringFieldUpdateOperationsInput | string | null
    winner?: EnumBattleWinnerFieldUpdateOperationsInput | $Enums.BattleWinner
    winningProposalId?: NullableStringFieldUpdateOperationsInput | string | null
    finalTerms?: JsonNullValueInput | InputJsonValue
    finalValuation?: FloatFieldUpdateOperationsInput | number
    implementation?: JsonNullValueInput | InputJsonValue
    stakeholdersPayouts?: JsonNullValueInput | InputJsonValue
    tokenRewards?: JsonNullValueInput | InputJsonValue
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    realWorldImpact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BattleOutcomeCreateManyInput = {
    id?: string
    battleId: string
    winningBattleId?: string | null
    winner: $Enums.BattleWinner
    winningProposalId?: string | null
    finalTerms: JsonNullValueInput | InputJsonValue
    finalValuation: number
    implementation: JsonNullValueInput | InputJsonValue
    stakeholdersPayouts: JsonNullValueInput | InputJsonValue
    tokenRewards: JsonNullValueInput | InputJsonValue
    completionDate?: Date | string | null
    realWorldImpact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BattleOutcomeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    winner?: EnumBattleWinnerFieldUpdateOperationsInput | $Enums.BattleWinner
    winningProposalId?: NullableStringFieldUpdateOperationsInput | string | null
    finalTerms?: JsonNullValueInput | InputJsonValue
    finalValuation?: FloatFieldUpdateOperationsInput | number
    implementation?: JsonNullValueInput | InputJsonValue
    stakeholdersPayouts?: JsonNullValueInput | InputJsonValue
    tokenRewards?: JsonNullValueInput | InputJsonValue
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    realWorldImpact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BattleOutcomeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    battleId?: StringFieldUpdateOperationsInput | string
    winningBattleId?: NullableStringFieldUpdateOperationsInput | string | null
    winner?: EnumBattleWinnerFieldUpdateOperationsInput | $Enums.BattleWinner
    winningProposalId?: NullableStringFieldUpdateOperationsInput | string | null
    finalTerms?: JsonNullValueInput | InputJsonValue
    finalValuation?: FloatFieldUpdateOperationsInput | number
    implementation?: JsonNullValueInput | InputJsonValue
    stakeholdersPayouts?: JsonNullValueInput | InputJsonValue
    tokenRewards?: JsonNullValueInput | InputJsonValue
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    realWorldImpact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StakingPoolCreateInput = {
    id?: string
    name: string
    description?: string | null
    poolType: $Enums.StakingPoolType
    totalStaked?: number
    totalRewards?: number
    apy?: number
    minStakeAmount?: number
    lockupPeriod?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stakes?: StakingPositionCreateNestedManyWithoutPoolInput
    rewards?: StakingRewardCreateNestedManyWithoutPoolInput
  }

  export type StakingPoolUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    poolType: $Enums.StakingPoolType
    totalStaked?: number
    totalRewards?: number
    apy?: number
    minStakeAmount?: number
    lockupPeriod?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stakes?: StakingPositionUncheckedCreateNestedManyWithoutPoolInput
    rewards?: StakingRewardUncheckedCreateNestedManyWithoutPoolInput
  }

  export type StakingPoolUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    poolType?: EnumStakingPoolTypeFieldUpdateOperationsInput | $Enums.StakingPoolType
    totalStaked?: FloatFieldUpdateOperationsInput | number
    totalRewards?: FloatFieldUpdateOperationsInput | number
    apy?: FloatFieldUpdateOperationsInput | number
    minStakeAmount?: FloatFieldUpdateOperationsInput | number
    lockupPeriod?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stakes?: StakingPositionUpdateManyWithoutPoolNestedInput
    rewards?: StakingRewardUpdateManyWithoutPoolNestedInput
  }

  export type StakingPoolUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    poolType?: EnumStakingPoolTypeFieldUpdateOperationsInput | $Enums.StakingPoolType
    totalStaked?: FloatFieldUpdateOperationsInput | number
    totalRewards?: FloatFieldUpdateOperationsInput | number
    apy?: FloatFieldUpdateOperationsInput | number
    minStakeAmount?: FloatFieldUpdateOperationsInput | number
    lockupPeriod?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stakes?: StakingPositionUncheckedUpdateManyWithoutPoolNestedInput
    rewards?: StakingRewardUncheckedUpdateManyWithoutPoolNestedInput
  }

  export type StakingPoolCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    poolType: $Enums.StakingPoolType
    totalStaked?: number
    totalRewards?: number
    apy?: number
    minStakeAmount?: number
    lockupPeriod?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StakingPoolUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    poolType?: EnumStakingPoolTypeFieldUpdateOperationsInput | $Enums.StakingPoolType
    totalStaked?: FloatFieldUpdateOperationsInput | number
    totalRewards?: FloatFieldUpdateOperationsInput | number
    apy?: FloatFieldUpdateOperationsInput | number
    minStakeAmount?: FloatFieldUpdateOperationsInput | number
    lockupPeriod?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StakingPoolUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    poolType?: EnumStakingPoolTypeFieldUpdateOperationsInput | $Enums.StakingPoolType
    totalStaked?: FloatFieldUpdateOperationsInput | number
    totalRewards?: FloatFieldUpdateOperationsInput | number
    apy?: FloatFieldUpdateOperationsInput | number
    minStakeAmount?: FloatFieldUpdateOperationsInput | number
    lockupPeriod?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StakingPositionCreateInput = {
    id?: string
    amount: number
    stakedAt?: Date | string
    unstakedAt?: Date | string | null
    lockupEndsAt?: Date | string | null
    isActive?: boolean
    user: UserCreateNestedOneWithoutStakingPositionsInput
    pool: StakingPoolCreateNestedOneWithoutStakesInput
    rewards?: StakingRewardCreateNestedManyWithoutPositionInput
  }

  export type StakingPositionUncheckedCreateInput = {
    id?: string
    userId: string
    poolId: string
    amount: number
    stakedAt?: Date | string
    unstakedAt?: Date | string | null
    lockupEndsAt?: Date | string | null
    isActive?: boolean
    rewards?: StakingRewardUncheckedCreateNestedManyWithoutPositionInput
  }

  export type StakingPositionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    stakedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unstakedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockupEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutStakingPositionsNestedInput
    pool?: StakingPoolUpdateOneRequiredWithoutStakesNestedInput
    rewards?: StakingRewardUpdateManyWithoutPositionNestedInput
  }

  export type StakingPositionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    poolId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    stakedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unstakedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockupEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    rewards?: StakingRewardUncheckedUpdateManyWithoutPositionNestedInput
  }

  export type StakingPositionCreateManyInput = {
    id?: string
    userId: string
    poolId: string
    amount: number
    stakedAt?: Date | string
    unstakedAt?: Date | string | null
    lockupEndsAt?: Date | string | null
    isActive?: boolean
  }

  export type StakingPositionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    stakedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unstakedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockupEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StakingPositionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    poolId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    stakedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unstakedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockupEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StakingRewardCreateInput = {
    id?: string
    amount: number
    rewardType: $Enums.StakingRewardType
    claimedAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutStakingRewardsInput
    pool: StakingPoolCreateNestedOneWithoutRewardsInput
    position: StakingPositionCreateNestedOneWithoutRewardsInput
  }

  export type StakingRewardUncheckedCreateInput = {
    id?: string
    userId: string
    poolId: string
    positionId: string
    amount: number
    rewardType: $Enums.StakingRewardType
    claimedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type StakingRewardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    rewardType?: EnumStakingRewardTypeFieldUpdateOperationsInput | $Enums.StakingRewardType
    claimedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStakingRewardsNestedInput
    pool?: StakingPoolUpdateOneRequiredWithoutRewardsNestedInput
    position?: StakingPositionUpdateOneRequiredWithoutRewardsNestedInput
  }

  export type StakingRewardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    poolId?: StringFieldUpdateOperationsInput | string
    positionId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    rewardType?: EnumStakingRewardTypeFieldUpdateOperationsInput | $Enums.StakingRewardType
    claimedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StakingRewardCreateManyInput = {
    id?: string
    userId: string
    poolId: string
    positionId: string
    amount: number
    rewardType: $Enums.StakingRewardType
    claimedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type StakingRewardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    rewardType?: EnumStakingRewardTypeFieldUpdateOperationsInput | $Enums.StakingRewardType
    claimedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StakingRewardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    poolId?: StringFieldUpdateOperationsInput | string
    positionId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    rewardType?: EnumStakingRewardTypeFieldUpdateOperationsInput | $Enums.StakingRewardType
    claimedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GovernanceProposalCreateInput = {
    id?: string
    title: string
    description: string
    proposalType: $Enums.ProposalType
    status?: $Enums.GovernanceStatus
    votingStartsAt: Date | string
    votingEndsAt: Date | string
    executionDate?: Date | string | null
    minQuorum?: number
    minApproval?: number
    totalVotes?: number
    yesVotes?: number
    noVotes?: number
    abstainVotes?: number
    isExecuted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    proposer: UserCreateNestedOneWithoutGovernanceProposalsInput
    votes?: GovernanceVoteCreateNestedManyWithoutProposalInput
  }

  export type GovernanceProposalUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    proposalType: $Enums.ProposalType
    proposerId: string
    status?: $Enums.GovernanceStatus
    votingStartsAt: Date | string
    votingEndsAt: Date | string
    executionDate?: Date | string | null
    minQuorum?: number
    minApproval?: number
    totalVotes?: number
    yesVotes?: number
    noVotes?: number
    abstainVotes?: number
    isExecuted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    votes?: GovernanceVoteUncheckedCreateNestedManyWithoutProposalInput
  }

  export type GovernanceProposalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    proposalType?: EnumProposalTypeFieldUpdateOperationsInput | $Enums.ProposalType
    status?: EnumGovernanceStatusFieldUpdateOperationsInput | $Enums.GovernanceStatus
    votingStartsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votingEndsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    minQuorum?: FloatFieldUpdateOperationsInput | number
    minApproval?: FloatFieldUpdateOperationsInput | number
    totalVotes?: FloatFieldUpdateOperationsInput | number
    yesVotes?: FloatFieldUpdateOperationsInput | number
    noVotes?: FloatFieldUpdateOperationsInput | number
    abstainVotes?: FloatFieldUpdateOperationsInput | number
    isExecuted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    proposer?: UserUpdateOneRequiredWithoutGovernanceProposalsNestedInput
    votes?: GovernanceVoteUpdateManyWithoutProposalNestedInput
  }

  export type GovernanceProposalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    proposalType?: EnumProposalTypeFieldUpdateOperationsInput | $Enums.ProposalType
    proposerId?: StringFieldUpdateOperationsInput | string
    status?: EnumGovernanceStatusFieldUpdateOperationsInput | $Enums.GovernanceStatus
    votingStartsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votingEndsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    minQuorum?: FloatFieldUpdateOperationsInput | number
    minApproval?: FloatFieldUpdateOperationsInput | number
    totalVotes?: FloatFieldUpdateOperationsInput | number
    yesVotes?: FloatFieldUpdateOperationsInput | number
    noVotes?: FloatFieldUpdateOperationsInput | number
    abstainVotes?: FloatFieldUpdateOperationsInput | number
    isExecuted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    votes?: GovernanceVoteUncheckedUpdateManyWithoutProposalNestedInput
  }

  export type GovernanceProposalCreateManyInput = {
    id?: string
    title: string
    description: string
    proposalType: $Enums.ProposalType
    proposerId: string
    status?: $Enums.GovernanceStatus
    votingStartsAt: Date | string
    votingEndsAt: Date | string
    executionDate?: Date | string | null
    minQuorum?: number
    minApproval?: number
    totalVotes?: number
    yesVotes?: number
    noVotes?: number
    abstainVotes?: number
    isExecuted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
  }

  export type GovernanceProposalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    proposalType?: EnumProposalTypeFieldUpdateOperationsInput | $Enums.ProposalType
    status?: EnumGovernanceStatusFieldUpdateOperationsInput | $Enums.GovernanceStatus
    votingStartsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votingEndsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    minQuorum?: FloatFieldUpdateOperationsInput | number
    minApproval?: FloatFieldUpdateOperationsInput | number
    totalVotes?: FloatFieldUpdateOperationsInput | number
    yesVotes?: FloatFieldUpdateOperationsInput | number
    noVotes?: FloatFieldUpdateOperationsInput | number
    abstainVotes?: FloatFieldUpdateOperationsInput | number
    isExecuted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
  }

  export type GovernanceProposalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    proposalType?: EnumProposalTypeFieldUpdateOperationsInput | $Enums.ProposalType
    proposerId?: StringFieldUpdateOperationsInput | string
    status?: EnumGovernanceStatusFieldUpdateOperationsInput | $Enums.GovernanceStatus
    votingStartsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votingEndsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    minQuorum?: FloatFieldUpdateOperationsInput | number
    minApproval?: FloatFieldUpdateOperationsInput | number
    totalVotes?: FloatFieldUpdateOperationsInput | number
    yesVotes?: FloatFieldUpdateOperationsInput | number
    noVotes?: FloatFieldUpdateOperationsInput | number
    abstainVotes?: FloatFieldUpdateOperationsInput | number
    isExecuted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
  }

  export type GovernanceVoteCreateInput = {
    id?: string
    voteChoice: $Enums.VoteChoice
    votingPower: number
    reason?: string | null
    votedAt?: Date | string
    proposal: GovernanceProposalCreateNestedOneWithoutVotesInput
    user: UserCreateNestedOneWithoutGovernanceVotesInput
  }

  export type GovernanceVoteUncheckedCreateInput = {
    id?: string
    proposalId: string
    userId: string
    voteChoice: $Enums.VoteChoice
    votingPower: number
    reason?: string | null
    votedAt?: Date | string
  }

  export type GovernanceVoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    voteChoice?: EnumVoteChoiceFieldUpdateOperationsInput | $Enums.VoteChoice
    votingPower?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    votedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proposal?: GovernanceProposalUpdateOneRequiredWithoutVotesNestedInput
    user?: UserUpdateOneRequiredWithoutGovernanceVotesNestedInput
  }

  export type GovernanceVoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposalId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    voteChoice?: EnumVoteChoiceFieldUpdateOperationsInput | $Enums.VoteChoice
    votingPower?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    votedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GovernanceVoteCreateManyInput = {
    id?: string
    proposalId: string
    userId: string
    voteChoice: $Enums.VoteChoice
    votingPower: number
    reason?: string | null
    votedAt?: Date | string
  }

  export type GovernanceVoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    voteChoice?: EnumVoteChoiceFieldUpdateOperationsInput | $Enums.VoteChoice
    votingPower?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    votedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GovernanceVoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposalId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    voteChoice?: EnumVoteChoiceFieldUpdateOperationsInput | $Enums.VoteChoice
    votingPower?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    votedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserSubscriptionNullableScalarRelationFilter = {
    is?: UserSubscriptionWhereInput | null
    isNot?: UserSubscriptionWhereInput | null
  }

  export type CryptoWalletListRelationFilter = {
    every?: CryptoWalletWhereInput
    some?: CryptoWalletWhereInput
    none?: CryptoWalletWhereInput
  }

  export type PhysicalCardNullableScalarRelationFilter = {
    is?: PhysicalCardWhereInput | null
    isNot?: PhysicalCardWhereInput | null
  }

  export type CardListRelationFilter = {
    every?: CardWhereInput
    some?: CardWhereInput
    none?: CardWhereInput
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type BidListRelationFilter = {
    every?: BidWhereInput
    some?: BidWhereInput
    none?: BidWhereInput
  }

  export type MarketplaceListingListRelationFilter = {
    every?: MarketplaceListingWhereInput
    some?: MarketplaceListingWhereInput
    none?: MarketplaceListingWhereInput
  }

  export type AppOrderListRelationFilter = {
    every?: AppOrderWhereInput
    some?: AppOrderWhereInput
    none?: AppOrderWhereInput
  }

  export type OrderRevisionListRelationFilter = {
    every?: OrderRevisionWhereInput
    some?: OrderRevisionWhereInput
    none?: OrderRevisionWhereInput
  }

  export type OrderCommunicationListRelationFilter = {
    every?: OrderCommunicationWhereInput
    some?: OrderCommunicationWhereInput
    none?: OrderCommunicationWhereInput
  }

  export type BettingPositionListRelationFilter = {
    every?: BettingPositionWhereInput
    some?: BettingPositionWhereInput
    none?: BettingPositionWhereInput
  }

  export type BettingPayoutListRelationFilter = {
    every?: BettingPayoutWhereInput
    some?: BettingPayoutWhereInput
    none?: BettingPayoutWhereInput
  }

  export type CardAuctionListRelationFilter = {
    every?: CardAuctionWhereInput
    some?: CardAuctionWhereInput
    none?: CardAuctionWhereInput
  }

  export type AuctionBidListRelationFilter = {
    every?: AuctionBidWhereInput
    some?: AuctionBidWhereInput
    none?: AuctionBidWhereInput
  }

  export type AuctionWatcherListRelationFilter = {
    every?: AuctionWatcherWhereInput
    some?: AuctionWatcherWhereInput
    none?: AuctionWatcherWhereInput
  }

  export type MABattleListRelationFilter = {
    every?: MABattleWhereInput
    some?: MABattleWhereInput
    none?: MABattleWhereInput
  }

  export type BattleProposalListRelationFilter = {
    every?: BattleProposalWhereInput
    some?: BattleProposalWhereInput
    none?: BattleProposalWhereInput
  }

  export type BattleVotingListRelationFilter = {
    every?: BattleVotingWhereInput
    some?: BattleVotingWhereInput
    none?: BattleVotingWhereInput
  }

  export type StakingPositionListRelationFilter = {
    every?: StakingPositionWhereInput
    some?: StakingPositionWhereInput
    none?: StakingPositionWhereInput
  }

  export type StakingRewardListRelationFilter = {
    every?: StakingRewardWhereInput
    some?: StakingRewardWhereInput
    none?: StakingRewardWhereInput
  }

  export type GovernanceProposalListRelationFilter = {
    every?: GovernanceProposalWhereInput
    some?: GovernanceProposalWhereInput
    none?: GovernanceProposalWhereInput
  }

  export type GovernanceVoteListRelationFilter = {
    every?: GovernanceVoteWhereInput
    some?: GovernanceVoteWhereInput
    none?: GovernanceVoteWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type SocialFeedListRelationFilter = {
    every?: SocialFeedWhereInput
    some?: SocialFeedWhereInput
    none?: SocialFeedWhereInput
  }

  export type FollowListRelationFilter = {
    every?: FollowWhereInput
    some?: FollowWhereInput
    none?: FollowWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CryptoWalletOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BidOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MarketplaceListingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AppOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderRevisionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderCommunicationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BettingPositionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BettingPayoutOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CardAuctionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuctionBidOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuctionWatcherOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MABattleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BattleProposalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BattleVotingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StakingPositionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StakingRewardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GovernanceProposalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GovernanceVoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SocialFeedOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FollowOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    avatar?: SortOrder
    passwordHash?: SortOrder
    emailVerified?: SortOrder
    eceBalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastActive?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    eceBalance?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    avatar?: SortOrder
    passwordHash?: SortOrder
    emailVerified?: SortOrder
    eceBalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastActive?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    avatar?: SortOrder
    passwordHash?: SortOrder
    emailVerified?: SortOrder
    eceBalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastActive?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    eceBalance?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumSubscriptionPlanFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionPlanFilter<$PrismaModel> | $Enums.SubscriptionPlan
  }

  export type EnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SubscriptionFeaturesNullableScalarRelationFilter = {
    is?: SubscriptionFeaturesWhereInput | null
    isNot?: SubscriptionFeaturesWhereInput | null
  }

  export type SubscriptionUsageNullableScalarRelationFilter = {
    is?: SubscriptionUsageWhereInput | null
    isNot?: SubscriptionUsageWhereInput | null
  }

  export type UserSubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumSubscriptionPlanWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionPlanWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionPlan
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionPlanFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionPlanFilter<$PrismaModel>
  }

  export type EnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type UserSubscriptionScalarRelationFilter = {
    is?: UserSubscriptionWhereInput
    isNot?: UserSubscriptionWhereInput
  }

  export type SubscriptionFeaturesCountOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    maxTrades?: SortOrder
    advancedAnalytics?: SortOrder
    prioritySupport?: SortOrder
    marketplaceAccess?: SortOrder
    premiumListings?: SortOrder
    bulkOperations?: SortOrder
    cryptoPayments?: SortOrder
    physicalCard?: SortOrder
    businessStipend?: SortOrder
    withdrawalLimit?: SortOrder
  }

  export type SubscriptionFeaturesAvgOrderByAggregateInput = {
    maxTrades?: SortOrder
    businessStipend?: SortOrder
    withdrawalLimit?: SortOrder
  }

  export type SubscriptionFeaturesMaxOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    maxTrades?: SortOrder
    advancedAnalytics?: SortOrder
    prioritySupport?: SortOrder
    marketplaceAccess?: SortOrder
    premiumListings?: SortOrder
    bulkOperations?: SortOrder
    cryptoPayments?: SortOrder
    physicalCard?: SortOrder
    businessStipend?: SortOrder
    withdrawalLimit?: SortOrder
  }

  export type SubscriptionFeaturesMinOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    maxTrades?: SortOrder
    advancedAnalytics?: SortOrder
    prioritySupport?: SortOrder
    marketplaceAccess?: SortOrder
    premiumListings?: SortOrder
    bulkOperations?: SortOrder
    cryptoPayments?: SortOrder
    physicalCard?: SortOrder
    businessStipend?: SortOrder
    withdrawalLimit?: SortOrder
  }

  export type SubscriptionFeaturesSumOrderByAggregateInput = {
    maxTrades?: SortOrder
    businessStipend?: SortOrder
    withdrawalLimit?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type SubscriptionUsageCountOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    tradesThisMonth?: SortOrder
    listingsThisMonth?: SortOrder
    stipendUsed?: SortOrder
    lastResetAt?: SortOrder
  }

  export type SubscriptionUsageAvgOrderByAggregateInput = {
    tradesThisMonth?: SortOrder
    listingsThisMonth?: SortOrder
    stipendUsed?: SortOrder
  }

  export type SubscriptionUsageMaxOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    tradesThisMonth?: SortOrder
    listingsThisMonth?: SortOrder
    stipendUsed?: SortOrder
    lastResetAt?: SortOrder
  }

  export type SubscriptionUsageMinOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    tradesThisMonth?: SortOrder
    listingsThisMonth?: SortOrder
    stipendUsed?: SortOrder
    lastResetAt?: SortOrder
  }

  export type SubscriptionUsageSumOrderByAggregateInput = {
    tradesThisMonth?: SortOrder
    listingsThisMonth?: SortOrder
    stipendUsed?: SortOrder
  }

  export type EnumCardCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.CardCategory | EnumCardCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.CardCategory[] | ListEnumCardCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.CardCategory[] | ListEnumCardCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumCardCategoryFilter<$PrismaModel> | $Enums.CardCategory
  }

  export type EnumCardRarityFilter<$PrismaModel = never> = {
    equals?: $Enums.CardRarity | EnumCardRarityFieldRefInput<$PrismaModel>
    in?: $Enums.CardRarity[] | ListEnumCardRarityFieldRefInput<$PrismaModel>
    notIn?: $Enums.CardRarity[] | ListEnumCardRarityFieldRefInput<$PrismaModel>
    not?: NestedEnumCardRarityFilter<$PrismaModel> | $Enums.CardRarity
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type MarketplaceListingNullableScalarRelationFilter = {
    is?: MarketplaceListingWhereInput | null
    isNot?: MarketplaceListingWhereInput | null
  }

  export type BettingMarketListRelationFilter = {
    every?: BettingMarketWhereInput
    some?: BettingMarketWhereInput
    none?: BettingMarketWhereInput
  }

  export type MarketMetricsListRelationFilter = {
    every?: MarketMetricsWhereInput
    some?: MarketMetricsWhereInput
    none?: MarketMetricsWhereInput
  }

  export type CardAuctionNullableScalarRelationFilter = {
    is?: CardAuctionWhereInput | null
    isNot?: CardAuctionWhereInput | null
  }

  export type AuctionHistoryListRelationFilter = {
    every?: AuctionHistoryWhereInput
    some?: AuctionHistoryWhereInput
    none?: AuctionHistoryWhereInput
  }

  export type BettingMarketOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MarketMetricsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuctionHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CardCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    rarity?: SortOrder
    company?: SortOrder
    currentPrice?: SortOrder
    historicalPrices?: SortOrder
    imageUrl?: SortOrder
    metadata?: SortOrder
    stats?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CardAvgOrderByAggregateInput = {
    currentPrice?: SortOrder
  }

  export type CardMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    rarity?: SortOrder
    company?: SortOrder
    currentPrice?: SortOrder
    imageUrl?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CardMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    rarity?: SortOrder
    company?: SortOrder
    currentPrice?: SortOrder
    imageUrl?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CardSumOrderByAggregateInput = {
    currentPrice?: SortOrder
  }

  export type EnumCardCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CardCategory | EnumCardCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.CardCategory[] | ListEnumCardCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.CardCategory[] | ListEnumCardCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumCardCategoryWithAggregatesFilter<$PrismaModel> | $Enums.CardCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCardCategoryFilter<$PrismaModel>
    _max?: NestedEnumCardCategoryFilter<$PrismaModel>
  }

  export type EnumCardRarityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CardRarity | EnumCardRarityFieldRefInput<$PrismaModel>
    in?: $Enums.CardRarity[] | ListEnumCardRarityFieldRefInput<$PrismaModel>
    notIn?: $Enums.CardRarity[] | ListEnumCardRarityFieldRefInput<$PrismaModel>
    not?: NestedEnumCardRarityWithAggregatesFilter<$PrismaModel> | $Enums.CardRarity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCardRarityFilter<$PrismaModel>
    _max?: NestedEnumCardRarityFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumListingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ListingType | EnumListingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ListingType[] | ListEnumListingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ListingType[] | ListEnumListingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumListingTypeFilter<$PrismaModel> | $Enums.ListingType
  }

  export type EnumListingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ListingStatus | EnumListingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumListingStatusFilter<$PrismaModel> | $Enums.ListingStatus
  }

  export type CardScalarRelationFilter = {
    is?: CardWhereInput
    isNot?: CardWhereInput
  }

  export type MarketplaceListingCountOrderByAggregateInput = {
    id?: SortOrder
    cardId?: SortOrder
    sellerId?: SortOrder
    price?: SortOrder
    listingType?: SortOrder
    auctionEnd?: SortOrder
    status?: SortOrder
    featured?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketplaceListingAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type MarketplaceListingMaxOrderByAggregateInput = {
    id?: SortOrder
    cardId?: SortOrder
    sellerId?: SortOrder
    price?: SortOrder
    listingType?: SortOrder
    auctionEnd?: SortOrder
    status?: SortOrder
    featured?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketplaceListingMinOrderByAggregateInput = {
    id?: SortOrder
    cardId?: SortOrder
    sellerId?: SortOrder
    price?: SortOrder
    listingType?: SortOrder
    auctionEnd?: SortOrder
    status?: SortOrder
    featured?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketplaceListingSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type EnumListingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ListingType | EnumListingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ListingType[] | ListEnumListingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ListingType[] | ListEnumListingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumListingTypeWithAggregatesFilter<$PrismaModel> | $Enums.ListingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumListingTypeFilter<$PrismaModel>
    _max?: NestedEnumListingTypeFilter<$PrismaModel>
  }

  export type EnumListingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ListingStatus | EnumListingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumListingStatusWithAggregatesFilter<$PrismaModel> | $Enums.ListingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumListingStatusFilter<$PrismaModel>
    _max?: NestedEnumListingStatusFilter<$PrismaModel>
  }

  export type EnumBidStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BidStatus | EnumBidStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BidStatus[] | ListEnumBidStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BidStatus[] | ListEnumBidStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBidStatusFilter<$PrismaModel> | $Enums.BidStatus
  }

  export type MarketplaceListingScalarRelationFilter = {
    is?: MarketplaceListingWhereInput
    isNot?: MarketplaceListingWhereInput
  }

  export type BidCountOrderByAggregateInput = {
    id?: SortOrder
    listingId?: SortOrder
    bidderId?: SortOrder
    cardId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BidAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type BidMaxOrderByAggregateInput = {
    id?: SortOrder
    listingId?: SortOrder
    bidderId?: SortOrder
    cardId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BidMinOrderByAggregateInput = {
    id?: SortOrder
    listingId?: SortOrder
    bidderId?: SortOrder
    cardId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BidSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumBidStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BidStatus | EnumBidStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BidStatus[] | ListEnumBidStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BidStatus[] | ListEnumBidStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBidStatusWithAggregatesFilter<$PrismaModel> | $Enums.BidStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBidStatusFilter<$PrismaModel>
    _max?: NestedEnumBidStatusFilter<$PrismaModel>
  }

  export type EnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type EnumTransactionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusFilter<$PrismaModel> | $Enums.TransactionStatus
  }

  export type CardNullableScalarRelationFilter = {
    is?: CardWhereInput | null
    isNot?: CardWhereInput | null
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    cardId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    description?: SortOrder
    metadata?: SortOrder
    paymentMethod?: SortOrder
    paymentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    cardId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    description?: SortOrder
    paymentMethod?: SortOrder
    paymentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    cardId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    description?: SortOrder
    paymentMethod?: SortOrder
    paymentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type EnumTransactionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransactionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionStatusFilter<$PrismaModel>
    _max?: NestedEnumTransactionStatusFilter<$PrismaModel>
  }

  export type CryptoWalletUserIdCurrencyCompoundUniqueInput = {
    userId: string
    currency: string
  }

  export type CryptoWalletCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    currency?: SortOrder
    address?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CryptoWalletAvgOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type CryptoWalletMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    currency?: SortOrder
    address?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CryptoWalletMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    currency?: SortOrder
    address?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CryptoWalletSumOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type EnumPhysicalCardStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PhysicalCardStatus | EnumPhysicalCardStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PhysicalCardStatus[] | ListEnumPhysicalCardStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PhysicalCardStatus[] | ListEnumPhysicalCardStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPhysicalCardStatusFilter<$PrismaModel> | $Enums.PhysicalCardStatus
  }

  export type PhysicalCardCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    cardNumber?: SortOrder
    expiryDate?: SortOrder
    cvv?: SortOrder
    status?: SortOrder
    appleWalletPassId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PhysicalCardMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    cardNumber?: SortOrder
    expiryDate?: SortOrder
    cvv?: SortOrder
    status?: SortOrder
    appleWalletPassId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PhysicalCardMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    cardNumber?: SortOrder
    expiryDate?: SortOrder
    cvv?: SortOrder
    status?: SortOrder
    appleWalletPassId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumPhysicalCardStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PhysicalCardStatus | EnumPhysicalCardStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PhysicalCardStatus[] | ListEnumPhysicalCardStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PhysicalCardStatus[] | ListEnumPhysicalCardStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPhysicalCardStatusWithAggregatesFilter<$PrismaModel> | $Enums.PhysicalCardStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPhysicalCardStatusFilter<$PrismaModel>
    _max?: NestedEnumPhysicalCardStatusFilter<$PrismaModel>
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type EnumNotificationPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationPriority | EnumNotificationPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationPriorityFilter<$PrismaModel> | $Enums.NotificationPriority
  }

  export type EnumSubscriptionPlanNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel> | null
    in?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSubscriptionPlanNullableFilter<$PrismaModel> | $Enums.SubscriptionPlan | null
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    data?: SortOrder
    read?: SortOrder
    priority?: SortOrder
    requiresSubscription?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    priority?: SortOrder
    requiresSubscription?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    priority?: SortOrder
    requiresSubscription?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type EnumNotificationPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationPriority | EnumNotificationPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationPriorityWithAggregatesFilter<$PrismaModel> | $Enums.NotificationPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationPriorityFilter<$PrismaModel>
    _max?: NestedEnumNotificationPriorityFilter<$PrismaModel>
  }

  export type EnumSubscriptionPlanNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel> | null
    in?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSubscriptionPlanNullableWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionPlan | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionPlanNullableFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionPlanNullableFilter<$PrismaModel>
  }

  export type EnumSocialFeedTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SocialFeedType | EnumSocialFeedTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SocialFeedType[] | ListEnumSocialFeedTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SocialFeedType[] | ListEnumSocialFeedTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSocialFeedTypeFilter<$PrismaModel> | $Enums.SocialFeedType
  }

  export type EnumSocialVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.SocialVisibility | EnumSocialVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.SocialVisibility[] | ListEnumSocialVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.SocialVisibility[] | ListEnumSocialVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumSocialVisibilityFilter<$PrismaModel> | $Enums.SocialVisibility
  }

  export type SocialFeedCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    data?: SortOrder
    likes?: SortOrder
    comments?: SortOrder
    shares?: SortOrder
    visibility?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SocialFeedAvgOrderByAggregateInput = {
    likes?: SortOrder
    comments?: SortOrder
    shares?: SortOrder
  }

  export type SocialFeedMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    likes?: SortOrder
    comments?: SortOrder
    shares?: SortOrder
    visibility?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SocialFeedMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    likes?: SortOrder
    comments?: SortOrder
    shares?: SortOrder
    visibility?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SocialFeedSumOrderByAggregateInput = {
    likes?: SortOrder
    comments?: SortOrder
    shares?: SortOrder
  }

  export type EnumSocialFeedTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SocialFeedType | EnumSocialFeedTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SocialFeedType[] | ListEnumSocialFeedTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SocialFeedType[] | ListEnumSocialFeedTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSocialFeedTypeWithAggregatesFilter<$PrismaModel> | $Enums.SocialFeedType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSocialFeedTypeFilter<$PrismaModel>
    _max?: NestedEnumSocialFeedTypeFilter<$PrismaModel>
  }

  export type EnumSocialVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SocialVisibility | EnumSocialVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.SocialVisibility[] | ListEnumSocialVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.SocialVisibility[] | ListEnumSocialVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumSocialVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.SocialVisibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSocialVisibilityFilter<$PrismaModel>
    _max?: NestedEnumSocialVisibilityFilter<$PrismaModel>
  }

  export type FollowFollowerIdFollowingIdCompoundUniqueInput = {
    followerId: string
    followingId: string
  }

  export type FollowCountOrderByAggregateInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingId?: SortOrder
    createdAt?: SortOrder
  }

  export type FollowMaxOrderByAggregateInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingId?: SortOrder
    createdAt?: SortOrder
  }

  export type FollowMinOrderByAggregateInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumProjectTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectType | EnumProjectTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectType[] | ListEnumProjectTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectType[] | ListEnumProjectTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectTypeFilter<$PrismaModel> | $Enums.ProjectType
  }

  export type EnumOrderTimelineFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderTimeline | EnumOrderTimelineFieldRefInput<$PrismaModel>
    in?: $Enums.OrderTimeline[] | ListEnumOrderTimelineFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderTimeline[] | ListEnumOrderTimelineFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderTimelineFilter<$PrismaModel> | $Enums.OrderTimeline
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type EnumOrderPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderPriority | EnumOrderPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.OrderPriority[] | ListEnumOrderPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderPriority[] | ListEnumOrderPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderPriorityFilter<$PrismaModel> | $Enums.OrderPriority
  }

  export type OrderDeliverableListRelationFilter = {
    every?: OrderDeliverableWhereInput
    some?: OrderDeliverableWhereInput
    none?: OrderDeliverableWhereInput
  }

  export type OrderDeliverableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AppOrderCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    projectType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    requirements?: SortOrder
    timeline?: SortOrder
    estimatedCost?: SortOrder
    actualCost?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    deliveryDate?: SortOrder
    githubRepo?: SortOrder
    vercelLink?: SortOrder
    downloadLink?: SortOrder
    progressPercentage?: SortOrder
    currentMilestone?: SortOrder
    assignedAdminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AppOrderAvgOrderByAggregateInput = {
    estimatedCost?: SortOrder
    actualCost?: SortOrder
    progressPercentage?: SortOrder
  }

  export type AppOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    projectType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    timeline?: SortOrder
    estimatedCost?: SortOrder
    actualCost?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    deliveryDate?: SortOrder
    githubRepo?: SortOrder
    vercelLink?: SortOrder
    downloadLink?: SortOrder
    progressPercentage?: SortOrder
    currentMilestone?: SortOrder
    assignedAdminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AppOrderMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    projectType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    timeline?: SortOrder
    estimatedCost?: SortOrder
    actualCost?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    deliveryDate?: SortOrder
    githubRepo?: SortOrder
    vercelLink?: SortOrder
    downloadLink?: SortOrder
    progressPercentage?: SortOrder
    currentMilestone?: SortOrder
    assignedAdminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AppOrderSumOrderByAggregateInput = {
    estimatedCost?: SortOrder
    actualCost?: SortOrder
    progressPercentage?: SortOrder
  }

  export type EnumProjectTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectType | EnumProjectTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectType[] | ListEnumProjectTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectType[] | ListEnumProjectTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProjectType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectTypeFilter<$PrismaModel>
    _max?: NestedEnumProjectTypeFilter<$PrismaModel>
  }

  export type EnumOrderTimelineWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderTimeline | EnumOrderTimelineFieldRefInput<$PrismaModel>
    in?: $Enums.OrderTimeline[] | ListEnumOrderTimelineFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderTimeline[] | ListEnumOrderTimelineFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderTimelineWithAggregatesFilter<$PrismaModel> | $Enums.OrderTimeline
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderTimelineFilter<$PrismaModel>
    _max?: NestedEnumOrderTimelineFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type EnumOrderPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderPriority | EnumOrderPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.OrderPriority[] | ListEnumOrderPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderPriority[] | ListEnumOrderPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderPriorityWithAggregatesFilter<$PrismaModel> | $Enums.OrderPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderPriorityFilter<$PrismaModel>
    _max?: NestedEnumOrderPriorityFilter<$PrismaModel>
  }

  export type EnumRevisionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RevisionStatus | EnumRevisionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RevisionStatus[] | ListEnumRevisionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RevisionStatus[] | ListEnumRevisionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRevisionStatusFilter<$PrismaModel> | $Enums.RevisionStatus
  }

  export type AppOrderScalarRelationFilter = {
    is?: AppOrderWhereInput
    isNot?: AppOrderWhereInput
  }

  export type OrderRevisionCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    userId?: SortOrder
    revisionNumber?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    adminResponse?: SortOrder
    adminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderRevisionAvgOrderByAggregateInput = {
    revisionNumber?: SortOrder
  }

  export type OrderRevisionMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    userId?: SortOrder
    revisionNumber?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    adminResponse?: SortOrder
    adminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderRevisionMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    userId?: SortOrder
    revisionNumber?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    adminResponse?: SortOrder
    adminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderRevisionSumOrderByAggregateInput = {
    revisionNumber?: SortOrder
  }

  export type EnumRevisionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RevisionStatus | EnumRevisionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RevisionStatus[] | ListEnumRevisionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RevisionStatus[] | ListEnumRevisionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRevisionStatusWithAggregatesFilter<$PrismaModel> | $Enums.RevisionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRevisionStatusFilter<$PrismaModel>
    _max?: NestedEnumRevisionStatusFilter<$PrismaModel>
  }

  export type EnumCommunicationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CommunicationType | EnumCommunicationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CommunicationType[] | ListEnumCommunicationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommunicationType[] | ListEnumCommunicationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCommunicationTypeFilter<$PrismaModel> | $Enums.CommunicationType
  }

  export type OrderCommunicationCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    userId?: SortOrder
    messageType?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    isFromAdmin?: SortOrder
    attachments?: SortOrder
    read?: SortOrder
    important?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderCommunicationMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    userId?: SortOrder
    messageType?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    isFromAdmin?: SortOrder
    read?: SortOrder
    important?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderCommunicationMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    userId?: SortOrder
    messageType?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    isFromAdmin?: SortOrder
    read?: SortOrder
    important?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumCommunicationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CommunicationType | EnumCommunicationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CommunicationType[] | ListEnumCommunicationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommunicationType[] | ListEnumCommunicationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCommunicationTypeWithAggregatesFilter<$PrismaModel> | $Enums.CommunicationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCommunicationTypeFilter<$PrismaModel>
    _max?: NestedEnumCommunicationTypeFilter<$PrismaModel>
  }

  export type EnumDeliverableTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliverableType | EnumDeliverableTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DeliverableType[] | ListEnumDeliverableTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeliverableType[] | ListEnumDeliverableTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDeliverableTypeFilter<$PrismaModel> | $Enums.DeliverableType
  }

  export type EnumDeliverableStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliverableStatus | EnumDeliverableStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeliverableStatus[] | ListEnumDeliverableStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeliverableStatus[] | ListEnumDeliverableStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDeliverableStatusFilter<$PrismaModel> | $Enums.DeliverableStatus
  }

  export type OrderDeliverableCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    url?: SortOrder
    filePath?: SortOrder
    status?: SortOrder
    delivered?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderDeliverableMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    url?: SortOrder
    filePath?: SortOrder
    status?: SortOrder
    delivered?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderDeliverableMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    url?: SortOrder
    filePath?: SortOrder
    status?: SortOrder
    delivered?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDeliverableTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliverableType | EnumDeliverableTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DeliverableType[] | ListEnumDeliverableTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeliverableType[] | ListEnumDeliverableTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDeliverableTypeWithAggregatesFilter<$PrismaModel> | $Enums.DeliverableType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeliverableTypeFilter<$PrismaModel>
    _max?: NestedEnumDeliverableTypeFilter<$PrismaModel>
  }

  export type EnumDeliverableStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliverableStatus | EnumDeliverableStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeliverableStatus[] | ListEnumDeliverableStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeliverableStatus[] | ListEnumDeliverableStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDeliverableStatusWithAggregatesFilter<$PrismaModel> | $Enums.DeliverableStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeliverableStatusFilter<$PrismaModel>
    _max?: NestedEnumDeliverableStatusFilter<$PrismaModel>
  }

  export type EnumMarketMetricTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MarketMetricType | EnumMarketMetricTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MarketMetricType[] | ListEnumMarketMetricTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MarketMetricType[] | ListEnumMarketMetricTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMarketMetricTypeFilter<$PrismaModel> | $Enums.MarketMetricType
  }

  export type EnumPredictionDirectionFilter<$PrismaModel = never> = {
    equals?: $Enums.PredictionDirection | EnumPredictionDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.PredictionDirection[] | ListEnumPredictionDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.PredictionDirection[] | ListEnumPredictionDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumPredictionDirectionFilter<$PrismaModel> | $Enums.PredictionDirection
  }

  export type EnumMarketStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MarketStatus | EnumMarketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MarketStatus[] | ListEnumMarketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MarketStatus[] | ListEnumMarketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMarketStatusFilter<$PrismaModel> | $Enums.MarketStatus
  }

  export type EnumPredictionDirectionNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PredictionDirection | EnumPredictionDirectionFieldRefInput<$PrismaModel> | null
    in?: $Enums.PredictionDirection[] | ListEnumPredictionDirectionFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PredictionDirection[] | ListEnumPredictionDirectionFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPredictionDirectionNullableFilter<$PrismaModel> | $Enums.PredictionDirection | null
  }

  export type BettingMarketCountOrderByAggregateInput = {
    id?: SortOrder
    cardId?: SortOrder
    metricType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    currentValue?: SortOrder
    predictionTarget?: SortOrder
    targetDirection?: SortOrder
    odds?: SortOrder
    totalPot?: SortOrder
    minimumBet?: SortOrder
    maximumBet?: SortOrder
    startTime?: SortOrder
    expiryDate?: SortOrder
    settlementDate?: SortOrder
    status?: SortOrder
    settled?: SortOrder
    settledValue?: SortOrder
    winningDirection?: SortOrder
    marketMakerFee?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BettingMarketAvgOrderByAggregateInput = {
    currentValue?: SortOrder
    predictionTarget?: SortOrder
    odds?: SortOrder
    totalPot?: SortOrder
    minimumBet?: SortOrder
    maximumBet?: SortOrder
    settledValue?: SortOrder
    marketMakerFee?: SortOrder
  }

  export type BettingMarketMaxOrderByAggregateInput = {
    id?: SortOrder
    cardId?: SortOrder
    metricType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    currentValue?: SortOrder
    predictionTarget?: SortOrder
    targetDirection?: SortOrder
    odds?: SortOrder
    totalPot?: SortOrder
    minimumBet?: SortOrder
    maximumBet?: SortOrder
    startTime?: SortOrder
    expiryDate?: SortOrder
    settlementDate?: SortOrder
    status?: SortOrder
    settled?: SortOrder
    settledValue?: SortOrder
    winningDirection?: SortOrder
    marketMakerFee?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BettingMarketMinOrderByAggregateInput = {
    id?: SortOrder
    cardId?: SortOrder
    metricType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    currentValue?: SortOrder
    predictionTarget?: SortOrder
    targetDirection?: SortOrder
    odds?: SortOrder
    totalPot?: SortOrder
    minimumBet?: SortOrder
    maximumBet?: SortOrder
    startTime?: SortOrder
    expiryDate?: SortOrder
    settlementDate?: SortOrder
    status?: SortOrder
    settled?: SortOrder
    settledValue?: SortOrder
    winningDirection?: SortOrder
    marketMakerFee?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BettingMarketSumOrderByAggregateInput = {
    currentValue?: SortOrder
    predictionTarget?: SortOrder
    odds?: SortOrder
    totalPot?: SortOrder
    minimumBet?: SortOrder
    maximumBet?: SortOrder
    settledValue?: SortOrder
    marketMakerFee?: SortOrder
  }

  export type EnumMarketMetricTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MarketMetricType | EnumMarketMetricTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MarketMetricType[] | ListEnumMarketMetricTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MarketMetricType[] | ListEnumMarketMetricTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMarketMetricTypeWithAggregatesFilter<$PrismaModel> | $Enums.MarketMetricType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMarketMetricTypeFilter<$PrismaModel>
    _max?: NestedEnumMarketMetricTypeFilter<$PrismaModel>
  }

  export type EnumPredictionDirectionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PredictionDirection | EnumPredictionDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.PredictionDirection[] | ListEnumPredictionDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.PredictionDirection[] | ListEnumPredictionDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumPredictionDirectionWithAggregatesFilter<$PrismaModel> | $Enums.PredictionDirection
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPredictionDirectionFilter<$PrismaModel>
    _max?: NestedEnumPredictionDirectionFilter<$PrismaModel>
  }

  export type EnumMarketStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MarketStatus | EnumMarketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MarketStatus[] | ListEnumMarketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MarketStatus[] | ListEnumMarketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMarketStatusWithAggregatesFilter<$PrismaModel> | $Enums.MarketStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMarketStatusFilter<$PrismaModel>
    _max?: NestedEnumMarketStatusFilter<$PrismaModel>
  }

  export type EnumPredictionDirectionNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PredictionDirection | EnumPredictionDirectionFieldRefInput<$PrismaModel> | null
    in?: $Enums.PredictionDirection[] | ListEnumPredictionDirectionFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PredictionDirection[] | ListEnumPredictionDirectionFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPredictionDirectionNullableWithAggregatesFilter<$PrismaModel> | $Enums.PredictionDirection | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPredictionDirectionNullableFilter<$PrismaModel>
    _max?: NestedEnumPredictionDirectionNullableFilter<$PrismaModel>
  }

  export type EnumPositionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PositionStatus | EnumPositionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PositionStatus[] | ListEnumPositionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PositionStatus[] | ListEnumPositionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPositionStatusFilter<$PrismaModel> | $Enums.PositionStatus
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type BettingMarketScalarRelationFilter = {
    is?: BettingMarketWhereInput
    isNot?: BettingMarketWhereInput
  }

  export type BettingPositionCountOrderByAggregateInput = {
    id?: SortOrder
    marketId?: SortOrder
    userId?: SortOrder
    position?: SortOrder
    amount?: SortOrder
    odds?: SortOrder
    potentialWinning?: SortOrder
    pickGroupId?: SortOrder
    multiplier?: SortOrder
    powerPlay?: SortOrder
    status?: SortOrder
    settled?: SortOrder
    won?: SortOrder
    payout?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BettingPositionAvgOrderByAggregateInput = {
    amount?: SortOrder
    odds?: SortOrder
    potentialWinning?: SortOrder
    multiplier?: SortOrder
    payout?: SortOrder
  }

  export type BettingPositionMaxOrderByAggregateInput = {
    id?: SortOrder
    marketId?: SortOrder
    userId?: SortOrder
    position?: SortOrder
    amount?: SortOrder
    odds?: SortOrder
    potentialWinning?: SortOrder
    pickGroupId?: SortOrder
    multiplier?: SortOrder
    powerPlay?: SortOrder
    status?: SortOrder
    settled?: SortOrder
    won?: SortOrder
    payout?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BettingPositionMinOrderByAggregateInput = {
    id?: SortOrder
    marketId?: SortOrder
    userId?: SortOrder
    position?: SortOrder
    amount?: SortOrder
    odds?: SortOrder
    potentialWinning?: SortOrder
    pickGroupId?: SortOrder
    multiplier?: SortOrder
    powerPlay?: SortOrder
    status?: SortOrder
    settled?: SortOrder
    won?: SortOrder
    payout?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BettingPositionSumOrderByAggregateInput = {
    amount?: SortOrder
    odds?: SortOrder
    potentialWinning?: SortOrder
    multiplier?: SortOrder
    payout?: SortOrder
  }

  export type EnumPositionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PositionStatus | EnumPositionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PositionStatus[] | ListEnumPositionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PositionStatus[] | ListEnumPositionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPositionStatusWithAggregatesFilter<$PrismaModel> | $Enums.PositionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPositionStatusFilter<$PrismaModel>
    _max?: NestedEnumPositionStatusFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BettingMarketNullableScalarRelationFilter = {
    is?: BettingMarketWhereInput | null
    isNot?: BettingMarketWhereInput | null
  }

  export type MarketMetricsCountOrderByAggregateInput = {
    id?: SortOrder
    cardId?: SortOrder
    marketId?: SortOrder
    revenue?: SortOrder
    userGrowth?: SortOrder
    valuation?: SortOrder
    marketCap?: SortOrder
    quarterlyGrowth?: SortOrder
    userEngagement?: SortOrder
    productLaunches?: SortOrder
    competitorRank?: SortOrder
    sentimentScore?: SortOrder
    trendingScore?: SortOrder
    socialMentions?: SortOrder
    recordDate?: SortOrder
    dataSource?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketMetricsAvgOrderByAggregateInput = {
    revenue?: SortOrder
    userGrowth?: SortOrder
    valuation?: SortOrder
    marketCap?: SortOrder
    quarterlyGrowth?: SortOrder
    userEngagement?: SortOrder
    productLaunches?: SortOrder
    competitorRank?: SortOrder
    sentimentScore?: SortOrder
    trendingScore?: SortOrder
    socialMentions?: SortOrder
  }

  export type MarketMetricsMaxOrderByAggregateInput = {
    id?: SortOrder
    cardId?: SortOrder
    marketId?: SortOrder
    revenue?: SortOrder
    userGrowth?: SortOrder
    valuation?: SortOrder
    marketCap?: SortOrder
    quarterlyGrowth?: SortOrder
    userEngagement?: SortOrder
    productLaunches?: SortOrder
    competitorRank?: SortOrder
    sentimentScore?: SortOrder
    trendingScore?: SortOrder
    socialMentions?: SortOrder
    recordDate?: SortOrder
    dataSource?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketMetricsMinOrderByAggregateInput = {
    id?: SortOrder
    cardId?: SortOrder
    marketId?: SortOrder
    revenue?: SortOrder
    userGrowth?: SortOrder
    valuation?: SortOrder
    marketCap?: SortOrder
    quarterlyGrowth?: SortOrder
    userEngagement?: SortOrder
    productLaunches?: SortOrder
    competitorRank?: SortOrder
    sentimentScore?: SortOrder
    trendingScore?: SortOrder
    socialMentions?: SortOrder
    recordDate?: SortOrder
    dataSource?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketMetricsSumOrderByAggregateInput = {
    revenue?: SortOrder
    userGrowth?: SortOrder
    valuation?: SortOrder
    marketCap?: SortOrder
    quarterlyGrowth?: SortOrder
    userEngagement?: SortOrder
    productLaunches?: SortOrder
    competitorRank?: SortOrder
    sentimentScore?: SortOrder
    trendingScore?: SortOrder
    socialMentions?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumPayoutStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PayoutStatus | EnumPayoutStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PayoutStatus[] | ListEnumPayoutStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayoutStatus[] | ListEnumPayoutStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPayoutStatusFilter<$PrismaModel> | $Enums.PayoutStatus
  }

  export type BettingPayoutCountOrderByAggregateInput = {
    id?: SortOrder
    marketId?: SortOrder
    userId?: SortOrder
    positionId?: SortOrder
    winnings?: SortOrder
    originalBet?: SortOrder
    multiplier?: SortOrder
    status?: SortOrder
    payoutDate?: SortOrder
    transactionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BettingPayoutAvgOrderByAggregateInput = {
    winnings?: SortOrder
    originalBet?: SortOrder
    multiplier?: SortOrder
  }

  export type BettingPayoutMaxOrderByAggregateInput = {
    id?: SortOrder
    marketId?: SortOrder
    userId?: SortOrder
    positionId?: SortOrder
    winnings?: SortOrder
    originalBet?: SortOrder
    multiplier?: SortOrder
    status?: SortOrder
    payoutDate?: SortOrder
    transactionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BettingPayoutMinOrderByAggregateInput = {
    id?: SortOrder
    marketId?: SortOrder
    userId?: SortOrder
    positionId?: SortOrder
    winnings?: SortOrder
    originalBet?: SortOrder
    multiplier?: SortOrder
    status?: SortOrder
    payoutDate?: SortOrder
    transactionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BettingPayoutSumOrderByAggregateInput = {
    winnings?: SortOrder
    originalBet?: SortOrder
    multiplier?: SortOrder
  }

  export type EnumPayoutStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PayoutStatus | EnumPayoutStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PayoutStatus[] | ListEnumPayoutStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayoutStatus[] | ListEnumPayoutStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPayoutStatusWithAggregatesFilter<$PrismaModel> | $Enums.PayoutStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPayoutStatusFilter<$PrismaModel>
    _max?: NestedEnumPayoutStatusFilter<$PrismaModel>
  }

  export type EnumAuctionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AuctionStatus | EnumAuctionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AuctionStatus[] | ListEnumAuctionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuctionStatus[] | ListEnumAuctionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAuctionStatusFilter<$PrismaModel> | $Enums.AuctionStatus
  }

  export type AuctionConditionsNullableScalarRelationFilter = {
    is?: AuctionConditionsWhereInput | null
    isNot?: AuctionConditionsWhereInput | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type CardAuctionCountOrderByAggregateInput = {
    id?: SortOrder
    cardId?: SortOrder
    ownerId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startPrice?: SortOrder
    reservePrice?: SortOrder
    currentBid?: SortOrder
    bidIncrement?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    autoExtend?: SortOrder
    status?: SortOrder
    finalized?: SortOrder
    winnerId?: SortOrder
    viewCount?: SortOrder
    watcherCount?: SortOrder
    bidCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CardAuctionAvgOrderByAggregateInput = {
    startPrice?: SortOrder
    reservePrice?: SortOrder
    currentBid?: SortOrder
    bidIncrement?: SortOrder
    viewCount?: SortOrder
    watcherCount?: SortOrder
    bidCount?: SortOrder
  }

  export type CardAuctionMaxOrderByAggregateInput = {
    id?: SortOrder
    cardId?: SortOrder
    ownerId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startPrice?: SortOrder
    reservePrice?: SortOrder
    currentBid?: SortOrder
    bidIncrement?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    autoExtend?: SortOrder
    status?: SortOrder
    finalized?: SortOrder
    winnerId?: SortOrder
    viewCount?: SortOrder
    watcherCount?: SortOrder
    bidCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CardAuctionMinOrderByAggregateInput = {
    id?: SortOrder
    cardId?: SortOrder
    ownerId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startPrice?: SortOrder
    reservePrice?: SortOrder
    currentBid?: SortOrder
    bidIncrement?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    autoExtend?: SortOrder
    status?: SortOrder
    finalized?: SortOrder
    winnerId?: SortOrder
    viewCount?: SortOrder
    watcherCount?: SortOrder
    bidCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CardAuctionSumOrderByAggregateInput = {
    startPrice?: SortOrder
    reservePrice?: SortOrder
    currentBid?: SortOrder
    bidIncrement?: SortOrder
    viewCount?: SortOrder
    watcherCount?: SortOrder
    bidCount?: SortOrder
  }

  export type EnumAuctionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuctionStatus | EnumAuctionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AuctionStatus[] | ListEnumAuctionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuctionStatus[] | ListEnumAuctionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAuctionStatusWithAggregatesFilter<$PrismaModel> | $Enums.AuctionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuctionStatusFilter<$PrismaModel>
    _max?: NestedEnumAuctionStatusFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type CardAuctionScalarRelationFilter = {
    is?: CardAuctionWhereInput
    isNot?: CardAuctionWhereInput
  }

  export type AuctionConditionsCountOrderByAggregateInput = {
    id?: SortOrder
    auctionId?: SortOrder
    proMembersOnly?: SortOrder
    minimumRating?: SortOrder
    geographicRestrictions?: SortOrder
    minimumNetWorth?: SortOrder
    verificationRequired?: SortOrder
    minimumPortfolioValue?: SortOrder
    minimumCardsOwned?: SortOrder
    industryRestrictions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuctionConditionsAvgOrderByAggregateInput = {
    minimumRating?: SortOrder
    minimumNetWorth?: SortOrder
    minimumPortfolioValue?: SortOrder
    minimumCardsOwned?: SortOrder
  }

  export type AuctionConditionsMaxOrderByAggregateInput = {
    id?: SortOrder
    auctionId?: SortOrder
    proMembersOnly?: SortOrder
    minimumRating?: SortOrder
    minimumNetWorth?: SortOrder
    verificationRequired?: SortOrder
    minimumPortfolioValue?: SortOrder
    minimumCardsOwned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuctionConditionsMinOrderByAggregateInput = {
    id?: SortOrder
    auctionId?: SortOrder
    proMembersOnly?: SortOrder
    minimumRating?: SortOrder
    minimumNetWorth?: SortOrder
    verificationRequired?: SortOrder
    minimumPortfolioValue?: SortOrder
    minimumCardsOwned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuctionConditionsSumOrderByAggregateInput = {
    minimumRating?: SortOrder
    minimumNetWorth?: SortOrder
    minimumPortfolioValue?: SortOrder
    minimumCardsOwned?: SortOrder
  }

  export type EnumBidTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BidType | EnumBidTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BidType[] | ListEnumBidTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BidType[] | ListEnumBidTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBidTypeFilter<$PrismaModel> | $Enums.BidType
  }

  export type EnumAuctionBidStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AuctionBidStatus | EnumAuctionBidStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AuctionBidStatus[] | ListEnumAuctionBidStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuctionBidStatus[] | ListEnumAuctionBidStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAuctionBidStatusFilter<$PrismaModel> | $Enums.AuctionBidStatus
  }

  export type AuctionBidCountOrderByAggregateInput = {
    id?: SortOrder
    auctionId?: SortOrder
    bidderId?: SortOrder
    bidAmount?: SortOrder
    maxAutoBid?: SortOrder
    bidType?: SortOrder
    status?: SortOrder
    isWinning?: SortOrder
    outbidNotified?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuctionBidAvgOrderByAggregateInput = {
    bidAmount?: SortOrder
    maxAutoBid?: SortOrder
  }

  export type AuctionBidMaxOrderByAggregateInput = {
    id?: SortOrder
    auctionId?: SortOrder
    bidderId?: SortOrder
    bidAmount?: SortOrder
    maxAutoBid?: SortOrder
    bidType?: SortOrder
    status?: SortOrder
    isWinning?: SortOrder
    outbidNotified?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuctionBidMinOrderByAggregateInput = {
    id?: SortOrder
    auctionId?: SortOrder
    bidderId?: SortOrder
    bidAmount?: SortOrder
    maxAutoBid?: SortOrder
    bidType?: SortOrder
    status?: SortOrder
    isWinning?: SortOrder
    outbidNotified?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuctionBidSumOrderByAggregateInput = {
    bidAmount?: SortOrder
    maxAutoBid?: SortOrder
  }

  export type EnumBidTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BidType | EnumBidTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BidType[] | ListEnumBidTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BidType[] | ListEnumBidTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBidTypeWithAggregatesFilter<$PrismaModel> | $Enums.BidType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBidTypeFilter<$PrismaModel>
    _max?: NestedEnumBidTypeFilter<$PrismaModel>
  }

  export type EnumAuctionBidStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuctionBidStatus | EnumAuctionBidStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AuctionBidStatus[] | ListEnumAuctionBidStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuctionBidStatus[] | ListEnumAuctionBidStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAuctionBidStatusWithAggregatesFilter<$PrismaModel> | $Enums.AuctionBidStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuctionBidStatusFilter<$PrismaModel>
    _max?: NestedEnumAuctionBidStatusFilter<$PrismaModel>
  }

  export type AuctionWatcherAuctionIdUserIdCompoundUniqueInput = {
    auctionId: string
    userId: string
  }

  export type AuctionWatcherCountOrderByAggregateInput = {
    id?: SortOrder
    auctionId?: SortOrder
    userId?: SortOrder
    bidNotifications?: SortOrder
    endingNotifications?: SortOrder
    priceAlerts?: SortOrder
    alertThreshold?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuctionWatcherAvgOrderByAggregateInput = {
    alertThreshold?: SortOrder
  }

  export type AuctionWatcherMaxOrderByAggregateInput = {
    id?: SortOrder
    auctionId?: SortOrder
    userId?: SortOrder
    bidNotifications?: SortOrder
    endingNotifications?: SortOrder
    priceAlerts?: SortOrder
    alertThreshold?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuctionWatcherMinOrderByAggregateInput = {
    id?: SortOrder
    auctionId?: SortOrder
    userId?: SortOrder
    bidNotifications?: SortOrder
    endingNotifications?: SortOrder
    priceAlerts?: SortOrder
    alertThreshold?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuctionWatcherSumOrderByAggregateInput = {
    alertThreshold?: SortOrder
  }

  export type EnumSaleTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SaleType | EnumSaleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SaleType[] | ListEnumSaleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SaleType[] | ListEnumSaleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSaleTypeFilter<$PrismaModel> | $Enums.SaleType
  }

  export type AuctionHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    cardId?: SortOrder
    auctionId?: SortOrder
    salePrice?: SortOrder
    sellerId?: SortOrder
    buyerId?: SortOrder
    saleType?: SortOrder
    marketTrends?: SortOrder
    priceHistory?: SortOrder
    daysSinceListing?: SortOrder
    numberOfBids?: SortOrder
    highestBid?: SortOrder
    saleDate?: SortOrder
    createdAt?: SortOrder
  }

  export type AuctionHistoryAvgOrderByAggregateInput = {
    salePrice?: SortOrder
    daysSinceListing?: SortOrder
    numberOfBids?: SortOrder
    highestBid?: SortOrder
  }

  export type AuctionHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    cardId?: SortOrder
    auctionId?: SortOrder
    salePrice?: SortOrder
    sellerId?: SortOrder
    buyerId?: SortOrder
    saleType?: SortOrder
    daysSinceListing?: SortOrder
    numberOfBids?: SortOrder
    highestBid?: SortOrder
    saleDate?: SortOrder
    createdAt?: SortOrder
  }

  export type AuctionHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    cardId?: SortOrder
    auctionId?: SortOrder
    salePrice?: SortOrder
    sellerId?: SortOrder
    buyerId?: SortOrder
    saleType?: SortOrder
    daysSinceListing?: SortOrder
    numberOfBids?: SortOrder
    highestBid?: SortOrder
    saleDate?: SortOrder
    createdAt?: SortOrder
  }

  export type AuctionHistorySumOrderByAggregateInput = {
    salePrice?: SortOrder
    daysSinceListing?: SortOrder
    numberOfBids?: SortOrder
    highestBid?: SortOrder
  }

  export type EnumSaleTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SaleType | EnumSaleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SaleType[] | ListEnumSaleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SaleType[] | ListEnumSaleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSaleTypeWithAggregatesFilter<$PrismaModel> | $Enums.SaleType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSaleTypeFilter<$PrismaModel>
    _max?: NestedEnumSaleTypeFilter<$PrismaModel>
  }

  export type EnumBattleTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BattleType | EnumBattleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BattleType[] | ListEnumBattleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BattleType[] | ListEnumBattleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBattleTypeFilter<$PrismaModel> | $Enums.BattleType
  }

  export type EnumBattleStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BattleStatus | EnumBattleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BattleStatus[] | ListEnumBattleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BattleStatus[] | ListEnumBattleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBattleStatusFilter<$PrismaModel> | $Enums.BattleStatus
  }

  export type BattleOutcomeNullableScalarRelationFilter = {
    is?: BattleOutcomeWhereInput | null
    isNot?: BattleOutcomeWhereInput | null
  }

  export type BattleOutcomeListRelationFilter = {
    every?: BattleOutcomeWhereInput
    some?: BattleOutcomeWhereInput
    none?: BattleOutcomeWhereInput
  }

  export type BattleOutcomeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MABattleCountOrderByAggregateInput = {
    id?: SortOrder
    initiatorCardId?: SortOrder
    targetCardId?: SortOrder
    initiatorUserId?: SortOrder
    targetUserId?: SortOrder
    battleType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    stakes?: SortOrder
    timeline?: SortOrder
    votingPeriod?: SortOrder
    status?: SortOrder
    resolved?: SortOrder
    viewCount?: SortOrder
    participantCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MABattleAvgOrderByAggregateInput = {
    stakes?: SortOrder
    viewCount?: SortOrder
    participantCount?: SortOrder
  }

  export type MABattleMaxOrderByAggregateInput = {
    id?: SortOrder
    initiatorCardId?: SortOrder
    targetCardId?: SortOrder
    initiatorUserId?: SortOrder
    targetUserId?: SortOrder
    battleType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    stakes?: SortOrder
    timeline?: SortOrder
    votingPeriod?: SortOrder
    status?: SortOrder
    resolved?: SortOrder
    viewCount?: SortOrder
    participantCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MABattleMinOrderByAggregateInput = {
    id?: SortOrder
    initiatorCardId?: SortOrder
    targetCardId?: SortOrder
    initiatorUserId?: SortOrder
    targetUserId?: SortOrder
    battleType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    stakes?: SortOrder
    timeline?: SortOrder
    votingPeriod?: SortOrder
    status?: SortOrder
    resolved?: SortOrder
    viewCount?: SortOrder
    participantCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MABattleSumOrderByAggregateInput = {
    stakes?: SortOrder
    viewCount?: SortOrder
    participantCount?: SortOrder
  }

  export type EnumBattleTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BattleType | EnumBattleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BattleType[] | ListEnumBattleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BattleType[] | ListEnumBattleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBattleTypeWithAggregatesFilter<$PrismaModel> | $Enums.BattleType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBattleTypeFilter<$PrismaModel>
    _max?: NestedEnumBattleTypeFilter<$PrismaModel>
  }

  export type EnumBattleStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BattleStatus | EnumBattleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BattleStatus[] | ListEnumBattleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BattleStatus[] | ListEnumBattleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBattleStatusWithAggregatesFilter<$PrismaModel> | $Enums.BattleStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBattleStatusFilter<$PrismaModel>
    _max?: NestedEnumBattleStatusFilter<$PrismaModel>
  }

  export type EnumProposalTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProposalType | EnumProposalTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProposalType[] | ListEnumProposalTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProposalType[] | ListEnumProposalTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProposalTypeFilter<$PrismaModel> | $Enums.ProposalType
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumProposalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProposalStatus | EnumProposalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProposalStatus[] | ListEnumProposalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProposalStatus[] | ListEnumProposalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProposalStatusFilter<$PrismaModel> | $Enums.ProposalStatus
  }

  export type MABattleScalarRelationFilter = {
    is?: MABattleWhereInput
    isNot?: MABattleWhereInput
  }

  export type BattleProposalCountOrderByAggregateInput = {
    id?: SortOrder
    battleId?: SortOrder
    proposerId?: SortOrder
    proposalType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    terms?: SortOrder
    valuation?: SortOrder
    paymentStructure?: SortOrder
    timeline?: SortOrder
    synergies?: SortOrder
    conditions?: SortOrder
    contingencies?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BattleProposalAvgOrderByAggregateInput = {
    valuation?: SortOrder
  }

  export type BattleProposalMaxOrderByAggregateInput = {
    id?: SortOrder
    battleId?: SortOrder
    proposerId?: SortOrder
    proposalType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    valuation?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BattleProposalMinOrderByAggregateInput = {
    id?: SortOrder
    battleId?: SortOrder
    proposerId?: SortOrder
    proposalType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    valuation?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BattleProposalSumOrderByAggregateInput = {
    valuation?: SortOrder
  }

  export type EnumProposalTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProposalType | EnumProposalTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProposalType[] | ListEnumProposalTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProposalType[] | ListEnumProposalTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProposalTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProposalType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProposalTypeFilter<$PrismaModel>
    _max?: NestedEnumProposalTypeFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumProposalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProposalStatus | EnumProposalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProposalStatus[] | ListEnumProposalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProposalStatus[] | ListEnumProposalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProposalStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProposalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProposalStatusFilter<$PrismaModel>
    _max?: NestedEnumProposalStatusFilter<$PrismaModel>
  }

  export type EnumVoteDirectionFilter<$PrismaModel = never> = {
    equals?: $Enums.VoteDirection | EnumVoteDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.VoteDirection[] | ListEnumVoteDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.VoteDirection[] | ListEnumVoteDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumVoteDirectionFilter<$PrismaModel> | $Enums.VoteDirection
  }

  export type BattleProposalNullableScalarRelationFilter = {
    is?: BattleProposalWhereInput | null
    isNot?: BattleProposalWhereInput | null
  }

  export type BattleVotingBattleIdProposalIdVoterIdCompoundUniqueInput = {
    battleId: string
    proposalId: string
    voterId: string
  }

  export type BattleVotingCountOrderByAggregateInput = {
    id?: SortOrder
    battleId?: SortOrder
    proposalId?: SortOrder
    voterId?: SortOrder
    vote?: SortOrder
    voteWeight?: SortOrder
    reasoning?: SortOrder
    confidence?: SortOrder
    eceStaked?: SortOrder
    expertRating?: SortOrder
    portfolioValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BattleVotingAvgOrderByAggregateInput = {
    voteWeight?: SortOrder
    confidence?: SortOrder
    eceStaked?: SortOrder
    expertRating?: SortOrder
    portfolioValue?: SortOrder
  }

  export type BattleVotingMaxOrderByAggregateInput = {
    id?: SortOrder
    battleId?: SortOrder
    proposalId?: SortOrder
    voterId?: SortOrder
    vote?: SortOrder
    voteWeight?: SortOrder
    reasoning?: SortOrder
    confidence?: SortOrder
    eceStaked?: SortOrder
    expertRating?: SortOrder
    portfolioValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BattleVotingMinOrderByAggregateInput = {
    id?: SortOrder
    battleId?: SortOrder
    proposalId?: SortOrder
    voterId?: SortOrder
    vote?: SortOrder
    voteWeight?: SortOrder
    reasoning?: SortOrder
    confidence?: SortOrder
    eceStaked?: SortOrder
    expertRating?: SortOrder
    portfolioValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BattleVotingSumOrderByAggregateInput = {
    voteWeight?: SortOrder
    confidence?: SortOrder
    eceStaked?: SortOrder
    expertRating?: SortOrder
    portfolioValue?: SortOrder
  }

  export type EnumVoteDirectionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VoteDirection | EnumVoteDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.VoteDirection[] | ListEnumVoteDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.VoteDirection[] | ListEnumVoteDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumVoteDirectionWithAggregatesFilter<$PrismaModel> | $Enums.VoteDirection
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVoteDirectionFilter<$PrismaModel>
    _max?: NestedEnumVoteDirectionFilter<$PrismaModel>
  }

  export type EnumBattleWinnerFilter<$PrismaModel = never> = {
    equals?: $Enums.BattleWinner | EnumBattleWinnerFieldRefInput<$PrismaModel>
    in?: $Enums.BattleWinner[] | ListEnumBattleWinnerFieldRefInput<$PrismaModel>
    notIn?: $Enums.BattleWinner[] | ListEnumBattleWinnerFieldRefInput<$PrismaModel>
    not?: NestedEnumBattleWinnerFilter<$PrismaModel> | $Enums.BattleWinner
  }

  export type MABattleNullableScalarRelationFilter = {
    is?: MABattleWhereInput | null
    isNot?: MABattleWhereInput | null
  }

  export type BattleOutcomeCountOrderByAggregateInput = {
    id?: SortOrder
    battleId?: SortOrder
    winningBattleId?: SortOrder
    winner?: SortOrder
    winningProposalId?: SortOrder
    finalTerms?: SortOrder
    finalValuation?: SortOrder
    implementation?: SortOrder
    stakeholdersPayouts?: SortOrder
    tokenRewards?: SortOrder
    completionDate?: SortOrder
    realWorldImpact?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BattleOutcomeAvgOrderByAggregateInput = {
    finalValuation?: SortOrder
  }

  export type BattleOutcomeMaxOrderByAggregateInput = {
    id?: SortOrder
    battleId?: SortOrder
    winningBattleId?: SortOrder
    winner?: SortOrder
    winningProposalId?: SortOrder
    finalValuation?: SortOrder
    completionDate?: SortOrder
    realWorldImpact?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BattleOutcomeMinOrderByAggregateInput = {
    id?: SortOrder
    battleId?: SortOrder
    winningBattleId?: SortOrder
    winner?: SortOrder
    winningProposalId?: SortOrder
    finalValuation?: SortOrder
    completionDate?: SortOrder
    realWorldImpact?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BattleOutcomeSumOrderByAggregateInput = {
    finalValuation?: SortOrder
  }

  export type EnumBattleWinnerWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BattleWinner | EnumBattleWinnerFieldRefInput<$PrismaModel>
    in?: $Enums.BattleWinner[] | ListEnumBattleWinnerFieldRefInput<$PrismaModel>
    notIn?: $Enums.BattleWinner[] | ListEnumBattleWinnerFieldRefInput<$PrismaModel>
    not?: NestedEnumBattleWinnerWithAggregatesFilter<$PrismaModel> | $Enums.BattleWinner
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBattleWinnerFilter<$PrismaModel>
    _max?: NestedEnumBattleWinnerFilter<$PrismaModel>
  }

  export type EnumStakingPoolTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StakingPoolType | EnumStakingPoolTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StakingPoolType[] | ListEnumStakingPoolTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StakingPoolType[] | ListEnumStakingPoolTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStakingPoolTypeFilter<$PrismaModel> | $Enums.StakingPoolType
  }

  export type StakingPoolCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    poolType?: SortOrder
    totalStaked?: SortOrder
    totalRewards?: SortOrder
    apy?: SortOrder
    minStakeAmount?: SortOrder
    lockupPeriod?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StakingPoolAvgOrderByAggregateInput = {
    totalStaked?: SortOrder
    totalRewards?: SortOrder
    apy?: SortOrder
    minStakeAmount?: SortOrder
    lockupPeriod?: SortOrder
  }

  export type StakingPoolMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    poolType?: SortOrder
    totalStaked?: SortOrder
    totalRewards?: SortOrder
    apy?: SortOrder
    minStakeAmount?: SortOrder
    lockupPeriod?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StakingPoolMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    poolType?: SortOrder
    totalStaked?: SortOrder
    totalRewards?: SortOrder
    apy?: SortOrder
    minStakeAmount?: SortOrder
    lockupPeriod?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StakingPoolSumOrderByAggregateInput = {
    totalStaked?: SortOrder
    totalRewards?: SortOrder
    apy?: SortOrder
    minStakeAmount?: SortOrder
    lockupPeriod?: SortOrder
  }

  export type EnumStakingPoolTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StakingPoolType | EnumStakingPoolTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StakingPoolType[] | ListEnumStakingPoolTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StakingPoolType[] | ListEnumStakingPoolTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStakingPoolTypeWithAggregatesFilter<$PrismaModel> | $Enums.StakingPoolType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStakingPoolTypeFilter<$PrismaModel>
    _max?: NestedEnumStakingPoolTypeFilter<$PrismaModel>
  }

  export type StakingPoolScalarRelationFilter = {
    is?: StakingPoolWhereInput
    isNot?: StakingPoolWhereInput
  }

  export type StakingPositionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    poolId?: SortOrder
    amount?: SortOrder
    stakedAt?: SortOrder
    unstakedAt?: SortOrder
    lockupEndsAt?: SortOrder
    isActive?: SortOrder
  }

  export type StakingPositionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type StakingPositionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    poolId?: SortOrder
    amount?: SortOrder
    stakedAt?: SortOrder
    unstakedAt?: SortOrder
    lockupEndsAt?: SortOrder
    isActive?: SortOrder
  }

  export type StakingPositionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    poolId?: SortOrder
    amount?: SortOrder
    stakedAt?: SortOrder
    unstakedAt?: SortOrder
    lockupEndsAt?: SortOrder
    isActive?: SortOrder
  }

  export type StakingPositionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumStakingRewardTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StakingRewardType | EnumStakingRewardTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StakingRewardType[] | ListEnumStakingRewardTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StakingRewardType[] | ListEnumStakingRewardTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStakingRewardTypeFilter<$PrismaModel> | $Enums.StakingRewardType
  }

  export type StakingPositionScalarRelationFilter = {
    is?: StakingPositionWhereInput
    isNot?: StakingPositionWhereInput
  }

  export type StakingRewardCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    poolId?: SortOrder
    positionId?: SortOrder
    amount?: SortOrder
    rewardType?: SortOrder
    claimedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type StakingRewardAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type StakingRewardMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    poolId?: SortOrder
    positionId?: SortOrder
    amount?: SortOrder
    rewardType?: SortOrder
    claimedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type StakingRewardMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    poolId?: SortOrder
    positionId?: SortOrder
    amount?: SortOrder
    rewardType?: SortOrder
    claimedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type StakingRewardSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumStakingRewardTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StakingRewardType | EnumStakingRewardTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StakingRewardType[] | ListEnumStakingRewardTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StakingRewardType[] | ListEnumStakingRewardTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStakingRewardTypeWithAggregatesFilter<$PrismaModel> | $Enums.StakingRewardType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStakingRewardTypeFilter<$PrismaModel>
    _max?: NestedEnumStakingRewardTypeFilter<$PrismaModel>
  }

  export type EnumGovernanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.GovernanceStatus | EnumGovernanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GovernanceStatus[] | ListEnumGovernanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GovernanceStatus[] | ListEnumGovernanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGovernanceStatusFilter<$PrismaModel> | $Enums.GovernanceStatus
  }

  export type GovernanceProposalCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    proposalType?: SortOrder
    proposerId?: SortOrder
    status?: SortOrder
    votingStartsAt?: SortOrder
    votingEndsAt?: SortOrder
    executionDate?: SortOrder
    minQuorum?: SortOrder
    minApproval?: SortOrder
    totalVotes?: SortOrder
    yesVotes?: SortOrder
    noVotes?: SortOrder
    abstainVotes?: SortOrder
    isExecuted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parameters?: SortOrder
  }

  export type GovernanceProposalAvgOrderByAggregateInput = {
    minQuorum?: SortOrder
    minApproval?: SortOrder
    totalVotes?: SortOrder
    yesVotes?: SortOrder
    noVotes?: SortOrder
    abstainVotes?: SortOrder
  }

  export type GovernanceProposalMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    proposalType?: SortOrder
    proposerId?: SortOrder
    status?: SortOrder
    votingStartsAt?: SortOrder
    votingEndsAt?: SortOrder
    executionDate?: SortOrder
    minQuorum?: SortOrder
    minApproval?: SortOrder
    totalVotes?: SortOrder
    yesVotes?: SortOrder
    noVotes?: SortOrder
    abstainVotes?: SortOrder
    isExecuted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GovernanceProposalMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    proposalType?: SortOrder
    proposerId?: SortOrder
    status?: SortOrder
    votingStartsAt?: SortOrder
    votingEndsAt?: SortOrder
    executionDate?: SortOrder
    minQuorum?: SortOrder
    minApproval?: SortOrder
    totalVotes?: SortOrder
    yesVotes?: SortOrder
    noVotes?: SortOrder
    abstainVotes?: SortOrder
    isExecuted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GovernanceProposalSumOrderByAggregateInput = {
    minQuorum?: SortOrder
    minApproval?: SortOrder
    totalVotes?: SortOrder
    yesVotes?: SortOrder
    noVotes?: SortOrder
    abstainVotes?: SortOrder
  }

  export type EnumGovernanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GovernanceStatus | EnumGovernanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GovernanceStatus[] | ListEnumGovernanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GovernanceStatus[] | ListEnumGovernanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGovernanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.GovernanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGovernanceStatusFilter<$PrismaModel>
    _max?: NestedEnumGovernanceStatusFilter<$PrismaModel>
  }

  export type EnumVoteChoiceFilter<$PrismaModel = never> = {
    equals?: $Enums.VoteChoice | EnumVoteChoiceFieldRefInput<$PrismaModel>
    in?: $Enums.VoteChoice[] | ListEnumVoteChoiceFieldRefInput<$PrismaModel>
    notIn?: $Enums.VoteChoice[] | ListEnumVoteChoiceFieldRefInput<$PrismaModel>
    not?: NestedEnumVoteChoiceFilter<$PrismaModel> | $Enums.VoteChoice
  }

  export type GovernanceProposalScalarRelationFilter = {
    is?: GovernanceProposalWhereInput
    isNot?: GovernanceProposalWhereInput
  }

  export type GovernanceVoteProposalIdUserIdCompoundUniqueInput = {
    proposalId: string
    userId: string
  }

  export type GovernanceVoteCountOrderByAggregateInput = {
    id?: SortOrder
    proposalId?: SortOrder
    userId?: SortOrder
    voteChoice?: SortOrder
    votingPower?: SortOrder
    reason?: SortOrder
    votedAt?: SortOrder
  }

  export type GovernanceVoteAvgOrderByAggregateInput = {
    votingPower?: SortOrder
  }

  export type GovernanceVoteMaxOrderByAggregateInput = {
    id?: SortOrder
    proposalId?: SortOrder
    userId?: SortOrder
    voteChoice?: SortOrder
    votingPower?: SortOrder
    reason?: SortOrder
    votedAt?: SortOrder
  }

  export type GovernanceVoteMinOrderByAggregateInput = {
    id?: SortOrder
    proposalId?: SortOrder
    userId?: SortOrder
    voteChoice?: SortOrder
    votingPower?: SortOrder
    reason?: SortOrder
    votedAt?: SortOrder
  }

  export type GovernanceVoteSumOrderByAggregateInput = {
    votingPower?: SortOrder
  }

  export type EnumVoteChoiceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VoteChoice | EnumVoteChoiceFieldRefInput<$PrismaModel>
    in?: $Enums.VoteChoice[] | ListEnumVoteChoiceFieldRefInput<$PrismaModel>
    notIn?: $Enums.VoteChoice[] | ListEnumVoteChoiceFieldRefInput<$PrismaModel>
    not?: NestedEnumVoteChoiceWithAggregatesFilter<$PrismaModel> | $Enums.VoteChoice
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVoteChoiceFilter<$PrismaModel>
    _max?: NestedEnumVoteChoiceFilter<$PrismaModel>
  }

  export type UserSubscriptionCreateNestedOneWithoutUserInput = {
    create?: XOR<UserSubscriptionCreateWithoutUserInput, UserSubscriptionUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSubscriptionCreateOrConnectWithoutUserInput
    connect?: UserSubscriptionWhereUniqueInput
  }

  export type CryptoWalletCreateNestedManyWithoutUserInput = {
    create?: XOR<CryptoWalletCreateWithoutUserInput, CryptoWalletUncheckedCreateWithoutUserInput> | CryptoWalletCreateWithoutUserInput[] | CryptoWalletUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CryptoWalletCreateOrConnectWithoutUserInput | CryptoWalletCreateOrConnectWithoutUserInput[]
    createMany?: CryptoWalletCreateManyUserInputEnvelope
    connect?: CryptoWalletWhereUniqueInput | CryptoWalletWhereUniqueInput[]
  }

  export type PhysicalCardCreateNestedOneWithoutUserInput = {
    create?: XOR<PhysicalCardCreateWithoutUserInput, PhysicalCardUncheckedCreateWithoutUserInput>
    connectOrCreate?: PhysicalCardCreateOrConnectWithoutUserInput
    connect?: PhysicalCardWhereUniqueInput
  }

  export type CardCreateNestedManyWithoutOwnerInput = {
    create?: XOR<CardCreateWithoutOwnerInput, CardUncheckedCreateWithoutOwnerInput> | CardCreateWithoutOwnerInput[] | CardUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: CardCreateOrConnectWithoutOwnerInput | CardCreateOrConnectWithoutOwnerInput[]
    createMany?: CardCreateManyOwnerInputEnvelope
    connect?: CardWhereUniqueInput | CardWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutUserInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type BidCreateNestedManyWithoutBidderInput = {
    create?: XOR<BidCreateWithoutBidderInput, BidUncheckedCreateWithoutBidderInput> | BidCreateWithoutBidderInput[] | BidUncheckedCreateWithoutBidderInput[]
    connectOrCreate?: BidCreateOrConnectWithoutBidderInput | BidCreateOrConnectWithoutBidderInput[]
    createMany?: BidCreateManyBidderInputEnvelope
    connect?: BidWhereUniqueInput | BidWhereUniqueInput[]
  }

  export type MarketplaceListingCreateNestedManyWithoutSellerInput = {
    create?: XOR<MarketplaceListingCreateWithoutSellerInput, MarketplaceListingUncheckedCreateWithoutSellerInput> | MarketplaceListingCreateWithoutSellerInput[] | MarketplaceListingUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: MarketplaceListingCreateOrConnectWithoutSellerInput | MarketplaceListingCreateOrConnectWithoutSellerInput[]
    createMany?: MarketplaceListingCreateManySellerInputEnvelope
    connect?: MarketplaceListingWhereUniqueInput | MarketplaceListingWhereUniqueInput[]
  }

  export type AppOrderCreateNestedManyWithoutUserInput = {
    create?: XOR<AppOrderCreateWithoutUserInput, AppOrderUncheckedCreateWithoutUserInput> | AppOrderCreateWithoutUserInput[] | AppOrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AppOrderCreateOrConnectWithoutUserInput | AppOrderCreateOrConnectWithoutUserInput[]
    createMany?: AppOrderCreateManyUserInputEnvelope
    connect?: AppOrderWhereUniqueInput | AppOrderWhereUniqueInput[]
  }

  export type OrderRevisionCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderRevisionCreateWithoutUserInput, OrderRevisionUncheckedCreateWithoutUserInput> | OrderRevisionCreateWithoutUserInput[] | OrderRevisionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderRevisionCreateOrConnectWithoutUserInput | OrderRevisionCreateOrConnectWithoutUserInput[]
    createMany?: OrderRevisionCreateManyUserInputEnvelope
    connect?: OrderRevisionWhereUniqueInput | OrderRevisionWhereUniqueInput[]
  }

  export type OrderCommunicationCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderCommunicationCreateWithoutUserInput, OrderCommunicationUncheckedCreateWithoutUserInput> | OrderCommunicationCreateWithoutUserInput[] | OrderCommunicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCommunicationCreateOrConnectWithoutUserInput | OrderCommunicationCreateOrConnectWithoutUserInput[]
    createMany?: OrderCommunicationCreateManyUserInputEnvelope
    connect?: OrderCommunicationWhereUniqueInput | OrderCommunicationWhereUniqueInput[]
  }

  export type BettingPositionCreateNestedManyWithoutUserInput = {
    create?: XOR<BettingPositionCreateWithoutUserInput, BettingPositionUncheckedCreateWithoutUserInput> | BettingPositionCreateWithoutUserInput[] | BettingPositionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BettingPositionCreateOrConnectWithoutUserInput | BettingPositionCreateOrConnectWithoutUserInput[]
    createMany?: BettingPositionCreateManyUserInputEnvelope
    connect?: BettingPositionWhereUniqueInput | BettingPositionWhereUniqueInput[]
  }

  export type BettingPayoutCreateNestedManyWithoutUserInput = {
    create?: XOR<BettingPayoutCreateWithoutUserInput, BettingPayoutUncheckedCreateWithoutUserInput> | BettingPayoutCreateWithoutUserInput[] | BettingPayoutUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BettingPayoutCreateOrConnectWithoutUserInput | BettingPayoutCreateOrConnectWithoutUserInput[]
    createMany?: BettingPayoutCreateManyUserInputEnvelope
    connect?: BettingPayoutWhereUniqueInput | BettingPayoutWhereUniqueInput[]
  }

  export type CardAuctionCreateNestedManyWithoutOwnerInput = {
    create?: XOR<CardAuctionCreateWithoutOwnerInput, CardAuctionUncheckedCreateWithoutOwnerInput> | CardAuctionCreateWithoutOwnerInput[] | CardAuctionUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: CardAuctionCreateOrConnectWithoutOwnerInput | CardAuctionCreateOrConnectWithoutOwnerInput[]
    createMany?: CardAuctionCreateManyOwnerInputEnvelope
    connect?: CardAuctionWhereUniqueInput | CardAuctionWhereUniqueInput[]
  }

  export type CardAuctionCreateNestedManyWithoutWinnerInput = {
    create?: XOR<CardAuctionCreateWithoutWinnerInput, CardAuctionUncheckedCreateWithoutWinnerInput> | CardAuctionCreateWithoutWinnerInput[] | CardAuctionUncheckedCreateWithoutWinnerInput[]
    connectOrCreate?: CardAuctionCreateOrConnectWithoutWinnerInput | CardAuctionCreateOrConnectWithoutWinnerInput[]
    createMany?: CardAuctionCreateManyWinnerInputEnvelope
    connect?: CardAuctionWhereUniqueInput | CardAuctionWhereUniqueInput[]
  }

  export type AuctionBidCreateNestedManyWithoutBidderInput = {
    create?: XOR<AuctionBidCreateWithoutBidderInput, AuctionBidUncheckedCreateWithoutBidderInput> | AuctionBidCreateWithoutBidderInput[] | AuctionBidUncheckedCreateWithoutBidderInput[]
    connectOrCreate?: AuctionBidCreateOrConnectWithoutBidderInput | AuctionBidCreateOrConnectWithoutBidderInput[]
    createMany?: AuctionBidCreateManyBidderInputEnvelope
    connect?: AuctionBidWhereUniqueInput | AuctionBidWhereUniqueInput[]
  }

  export type AuctionWatcherCreateNestedManyWithoutUserInput = {
    create?: XOR<AuctionWatcherCreateWithoutUserInput, AuctionWatcherUncheckedCreateWithoutUserInput> | AuctionWatcherCreateWithoutUserInput[] | AuctionWatcherUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuctionWatcherCreateOrConnectWithoutUserInput | AuctionWatcherCreateOrConnectWithoutUserInput[]
    createMany?: AuctionWatcherCreateManyUserInputEnvelope
    connect?: AuctionWatcherWhereUniqueInput | AuctionWatcherWhereUniqueInput[]
  }

  export type MABattleCreateNestedManyWithoutInitiatorInput = {
    create?: XOR<MABattleCreateWithoutInitiatorInput, MABattleUncheckedCreateWithoutInitiatorInput> | MABattleCreateWithoutInitiatorInput[] | MABattleUncheckedCreateWithoutInitiatorInput[]
    connectOrCreate?: MABattleCreateOrConnectWithoutInitiatorInput | MABattleCreateOrConnectWithoutInitiatorInput[]
    createMany?: MABattleCreateManyInitiatorInputEnvelope
    connect?: MABattleWhereUniqueInput | MABattleWhereUniqueInput[]
  }

  export type MABattleCreateNestedManyWithoutTargetInput = {
    create?: XOR<MABattleCreateWithoutTargetInput, MABattleUncheckedCreateWithoutTargetInput> | MABattleCreateWithoutTargetInput[] | MABattleUncheckedCreateWithoutTargetInput[]
    connectOrCreate?: MABattleCreateOrConnectWithoutTargetInput | MABattleCreateOrConnectWithoutTargetInput[]
    createMany?: MABattleCreateManyTargetInputEnvelope
    connect?: MABattleWhereUniqueInput | MABattleWhereUniqueInput[]
  }

  export type BattleProposalCreateNestedManyWithoutProposerInput = {
    create?: XOR<BattleProposalCreateWithoutProposerInput, BattleProposalUncheckedCreateWithoutProposerInput> | BattleProposalCreateWithoutProposerInput[] | BattleProposalUncheckedCreateWithoutProposerInput[]
    connectOrCreate?: BattleProposalCreateOrConnectWithoutProposerInput | BattleProposalCreateOrConnectWithoutProposerInput[]
    createMany?: BattleProposalCreateManyProposerInputEnvelope
    connect?: BattleProposalWhereUniqueInput | BattleProposalWhereUniqueInput[]
  }

  export type BattleVotingCreateNestedManyWithoutVoterInput = {
    create?: XOR<BattleVotingCreateWithoutVoterInput, BattleVotingUncheckedCreateWithoutVoterInput> | BattleVotingCreateWithoutVoterInput[] | BattleVotingUncheckedCreateWithoutVoterInput[]
    connectOrCreate?: BattleVotingCreateOrConnectWithoutVoterInput | BattleVotingCreateOrConnectWithoutVoterInput[]
    createMany?: BattleVotingCreateManyVoterInputEnvelope
    connect?: BattleVotingWhereUniqueInput | BattleVotingWhereUniqueInput[]
  }

  export type StakingPositionCreateNestedManyWithoutUserInput = {
    create?: XOR<StakingPositionCreateWithoutUserInput, StakingPositionUncheckedCreateWithoutUserInput> | StakingPositionCreateWithoutUserInput[] | StakingPositionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StakingPositionCreateOrConnectWithoutUserInput | StakingPositionCreateOrConnectWithoutUserInput[]
    createMany?: StakingPositionCreateManyUserInputEnvelope
    connect?: StakingPositionWhereUniqueInput | StakingPositionWhereUniqueInput[]
  }

  export type StakingRewardCreateNestedManyWithoutUserInput = {
    create?: XOR<StakingRewardCreateWithoutUserInput, StakingRewardUncheckedCreateWithoutUserInput> | StakingRewardCreateWithoutUserInput[] | StakingRewardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StakingRewardCreateOrConnectWithoutUserInput | StakingRewardCreateOrConnectWithoutUserInput[]
    createMany?: StakingRewardCreateManyUserInputEnvelope
    connect?: StakingRewardWhereUniqueInput | StakingRewardWhereUniqueInput[]
  }

  export type GovernanceProposalCreateNestedManyWithoutProposerInput = {
    create?: XOR<GovernanceProposalCreateWithoutProposerInput, GovernanceProposalUncheckedCreateWithoutProposerInput> | GovernanceProposalCreateWithoutProposerInput[] | GovernanceProposalUncheckedCreateWithoutProposerInput[]
    connectOrCreate?: GovernanceProposalCreateOrConnectWithoutProposerInput | GovernanceProposalCreateOrConnectWithoutProposerInput[]
    createMany?: GovernanceProposalCreateManyProposerInputEnvelope
    connect?: GovernanceProposalWhereUniqueInput | GovernanceProposalWhereUniqueInput[]
  }

  export type GovernanceVoteCreateNestedManyWithoutUserInput = {
    create?: XOR<GovernanceVoteCreateWithoutUserInput, GovernanceVoteUncheckedCreateWithoutUserInput> | GovernanceVoteCreateWithoutUserInput[] | GovernanceVoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GovernanceVoteCreateOrConnectWithoutUserInput | GovernanceVoteCreateOrConnectWithoutUserInput[]
    createMany?: GovernanceVoteCreateManyUserInputEnvelope
    connect?: GovernanceVoteWhereUniqueInput | GovernanceVoteWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type SocialFeedCreateNestedManyWithoutUserInput = {
    create?: XOR<SocialFeedCreateWithoutUserInput, SocialFeedUncheckedCreateWithoutUserInput> | SocialFeedCreateWithoutUserInput[] | SocialFeedUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SocialFeedCreateOrConnectWithoutUserInput | SocialFeedCreateOrConnectWithoutUserInput[]
    createMany?: SocialFeedCreateManyUserInputEnvelope
    connect?: SocialFeedWhereUniqueInput | SocialFeedWhereUniqueInput[]
  }

  export type FollowCreateNestedManyWithoutFollowerInput = {
    create?: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput> | FollowCreateWithoutFollowerInput[] | FollowUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowerInput | FollowCreateOrConnectWithoutFollowerInput[]
    createMany?: FollowCreateManyFollowerInputEnvelope
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
  }

  export type FollowCreateNestedManyWithoutFollowingInput = {
    create?: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput> | FollowCreateWithoutFollowingInput[] | FollowUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowingInput | FollowCreateOrConnectWithoutFollowingInput[]
    createMany?: FollowCreateManyFollowingInputEnvelope
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
  }

  export type UserSubscriptionUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserSubscriptionCreateWithoutUserInput, UserSubscriptionUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSubscriptionCreateOrConnectWithoutUserInput
    connect?: UserSubscriptionWhereUniqueInput
  }

  export type CryptoWalletUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CryptoWalletCreateWithoutUserInput, CryptoWalletUncheckedCreateWithoutUserInput> | CryptoWalletCreateWithoutUserInput[] | CryptoWalletUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CryptoWalletCreateOrConnectWithoutUserInput | CryptoWalletCreateOrConnectWithoutUserInput[]
    createMany?: CryptoWalletCreateManyUserInputEnvelope
    connect?: CryptoWalletWhereUniqueInput | CryptoWalletWhereUniqueInput[]
  }

  export type PhysicalCardUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<PhysicalCardCreateWithoutUserInput, PhysicalCardUncheckedCreateWithoutUserInput>
    connectOrCreate?: PhysicalCardCreateOrConnectWithoutUserInput
    connect?: PhysicalCardWhereUniqueInput
  }

  export type CardUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<CardCreateWithoutOwnerInput, CardUncheckedCreateWithoutOwnerInput> | CardCreateWithoutOwnerInput[] | CardUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: CardCreateOrConnectWithoutOwnerInput | CardCreateOrConnectWithoutOwnerInput[]
    createMany?: CardCreateManyOwnerInputEnvelope
    connect?: CardWhereUniqueInput | CardWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type BidUncheckedCreateNestedManyWithoutBidderInput = {
    create?: XOR<BidCreateWithoutBidderInput, BidUncheckedCreateWithoutBidderInput> | BidCreateWithoutBidderInput[] | BidUncheckedCreateWithoutBidderInput[]
    connectOrCreate?: BidCreateOrConnectWithoutBidderInput | BidCreateOrConnectWithoutBidderInput[]
    createMany?: BidCreateManyBidderInputEnvelope
    connect?: BidWhereUniqueInput | BidWhereUniqueInput[]
  }

  export type MarketplaceListingUncheckedCreateNestedManyWithoutSellerInput = {
    create?: XOR<MarketplaceListingCreateWithoutSellerInput, MarketplaceListingUncheckedCreateWithoutSellerInput> | MarketplaceListingCreateWithoutSellerInput[] | MarketplaceListingUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: MarketplaceListingCreateOrConnectWithoutSellerInput | MarketplaceListingCreateOrConnectWithoutSellerInput[]
    createMany?: MarketplaceListingCreateManySellerInputEnvelope
    connect?: MarketplaceListingWhereUniqueInput | MarketplaceListingWhereUniqueInput[]
  }

  export type AppOrderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AppOrderCreateWithoutUserInput, AppOrderUncheckedCreateWithoutUserInput> | AppOrderCreateWithoutUserInput[] | AppOrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AppOrderCreateOrConnectWithoutUserInput | AppOrderCreateOrConnectWithoutUserInput[]
    createMany?: AppOrderCreateManyUserInputEnvelope
    connect?: AppOrderWhereUniqueInput | AppOrderWhereUniqueInput[]
  }

  export type OrderRevisionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderRevisionCreateWithoutUserInput, OrderRevisionUncheckedCreateWithoutUserInput> | OrderRevisionCreateWithoutUserInput[] | OrderRevisionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderRevisionCreateOrConnectWithoutUserInput | OrderRevisionCreateOrConnectWithoutUserInput[]
    createMany?: OrderRevisionCreateManyUserInputEnvelope
    connect?: OrderRevisionWhereUniqueInput | OrderRevisionWhereUniqueInput[]
  }

  export type OrderCommunicationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderCommunicationCreateWithoutUserInput, OrderCommunicationUncheckedCreateWithoutUserInput> | OrderCommunicationCreateWithoutUserInput[] | OrderCommunicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCommunicationCreateOrConnectWithoutUserInput | OrderCommunicationCreateOrConnectWithoutUserInput[]
    createMany?: OrderCommunicationCreateManyUserInputEnvelope
    connect?: OrderCommunicationWhereUniqueInput | OrderCommunicationWhereUniqueInput[]
  }

  export type BettingPositionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BettingPositionCreateWithoutUserInput, BettingPositionUncheckedCreateWithoutUserInput> | BettingPositionCreateWithoutUserInput[] | BettingPositionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BettingPositionCreateOrConnectWithoutUserInput | BettingPositionCreateOrConnectWithoutUserInput[]
    createMany?: BettingPositionCreateManyUserInputEnvelope
    connect?: BettingPositionWhereUniqueInput | BettingPositionWhereUniqueInput[]
  }

  export type BettingPayoutUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BettingPayoutCreateWithoutUserInput, BettingPayoutUncheckedCreateWithoutUserInput> | BettingPayoutCreateWithoutUserInput[] | BettingPayoutUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BettingPayoutCreateOrConnectWithoutUserInput | BettingPayoutCreateOrConnectWithoutUserInput[]
    createMany?: BettingPayoutCreateManyUserInputEnvelope
    connect?: BettingPayoutWhereUniqueInput | BettingPayoutWhereUniqueInput[]
  }

  export type CardAuctionUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<CardAuctionCreateWithoutOwnerInput, CardAuctionUncheckedCreateWithoutOwnerInput> | CardAuctionCreateWithoutOwnerInput[] | CardAuctionUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: CardAuctionCreateOrConnectWithoutOwnerInput | CardAuctionCreateOrConnectWithoutOwnerInput[]
    createMany?: CardAuctionCreateManyOwnerInputEnvelope
    connect?: CardAuctionWhereUniqueInput | CardAuctionWhereUniqueInput[]
  }

  export type CardAuctionUncheckedCreateNestedManyWithoutWinnerInput = {
    create?: XOR<CardAuctionCreateWithoutWinnerInput, CardAuctionUncheckedCreateWithoutWinnerInput> | CardAuctionCreateWithoutWinnerInput[] | CardAuctionUncheckedCreateWithoutWinnerInput[]
    connectOrCreate?: CardAuctionCreateOrConnectWithoutWinnerInput | CardAuctionCreateOrConnectWithoutWinnerInput[]
    createMany?: CardAuctionCreateManyWinnerInputEnvelope
    connect?: CardAuctionWhereUniqueInput | CardAuctionWhereUniqueInput[]
  }

  export type AuctionBidUncheckedCreateNestedManyWithoutBidderInput = {
    create?: XOR<AuctionBidCreateWithoutBidderInput, AuctionBidUncheckedCreateWithoutBidderInput> | AuctionBidCreateWithoutBidderInput[] | AuctionBidUncheckedCreateWithoutBidderInput[]
    connectOrCreate?: AuctionBidCreateOrConnectWithoutBidderInput | AuctionBidCreateOrConnectWithoutBidderInput[]
    createMany?: AuctionBidCreateManyBidderInputEnvelope
    connect?: AuctionBidWhereUniqueInput | AuctionBidWhereUniqueInput[]
  }

  export type AuctionWatcherUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuctionWatcherCreateWithoutUserInput, AuctionWatcherUncheckedCreateWithoutUserInput> | AuctionWatcherCreateWithoutUserInput[] | AuctionWatcherUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuctionWatcherCreateOrConnectWithoutUserInput | AuctionWatcherCreateOrConnectWithoutUserInput[]
    createMany?: AuctionWatcherCreateManyUserInputEnvelope
    connect?: AuctionWatcherWhereUniqueInput | AuctionWatcherWhereUniqueInput[]
  }

  export type MABattleUncheckedCreateNestedManyWithoutInitiatorInput = {
    create?: XOR<MABattleCreateWithoutInitiatorInput, MABattleUncheckedCreateWithoutInitiatorInput> | MABattleCreateWithoutInitiatorInput[] | MABattleUncheckedCreateWithoutInitiatorInput[]
    connectOrCreate?: MABattleCreateOrConnectWithoutInitiatorInput | MABattleCreateOrConnectWithoutInitiatorInput[]
    createMany?: MABattleCreateManyInitiatorInputEnvelope
    connect?: MABattleWhereUniqueInput | MABattleWhereUniqueInput[]
  }

  export type MABattleUncheckedCreateNestedManyWithoutTargetInput = {
    create?: XOR<MABattleCreateWithoutTargetInput, MABattleUncheckedCreateWithoutTargetInput> | MABattleCreateWithoutTargetInput[] | MABattleUncheckedCreateWithoutTargetInput[]
    connectOrCreate?: MABattleCreateOrConnectWithoutTargetInput | MABattleCreateOrConnectWithoutTargetInput[]
    createMany?: MABattleCreateManyTargetInputEnvelope
    connect?: MABattleWhereUniqueInput | MABattleWhereUniqueInput[]
  }

  export type BattleProposalUncheckedCreateNestedManyWithoutProposerInput = {
    create?: XOR<BattleProposalCreateWithoutProposerInput, BattleProposalUncheckedCreateWithoutProposerInput> | BattleProposalCreateWithoutProposerInput[] | BattleProposalUncheckedCreateWithoutProposerInput[]
    connectOrCreate?: BattleProposalCreateOrConnectWithoutProposerInput | BattleProposalCreateOrConnectWithoutProposerInput[]
    createMany?: BattleProposalCreateManyProposerInputEnvelope
    connect?: BattleProposalWhereUniqueInput | BattleProposalWhereUniqueInput[]
  }

  export type BattleVotingUncheckedCreateNestedManyWithoutVoterInput = {
    create?: XOR<BattleVotingCreateWithoutVoterInput, BattleVotingUncheckedCreateWithoutVoterInput> | BattleVotingCreateWithoutVoterInput[] | BattleVotingUncheckedCreateWithoutVoterInput[]
    connectOrCreate?: BattleVotingCreateOrConnectWithoutVoterInput | BattleVotingCreateOrConnectWithoutVoterInput[]
    createMany?: BattleVotingCreateManyVoterInputEnvelope
    connect?: BattleVotingWhereUniqueInput | BattleVotingWhereUniqueInput[]
  }

  export type StakingPositionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<StakingPositionCreateWithoutUserInput, StakingPositionUncheckedCreateWithoutUserInput> | StakingPositionCreateWithoutUserInput[] | StakingPositionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StakingPositionCreateOrConnectWithoutUserInput | StakingPositionCreateOrConnectWithoutUserInput[]
    createMany?: StakingPositionCreateManyUserInputEnvelope
    connect?: StakingPositionWhereUniqueInput | StakingPositionWhereUniqueInput[]
  }

  export type StakingRewardUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<StakingRewardCreateWithoutUserInput, StakingRewardUncheckedCreateWithoutUserInput> | StakingRewardCreateWithoutUserInput[] | StakingRewardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StakingRewardCreateOrConnectWithoutUserInput | StakingRewardCreateOrConnectWithoutUserInput[]
    createMany?: StakingRewardCreateManyUserInputEnvelope
    connect?: StakingRewardWhereUniqueInput | StakingRewardWhereUniqueInput[]
  }

  export type GovernanceProposalUncheckedCreateNestedManyWithoutProposerInput = {
    create?: XOR<GovernanceProposalCreateWithoutProposerInput, GovernanceProposalUncheckedCreateWithoutProposerInput> | GovernanceProposalCreateWithoutProposerInput[] | GovernanceProposalUncheckedCreateWithoutProposerInput[]
    connectOrCreate?: GovernanceProposalCreateOrConnectWithoutProposerInput | GovernanceProposalCreateOrConnectWithoutProposerInput[]
    createMany?: GovernanceProposalCreateManyProposerInputEnvelope
    connect?: GovernanceProposalWhereUniqueInput | GovernanceProposalWhereUniqueInput[]
  }

  export type GovernanceVoteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<GovernanceVoteCreateWithoutUserInput, GovernanceVoteUncheckedCreateWithoutUserInput> | GovernanceVoteCreateWithoutUserInput[] | GovernanceVoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GovernanceVoteCreateOrConnectWithoutUserInput | GovernanceVoteCreateOrConnectWithoutUserInput[]
    createMany?: GovernanceVoteCreateManyUserInputEnvelope
    connect?: GovernanceVoteWhereUniqueInput | GovernanceVoteWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type SocialFeedUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SocialFeedCreateWithoutUserInput, SocialFeedUncheckedCreateWithoutUserInput> | SocialFeedCreateWithoutUserInput[] | SocialFeedUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SocialFeedCreateOrConnectWithoutUserInput | SocialFeedCreateOrConnectWithoutUserInput[]
    createMany?: SocialFeedCreateManyUserInputEnvelope
    connect?: SocialFeedWhereUniqueInput | SocialFeedWhereUniqueInput[]
  }

  export type FollowUncheckedCreateNestedManyWithoutFollowerInput = {
    create?: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput> | FollowCreateWithoutFollowerInput[] | FollowUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowerInput | FollowCreateOrConnectWithoutFollowerInput[]
    createMany?: FollowCreateManyFollowerInputEnvelope
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
  }

  export type FollowUncheckedCreateNestedManyWithoutFollowingInput = {
    create?: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput> | FollowCreateWithoutFollowingInput[] | FollowUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowingInput | FollowCreateOrConnectWithoutFollowingInput[]
    createMany?: FollowCreateManyFollowingInputEnvelope
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserSubscriptionUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserSubscriptionCreateWithoutUserInput, UserSubscriptionUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSubscriptionCreateOrConnectWithoutUserInput
    upsert?: UserSubscriptionUpsertWithoutUserInput
    disconnect?: UserSubscriptionWhereInput | boolean
    delete?: UserSubscriptionWhereInput | boolean
    connect?: UserSubscriptionWhereUniqueInput
    update?: XOR<XOR<UserSubscriptionUpdateToOneWithWhereWithoutUserInput, UserSubscriptionUpdateWithoutUserInput>, UserSubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type CryptoWalletUpdateManyWithoutUserNestedInput = {
    create?: XOR<CryptoWalletCreateWithoutUserInput, CryptoWalletUncheckedCreateWithoutUserInput> | CryptoWalletCreateWithoutUserInput[] | CryptoWalletUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CryptoWalletCreateOrConnectWithoutUserInput | CryptoWalletCreateOrConnectWithoutUserInput[]
    upsert?: CryptoWalletUpsertWithWhereUniqueWithoutUserInput | CryptoWalletUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CryptoWalletCreateManyUserInputEnvelope
    set?: CryptoWalletWhereUniqueInput | CryptoWalletWhereUniqueInput[]
    disconnect?: CryptoWalletWhereUniqueInput | CryptoWalletWhereUniqueInput[]
    delete?: CryptoWalletWhereUniqueInput | CryptoWalletWhereUniqueInput[]
    connect?: CryptoWalletWhereUniqueInput | CryptoWalletWhereUniqueInput[]
    update?: CryptoWalletUpdateWithWhereUniqueWithoutUserInput | CryptoWalletUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CryptoWalletUpdateManyWithWhereWithoutUserInput | CryptoWalletUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CryptoWalletScalarWhereInput | CryptoWalletScalarWhereInput[]
  }

  export type PhysicalCardUpdateOneWithoutUserNestedInput = {
    create?: XOR<PhysicalCardCreateWithoutUserInput, PhysicalCardUncheckedCreateWithoutUserInput>
    connectOrCreate?: PhysicalCardCreateOrConnectWithoutUserInput
    upsert?: PhysicalCardUpsertWithoutUserInput
    disconnect?: PhysicalCardWhereInput | boolean
    delete?: PhysicalCardWhereInput | boolean
    connect?: PhysicalCardWhereUniqueInput
    update?: XOR<XOR<PhysicalCardUpdateToOneWithWhereWithoutUserInput, PhysicalCardUpdateWithoutUserInput>, PhysicalCardUncheckedUpdateWithoutUserInput>
  }

  export type CardUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<CardCreateWithoutOwnerInput, CardUncheckedCreateWithoutOwnerInput> | CardCreateWithoutOwnerInput[] | CardUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: CardCreateOrConnectWithoutOwnerInput | CardCreateOrConnectWithoutOwnerInput[]
    upsert?: CardUpsertWithWhereUniqueWithoutOwnerInput | CardUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: CardCreateManyOwnerInputEnvelope
    set?: CardWhereUniqueInput | CardWhereUniqueInput[]
    disconnect?: CardWhereUniqueInput | CardWhereUniqueInput[]
    delete?: CardWhereUniqueInput | CardWhereUniqueInput[]
    connect?: CardWhereUniqueInput | CardWhereUniqueInput[]
    update?: CardUpdateWithWhereUniqueWithoutOwnerInput | CardUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: CardUpdateManyWithWhereWithoutOwnerInput | CardUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: CardScalarWhereInput | CardScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutUserInput | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutUserInput | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutUserInput | TransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type BidUpdateManyWithoutBidderNestedInput = {
    create?: XOR<BidCreateWithoutBidderInput, BidUncheckedCreateWithoutBidderInput> | BidCreateWithoutBidderInput[] | BidUncheckedCreateWithoutBidderInput[]
    connectOrCreate?: BidCreateOrConnectWithoutBidderInput | BidCreateOrConnectWithoutBidderInput[]
    upsert?: BidUpsertWithWhereUniqueWithoutBidderInput | BidUpsertWithWhereUniqueWithoutBidderInput[]
    createMany?: BidCreateManyBidderInputEnvelope
    set?: BidWhereUniqueInput | BidWhereUniqueInput[]
    disconnect?: BidWhereUniqueInput | BidWhereUniqueInput[]
    delete?: BidWhereUniqueInput | BidWhereUniqueInput[]
    connect?: BidWhereUniqueInput | BidWhereUniqueInput[]
    update?: BidUpdateWithWhereUniqueWithoutBidderInput | BidUpdateWithWhereUniqueWithoutBidderInput[]
    updateMany?: BidUpdateManyWithWhereWithoutBidderInput | BidUpdateManyWithWhereWithoutBidderInput[]
    deleteMany?: BidScalarWhereInput | BidScalarWhereInput[]
  }

  export type MarketplaceListingUpdateManyWithoutSellerNestedInput = {
    create?: XOR<MarketplaceListingCreateWithoutSellerInput, MarketplaceListingUncheckedCreateWithoutSellerInput> | MarketplaceListingCreateWithoutSellerInput[] | MarketplaceListingUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: MarketplaceListingCreateOrConnectWithoutSellerInput | MarketplaceListingCreateOrConnectWithoutSellerInput[]
    upsert?: MarketplaceListingUpsertWithWhereUniqueWithoutSellerInput | MarketplaceListingUpsertWithWhereUniqueWithoutSellerInput[]
    createMany?: MarketplaceListingCreateManySellerInputEnvelope
    set?: MarketplaceListingWhereUniqueInput | MarketplaceListingWhereUniqueInput[]
    disconnect?: MarketplaceListingWhereUniqueInput | MarketplaceListingWhereUniqueInput[]
    delete?: MarketplaceListingWhereUniqueInput | MarketplaceListingWhereUniqueInput[]
    connect?: MarketplaceListingWhereUniqueInput | MarketplaceListingWhereUniqueInput[]
    update?: MarketplaceListingUpdateWithWhereUniqueWithoutSellerInput | MarketplaceListingUpdateWithWhereUniqueWithoutSellerInput[]
    updateMany?: MarketplaceListingUpdateManyWithWhereWithoutSellerInput | MarketplaceListingUpdateManyWithWhereWithoutSellerInput[]
    deleteMany?: MarketplaceListingScalarWhereInput | MarketplaceListingScalarWhereInput[]
  }

  export type AppOrderUpdateManyWithoutUserNestedInput = {
    create?: XOR<AppOrderCreateWithoutUserInput, AppOrderUncheckedCreateWithoutUserInput> | AppOrderCreateWithoutUserInput[] | AppOrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AppOrderCreateOrConnectWithoutUserInput | AppOrderCreateOrConnectWithoutUserInput[]
    upsert?: AppOrderUpsertWithWhereUniqueWithoutUserInput | AppOrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AppOrderCreateManyUserInputEnvelope
    set?: AppOrderWhereUniqueInput | AppOrderWhereUniqueInput[]
    disconnect?: AppOrderWhereUniqueInput | AppOrderWhereUniqueInput[]
    delete?: AppOrderWhereUniqueInput | AppOrderWhereUniqueInput[]
    connect?: AppOrderWhereUniqueInput | AppOrderWhereUniqueInput[]
    update?: AppOrderUpdateWithWhereUniqueWithoutUserInput | AppOrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AppOrderUpdateManyWithWhereWithoutUserInput | AppOrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AppOrderScalarWhereInput | AppOrderScalarWhereInput[]
  }

  export type OrderRevisionUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderRevisionCreateWithoutUserInput, OrderRevisionUncheckedCreateWithoutUserInput> | OrderRevisionCreateWithoutUserInput[] | OrderRevisionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderRevisionCreateOrConnectWithoutUserInput | OrderRevisionCreateOrConnectWithoutUserInput[]
    upsert?: OrderRevisionUpsertWithWhereUniqueWithoutUserInput | OrderRevisionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderRevisionCreateManyUserInputEnvelope
    set?: OrderRevisionWhereUniqueInput | OrderRevisionWhereUniqueInput[]
    disconnect?: OrderRevisionWhereUniqueInput | OrderRevisionWhereUniqueInput[]
    delete?: OrderRevisionWhereUniqueInput | OrderRevisionWhereUniqueInput[]
    connect?: OrderRevisionWhereUniqueInput | OrderRevisionWhereUniqueInput[]
    update?: OrderRevisionUpdateWithWhereUniqueWithoutUserInput | OrderRevisionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderRevisionUpdateManyWithWhereWithoutUserInput | OrderRevisionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderRevisionScalarWhereInput | OrderRevisionScalarWhereInput[]
  }

  export type OrderCommunicationUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderCommunicationCreateWithoutUserInput, OrderCommunicationUncheckedCreateWithoutUserInput> | OrderCommunicationCreateWithoutUserInput[] | OrderCommunicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCommunicationCreateOrConnectWithoutUserInput | OrderCommunicationCreateOrConnectWithoutUserInput[]
    upsert?: OrderCommunicationUpsertWithWhereUniqueWithoutUserInput | OrderCommunicationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderCommunicationCreateManyUserInputEnvelope
    set?: OrderCommunicationWhereUniqueInput | OrderCommunicationWhereUniqueInput[]
    disconnect?: OrderCommunicationWhereUniqueInput | OrderCommunicationWhereUniqueInput[]
    delete?: OrderCommunicationWhereUniqueInput | OrderCommunicationWhereUniqueInput[]
    connect?: OrderCommunicationWhereUniqueInput | OrderCommunicationWhereUniqueInput[]
    update?: OrderCommunicationUpdateWithWhereUniqueWithoutUserInput | OrderCommunicationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderCommunicationUpdateManyWithWhereWithoutUserInput | OrderCommunicationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderCommunicationScalarWhereInput | OrderCommunicationScalarWhereInput[]
  }

  export type BettingPositionUpdateManyWithoutUserNestedInput = {
    create?: XOR<BettingPositionCreateWithoutUserInput, BettingPositionUncheckedCreateWithoutUserInput> | BettingPositionCreateWithoutUserInput[] | BettingPositionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BettingPositionCreateOrConnectWithoutUserInput | BettingPositionCreateOrConnectWithoutUserInput[]
    upsert?: BettingPositionUpsertWithWhereUniqueWithoutUserInput | BettingPositionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BettingPositionCreateManyUserInputEnvelope
    set?: BettingPositionWhereUniqueInput | BettingPositionWhereUniqueInput[]
    disconnect?: BettingPositionWhereUniqueInput | BettingPositionWhereUniqueInput[]
    delete?: BettingPositionWhereUniqueInput | BettingPositionWhereUniqueInput[]
    connect?: BettingPositionWhereUniqueInput | BettingPositionWhereUniqueInput[]
    update?: BettingPositionUpdateWithWhereUniqueWithoutUserInput | BettingPositionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BettingPositionUpdateManyWithWhereWithoutUserInput | BettingPositionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BettingPositionScalarWhereInput | BettingPositionScalarWhereInput[]
  }

  export type BettingPayoutUpdateManyWithoutUserNestedInput = {
    create?: XOR<BettingPayoutCreateWithoutUserInput, BettingPayoutUncheckedCreateWithoutUserInput> | BettingPayoutCreateWithoutUserInput[] | BettingPayoutUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BettingPayoutCreateOrConnectWithoutUserInput | BettingPayoutCreateOrConnectWithoutUserInput[]
    upsert?: BettingPayoutUpsertWithWhereUniqueWithoutUserInput | BettingPayoutUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BettingPayoutCreateManyUserInputEnvelope
    set?: BettingPayoutWhereUniqueInput | BettingPayoutWhereUniqueInput[]
    disconnect?: BettingPayoutWhereUniqueInput | BettingPayoutWhereUniqueInput[]
    delete?: BettingPayoutWhereUniqueInput | BettingPayoutWhereUniqueInput[]
    connect?: BettingPayoutWhereUniqueInput | BettingPayoutWhereUniqueInput[]
    update?: BettingPayoutUpdateWithWhereUniqueWithoutUserInput | BettingPayoutUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BettingPayoutUpdateManyWithWhereWithoutUserInput | BettingPayoutUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BettingPayoutScalarWhereInput | BettingPayoutScalarWhereInput[]
  }

  export type CardAuctionUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<CardAuctionCreateWithoutOwnerInput, CardAuctionUncheckedCreateWithoutOwnerInput> | CardAuctionCreateWithoutOwnerInput[] | CardAuctionUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: CardAuctionCreateOrConnectWithoutOwnerInput | CardAuctionCreateOrConnectWithoutOwnerInput[]
    upsert?: CardAuctionUpsertWithWhereUniqueWithoutOwnerInput | CardAuctionUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: CardAuctionCreateManyOwnerInputEnvelope
    set?: CardAuctionWhereUniqueInput | CardAuctionWhereUniqueInput[]
    disconnect?: CardAuctionWhereUniqueInput | CardAuctionWhereUniqueInput[]
    delete?: CardAuctionWhereUniqueInput | CardAuctionWhereUniqueInput[]
    connect?: CardAuctionWhereUniqueInput | CardAuctionWhereUniqueInput[]
    update?: CardAuctionUpdateWithWhereUniqueWithoutOwnerInput | CardAuctionUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: CardAuctionUpdateManyWithWhereWithoutOwnerInput | CardAuctionUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: CardAuctionScalarWhereInput | CardAuctionScalarWhereInput[]
  }

  export type CardAuctionUpdateManyWithoutWinnerNestedInput = {
    create?: XOR<CardAuctionCreateWithoutWinnerInput, CardAuctionUncheckedCreateWithoutWinnerInput> | CardAuctionCreateWithoutWinnerInput[] | CardAuctionUncheckedCreateWithoutWinnerInput[]
    connectOrCreate?: CardAuctionCreateOrConnectWithoutWinnerInput | CardAuctionCreateOrConnectWithoutWinnerInput[]
    upsert?: CardAuctionUpsertWithWhereUniqueWithoutWinnerInput | CardAuctionUpsertWithWhereUniqueWithoutWinnerInput[]
    createMany?: CardAuctionCreateManyWinnerInputEnvelope
    set?: CardAuctionWhereUniqueInput | CardAuctionWhereUniqueInput[]
    disconnect?: CardAuctionWhereUniqueInput | CardAuctionWhereUniqueInput[]
    delete?: CardAuctionWhereUniqueInput | CardAuctionWhereUniqueInput[]
    connect?: CardAuctionWhereUniqueInput | CardAuctionWhereUniqueInput[]
    update?: CardAuctionUpdateWithWhereUniqueWithoutWinnerInput | CardAuctionUpdateWithWhereUniqueWithoutWinnerInput[]
    updateMany?: CardAuctionUpdateManyWithWhereWithoutWinnerInput | CardAuctionUpdateManyWithWhereWithoutWinnerInput[]
    deleteMany?: CardAuctionScalarWhereInput | CardAuctionScalarWhereInput[]
  }

  export type AuctionBidUpdateManyWithoutBidderNestedInput = {
    create?: XOR<AuctionBidCreateWithoutBidderInput, AuctionBidUncheckedCreateWithoutBidderInput> | AuctionBidCreateWithoutBidderInput[] | AuctionBidUncheckedCreateWithoutBidderInput[]
    connectOrCreate?: AuctionBidCreateOrConnectWithoutBidderInput | AuctionBidCreateOrConnectWithoutBidderInput[]
    upsert?: AuctionBidUpsertWithWhereUniqueWithoutBidderInput | AuctionBidUpsertWithWhereUniqueWithoutBidderInput[]
    createMany?: AuctionBidCreateManyBidderInputEnvelope
    set?: AuctionBidWhereUniqueInput | AuctionBidWhereUniqueInput[]
    disconnect?: AuctionBidWhereUniqueInput | AuctionBidWhereUniqueInput[]
    delete?: AuctionBidWhereUniqueInput | AuctionBidWhereUniqueInput[]
    connect?: AuctionBidWhereUniqueInput | AuctionBidWhereUniqueInput[]
    update?: AuctionBidUpdateWithWhereUniqueWithoutBidderInput | AuctionBidUpdateWithWhereUniqueWithoutBidderInput[]
    updateMany?: AuctionBidUpdateManyWithWhereWithoutBidderInput | AuctionBidUpdateManyWithWhereWithoutBidderInput[]
    deleteMany?: AuctionBidScalarWhereInput | AuctionBidScalarWhereInput[]
  }

  export type AuctionWatcherUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuctionWatcherCreateWithoutUserInput, AuctionWatcherUncheckedCreateWithoutUserInput> | AuctionWatcherCreateWithoutUserInput[] | AuctionWatcherUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuctionWatcherCreateOrConnectWithoutUserInput | AuctionWatcherCreateOrConnectWithoutUserInput[]
    upsert?: AuctionWatcherUpsertWithWhereUniqueWithoutUserInput | AuctionWatcherUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuctionWatcherCreateManyUserInputEnvelope
    set?: AuctionWatcherWhereUniqueInput | AuctionWatcherWhereUniqueInput[]
    disconnect?: AuctionWatcherWhereUniqueInput | AuctionWatcherWhereUniqueInput[]
    delete?: AuctionWatcherWhereUniqueInput | AuctionWatcherWhereUniqueInput[]
    connect?: AuctionWatcherWhereUniqueInput | AuctionWatcherWhereUniqueInput[]
    update?: AuctionWatcherUpdateWithWhereUniqueWithoutUserInput | AuctionWatcherUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuctionWatcherUpdateManyWithWhereWithoutUserInput | AuctionWatcherUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuctionWatcherScalarWhereInput | AuctionWatcherScalarWhereInput[]
  }

  export type MABattleUpdateManyWithoutInitiatorNestedInput = {
    create?: XOR<MABattleCreateWithoutInitiatorInput, MABattleUncheckedCreateWithoutInitiatorInput> | MABattleCreateWithoutInitiatorInput[] | MABattleUncheckedCreateWithoutInitiatorInput[]
    connectOrCreate?: MABattleCreateOrConnectWithoutInitiatorInput | MABattleCreateOrConnectWithoutInitiatorInput[]
    upsert?: MABattleUpsertWithWhereUniqueWithoutInitiatorInput | MABattleUpsertWithWhereUniqueWithoutInitiatorInput[]
    createMany?: MABattleCreateManyInitiatorInputEnvelope
    set?: MABattleWhereUniqueInput | MABattleWhereUniqueInput[]
    disconnect?: MABattleWhereUniqueInput | MABattleWhereUniqueInput[]
    delete?: MABattleWhereUniqueInput | MABattleWhereUniqueInput[]
    connect?: MABattleWhereUniqueInput | MABattleWhereUniqueInput[]
    update?: MABattleUpdateWithWhereUniqueWithoutInitiatorInput | MABattleUpdateWithWhereUniqueWithoutInitiatorInput[]
    updateMany?: MABattleUpdateManyWithWhereWithoutInitiatorInput | MABattleUpdateManyWithWhereWithoutInitiatorInput[]
    deleteMany?: MABattleScalarWhereInput | MABattleScalarWhereInput[]
  }

  export type MABattleUpdateManyWithoutTargetNestedInput = {
    create?: XOR<MABattleCreateWithoutTargetInput, MABattleUncheckedCreateWithoutTargetInput> | MABattleCreateWithoutTargetInput[] | MABattleUncheckedCreateWithoutTargetInput[]
    connectOrCreate?: MABattleCreateOrConnectWithoutTargetInput | MABattleCreateOrConnectWithoutTargetInput[]
    upsert?: MABattleUpsertWithWhereUniqueWithoutTargetInput | MABattleUpsertWithWhereUniqueWithoutTargetInput[]
    createMany?: MABattleCreateManyTargetInputEnvelope
    set?: MABattleWhereUniqueInput | MABattleWhereUniqueInput[]
    disconnect?: MABattleWhereUniqueInput | MABattleWhereUniqueInput[]
    delete?: MABattleWhereUniqueInput | MABattleWhereUniqueInput[]
    connect?: MABattleWhereUniqueInput | MABattleWhereUniqueInput[]
    update?: MABattleUpdateWithWhereUniqueWithoutTargetInput | MABattleUpdateWithWhereUniqueWithoutTargetInput[]
    updateMany?: MABattleUpdateManyWithWhereWithoutTargetInput | MABattleUpdateManyWithWhereWithoutTargetInput[]
    deleteMany?: MABattleScalarWhereInput | MABattleScalarWhereInput[]
  }

  export type BattleProposalUpdateManyWithoutProposerNestedInput = {
    create?: XOR<BattleProposalCreateWithoutProposerInput, BattleProposalUncheckedCreateWithoutProposerInput> | BattleProposalCreateWithoutProposerInput[] | BattleProposalUncheckedCreateWithoutProposerInput[]
    connectOrCreate?: BattleProposalCreateOrConnectWithoutProposerInput | BattleProposalCreateOrConnectWithoutProposerInput[]
    upsert?: BattleProposalUpsertWithWhereUniqueWithoutProposerInput | BattleProposalUpsertWithWhereUniqueWithoutProposerInput[]
    createMany?: BattleProposalCreateManyProposerInputEnvelope
    set?: BattleProposalWhereUniqueInput | BattleProposalWhereUniqueInput[]
    disconnect?: BattleProposalWhereUniqueInput | BattleProposalWhereUniqueInput[]
    delete?: BattleProposalWhereUniqueInput | BattleProposalWhereUniqueInput[]
    connect?: BattleProposalWhereUniqueInput | BattleProposalWhereUniqueInput[]
    update?: BattleProposalUpdateWithWhereUniqueWithoutProposerInput | BattleProposalUpdateWithWhereUniqueWithoutProposerInput[]
    updateMany?: BattleProposalUpdateManyWithWhereWithoutProposerInput | BattleProposalUpdateManyWithWhereWithoutProposerInput[]
    deleteMany?: BattleProposalScalarWhereInput | BattleProposalScalarWhereInput[]
  }

  export type BattleVotingUpdateManyWithoutVoterNestedInput = {
    create?: XOR<BattleVotingCreateWithoutVoterInput, BattleVotingUncheckedCreateWithoutVoterInput> | BattleVotingCreateWithoutVoterInput[] | BattleVotingUncheckedCreateWithoutVoterInput[]
    connectOrCreate?: BattleVotingCreateOrConnectWithoutVoterInput | BattleVotingCreateOrConnectWithoutVoterInput[]
    upsert?: BattleVotingUpsertWithWhereUniqueWithoutVoterInput | BattleVotingUpsertWithWhereUniqueWithoutVoterInput[]
    createMany?: BattleVotingCreateManyVoterInputEnvelope
    set?: BattleVotingWhereUniqueInput | BattleVotingWhereUniqueInput[]
    disconnect?: BattleVotingWhereUniqueInput | BattleVotingWhereUniqueInput[]
    delete?: BattleVotingWhereUniqueInput | BattleVotingWhereUniqueInput[]
    connect?: BattleVotingWhereUniqueInput | BattleVotingWhereUniqueInput[]
    update?: BattleVotingUpdateWithWhereUniqueWithoutVoterInput | BattleVotingUpdateWithWhereUniqueWithoutVoterInput[]
    updateMany?: BattleVotingUpdateManyWithWhereWithoutVoterInput | BattleVotingUpdateManyWithWhereWithoutVoterInput[]
    deleteMany?: BattleVotingScalarWhereInput | BattleVotingScalarWhereInput[]
  }

  export type StakingPositionUpdateManyWithoutUserNestedInput = {
    create?: XOR<StakingPositionCreateWithoutUserInput, StakingPositionUncheckedCreateWithoutUserInput> | StakingPositionCreateWithoutUserInput[] | StakingPositionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StakingPositionCreateOrConnectWithoutUserInput | StakingPositionCreateOrConnectWithoutUserInput[]
    upsert?: StakingPositionUpsertWithWhereUniqueWithoutUserInput | StakingPositionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StakingPositionCreateManyUserInputEnvelope
    set?: StakingPositionWhereUniqueInput | StakingPositionWhereUniqueInput[]
    disconnect?: StakingPositionWhereUniqueInput | StakingPositionWhereUniqueInput[]
    delete?: StakingPositionWhereUniqueInput | StakingPositionWhereUniqueInput[]
    connect?: StakingPositionWhereUniqueInput | StakingPositionWhereUniqueInput[]
    update?: StakingPositionUpdateWithWhereUniqueWithoutUserInput | StakingPositionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StakingPositionUpdateManyWithWhereWithoutUserInput | StakingPositionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StakingPositionScalarWhereInput | StakingPositionScalarWhereInput[]
  }

  export type StakingRewardUpdateManyWithoutUserNestedInput = {
    create?: XOR<StakingRewardCreateWithoutUserInput, StakingRewardUncheckedCreateWithoutUserInput> | StakingRewardCreateWithoutUserInput[] | StakingRewardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StakingRewardCreateOrConnectWithoutUserInput | StakingRewardCreateOrConnectWithoutUserInput[]
    upsert?: StakingRewardUpsertWithWhereUniqueWithoutUserInput | StakingRewardUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StakingRewardCreateManyUserInputEnvelope
    set?: StakingRewardWhereUniqueInput | StakingRewardWhereUniqueInput[]
    disconnect?: StakingRewardWhereUniqueInput | StakingRewardWhereUniqueInput[]
    delete?: StakingRewardWhereUniqueInput | StakingRewardWhereUniqueInput[]
    connect?: StakingRewardWhereUniqueInput | StakingRewardWhereUniqueInput[]
    update?: StakingRewardUpdateWithWhereUniqueWithoutUserInput | StakingRewardUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StakingRewardUpdateManyWithWhereWithoutUserInput | StakingRewardUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StakingRewardScalarWhereInput | StakingRewardScalarWhereInput[]
  }

  export type GovernanceProposalUpdateManyWithoutProposerNestedInput = {
    create?: XOR<GovernanceProposalCreateWithoutProposerInput, GovernanceProposalUncheckedCreateWithoutProposerInput> | GovernanceProposalCreateWithoutProposerInput[] | GovernanceProposalUncheckedCreateWithoutProposerInput[]
    connectOrCreate?: GovernanceProposalCreateOrConnectWithoutProposerInput | GovernanceProposalCreateOrConnectWithoutProposerInput[]
    upsert?: GovernanceProposalUpsertWithWhereUniqueWithoutProposerInput | GovernanceProposalUpsertWithWhereUniqueWithoutProposerInput[]
    createMany?: GovernanceProposalCreateManyProposerInputEnvelope
    set?: GovernanceProposalWhereUniqueInput | GovernanceProposalWhereUniqueInput[]
    disconnect?: GovernanceProposalWhereUniqueInput | GovernanceProposalWhereUniqueInput[]
    delete?: GovernanceProposalWhereUniqueInput | GovernanceProposalWhereUniqueInput[]
    connect?: GovernanceProposalWhereUniqueInput | GovernanceProposalWhereUniqueInput[]
    update?: GovernanceProposalUpdateWithWhereUniqueWithoutProposerInput | GovernanceProposalUpdateWithWhereUniqueWithoutProposerInput[]
    updateMany?: GovernanceProposalUpdateManyWithWhereWithoutProposerInput | GovernanceProposalUpdateManyWithWhereWithoutProposerInput[]
    deleteMany?: GovernanceProposalScalarWhereInput | GovernanceProposalScalarWhereInput[]
  }

  export type GovernanceVoteUpdateManyWithoutUserNestedInput = {
    create?: XOR<GovernanceVoteCreateWithoutUserInput, GovernanceVoteUncheckedCreateWithoutUserInput> | GovernanceVoteCreateWithoutUserInput[] | GovernanceVoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GovernanceVoteCreateOrConnectWithoutUserInput | GovernanceVoteCreateOrConnectWithoutUserInput[]
    upsert?: GovernanceVoteUpsertWithWhereUniqueWithoutUserInput | GovernanceVoteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GovernanceVoteCreateManyUserInputEnvelope
    set?: GovernanceVoteWhereUniqueInput | GovernanceVoteWhereUniqueInput[]
    disconnect?: GovernanceVoteWhereUniqueInput | GovernanceVoteWhereUniqueInput[]
    delete?: GovernanceVoteWhereUniqueInput | GovernanceVoteWhereUniqueInput[]
    connect?: GovernanceVoteWhereUniqueInput | GovernanceVoteWhereUniqueInput[]
    update?: GovernanceVoteUpdateWithWhereUniqueWithoutUserInput | GovernanceVoteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GovernanceVoteUpdateManyWithWhereWithoutUserInput | GovernanceVoteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GovernanceVoteScalarWhereInput | GovernanceVoteScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type SocialFeedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SocialFeedCreateWithoutUserInput, SocialFeedUncheckedCreateWithoutUserInput> | SocialFeedCreateWithoutUserInput[] | SocialFeedUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SocialFeedCreateOrConnectWithoutUserInput | SocialFeedCreateOrConnectWithoutUserInput[]
    upsert?: SocialFeedUpsertWithWhereUniqueWithoutUserInput | SocialFeedUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SocialFeedCreateManyUserInputEnvelope
    set?: SocialFeedWhereUniqueInput | SocialFeedWhereUniqueInput[]
    disconnect?: SocialFeedWhereUniqueInput | SocialFeedWhereUniqueInput[]
    delete?: SocialFeedWhereUniqueInput | SocialFeedWhereUniqueInput[]
    connect?: SocialFeedWhereUniqueInput | SocialFeedWhereUniqueInput[]
    update?: SocialFeedUpdateWithWhereUniqueWithoutUserInput | SocialFeedUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SocialFeedUpdateManyWithWhereWithoutUserInput | SocialFeedUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SocialFeedScalarWhereInput | SocialFeedScalarWhereInput[]
  }

  export type FollowUpdateManyWithoutFollowerNestedInput = {
    create?: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput> | FollowCreateWithoutFollowerInput[] | FollowUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowerInput | FollowCreateOrConnectWithoutFollowerInput[]
    upsert?: FollowUpsertWithWhereUniqueWithoutFollowerInput | FollowUpsertWithWhereUniqueWithoutFollowerInput[]
    createMany?: FollowCreateManyFollowerInputEnvelope
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    update?: FollowUpdateWithWhereUniqueWithoutFollowerInput | FollowUpdateWithWhereUniqueWithoutFollowerInput[]
    updateMany?: FollowUpdateManyWithWhereWithoutFollowerInput | FollowUpdateManyWithWhereWithoutFollowerInput[]
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[]
  }

  export type FollowUpdateManyWithoutFollowingNestedInput = {
    create?: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput> | FollowCreateWithoutFollowingInput[] | FollowUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowingInput | FollowCreateOrConnectWithoutFollowingInput[]
    upsert?: FollowUpsertWithWhereUniqueWithoutFollowingInput | FollowUpsertWithWhereUniqueWithoutFollowingInput[]
    createMany?: FollowCreateManyFollowingInputEnvelope
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    update?: FollowUpdateWithWhereUniqueWithoutFollowingInput | FollowUpdateWithWhereUniqueWithoutFollowingInput[]
    updateMany?: FollowUpdateManyWithWhereWithoutFollowingInput | FollowUpdateManyWithWhereWithoutFollowingInput[]
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[]
  }

  export type UserSubscriptionUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserSubscriptionCreateWithoutUserInput, UserSubscriptionUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSubscriptionCreateOrConnectWithoutUserInput
    upsert?: UserSubscriptionUpsertWithoutUserInput
    disconnect?: UserSubscriptionWhereInput | boolean
    delete?: UserSubscriptionWhereInput | boolean
    connect?: UserSubscriptionWhereUniqueInput
    update?: XOR<XOR<UserSubscriptionUpdateToOneWithWhereWithoutUserInput, UserSubscriptionUpdateWithoutUserInput>, UserSubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type CryptoWalletUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CryptoWalletCreateWithoutUserInput, CryptoWalletUncheckedCreateWithoutUserInput> | CryptoWalletCreateWithoutUserInput[] | CryptoWalletUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CryptoWalletCreateOrConnectWithoutUserInput | CryptoWalletCreateOrConnectWithoutUserInput[]
    upsert?: CryptoWalletUpsertWithWhereUniqueWithoutUserInput | CryptoWalletUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CryptoWalletCreateManyUserInputEnvelope
    set?: CryptoWalletWhereUniqueInput | CryptoWalletWhereUniqueInput[]
    disconnect?: CryptoWalletWhereUniqueInput | CryptoWalletWhereUniqueInput[]
    delete?: CryptoWalletWhereUniqueInput | CryptoWalletWhereUniqueInput[]
    connect?: CryptoWalletWhereUniqueInput | CryptoWalletWhereUniqueInput[]
    update?: CryptoWalletUpdateWithWhereUniqueWithoutUserInput | CryptoWalletUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CryptoWalletUpdateManyWithWhereWithoutUserInput | CryptoWalletUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CryptoWalletScalarWhereInput | CryptoWalletScalarWhereInput[]
  }

  export type PhysicalCardUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<PhysicalCardCreateWithoutUserInput, PhysicalCardUncheckedCreateWithoutUserInput>
    connectOrCreate?: PhysicalCardCreateOrConnectWithoutUserInput
    upsert?: PhysicalCardUpsertWithoutUserInput
    disconnect?: PhysicalCardWhereInput | boolean
    delete?: PhysicalCardWhereInput | boolean
    connect?: PhysicalCardWhereUniqueInput
    update?: XOR<XOR<PhysicalCardUpdateToOneWithWhereWithoutUserInput, PhysicalCardUpdateWithoutUserInput>, PhysicalCardUncheckedUpdateWithoutUserInput>
  }

  export type CardUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<CardCreateWithoutOwnerInput, CardUncheckedCreateWithoutOwnerInput> | CardCreateWithoutOwnerInput[] | CardUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: CardCreateOrConnectWithoutOwnerInput | CardCreateOrConnectWithoutOwnerInput[]
    upsert?: CardUpsertWithWhereUniqueWithoutOwnerInput | CardUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: CardCreateManyOwnerInputEnvelope
    set?: CardWhereUniqueInput | CardWhereUniqueInput[]
    disconnect?: CardWhereUniqueInput | CardWhereUniqueInput[]
    delete?: CardWhereUniqueInput | CardWhereUniqueInput[]
    connect?: CardWhereUniqueInput | CardWhereUniqueInput[]
    update?: CardUpdateWithWhereUniqueWithoutOwnerInput | CardUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: CardUpdateManyWithWhereWithoutOwnerInput | CardUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: CardScalarWhereInput | CardScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutUserInput | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutUserInput | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutUserInput | TransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type BidUncheckedUpdateManyWithoutBidderNestedInput = {
    create?: XOR<BidCreateWithoutBidderInput, BidUncheckedCreateWithoutBidderInput> | BidCreateWithoutBidderInput[] | BidUncheckedCreateWithoutBidderInput[]
    connectOrCreate?: BidCreateOrConnectWithoutBidderInput | BidCreateOrConnectWithoutBidderInput[]
    upsert?: BidUpsertWithWhereUniqueWithoutBidderInput | BidUpsertWithWhereUniqueWithoutBidderInput[]
    createMany?: BidCreateManyBidderInputEnvelope
    set?: BidWhereUniqueInput | BidWhereUniqueInput[]
    disconnect?: BidWhereUniqueInput | BidWhereUniqueInput[]
    delete?: BidWhereUniqueInput | BidWhereUniqueInput[]
    connect?: BidWhereUniqueInput | BidWhereUniqueInput[]
    update?: BidUpdateWithWhereUniqueWithoutBidderInput | BidUpdateWithWhereUniqueWithoutBidderInput[]
    updateMany?: BidUpdateManyWithWhereWithoutBidderInput | BidUpdateManyWithWhereWithoutBidderInput[]
    deleteMany?: BidScalarWhereInput | BidScalarWhereInput[]
  }

  export type MarketplaceListingUncheckedUpdateManyWithoutSellerNestedInput = {
    create?: XOR<MarketplaceListingCreateWithoutSellerInput, MarketplaceListingUncheckedCreateWithoutSellerInput> | MarketplaceListingCreateWithoutSellerInput[] | MarketplaceListingUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: MarketplaceListingCreateOrConnectWithoutSellerInput | MarketplaceListingCreateOrConnectWithoutSellerInput[]
    upsert?: MarketplaceListingUpsertWithWhereUniqueWithoutSellerInput | MarketplaceListingUpsertWithWhereUniqueWithoutSellerInput[]
    createMany?: MarketplaceListingCreateManySellerInputEnvelope
    set?: MarketplaceListingWhereUniqueInput | MarketplaceListingWhereUniqueInput[]
    disconnect?: MarketplaceListingWhereUniqueInput | MarketplaceListingWhereUniqueInput[]
    delete?: MarketplaceListingWhereUniqueInput | MarketplaceListingWhereUniqueInput[]
    connect?: MarketplaceListingWhereUniqueInput | MarketplaceListingWhereUniqueInput[]
    update?: MarketplaceListingUpdateWithWhereUniqueWithoutSellerInput | MarketplaceListingUpdateWithWhereUniqueWithoutSellerInput[]
    updateMany?: MarketplaceListingUpdateManyWithWhereWithoutSellerInput | MarketplaceListingUpdateManyWithWhereWithoutSellerInput[]
    deleteMany?: MarketplaceListingScalarWhereInput | MarketplaceListingScalarWhereInput[]
  }

  export type AppOrderUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AppOrderCreateWithoutUserInput, AppOrderUncheckedCreateWithoutUserInput> | AppOrderCreateWithoutUserInput[] | AppOrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AppOrderCreateOrConnectWithoutUserInput | AppOrderCreateOrConnectWithoutUserInput[]
    upsert?: AppOrderUpsertWithWhereUniqueWithoutUserInput | AppOrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AppOrderCreateManyUserInputEnvelope
    set?: AppOrderWhereUniqueInput | AppOrderWhereUniqueInput[]
    disconnect?: AppOrderWhereUniqueInput | AppOrderWhereUniqueInput[]
    delete?: AppOrderWhereUniqueInput | AppOrderWhereUniqueInput[]
    connect?: AppOrderWhereUniqueInput | AppOrderWhereUniqueInput[]
    update?: AppOrderUpdateWithWhereUniqueWithoutUserInput | AppOrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AppOrderUpdateManyWithWhereWithoutUserInput | AppOrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AppOrderScalarWhereInput | AppOrderScalarWhereInput[]
  }

  export type OrderRevisionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderRevisionCreateWithoutUserInput, OrderRevisionUncheckedCreateWithoutUserInput> | OrderRevisionCreateWithoutUserInput[] | OrderRevisionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderRevisionCreateOrConnectWithoutUserInput | OrderRevisionCreateOrConnectWithoutUserInput[]
    upsert?: OrderRevisionUpsertWithWhereUniqueWithoutUserInput | OrderRevisionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderRevisionCreateManyUserInputEnvelope
    set?: OrderRevisionWhereUniqueInput | OrderRevisionWhereUniqueInput[]
    disconnect?: OrderRevisionWhereUniqueInput | OrderRevisionWhereUniqueInput[]
    delete?: OrderRevisionWhereUniqueInput | OrderRevisionWhereUniqueInput[]
    connect?: OrderRevisionWhereUniqueInput | OrderRevisionWhereUniqueInput[]
    update?: OrderRevisionUpdateWithWhereUniqueWithoutUserInput | OrderRevisionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderRevisionUpdateManyWithWhereWithoutUserInput | OrderRevisionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderRevisionScalarWhereInput | OrderRevisionScalarWhereInput[]
  }

  export type OrderCommunicationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderCommunicationCreateWithoutUserInput, OrderCommunicationUncheckedCreateWithoutUserInput> | OrderCommunicationCreateWithoutUserInput[] | OrderCommunicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCommunicationCreateOrConnectWithoutUserInput | OrderCommunicationCreateOrConnectWithoutUserInput[]
    upsert?: OrderCommunicationUpsertWithWhereUniqueWithoutUserInput | OrderCommunicationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderCommunicationCreateManyUserInputEnvelope
    set?: OrderCommunicationWhereUniqueInput | OrderCommunicationWhereUniqueInput[]
    disconnect?: OrderCommunicationWhereUniqueInput | OrderCommunicationWhereUniqueInput[]
    delete?: OrderCommunicationWhereUniqueInput | OrderCommunicationWhereUniqueInput[]
    connect?: OrderCommunicationWhereUniqueInput | OrderCommunicationWhereUniqueInput[]
    update?: OrderCommunicationUpdateWithWhereUniqueWithoutUserInput | OrderCommunicationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderCommunicationUpdateManyWithWhereWithoutUserInput | OrderCommunicationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderCommunicationScalarWhereInput | OrderCommunicationScalarWhereInput[]
  }

  export type BettingPositionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BettingPositionCreateWithoutUserInput, BettingPositionUncheckedCreateWithoutUserInput> | BettingPositionCreateWithoutUserInput[] | BettingPositionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BettingPositionCreateOrConnectWithoutUserInput | BettingPositionCreateOrConnectWithoutUserInput[]
    upsert?: BettingPositionUpsertWithWhereUniqueWithoutUserInput | BettingPositionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BettingPositionCreateManyUserInputEnvelope
    set?: BettingPositionWhereUniqueInput | BettingPositionWhereUniqueInput[]
    disconnect?: BettingPositionWhereUniqueInput | BettingPositionWhereUniqueInput[]
    delete?: BettingPositionWhereUniqueInput | BettingPositionWhereUniqueInput[]
    connect?: BettingPositionWhereUniqueInput | BettingPositionWhereUniqueInput[]
    update?: BettingPositionUpdateWithWhereUniqueWithoutUserInput | BettingPositionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BettingPositionUpdateManyWithWhereWithoutUserInput | BettingPositionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BettingPositionScalarWhereInput | BettingPositionScalarWhereInput[]
  }

  export type BettingPayoutUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BettingPayoutCreateWithoutUserInput, BettingPayoutUncheckedCreateWithoutUserInput> | BettingPayoutCreateWithoutUserInput[] | BettingPayoutUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BettingPayoutCreateOrConnectWithoutUserInput | BettingPayoutCreateOrConnectWithoutUserInput[]
    upsert?: BettingPayoutUpsertWithWhereUniqueWithoutUserInput | BettingPayoutUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BettingPayoutCreateManyUserInputEnvelope
    set?: BettingPayoutWhereUniqueInput | BettingPayoutWhereUniqueInput[]
    disconnect?: BettingPayoutWhereUniqueInput | BettingPayoutWhereUniqueInput[]
    delete?: BettingPayoutWhereUniqueInput | BettingPayoutWhereUniqueInput[]
    connect?: BettingPayoutWhereUniqueInput | BettingPayoutWhereUniqueInput[]
    update?: BettingPayoutUpdateWithWhereUniqueWithoutUserInput | BettingPayoutUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BettingPayoutUpdateManyWithWhereWithoutUserInput | BettingPayoutUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BettingPayoutScalarWhereInput | BettingPayoutScalarWhereInput[]
  }

  export type CardAuctionUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<CardAuctionCreateWithoutOwnerInput, CardAuctionUncheckedCreateWithoutOwnerInput> | CardAuctionCreateWithoutOwnerInput[] | CardAuctionUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: CardAuctionCreateOrConnectWithoutOwnerInput | CardAuctionCreateOrConnectWithoutOwnerInput[]
    upsert?: CardAuctionUpsertWithWhereUniqueWithoutOwnerInput | CardAuctionUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: CardAuctionCreateManyOwnerInputEnvelope
    set?: CardAuctionWhereUniqueInput | CardAuctionWhereUniqueInput[]
    disconnect?: CardAuctionWhereUniqueInput | CardAuctionWhereUniqueInput[]
    delete?: CardAuctionWhereUniqueInput | CardAuctionWhereUniqueInput[]
    connect?: CardAuctionWhereUniqueInput | CardAuctionWhereUniqueInput[]
    update?: CardAuctionUpdateWithWhereUniqueWithoutOwnerInput | CardAuctionUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: CardAuctionUpdateManyWithWhereWithoutOwnerInput | CardAuctionUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: CardAuctionScalarWhereInput | CardAuctionScalarWhereInput[]
  }

  export type CardAuctionUncheckedUpdateManyWithoutWinnerNestedInput = {
    create?: XOR<CardAuctionCreateWithoutWinnerInput, CardAuctionUncheckedCreateWithoutWinnerInput> | CardAuctionCreateWithoutWinnerInput[] | CardAuctionUncheckedCreateWithoutWinnerInput[]
    connectOrCreate?: CardAuctionCreateOrConnectWithoutWinnerInput | CardAuctionCreateOrConnectWithoutWinnerInput[]
    upsert?: CardAuctionUpsertWithWhereUniqueWithoutWinnerInput | CardAuctionUpsertWithWhereUniqueWithoutWinnerInput[]
    createMany?: CardAuctionCreateManyWinnerInputEnvelope
    set?: CardAuctionWhereUniqueInput | CardAuctionWhereUniqueInput[]
    disconnect?: CardAuctionWhereUniqueInput | CardAuctionWhereUniqueInput[]
    delete?: CardAuctionWhereUniqueInput | CardAuctionWhereUniqueInput[]
    connect?: CardAuctionWhereUniqueInput | CardAuctionWhereUniqueInput[]
    update?: CardAuctionUpdateWithWhereUniqueWithoutWinnerInput | CardAuctionUpdateWithWhereUniqueWithoutWinnerInput[]
    updateMany?: CardAuctionUpdateManyWithWhereWithoutWinnerInput | CardAuctionUpdateManyWithWhereWithoutWinnerInput[]
    deleteMany?: CardAuctionScalarWhereInput | CardAuctionScalarWhereInput[]
  }

  export type AuctionBidUncheckedUpdateManyWithoutBidderNestedInput = {
    create?: XOR<AuctionBidCreateWithoutBidderInput, AuctionBidUncheckedCreateWithoutBidderInput> | AuctionBidCreateWithoutBidderInput[] | AuctionBidUncheckedCreateWithoutBidderInput[]
    connectOrCreate?: AuctionBidCreateOrConnectWithoutBidderInput | AuctionBidCreateOrConnectWithoutBidderInput[]
    upsert?: AuctionBidUpsertWithWhereUniqueWithoutBidderInput | AuctionBidUpsertWithWhereUniqueWithoutBidderInput[]
    createMany?: AuctionBidCreateManyBidderInputEnvelope
    set?: AuctionBidWhereUniqueInput | AuctionBidWhereUniqueInput[]
    disconnect?: AuctionBidWhereUniqueInput | AuctionBidWhereUniqueInput[]
    delete?: AuctionBidWhereUniqueInput | AuctionBidWhereUniqueInput[]
    connect?: AuctionBidWhereUniqueInput | AuctionBidWhereUniqueInput[]
    update?: AuctionBidUpdateWithWhereUniqueWithoutBidderInput | AuctionBidUpdateWithWhereUniqueWithoutBidderInput[]
    updateMany?: AuctionBidUpdateManyWithWhereWithoutBidderInput | AuctionBidUpdateManyWithWhereWithoutBidderInput[]
    deleteMany?: AuctionBidScalarWhereInput | AuctionBidScalarWhereInput[]
  }

  export type AuctionWatcherUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuctionWatcherCreateWithoutUserInput, AuctionWatcherUncheckedCreateWithoutUserInput> | AuctionWatcherCreateWithoutUserInput[] | AuctionWatcherUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuctionWatcherCreateOrConnectWithoutUserInput | AuctionWatcherCreateOrConnectWithoutUserInput[]
    upsert?: AuctionWatcherUpsertWithWhereUniqueWithoutUserInput | AuctionWatcherUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuctionWatcherCreateManyUserInputEnvelope
    set?: AuctionWatcherWhereUniqueInput | AuctionWatcherWhereUniqueInput[]
    disconnect?: AuctionWatcherWhereUniqueInput | AuctionWatcherWhereUniqueInput[]
    delete?: AuctionWatcherWhereUniqueInput | AuctionWatcherWhereUniqueInput[]
    connect?: AuctionWatcherWhereUniqueInput | AuctionWatcherWhereUniqueInput[]
    update?: AuctionWatcherUpdateWithWhereUniqueWithoutUserInput | AuctionWatcherUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuctionWatcherUpdateManyWithWhereWithoutUserInput | AuctionWatcherUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuctionWatcherScalarWhereInput | AuctionWatcherScalarWhereInput[]
  }

  export type MABattleUncheckedUpdateManyWithoutInitiatorNestedInput = {
    create?: XOR<MABattleCreateWithoutInitiatorInput, MABattleUncheckedCreateWithoutInitiatorInput> | MABattleCreateWithoutInitiatorInput[] | MABattleUncheckedCreateWithoutInitiatorInput[]
    connectOrCreate?: MABattleCreateOrConnectWithoutInitiatorInput | MABattleCreateOrConnectWithoutInitiatorInput[]
    upsert?: MABattleUpsertWithWhereUniqueWithoutInitiatorInput | MABattleUpsertWithWhereUniqueWithoutInitiatorInput[]
    createMany?: MABattleCreateManyInitiatorInputEnvelope
    set?: MABattleWhereUniqueInput | MABattleWhereUniqueInput[]
    disconnect?: MABattleWhereUniqueInput | MABattleWhereUniqueInput[]
    delete?: MABattleWhereUniqueInput | MABattleWhereUniqueInput[]
    connect?: MABattleWhereUniqueInput | MABattleWhereUniqueInput[]
    update?: MABattleUpdateWithWhereUniqueWithoutInitiatorInput | MABattleUpdateWithWhereUniqueWithoutInitiatorInput[]
    updateMany?: MABattleUpdateManyWithWhereWithoutInitiatorInput | MABattleUpdateManyWithWhereWithoutInitiatorInput[]
    deleteMany?: MABattleScalarWhereInput | MABattleScalarWhereInput[]
  }

  export type MABattleUncheckedUpdateManyWithoutTargetNestedInput = {
    create?: XOR<MABattleCreateWithoutTargetInput, MABattleUncheckedCreateWithoutTargetInput> | MABattleCreateWithoutTargetInput[] | MABattleUncheckedCreateWithoutTargetInput[]
    connectOrCreate?: MABattleCreateOrConnectWithoutTargetInput | MABattleCreateOrConnectWithoutTargetInput[]
    upsert?: MABattleUpsertWithWhereUniqueWithoutTargetInput | MABattleUpsertWithWhereUniqueWithoutTargetInput[]
    createMany?: MABattleCreateManyTargetInputEnvelope
    set?: MABattleWhereUniqueInput | MABattleWhereUniqueInput[]
    disconnect?: MABattleWhereUniqueInput | MABattleWhereUniqueInput[]
    delete?: MABattleWhereUniqueInput | MABattleWhereUniqueInput[]
    connect?: MABattleWhereUniqueInput | MABattleWhereUniqueInput[]
    update?: MABattleUpdateWithWhereUniqueWithoutTargetInput | MABattleUpdateWithWhereUniqueWithoutTargetInput[]
    updateMany?: MABattleUpdateManyWithWhereWithoutTargetInput | MABattleUpdateManyWithWhereWithoutTargetInput[]
    deleteMany?: MABattleScalarWhereInput | MABattleScalarWhereInput[]
  }

  export type BattleProposalUncheckedUpdateManyWithoutProposerNestedInput = {
    create?: XOR<BattleProposalCreateWithoutProposerInput, BattleProposalUncheckedCreateWithoutProposerInput> | BattleProposalCreateWithoutProposerInput[] | BattleProposalUncheckedCreateWithoutProposerInput[]
    connectOrCreate?: BattleProposalCreateOrConnectWithoutProposerInput | BattleProposalCreateOrConnectWithoutProposerInput[]
    upsert?: BattleProposalUpsertWithWhereUniqueWithoutProposerInput | BattleProposalUpsertWithWhereUniqueWithoutProposerInput[]
    createMany?: BattleProposalCreateManyProposerInputEnvelope
    set?: BattleProposalWhereUniqueInput | BattleProposalWhereUniqueInput[]
    disconnect?: BattleProposalWhereUniqueInput | BattleProposalWhereUniqueInput[]
    delete?: BattleProposalWhereUniqueInput | BattleProposalWhereUniqueInput[]
    connect?: BattleProposalWhereUniqueInput | BattleProposalWhereUniqueInput[]
    update?: BattleProposalUpdateWithWhereUniqueWithoutProposerInput | BattleProposalUpdateWithWhereUniqueWithoutProposerInput[]
    updateMany?: BattleProposalUpdateManyWithWhereWithoutProposerInput | BattleProposalUpdateManyWithWhereWithoutProposerInput[]
    deleteMany?: BattleProposalScalarWhereInput | BattleProposalScalarWhereInput[]
  }

  export type BattleVotingUncheckedUpdateManyWithoutVoterNestedInput = {
    create?: XOR<BattleVotingCreateWithoutVoterInput, BattleVotingUncheckedCreateWithoutVoterInput> | BattleVotingCreateWithoutVoterInput[] | BattleVotingUncheckedCreateWithoutVoterInput[]
    connectOrCreate?: BattleVotingCreateOrConnectWithoutVoterInput | BattleVotingCreateOrConnectWithoutVoterInput[]
    upsert?: BattleVotingUpsertWithWhereUniqueWithoutVoterInput | BattleVotingUpsertWithWhereUniqueWithoutVoterInput[]
    createMany?: BattleVotingCreateManyVoterInputEnvelope
    set?: BattleVotingWhereUniqueInput | BattleVotingWhereUniqueInput[]
    disconnect?: BattleVotingWhereUniqueInput | BattleVotingWhereUniqueInput[]
    delete?: BattleVotingWhereUniqueInput | BattleVotingWhereUniqueInput[]
    connect?: BattleVotingWhereUniqueInput | BattleVotingWhereUniqueInput[]
    update?: BattleVotingUpdateWithWhereUniqueWithoutVoterInput | BattleVotingUpdateWithWhereUniqueWithoutVoterInput[]
    updateMany?: BattleVotingUpdateManyWithWhereWithoutVoterInput | BattleVotingUpdateManyWithWhereWithoutVoterInput[]
    deleteMany?: BattleVotingScalarWhereInput | BattleVotingScalarWhereInput[]
  }

  export type StakingPositionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<StakingPositionCreateWithoutUserInput, StakingPositionUncheckedCreateWithoutUserInput> | StakingPositionCreateWithoutUserInput[] | StakingPositionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StakingPositionCreateOrConnectWithoutUserInput | StakingPositionCreateOrConnectWithoutUserInput[]
    upsert?: StakingPositionUpsertWithWhereUniqueWithoutUserInput | StakingPositionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StakingPositionCreateManyUserInputEnvelope
    set?: StakingPositionWhereUniqueInput | StakingPositionWhereUniqueInput[]
    disconnect?: StakingPositionWhereUniqueInput | StakingPositionWhereUniqueInput[]
    delete?: StakingPositionWhereUniqueInput | StakingPositionWhereUniqueInput[]
    connect?: StakingPositionWhereUniqueInput | StakingPositionWhereUniqueInput[]
    update?: StakingPositionUpdateWithWhereUniqueWithoutUserInput | StakingPositionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StakingPositionUpdateManyWithWhereWithoutUserInput | StakingPositionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StakingPositionScalarWhereInput | StakingPositionScalarWhereInput[]
  }

  export type StakingRewardUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<StakingRewardCreateWithoutUserInput, StakingRewardUncheckedCreateWithoutUserInput> | StakingRewardCreateWithoutUserInput[] | StakingRewardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StakingRewardCreateOrConnectWithoutUserInput | StakingRewardCreateOrConnectWithoutUserInput[]
    upsert?: StakingRewardUpsertWithWhereUniqueWithoutUserInput | StakingRewardUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StakingRewardCreateManyUserInputEnvelope
    set?: StakingRewardWhereUniqueInput | StakingRewardWhereUniqueInput[]
    disconnect?: StakingRewardWhereUniqueInput | StakingRewardWhereUniqueInput[]
    delete?: StakingRewardWhereUniqueInput | StakingRewardWhereUniqueInput[]
    connect?: StakingRewardWhereUniqueInput | StakingRewardWhereUniqueInput[]
    update?: StakingRewardUpdateWithWhereUniqueWithoutUserInput | StakingRewardUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StakingRewardUpdateManyWithWhereWithoutUserInput | StakingRewardUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StakingRewardScalarWhereInput | StakingRewardScalarWhereInput[]
  }

  export type GovernanceProposalUncheckedUpdateManyWithoutProposerNestedInput = {
    create?: XOR<GovernanceProposalCreateWithoutProposerInput, GovernanceProposalUncheckedCreateWithoutProposerInput> | GovernanceProposalCreateWithoutProposerInput[] | GovernanceProposalUncheckedCreateWithoutProposerInput[]
    connectOrCreate?: GovernanceProposalCreateOrConnectWithoutProposerInput | GovernanceProposalCreateOrConnectWithoutProposerInput[]
    upsert?: GovernanceProposalUpsertWithWhereUniqueWithoutProposerInput | GovernanceProposalUpsertWithWhereUniqueWithoutProposerInput[]
    createMany?: GovernanceProposalCreateManyProposerInputEnvelope
    set?: GovernanceProposalWhereUniqueInput | GovernanceProposalWhereUniqueInput[]
    disconnect?: GovernanceProposalWhereUniqueInput | GovernanceProposalWhereUniqueInput[]
    delete?: GovernanceProposalWhereUniqueInput | GovernanceProposalWhereUniqueInput[]
    connect?: GovernanceProposalWhereUniqueInput | GovernanceProposalWhereUniqueInput[]
    update?: GovernanceProposalUpdateWithWhereUniqueWithoutProposerInput | GovernanceProposalUpdateWithWhereUniqueWithoutProposerInput[]
    updateMany?: GovernanceProposalUpdateManyWithWhereWithoutProposerInput | GovernanceProposalUpdateManyWithWhereWithoutProposerInput[]
    deleteMany?: GovernanceProposalScalarWhereInput | GovernanceProposalScalarWhereInput[]
  }

  export type GovernanceVoteUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<GovernanceVoteCreateWithoutUserInput, GovernanceVoteUncheckedCreateWithoutUserInput> | GovernanceVoteCreateWithoutUserInput[] | GovernanceVoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GovernanceVoteCreateOrConnectWithoutUserInput | GovernanceVoteCreateOrConnectWithoutUserInput[]
    upsert?: GovernanceVoteUpsertWithWhereUniqueWithoutUserInput | GovernanceVoteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GovernanceVoteCreateManyUserInputEnvelope
    set?: GovernanceVoteWhereUniqueInput | GovernanceVoteWhereUniqueInput[]
    disconnect?: GovernanceVoteWhereUniqueInput | GovernanceVoteWhereUniqueInput[]
    delete?: GovernanceVoteWhereUniqueInput | GovernanceVoteWhereUniqueInput[]
    connect?: GovernanceVoteWhereUniqueInput | GovernanceVoteWhereUniqueInput[]
    update?: GovernanceVoteUpdateWithWhereUniqueWithoutUserInput | GovernanceVoteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GovernanceVoteUpdateManyWithWhereWithoutUserInput | GovernanceVoteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GovernanceVoteScalarWhereInput | GovernanceVoteScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type SocialFeedUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SocialFeedCreateWithoutUserInput, SocialFeedUncheckedCreateWithoutUserInput> | SocialFeedCreateWithoutUserInput[] | SocialFeedUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SocialFeedCreateOrConnectWithoutUserInput | SocialFeedCreateOrConnectWithoutUserInput[]
    upsert?: SocialFeedUpsertWithWhereUniqueWithoutUserInput | SocialFeedUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SocialFeedCreateManyUserInputEnvelope
    set?: SocialFeedWhereUniqueInput | SocialFeedWhereUniqueInput[]
    disconnect?: SocialFeedWhereUniqueInput | SocialFeedWhereUniqueInput[]
    delete?: SocialFeedWhereUniqueInput | SocialFeedWhereUniqueInput[]
    connect?: SocialFeedWhereUniqueInput | SocialFeedWhereUniqueInput[]
    update?: SocialFeedUpdateWithWhereUniqueWithoutUserInput | SocialFeedUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SocialFeedUpdateManyWithWhereWithoutUserInput | SocialFeedUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SocialFeedScalarWhereInput | SocialFeedScalarWhereInput[]
  }

  export type FollowUncheckedUpdateManyWithoutFollowerNestedInput = {
    create?: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput> | FollowCreateWithoutFollowerInput[] | FollowUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowerInput | FollowCreateOrConnectWithoutFollowerInput[]
    upsert?: FollowUpsertWithWhereUniqueWithoutFollowerInput | FollowUpsertWithWhereUniqueWithoutFollowerInput[]
    createMany?: FollowCreateManyFollowerInputEnvelope
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    update?: FollowUpdateWithWhereUniqueWithoutFollowerInput | FollowUpdateWithWhereUniqueWithoutFollowerInput[]
    updateMany?: FollowUpdateManyWithWhereWithoutFollowerInput | FollowUpdateManyWithWhereWithoutFollowerInput[]
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[]
  }

  export type FollowUncheckedUpdateManyWithoutFollowingNestedInput = {
    create?: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput> | FollowCreateWithoutFollowingInput[] | FollowUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowingInput | FollowCreateOrConnectWithoutFollowingInput[]
    upsert?: FollowUpsertWithWhereUniqueWithoutFollowingInput | FollowUpsertWithWhereUniqueWithoutFollowingInput[]
    createMany?: FollowCreateManyFollowingInputEnvelope
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    update?: FollowUpdateWithWhereUniqueWithoutFollowingInput | FollowUpdateWithWhereUniqueWithoutFollowingInput[]
    updateMany?: FollowUpdateManyWithWhereWithoutFollowingInput | FollowUpdateManyWithWhereWithoutFollowingInput[]
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSubscriptionInput = {
    create?: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionInput
    connect?: UserWhereUniqueInput
  }

  export type SubscriptionFeaturesCreateNestedOneWithoutSubscriptionInput = {
    create?: XOR<SubscriptionFeaturesCreateWithoutSubscriptionInput, SubscriptionFeaturesUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: SubscriptionFeaturesCreateOrConnectWithoutSubscriptionInput
    connect?: SubscriptionFeaturesWhereUniqueInput
  }

  export type SubscriptionUsageCreateNestedOneWithoutSubscriptionInput = {
    create?: XOR<SubscriptionUsageCreateWithoutSubscriptionInput, SubscriptionUsageUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: SubscriptionUsageCreateOrConnectWithoutSubscriptionInput
    connect?: SubscriptionUsageWhereUniqueInput
  }

  export type SubscriptionFeaturesUncheckedCreateNestedOneWithoutSubscriptionInput = {
    create?: XOR<SubscriptionFeaturesCreateWithoutSubscriptionInput, SubscriptionFeaturesUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: SubscriptionFeaturesCreateOrConnectWithoutSubscriptionInput
    connect?: SubscriptionFeaturesWhereUniqueInput
  }

  export type SubscriptionUsageUncheckedCreateNestedOneWithoutSubscriptionInput = {
    create?: XOR<SubscriptionUsageCreateWithoutSubscriptionInput, SubscriptionUsageUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: SubscriptionUsageCreateOrConnectWithoutSubscriptionInput
    connect?: SubscriptionUsageWhereUniqueInput
  }

  export type EnumSubscriptionPlanFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionPlan
  }

  export type EnumSubscriptionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionStatus
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutSubscriptionNestedInput = {
    create?: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionInput
    upsert?: UserUpsertWithoutSubscriptionInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSubscriptionInput, UserUpdateWithoutSubscriptionInput>, UserUncheckedUpdateWithoutSubscriptionInput>
  }

  export type SubscriptionFeaturesUpdateOneWithoutSubscriptionNestedInput = {
    create?: XOR<SubscriptionFeaturesCreateWithoutSubscriptionInput, SubscriptionFeaturesUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: SubscriptionFeaturesCreateOrConnectWithoutSubscriptionInput
    upsert?: SubscriptionFeaturesUpsertWithoutSubscriptionInput
    disconnect?: SubscriptionFeaturesWhereInput | boolean
    delete?: SubscriptionFeaturesWhereInput | boolean
    connect?: SubscriptionFeaturesWhereUniqueInput
    update?: XOR<XOR<SubscriptionFeaturesUpdateToOneWithWhereWithoutSubscriptionInput, SubscriptionFeaturesUpdateWithoutSubscriptionInput>, SubscriptionFeaturesUncheckedUpdateWithoutSubscriptionInput>
  }

  export type SubscriptionUsageUpdateOneWithoutSubscriptionNestedInput = {
    create?: XOR<SubscriptionUsageCreateWithoutSubscriptionInput, SubscriptionUsageUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: SubscriptionUsageCreateOrConnectWithoutSubscriptionInput
    upsert?: SubscriptionUsageUpsertWithoutSubscriptionInput
    disconnect?: SubscriptionUsageWhereInput | boolean
    delete?: SubscriptionUsageWhereInput | boolean
    connect?: SubscriptionUsageWhereUniqueInput
    update?: XOR<XOR<SubscriptionUsageUpdateToOneWithWhereWithoutSubscriptionInput, SubscriptionUsageUpdateWithoutSubscriptionInput>, SubscriptionUsageUncheckedUpdateWithoutSubscriptionInput>
  }

  export type SubscriptionFeaturesUncheckedUpdateOneWithoutSubscriptionNestedInput = {
    create?: XOR<SubscriptionFeaturesCreateWithoutSubscriptionInput, SubscriptionFeaturesUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: SubscriptionFeaturesCreateOrConnectWithoutSubscriptionInput
    upsert?: SubscriptionFeaturesUpsertWithoutSubscriptionInput
    disconnect?: SubscriptionFeaturesWhereInput | boolean
    delete?: SubscriptionFeaturesWhereInput | boolean
    connect?: SubscriptionFeaturesWhereUniqueInput
    update?: XOR<XOR<SubscriptionFeaturesUpdateToOneWithWhereWithoutSubscriptionInput, SubscriptionFeaturesUpdateWithoutSubscriptionInput>, SubscriptionFeaturesUncheckedUpdateWithoutSubscriptionInput>
  }

  export type SubscriptionUsageUncheckedUpdateOneWithoutSubscriptionNestedInput = {
    create?: XOR<SubscriptionUsageCreateWithoutSubscriptionInput, SubscriptionUsageUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: SubscriptionUsageCreateOrConnectWithoutSubscriptionInput
    upsert?: SubscriptionUsageUpsertWithoutSubscriptionInput
    disconnect?: SubscriptionUsageWhereInput | boolean
    delete?: SubscriptionUsageWhereInput | boolean
    connect?: SubscriptionUsageWhereUniqueInput
    update?: XOR<XOR<SubscriptionUsageUpdateToOneWithWhereWithoutSubscriptionInput, SubscriptionUsageUpdateWithoutSubscriptionInput>, SubscriptionUsageUncheckedUpdateWithoutSubscriptionInput>
  }

  export type UserSubscriptionCreateNestedOneWithoutFeaturesInput = {
    create?: XOR<UserSubscriptionCreateWithoutFeaturesInput, UserSubscriptionUncheckedCreateWithoutFeaturesInput>
    connectOrCreate?: UserSubscriptionCreateOrConnectWithoutFeaturesInput
    connect?: UserSubscriptionWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserSubscriptionUpdateOneRequiredWithoutFeaturesNestedInput = {
    create?: XOR<UserSubscriptionCreateWithoutFeaturesInput, UserSubscriptionUncheckedCreateWithoutFeaturesInput>
    connectOrCreate?: UserSubscriptionCreateOrConnectWithoutFeaturesInput
    upsert?: UserSubscriptionUpsertWithoutFeaturesInput
    connect?: UserSubscriptionWhereUniqueInput
    update?: XOR<XOR<UserSubscriptionUpdateToOneWithWhereWithoutFeaturesInput, UserSubscriptionUpdateWithoutFeaturesInput>, UserSubscriptionUncheckedUpdateWithoutFeaturesInput>
  }

  export type UserSubscriptionCreateNestedOneWithoutUsageInput = {
    create?: XOR<UserSubscriptionCreateWithoutUsageInput, UserSubscriptionUncheckedCreateWithoutUsageInput>
    connectOrCreate?: UserSubscriptionCreateOrConnectWithoutUsageInput
    connect?: UserSubscriptionWhereUniqueInput
  }

  export type UserSubscriptionUpdateOneRequiredWithoutUsageNestedInput = {
    create?: XOR<UserSubscriptionCreateWithoutUsageInput, UserSubscriptionUncheckedCreateWithoutUsageInput>
    connectOrCreate?: UserSubscriptionCreateOrConnectWithoutUsageInput
    upsert?: UserSubscriptionUpsertWithoutUsageInput
    connect?: UserSubscriptionWhereUniqueInput
    update?: XOR<XOR<UserSubscriptionUpdateToOneWithWhereWithoutUsageInput, UserSubscriptionUpdateWithoutUsageInput>, UserSubscriptionUncheckedUpdateWithoutUsageInput>
  }

  export type UserCreateNestedOneWithoutOwnedCardsInput = {
    create?: XOR<UserCreateWithoutOwnedCardsInput, UserUncheckedCreateWithoutOwnedCardsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedCardsInput
    connect?: UserWhereUniqueInput
  }

  export type MarketplaceListingCreateNestedOneWithoutCardInput = {
    create?: XOR<MarketplaceListingCreateWithoutCardInput, MarketplaceListingUncheckedCreateWithoutCardInput>
    connectOrCreate?: MarketplaceListingCreateOrConnectWithoutCardInput
    connect?: MarketplaceListingWhereUniqueInput
  }

  export type BidCreateNestedManyWithoutCardInput = {
    create?: XOR<BidCreateWithoutCardInput, BidUncheckedCreateWithoutCardInput> | BidCreateWithoutCardInput[] | BidUncheckedCreateWithoutCardInput[]
    connectOrCreate?: BidCreateOrConnectWithoutCardInput | BidCreateOrConnectWithoutCardInput[]
    createMany?: BidCreateManyCardInputEnvelope
    connect?: BidWhereUniqueInput | BidWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutCardInput = {
    create?: XOR<TransactionCreateWithoutCardInput, TransactionUncheckedCreateWithoutCardInput> | TransactionCreateWithoutCardInput[] | TransactionUncheckedCreateWithoutCardInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCardInput | TransactionCreateOrConnectWithoutCardInput[]
    createMany?: TransactionCreateManyCardInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type BettingMarketCreateNestedManyWithoutCardInput = {
    create?: XOR<BettingMarketCreateWithoutCardInput, BettingMarketUncheckedCreateWithoutCardInput> | BettingMarketCreateWithoutCardInput[] | BettingMarketUncheckedCreateWithoutCardInput[]
    connectOrCreate?: BettingMarketCreateOrConnectWithoutCardInput | BettingMarketCreateOrConnectWithoutCardInput[]
    createMany?: BettingMarketCreateManyCardInputEnvelope
    connect?: BettingMarketWhereUniqueInput | BettingMarketWhereUniqueInput[]
  }

  export type MarketMetricsCreateNestedManyWithoutCardInput = {
    create?: XOR<MarketMetricsCreateWithoutCardInput, MarketMetricsUncheckedCreateWithoutCardInput> | MarketMetricsCreateWithoutCardInput[] | MarketMetricsUncheckedCreateWithoutCardInput[]
    connectOrCreate?: MarketMetricsCreateOrConnectWithoutCardInput | MarketMetricsCreateOrConnectWithoutCardInput[]
    createMany?: MarketMetricsCreateManyCardInputEnvelope
    connect?: MarketMetricsWhereUniqueInput | MarketMetricsWhereUniqueInput[]
  }

  export type CardAuctionCreateNestedOneWithoutCardInput = {
    create?: XOR<CardAuctionCreateWithoutCardInput, CardAuctionUncheckedCreateWithoutCardInput>
    connectOrCreate?: CardAuctionCreateOrConnectWithoutCardInput
    connect?: CardAuctionWhereUniqueInput
  }

  export type AuctionHistoryCreateNestedManyWithoutCardInput = {
    create?: XOR<AuctionHistoryCreateWithoutCardInput, AuctionHistoryUncheckedCreateWithoutCardInput> | AuctionHistoryCreateWithoutCardInput[] | AuctionHistoryUncheckedCreateWithoutCardInput[]
    connectOrCreate?: AuctionHistoryCreateOrConnectWithoutCardInput | AuctionHistoryCreateOrConnectWithoutCardInput[]
    createMany?: AuctionHistoryCreateManyCardInputEnvelope
    connect?: AuctionHistoryWhereUniqueInput | AuctionHistoryWhereUniqueInput[]
  }

  export type MABattleCreateNestedManyWithoutInitiatorCardInput = {
    create?: XOR<MABattleCreateWithoutInitiatorCardInput, MABattleUncheckedCreateWithoutInitiatorCardInput> | MABattleCreateWithoutInitiatorCardInput[] | MABattleUncheckedCreateWithoutInitiatorCardInput[]
    connectOrCreate?: MABattleCreateOrConnectWithoutInitiatorCardInput | MABattleCreateOrConnectWithoutInitiatorCardInput[]
    createMany?: MABattleCreateManyInitiatorCardInputEnvelope
    connect?: MABattleWhereUniqueInput | MABattleWhereUniqueInput[]
  }

  export type MABattleCreateNestedManyWithoutTargetCardInput = {
    create?: XOR<MABattleCreateWithoutTargetCardInput, MABattleUncheckedCreateWithoutTargetCardInput> | MABattleCreateWithoutTargetCardInput[] | MABattleUncheckedCreateWithoutTargetCardInput[]
    connectOrCreate?: MABattleCreateOrConnectWithoutTargetCardInput | MABattleCreateOrConnectWithoutTargetCardInput[]
    createMany?: MABattleCreateManyTargetCardInputEnvelope
    connect?: MABattleWhereUniqueInput | MABattleWhereUniqueInput[]
  }

  export type MarketplaceListingUncheckedCreateNestedOneWithoutCardInput = {
    create?: XOR<MarketplaceListingCreateWithoutCardInput, MarketplaceListingUncheckedCreateWithoutCardInput>
    connectOrCreate?: MarketplaceListingCreateOrConnectWithoutCardInput
    connect?: MarketplaceListingWhereUniqueInput
  }

  export type BidUncheckedCreateNestedManyWithoutCardInput = {
    create?: XOR<BidCreateWithoutCardInput, BidUncheckedCreateWithoutCardInput> | BidCreateWithoutCardInput[] | BidUncheckedCreateWithoutCardInput[]
    connectOrCreate?: BidCreateOrConnectWithoutCardInput | BidCreateOrConnectWithoutCardInput[]
    createMany?: BidCreateManyCardInputEnvelope
    connect?: BidWhereUniqueInput | BidWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutCardInput = {
    create?: XOR<TransactionCreateWithoutCardInput, TransactionUncheckedCreateWithoutCardInput> | TransactionCreateWithoutCardInput[] | TransactionUncheckedCreateWithoutCardInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCardInput | TransactionCreateOrConnectWithoutCardInput[]
    createMany?: TransactionCreateManyCardInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type BettingMarketUncheckedCreateNestedManyWithoutCardInput = {
    create?: XOR<BettingMarketCreateWithoutCardInput, BettingMarketUncheckedCreateWithoutCardInput> | BettingMarketCreateWithoutCardInput[] | BettingMarketUncheckedCreateWithoutCardInput[]
    connectOrCreate?: BettingMarketCreateOrConnectWithoutCardInput | BettingMarketCreateOrConnectWithoutCardInput[]
    createMany?: BettingMarketCreateManyCardInputEnvelope
    connect?: BettingMarketWhereUniqueInput | BettingMarketWhereUniqueInput[]
  }

  export type MarketMetricsUncheckedCreateNestedManyWithoutCardInput = {
    create?: XOR<MarketMetricsCreateWithoutCardInput, MarketMetricsUncheckedCreateWithoutCardInput> | MarketMetricsCreateWithoutCardInput[] | MarketMetricsUncheckedCreateWithoutCardInput[]
    connectOrCreate?: MarketMetricsCreateOrConnectWithoutCardInput | MarketMetricsCreateOrConnectWithoutCardInput[]
    createMany?: MarketMetricsCreateManyCardInputEnvelope
    connect?: MarketMetricsWhereUniqueInput | MarketMetricsWhereUniqueInput[]
  }

  export type CardAuctionUncheckedCreateNestedOneWithoutCardInput = {
    create?: XOR<CardAuctionCreateWithoutCardInput, CardAuctionUncheckedCreateWithoutCardInput>
    connectOrCreate?: CardAuctionCreateOrConnectWithoutCardInput
    connect?: CardAuctionWhereUniqueInput
  }

  export type AuctionHistoryUncheckedCreateNestedManyWithoutCardInput = {
    create?: XOR<AuctionHistoryCreateWithoutCardInput, AuctionHistoryUncheckedCreateWithoutCardInput> | AuctionHistoryCreateWithoutCardInput[] | AuctionHistoryUncheckedCreateWithoutCardInput[]
    connectOrCreate?: AuctionHistoryCreateOrConnectWithoutCardInput | AuctionHistoryCreateOrConnectWithoutCardInput[]
    createMany?: AuctionHistoryCreateManyCardInputEnvelope
    connect?: AuctionHistoryWhereUniqueInput | AuctionHistoryWhereUniqueInput[]
  }

  export type MABattleUncheckedCreateNestedManyWithoutInitiatorCardInput = {
    create?: XOR<MABattleCreateWithoutInitiatorCardInput, MABattleUncheckedCreateWithoutInitiatorCardInput> | MABattleCreateWithoutInitiatorCardInput[] | MABattleUncheckedCreateWithoutInitiatorCardInput[]
    connectOrCreate?: MABattleCreateOrConnectWithoutInitiatorCardInput | MABattleCreateOrConnectWithoutInitiatorCardInput[]
    createMany?: MABattleCreateManyInitiatorCardInputEnvelope
    connect?: MABattleWhereUniqueInput | MABattleWhereUniqueInput[]
  }

  export type MABattleUncheckedCreateNestedManyWithoutTargetCardInput = {
    create?: XOR<MABattleCreateWithoutTargetCardInput, MABattleUncheckedCreateWithoutTargetCardInput> | MABattleCreateWithoutTargetCardInput[] | MABattleUncheckedCreateWithoutTargetCardInput[]
    connectOrCreate?: MABattleCreateOrConnectWithoutTargetCardInput | MABattleCreateOrConnectWithoutTargetCardInput[]
    createMany?: MABattleCreateManyTargetCardInputEnvelope
    connect?: MABattleWhereUniqueInput | MABattleWhereUniqueInput[]
  }

  export type EnumCardCategoryFieldUpdateOperationsInput = {
    set?: $Enums.CardCategory
  }

  export type EnumCardRarityFieldUpdateOperationsInput = {
    set?: $Enums.CardRarity
  }

  export type UserUpdateOneRequiredWithoutOwnedCardsNestedInput = {
    create?: XOR<UserCreateWithoutOwnedCardsInput, UserUncheckedCreateWithoutOwnedCardsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedCardsInput
    upsert?: UserUpsertWithoutOwnedCardsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOwnedCardsInput, UserUpdateWithoutOwnedCardsInput>, UserUncheckedUpdateWithoutOwnedCardsInput>
  }

  export type MarketplaceListingUpdateOneWithoutCardNestedInput = {
    create?: XOR<MarketplaceListingCreateWithoutCardInput, MarketplaceListingUncheckedCreateWithoutCardInput>
    connectOrCreate?: MarketplaceListingCreateOrConnectWithoutCardInput
    upsert?: MarketplaceListingUpsertWithoutCardInput
    disconnect?: MarketplaceListingWhereInput | boolean
    delete?: MarketplaceListingWhereInput | boolean
    connect?: MarketplaceListingWhereUniqueInput
    update?: XOR<XOR<MarketplaceListingUpdateToOneWithWhereWithoutCardInput, MarketplaceListingUpdateWithoutCardInput>, MarketplaceListingUncheckedUpdateWithoutCardInput>
  }

  export type BidUpdateManyWithoutCardNestedInput = {
    create?: XOR<BidCreateWithoutCardInput, BidUncheckedCreateWithoutCardInput> | BidCreateWithoutCardInput[] | BidUncheckedCreateWithoutCardInput[]
    connectOrCreate?: BidCreateOrConnectWithoutCardInput | BidCreateOrConnectWithoutCardInput[]
    upsert?: BidUpsertWithWhereUniqueWithoutCardInput | BidUpsertWithWhereUniqueWithoutCardInput[]
    createMany?: BidCreateManyCardInputEnvelope
    set?: BidWhereUniqueInput | BidWhereUniqueInput[]
    disconnect?: BidWhereUniqueInput | BidWhereUniqueInput[]
    delete?: BidWhereUniqueInput | BidWhereUniqueInput[]
    connect?: BidWhereUniqueInput | BidWhereUniqueInput[]
    update?: BidUpdateWithWhereUniqueWithoutCardInput | BidUpdateWithWhereUniqueWithoutCardInput[]
    updateMany?: BidUpdateManyWithWhereWithoutCardInput | BidUpdateManyWithWhereWithoutCardInput[]
    deleteMany?: BidScalarWhereInput | BidScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutCardNestedInput = {
    create?: XOR<TransactionCreateWithoutCardInput, TransactionUncheckedCreateWithoutCardInput> | TransactionCreateWithoutCardInput[] | TransactionUncheckedCreateWithoutCardInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCardInput | TransactionCreateOrConnectWithoutCardInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutCardInput | TransactionUpsertWithWhereUniqueWithoutCardInput[]
    createMany?: TransactionCreateManyCardInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutCardInput | TransactionUpdateWithWhereUniqueWithoutCardInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutCardInput | TransactionUpdateManyWithWhereWithoutCardInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type BettingMarketUpdateManyWithoutCardNestedInput = {
    create?: XOR<BettingMarketCreateWithoutCardInput, BettingMarketUncheckedCreateWithoutCardInput> | BettingMarketCreateWithoutCardInput[] | BettingMarketUncheckedCreateWithoutCardInput[]
    connectOrCreate?: BettingMarketCreateOrConnectWithoutCardInput | BettingMarketCreateOrConnectWithoutCardInput[]
    upsert?: BettingMarketUpsertWithWhereUniqueWithoutCardInput | BettingMarketUpsertWithWhereUniqueWithoutCardInput[]
    createMany?: BettingMarketCreateManyCardInputEnvelope
    set?: BettingMarketWhereUniqueInput | BettingMarketWhereUniqueInput[]
    disconnect?: BettingMarketWhereUniqueInput | BettingMarketWhereUniqueInput[]
    delete?: BettingMarketWhereUniqueInput | BettingMarketWhereUniqueInput[]
    connect?: BettingMarketWhereUniqueInput | BettingMarketWhereUniqueInput[]
    update?: BettingMarketUpdateWithWhereUniqueWithoutCardInput | BettingMarketUpdateWithWhereUniqueWithoutCardInput[]
    updateMany?: BettingMarketUpdateManyWithWhereWithoutCardInput | BettingMarketUpdateManyWithWhereWithoutCardInput[]
    deleteMany?: BettingMarketScalarWhereInput | BettingMarketScalarWhereInput[]
  }

  export type MarketMetricsUpdateManyWithoutCardNestedInput = {
    create?: XOR<MarketMetricsCreateWithoutCardInput, MarketMetricsUncheckedCreateWithoutCardInput> | MarketMetricsCreateWithoutCardInput[] | MarketMetricsUncheckedCreateWithoutCardInput[]
    connectOrCreate?: MarketMetricsCreateOrConnectWithoutCardInput | MarketMetricsCreateOrConnectWithoutCardInput[]
    upsert?: MarketMetricsUpsertWithWhereUniqueWithoutCardInput | MarketMetricsUpsertWithWhereUniqueWithoutCardInput[]
    createMany?: MarketMetricsCreateManyCardInputEnvelope
    set?: MarketMetricsWhereUniqueInput | MarketMetricsWhereUniqueInput[]
    disconnect?: MarketMetricsWhereUniqueInput | MarketMetricsWhereUniqueInput[]
    delete?: MarketMetricsWhereUniqueInput | MarketMetricsWhereUniqueInput[]
    connect?: MarketMetricsWhereUniqueInput | MarketMetricsWhereUniqueInput[]
    update?: MarketMetricsUpdateWithWhereUniqueWithoutCardInput | MarketMetricsUpdateWithWhereUniqueWithoutCardInput[]
    updateMany?: MarketMetricsUpdateManyWithWhereWithoutCardInput | MarketMetricsUpdateManyWithWhereWithoutCardInput[]
    deleteMany?: MarketMetricsScalarWhereInput | MarketMetricsScalarWhereInput[]
  }

  export type CardAuctionUpdateOneWithoutCardNestedInput = {
    create?: XOR<CardAuctionCreateWithoutCardInput, CardAuctionUncheckedCreateWithoutCardInput>
    connectOrCreate?: CardAuctionCreateOrConnectWithoutCardInput
    upsert?: CardAuctionUpsertWithoutCardInput
    disconnect?: CardAuctionWhereInput | boolean
    delete?: CardAuctionWhereInput | boolean
    connect?: CardAuctionWhereUniqueInput
    update?: XOR<XOR<CardAuctionUpdateToOneWithWhereWithoutCardInput, CardAuctionUpdateWithoutCardInput>, CardAuctionUncheckedUpdateWithoutCardInput>
  }

  export type AuctionHistoryUpdateManyWithoutCardNestedInput = {
    create?: XOR<AuctionHistoryCreateWithoutCardInput, AuctionHistoryUncheckedCreateWithoutCardInput> | AuctionHistoryCreateWithoutCardInput[] | AuctionHistoryUncheckedCreateWithoutCardInput[]
    connectOrCreate?: AuctionHistoryCreateOrConnectWithoutCardInput | AuctionHistoryCreateOrConnectWithoutCardInput[]
    upsert?: AuctionHistoryUpsertWithWhereUniqueWithoutCardInput | AuctionHistoryUpsertWithWhereUniqueWithoutCardInput[]
    createMany?: AuctionHistoryCreateManyCardInputEnvelope
    set?: AuctionHistoryWhereUniqueInput | AuctionHistoryWhereUniqueInput[]
    disconnect?: AuctionHistoryWhereUniqueInput | AuctionHistoryWhereUniqueInput[]
    delete?: AuctionHistoryWhereUniqueInput | AuctionHistoryWhereUniqueInput[]
    connect?: AuctionHistoryWhereUniqueInput | AuctionHistoryWhereUniqueInput[]
    update?: AuctionHistoryUpdateWithWhereUniqueWithoutCardInput | AuctionHistoryUpdateWithWhereUniqueWithoutCardInput[]
    updateMany?: AuctionHistoryUpdateManyWithWhereWithoutCardInput | AuctionHistoryUpdateManyWithWhereWithoutCardInput[]
    deleteMany?: AuctionHistoryScalarWhereInput | AuctionHistoryScalarWhereInput[]
  }

  export type MABattleUpdateManyWithoutInitiatorCardNestedInput = {
    create?: XOR<MABattleCreateWithoutInitiatorCardInput, MABattleUncheckedCreateWithoutInitiatorCardInput> | MABattleCreateWithoutInitiatorCardInput[] | MABattleUncheckedCreateWithoutInitiatorCardInput[]
    connectOrCreate?: MABattleCreateOrConnectWithoutInitiatorCardInput | MABattleCreateOrConnectWithoutInitiatorCardInput[]
    upsert?: MABattleUpsertWithWhereUniqueWithoutInitiatorCardInput | MABattleUpsertWithWhereUniqueWithoutInitiatorCardInput[]
    createMany?: MABattleCreateManyInitiatorCardInputEnvelope
    set?: MABattleWhereUniqueInput | MABattleWhereUniqueInput[]
    disconnect?: MABattleWhereUniqueInput | MABattleWhereUniqueInput[]
    delete?: MABattleWhereUniqueInput | MABattleWhereUniqueInput[]
    connect?: MABattleWhereUniqueInput | MABattleWhereUniqueInput[]
    update?: MABattleUpdateWithWhereUniqueWithoutInitiatorCardInput | MABattleUpdateWithWhereUniqueWithoutInitiatorCardInput[]
    updateMany?: MABattleUpdateManyWithWhereWithoutInitiatorCardInput | MABattleUpdateManyWithWhereWithoutInitiatorCardInput[]
    deleteMany?: MABattleScalarWhereInput | MABattleScalarWhereInput[]
  }

  export type MABattleUpdateManyWithoutTargetCardNestedInput = {
    create?: XOR<MABattleCreateWithoutTargetCardInput, MABattleUncheckedCreateWithoutTargetCardInput> | MABattleCreateWithoutTargetCardInput[] | MABattleUncheckedCreateWithoutTargetCardInput[]
    connectOrCreate?: MABattleCreateOrConnectWithoutTargetCardInput | MABattleCreateOrConnectWithoutTargetCardInput[]
    upsert?: MABattleUpsertWithWhereUniqueWithoutTargetCardInput | MABattleUpsertWithWhereUniqueWithoutTargetCardInput[]
    createMany?: MABattleCreateManyTargetCardInputEnvelope
    set?: MABattleWhereUniqueInput | MABattleWhereUniqueInput[]
    disconnect?: MABattleWhereUniqueInput | MABattleWhereUniqueInput[]
    delete?: MABattleWhereUniqueInput | MABattleWhereUniqueInput[]
    connect?: MABattleWhereUniqueInput | MABattleWhereUniqueInput[]
    update?: MABattleUpdateWithWhereUniqueWithoutTargetCardInput | MABattleUpdateWithWhereUniqueWithoutTargetCardInput[]
    updateMany?: MABattleUpdateManyWithWhereWithoutTargetCardInput | MABattleUpdateManyWithWhereWithoutTargetCardInput[]
    deleteMany?: MABattleScalarWhereInput | MABattleScalarWhereInput[]
  }

  export type MarketplaceListingUncheckedUpdateOneWithoutCardNestedInput = {
    create?: XOR<MarketplaceListingCreateWithoutCardInput, MarketplaceListingUncheckedCreateWithoutCardInput>
    connectOrCreate?: MarketplaceListingCreateOrConnectWithoutCardInput
    upsert?: MarketplaceListingUpsertWithoutCardInput
    disconnect?: MarketplaceListingWhereInput | boolean
    delete?: MarketplaceListingWhereInput | boolean
    connect?: MarketplaceListingWhereUniqueInput
    update?: XOR<XOR<MarketplaceListingUpdateToOneWithWhereWithoutCardInput, MarketplaceListingUpdateWithoutCardInput>, MarketplaceListingUncheckedUpdateWithoutCardInput>
  }

  export type BidUncheckedUpdateManyWithoutCardNestedInput = {
    create?: XOR<BidCreateWithoutCardInput, BidUncheckedCreateWithoutCardInput> | BidCreateWithoutCardInput[] | BidUncheckedCreateWithoutCardInput[]
    connectOrCreate?: BidCreateOrConnectWithoutCardInput | BidCreateOrConnectWithoutCardInput[]
    upsert?: BidUpsertWithWhereUniqueWithoutCardInput | BidUpsertWithWhereUniqueWithoutCardInput[]
    createMany?: BidCreateManyCardInputEnvelope
    set?: BidWhereUniqueInput | BidWhereUniqueInput[]
    disconnect?: BidWhereUniqueInput | BidWhereUniqueInput[]
    delete?: BidWhereUniqueInput | BidWhereUniqueInput[]
    connect?: BidWhereUniqueInput | BidWhereUniqueInput[]
    update?: BidUpdateWithWhereUniqueWithoutCardInput | BidUpdateWithWhereUniqueWithoutCardInput[]
    updateMany?: BidUpdateManyWithWhereWithoutCardInput | BidUpdateManyWithWhereWithoutCardInput[]
    deleteMany?: BidScalarWhereInput | BidScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutCardNestedInput = {
    create?: XOR<TransactionCreateWithoutCardInput, TransactionUncheckedCreateWithoutCardInput> | TransactionCreateWithoutCardInput[] | TransactionUncheckedCreateWithoutCardInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCardInput | TransactionCreateOrConnectWithoutCardInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutCardInput | TransactionUpsertWithWhereUniqueWithoutCardInput[]
    createMany?: TransactionCreateManyCardInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutCardInput | TransactionUpdateWithWhereUniqueWithoutCardInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutCardInput | TransactionUpdateManyWithWhereWithoutCardInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type BettingMarketUncheckedUpdateManyWithoutCardNestedInput = {
    create?: XOR<BettingMarketCreateWithoutCardInput, BettingMarketUncheckedCreateWithoutCardInput> | BettingMarketCreateWithoutCardInput[] | BettingMarketUncheckedCreateWithoutCardInput[]
    connectOrCreate?: BettingMarketCreateOrConnectWithoutCardInput | BettingMarketCreateOrConnectWithoutCardInput[]
    upsert?: BettingMarketUpsertWithWhereUniqueWithoutCardInput | BettingMarketUpsertWithWhereUniqueWithoutCardInput[]
    createMany?: BettingMarketCreateManyCardInputEnvelope
    set?: BettingMarketWhereUniqueInput | BettingMarketWhereUniqueInput[]
    disconnect?: BettingMarketWhereUniqueInput | BettingMarketWhereUniqueInput[]
    delete?: BettingMarketWhereUniqueInput | BettingMarketWhereUniqueInput[]
    connect?: BettingMarketWhereUniqueInput | BettingMarketWhereUniqueInput[]
    update?: BettingMarketUpdateWithWhereUniqueWithoutCardInput | BettingMarketUpdateWithWhereUniqueWithoutCardInput[]
    updateMany?: BettingMarketUpdateManyWithWhereWithoutCardInput | BettingMarketUpdateManyWithWhereWithoutCardInput[]
    deleteMany?: BettingMarketScalarWhereInput | BettingMarketScalarWhereInput[]
  }

  export type MarketMetricsUncheckedUpdateManyWithoutCardNestedInput = {
    create?: XOR<MarketMetricsCreateWithoutCardInput, MarketMetricsUncheckedCreateWithoutCardInput> | MarketMetricsCreateWithoutCardInput[] | MarketMetricsUncheckedCreateWithoutCardInput[]
    connectOrCreate?: MarketMetricsCreateOrConnectWithoutCardInput | MarketMetricsCreateOrConnectWithoutCardInput[]
    upsert?: MarketMetricsUpsertWithWhereUniqueWithoutCardInput | MarketMetricsUpsertWithWhereUniqueWithoutCardInput[]
    createMany?: MarketMetricsCreateManyCardInputEnvelope
    set?: MarketMetricsWhereUniqueInput | MarketMetricsWhereUniqueInput[]
    disconnect?: MarketMetricsWhereUniqueInput | MarketMetricsWhereUniqueInput[]
    delete?: MarketMetricsWhereUniqueInput | MarketMetricsWhereUniqueInput[]
    connect?: MarketMetricsWhereUniqueInput | MarketMetricsWhereUniqueInput[]
    update?: MarketMetricsUpdateWithWhereUniqueWithoutCardInput | MarketMetricsUpdateWithWhereUniqueWithoutCardInput[]
    updateMany?: MarketMetricsUpdateManyWithWhereWithoutCardInput | MarketMetricsUpdateManyWithWhereWithoutCardInput[]
    deleteMany?: MarketMetricsScalarWhereInput | MarketMetricsScalarWhereInput[]
  }

  export type CardAuctionUncheckedUpdateOneWithoutCardNestedInput = {
    create?: XOR<CardAuctionCreateWithoutCardInput, CardAuctionUncheckedCreateWithoutCardInput>
    connectOrCreate?: CardAuctionCreateOrConnectWithoutCardInput
    upsert?: CardAuctionUpsertWithoutCardInput
    disconnect?: CardAuctionWhereInput | boolean
    delete?: CardAuctionWhereInput | boolean
    connect?: CardAuctionWhereUniqueInput
    update?: XOR<XOR<CardAuctionUpdateToOneWithWhereWithoutCardInput, CardAuctionUpdateWithoutCardInput>, CardAuctionUncheckedUpdateWithoutCardInput>
  }

  export type AuctionHistoryUncheckedUpdateManyWithoutCardNestedInput = {
    create?: XOR<AuctionHistoryCreateWithoutCardInput, AuctionHistoryUncheckedCreateWithoutCardInput> | AuctionHistoryCreateWithoutCardInput[] | AuctionHistoryUncheckedCreateWithoutCardInput[]
    connectOrCreate?: AuctionHistoryCreateOrConnectWithoutCardInput | AuctionHistoryCreateOrConnectWithoutCardInput[]
    upsert?: AuctionHistoryUpsertWithWhereUniqueWithoutCardInput | AuctionHistoryUpsertWithWhereUniqueWithoutCardInput[]
    createMany?: AuctionHistoryCreateManyCardInputEnvelope
    set?: AuctionHistoryWhereUniqueInput | AuctionHistoryWhereUniqueInput[]
    disconnect?: AuctionHistoryWhereUniqueInput | AuctionHistoryWhereUniqueInput[]
    delete?: AuctionHistoryWhereUniqueInput | AuctionHistoryWhereUniqueInput[]
    connect?: AuctionHistoryWhereUniqueInput | AuctionHistoryWhereUniqueInput[]
    update?: AuctionHistoryUpdateWithWhereUniqueWithoutCardInput | AuctionHistoryUpdateWithWhereUniqueWithoutCardInput[]
    updateMany?: AuctionHistoryUpdateManyWithWhereWithoutCardInput | AuctionHistoryUpdateManyWithWhereWithoutCardInput[]
    deleteMany?: AuctionHistoryScalarWhereInput | AuctionHistoryScalarWhereInput[]
  }

  export type MABattleUncheckedUpdateManyWithoutInitiatorCardNestedInput = {
    create?: XOR<MABattleCreateWithoutInitiatorCardInput, MABattleUncheckedCreateWithoutInitiatorCardInput> | MABattleCreateWithoutInitiatorCardInput[] | MABattleUncheckedCreateWithoutInitiatorCardInput[]
    connectOrCreate?: MABattleCreateOrConnectWithoutInitiatorCardInput | MABattleCreateOrConnectWithoutInitiatorCardInput[]
    upsert?: MABattleUpsertWithWhereUniqueWithoutInitiatorCardInput | MABattleUpsertWithWhereUniqueWithoutInitiatorCardInput[]
    createMany?: MABattleCreateManyInitiatorCardInputEnvelope
    set?: MABattleWhereUniqueInput | MABattleWhereUniqueInput[]
    disconnect?: MABattleWhereUniqueInput | MABattleWhereUniqueInput[]
    delete?: MABattleWhereUniqueInput | MABattleWhereUniqueInput[]
    connect?: MABattleWhereUniqueInput | MABattleWhereUniqueInput[]
    update?: MABattleUpdateWithWhereUniqueWithoutInitiatorCardInput | MABattleUpdateWithWhereUniqueWithoutInitiatorCardInput[]
    updateMany?: MABattleUpdateManyWithWhereWithoutInitiatorCardInput | MABattleUpdateManyWithWhereWithoutInitiatorCardInput[]
    deleteMany?: MABattleScalarWhereInput | MABattleScalarWhereInput[]
  }

  export type MABattleUncheckedUpdateManyWithoutTargetCardNestedInput = {
    create?: XOR<MABattleCreateWithoutTargetCardInput, MABattleUncheckedCreateWithoutTargetCardInput> | MABattleCreateWithoutTargetCardInput[] | MABattleUncheckedCreateWithoutTargetCardInput[]
    connectOrCreate?: MABattleCreateOrConnectWithoutTargetCardInput | MABattleCreateOrConnectWithoutTargetCardInput[]
    upsert?: MABattleUpsertWithWhereUniqueWithoutTargetCardInput | MABattleUpsertWithWhereUniqueWithoutTargetCardInput[]
    createMany?: MABattleCreateManyTargetCardInputEnvelope
    set?: MABattleWhereUniqueInput | MABattleWhereUniqueInput[]
    disconnect?: MABattleWhereUniqueInput | MABattleWhereUniqueInput[]
    delete?: MABattleWhereUniqueInput | MABattleWhereUniqueInput[]
    connect?: MABattleWhereUniqueInput | MABattleWhereUniqueInput[]
    update?: MABattleUpdateWithWhereUniqueWithoutTargetCardInput | MABattleUpdateWithWhereUniqueWithoutTargetCardInput[]
    updateMany?: MABattleUpdateManyWithWhereWithoutTargetCardInput | MABattleUpdateManyWithWhereWithoutTargetCardInput[]
    deleteMany?: MABattleScalarWhereInput | MABattleScalarWhereInput[]
  }

  export type CardCreateNestedOneWithoutListingInput = {
    create?: XOR<CardCreateWithoutListingInput, CardUncheckedCreateWithoutListingInput>
    connectOrCreate?: CardCreateOrConnectWithoutListingInput
    connect?: CardWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutListingsInput = {
    create?: XOR<UserCreateWithoutListingsInput, UserUncheckedCreateWithoutListingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutListingsInput
    connect?: UserWhereUniqueInput
  }

  export type BidCreateNestedManyWithoutListingInput = {
    create?: XOR<BidCreateWithoutListingInput, BidUncheckedCreateWithoutListingInput> | BidCreateWithoutListingInput[] | BidUncheckedCreateWithoutListingInput[]
    connectOrCreate?: BidCreateOrConnectWithoutListingInput | BidCreateOrConnectWithoutListingInput[]
    createMany?: BidCreateManyListingInputEnvelope
    connect?: BidWhereUniqueInput | BidWhereUniqueInput[]
  }

  export type BidUncheckedCreateNestedManyWithoutListingInput = {
    create?: XOR<BidCreateWithoutListingInput, BidUncheckedCreateWithoutListingInput> | BidCreateWithoutListingInput[] | BidUncheckedCreateWithoutListingInput[]
    connectOrCreate?: BidCreateOrConnectWithoutListingInput | BidCreateOrConnectWithoutListingInput[]
    createMany?: BidCreateManyListingInputEnvelope
    connect?: BidWhereUniqueInput | BidWhereUniqueInput[]
  }

  export type EnumListingTypeFieldUpdateOperationsInput = {
    set?: $Enums.ListingType
  }

  export type EnumListingStatusFieldUpdateOperationsInput = {
    set?: $Enums.ListingStatus
  }

  export type CardUpdateOneRequiredWithoutListingNestedInput = {
    create?: XOR<CardCreateWithoutListingInput, CardUncheckedCreateWithoutListingInput>
    connectOrCreate?: CardCreateOrConnectWithoutListingInput
    upsert?: CardUpsertWithoutListingInput
    connect?: CardWhereUniqueInput
    update?: XOR<XOR<CardUpdateToOneWithWhereWithoutListingInput, CardUpdateWithoutListingInput>, CardUncheckedUpdateWithoutListingInput>
  }

  export type UserUpdateOneRequiredWithoutListingsNestedInput = {
    create?: XOR<UserCreateWithoutListingsInput, UserUncheckedCreateWithoutListingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutListingsInput
    upsert?: UserUpsertWithoutListingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutListingsInput, UserUpdateWithoutListingsInput>, UserUncheckedUpdateWithoutListingsInput>
  }

  export type BidUpdateManyWithoutListingNestedInput = {
    create?: XOR<BidCreateWithoutListingInput, BidUncheckedCreateWithoutListingInput> | BidCreateWithoutListingInput[] | BidUncheckedCreateWithoutListingInput[]
    connectOrCreate?: BidCreateOrConnectWithoutListingInput | BidCreateOrConnectWithoutListingInput[]
    upsert?: BidUpsertWithWhereUniqueWithoutListingInput | BidUpsertWithWhereUniqueWithoutListingInput[]
    createMany?: BidCreateManyListingInputEnvelope
    set?: BidWhereUniqueInput | BidWhereUniqueInput[]
    disconnect?: BidWhereUniqueInput | BidWhereUniqueInput[]
    delete?: BidWhereUniqueInput | BidWhereUniqueInput[]
    connect?: BidWhereUniqueInput | BidWhereUniqueInput[]
    update?: BidUpdateWithWhereUniqueWithoutListingInput | BidUpdateWithWhereUniqueWithoutListingInput[]
    updateMany?: BidUpdateManyWithWhereWithoutListingInput | BidUpdateManyWithWhereWithoutListingInput[]
    deleteMany?: BidScalarWhereInput | BidScalarWhereInput[]
  }

  export type BidUncheckedUpdateManyWithoutListingNestedInput = {
    create?: XOR<BidCreateWithoutListingInput, BidUncheckedCreateWithoutListingInput> | BidCreateWithoutListingInput[] | BidUncheckedCreateWithoutListingInput[]
    connectOrCreate?: BidCreateOrConnectWithoutListingInput | BidCreateOrConnectWithoutListingInput[]
    upsert?: BidUpsertWithWhereUniqueWithoutListingInput | BidUpsertWithWhereUniqueWithoutListingInput[]
    createMany?: BidCreateManyListingInputEnvelope
    set?: BidWhereUniqueInput | BidWhereUniqueInput[]
    disconnect?: BidWhereUniqueInput | BidWhereUniqueInput[]
    delete?: BidWhereUniqueInput | BidWhereUniqueInput[]
    connect?: BidWhereUniqueInput | BidWhereUniqueInput[]
    update?: BidUpdateWithWhereUniqueWithoutListingInput | BidUpdateWithWhereUniqueWithoutListingInput[]
    updateMany?: BidUpdateManyWithWhereWithoutListingInput | BidUpdateManyWithWhereWithoutListingInput[]
    deleteMany?: BidScalarWhereInput | BidScalarWhereInput[]
  }

  export type MarketplaceListingCreateNestedOneWithoutBidsInput = {
    create?: XOR<MarketplaceListingCreateWithoutBidsInput, MarketplaceListingUncheckedCreateWithoutBidsInput>
    connectOrCreate?: MarketplaceListingCreateOrConnectWithoutBidsInput
    connect?: MarketplaceListingWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBidsInput = {
    create?: XOR<UserCreateWithoutBidsInput, UserUncheckedCreateWithoutBidsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBidsInput
    connect?: UserWhereUniqueInput
  }

  export type CardCreateNestedOneWithoutBidsInput = {
    create?: XOR<CardCreateWithoutBidsInput, CardUncheckedCreateWithoutBidsInput>
    connectOrCreate?: CardCreateOrConnectWithoutBidsInput
    connect?: CardWhereUniqueInput
  }

  export type EnumBidStatusFieldUpdateOperationsInput = {
    set?: $Enums.BidStatus
  }

  export type MarketplaceListingUpdateOneRequiredWithoutBidsNestedInput = {
    create?: XOR<MarketplaceListingCreateWithoutBidsInput, MarketplaceListingUncheckedCreateWithoutBidsInput>
    connectOrCreate?: MarketplaceListingCreateOrConnectWithoutBidsInput
    upsert?: MarketplaceListingUpsertWithoutBidsInput
    connect?: MarketplaceListingWhereUniqueInput
    update?: XOR<XOR<MarketplaceListingUpdateToOneWithWhereWithoutBidsInput, MarketplaceListingUpdateWithoutBidsInput>, MarketplaceListingUncheckedUpdateWithoutBidsInput>
  }

  export type UserUpdateOneRequiredWithoutBidsNestedInput = {
    create?: XOR<UserCreateWithoutBidsInput, UserUncheckedCreateWithoutBidsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBidsInput
    upsert?: UserUpsertWithoutBidsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBidsInput, UserUpdateWithoutBidsInput>, UserUncheckedUpdateWithoutBidsInput>
  }

  export type CardUpdateOneRequiredWithoutBidsNestedInput = {
    create?: XOR<CardCreateWithoutBidsInput, CardUncheckedCreateWithoutBidsInput>
    connectOrCreate?: CardCreateOrConnectWithoutBidsInput
    upsert?: CardUpsertWithoutBidsInput
    connect?: CardWhereUniqueInput
    update?: XOR<XOR<CardUpdateToOneWithWhereWithoutBidsInput, CardUpdateWithoutBidsInput>, CardUncheckedUpdateWithoutBidsInput>
  }

  export type UserCreateNestedOneWithoutTradingHistoryInput = {
    create?: XOR<UserCreateWithoutTradingHistoryInput, UserUncheckedCreateWithoutTradingHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutTradingHistoryInput
    connect?: UserWhereUniqueInput
  }

  export type CardCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<CardCreateWithoutTransactionsInput, CardUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: CardCreateOrConnectWithoutTransactionsInput
    connect?: CardWhereUniqueInput
  }

  export type EnumTransactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.TransactionType
  }

  export type EnumTransactionStatusFieldUpdateOperationsInput = {
    set?: $Enums.TransactionStatus
  }

  export type UserUpdateOneRequiredWithoutTradingHistoryNestedInput = {
    create?: XOR<UserCreateWithoutTradingHistoryInput, UserUncheckedCreateWithoutTradingHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutTradingHistoryInput
    upsert?: UserUpsertWithoutTradingHistoryInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTradingHistoryInput, UserUpdateWithoutTradingHistoryInput>, UserUncheckedUpdateWithoutTradingHistoryInput>
  }

  export type CardUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<CardCreateWithoutTransactionsInput, CardUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: CardCreateOrConnectWithoutTransactionsInput
    upsert?: CardUpsertWithoutTransactionsInput
    disconnect?: CardWhereInput | boolean
    delete?: CardWhereInput | boolean
    connect?: CardWhereUniqueInput
    update?: XOR<XOR<CardUpdateToOneWithWhereWithoutTransactionsInput, CardUpdateWithoutTransactionsInput>, CardUncheckedUpdateWithoutTransactionsInput>
  }

  export type UserCreateNestedOneWithoutCryptoWalletsInput = {
    create?: XOR<UserCreateWithoutCryptoWalletsInput, UserUncheckedCreateWithoutCryptoWalletsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCryptoWalletsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCryptoWalletsNestedInput = {
    create?: XOR<UserCreateWithoutCryptoWalletsInput, UserUncheckedCreateWithoutCryptoWalletsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCryptoWalletsInput
    upsert?: UserUpsertWithoutCryptoWalletsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCryptoWalletsInput, UserUpdateWithoutCryptoWalletsInput>, UserUncheckedUpdateWithoutCryptoWalletsInput>
  }

  export type UserCreateNestedOneWithoutPhysicalCardInput = {
    create?: XOR<UserCreateWithoutPhysicalCardInput, UserUncheckedCreateWithoutPhysicalCardInput>
    connectOrCreate?: UserCreateOrConnectWithoutPhysicalCardInput
    connect?: UserWhereUniqueInput
  }

  export type EnumPhysicalCardStatusFieldUpdateOperationsInput = {
    set?: $Enums.PhysicalCardStatus
  }

  export type UserUpdateOneRequiredWithoutPhysicalCardNestedInput = {
    create?: XOR<UserCreateWithoutPhysicalCardInput, UserUncheckedCreateWithoutPhysicalCardInput>
    connectOrCreate?: UserCreateOrConnectWithoutPhysicalCardInput
    upsert?: UserUpsertWithoutPhysicalCardInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPhysicalCardInput, UserUpdateWithoutPhysicalCardInput>, UserUncheckedUpdateWithoutPhysicalCardInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type EnumNotificationPriorityFieldUpdateOperationsInput = {
    set?: $Enums.NotificationPriority
  }

  export type NullableEnumSubscriptionPlanFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionPlan | null
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutSocialFeedsInput = {
    create?: XOR<UserCreateWithoutSocialFeedsInput, UserUncheckedCreateWithoutSocialFeedsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSocialFeedsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumSocialFeedTypeFieldUpdateOperationsInput = {
    set?: $Enums.SocialFeedType
  }

  export type EnumSocialVisibilityFieldUpdateOperationsInput = {
    set?: $Enums.SocialVisibility
  }

  export type UserUpdateOneRequiredWithoutSocialFeedsNestedInput = {
    create?: XOR<UserCreateWithoutSocialFeedsInput, UserUncheckedCreateWithoutSocialFeedsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSocialFeedsInput
    upsert?: UserUpsertWithoutSocialFeedsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSocialFeedsInput, UserUpdateWithoutSocialFeedsInput>, UserUncheckedUpdateWithoutSocialFeedsInput>
  }

  export type UserCreateNestedOneWithoutFollowersInput = {
    create?: XOR<UserCreateWithoutFollowersInput, UserUncheckedCreateWithoutFollowersInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowersInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFollowingInput = {
    create?: XOR<UserCreateWithoutFollowingInput, UserUncheckedCreateWithoutFollowingInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowingInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFollowersNestedInput = {
    create?: XOR<UserCreateWithoutFollowersInput, UserUncheckedCreateWithoutFollowersInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowersInput
    upsert?: UserUpsertWithoutFollowersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFollowersInput, UserUpdateWithoutFollowersInput>, UserUncheckedUpdateWithoutFollowersInput>
  }

  export type UserUpdateOneRequiredWithoutFollowingNestedInput = {
    create?: XOR<UserCreateWithoutFollowingInput, UserUncheckedCreateWithoutFollowingInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowingInput
    upsert?: UserUpsertWithoutFollowingInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFollowingInput, UserUpdateWithoutFollowingInput>, UserUncheckedUpdateWithoutFollowingInput>
  }

  export type UserCreateNestedOneWithoutAppOrdersInput = {
    create?: XOR<UserCreateWithoutAppOrdersInput, UserUncheckedCreateWithoutAppOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutAppOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type OrderRevisionCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderRevisionCreateWithoutOrderInput, OrderRevisionUncheckedCreateWithoutOrderInput> | OrderRevisionCreateWithoutOrderInput[] | OrderRevisionUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderRevisionCreateOrConnectWithoutOrderInput | OrderRevisionCreateOrConnectWithoutOrderInput[]
    createMany?: OrderRevisionCreateManyOrderInputEnvelope
    connect?: OrderRevisionWhereUniqueInput | OrderRevisionWhereUniqueInput[]
  }

  export type OrderCommunicationCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderCommunicationCreateWithoutOrderInput, OrderCommunicationUncheckedCreateWithoutOrderInput> | OrderCommunicationCreateWithoutOrderInput[] | OrderCommunicationUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderCommunicationCreateOrConnectWithoutOrderInput | OrderCommunicationCreateOrConnectWithoutOrderInput[]
    createMany?: OrderCommunicationCreateManyOrderInputEnvelope
    connect?: OrderCommunicationWhereUniqueInput | OrderCommunicationWhereUniqueInput[]
  }

  export type OrderDeliverableCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderDeliverableCreateWithoutOrderInput, OrderDeliverableUncheckedCreateWithoutOrderInput> | OrderDeliverableCreateWithoutOrderInput[] | OrderDeliverableUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderDeliverableCreateOrConnectWithoutOrderInput | OrderDeliverableCreateOrConnectWithoutOrderInput[]
    createMany?: OrderDeliverableCreateManyOrderInputEnvelope
    connect?: OrderDeliverableWhereUniqueInput | OrderDeliverableWhereUniqueInput[]
  }

  export type OrderRevisionUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderRevisionCreateWithoutOrderInput, OrderRevisionUncheckedCreateWithoutOrderInput> | OrderRevisionCreateWithoutOrderInput[] | OrderRevisionUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderRevisionCreateOrConnectWithoutOrderInput | OrderRevisionCreateOrConnectWithoutOrderInput[]
    createMany?: OrderRevisionCreateManyOrderInputEnvelope
    connect?: OrderRevisionWhereUniqueInput | OrderRevisionWhereUniqueInput[]
  }

  export type OrderCommunicationUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderCommunicationCreateWithoutOrderInput, OrderCommunicationUncheckedCreateWithoutOrderInput> | OrderCommunicationCreateWithoutOrderInput[] | OrderCommunicationUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderCommunicationCreateOrConnectWithoutOrderInput | OrderCommunicationCreateOrConnectWithoutOrderInput[]
    createMany?: OrderCommunicationCreateManyOrderInputEnvelope
    connect?: OrderCommunicationWhereUniqueInput | OrderCommunicationWhereUniqueInput[]
  }

  export type OrderDeliverableUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderDeliverableCreateWithoutOrderInput, OrderDeliverableUncheckedCreateWithoutOrderInput> | OrderDeliverableCreateWithoutOrderInput[] | OrderDeliverableUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderDeliverableCreateOrConnectWithoutOrderInput | OrderDeliverableCreateOrConnectWithoutOrderInput[]
    createMany?: OrderDeliverableCreateManyOrderInputEnvelope
    connect?: OrderDeliverableWhereUniqueInput | OrderDeliverableWhereUniqueInput[]
  }

  export type EnumProjectTypeFieldUpdateOperationsInput = {
    set?: $Enums.ProjectType
  }

  export type EnumOrderTimelineFieldUpdateOperationsInput = {
    set?: $Enums.OrderTimeline
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.OrderStatus
  }

  export type EnumOrderPriorityFieldUpdateOperationsInput = {
    set?: $Enums.OrderPriority
  }

  export type UserUpdateOneRequiredWithoutAppOrdersNestedInput = {
    create?: XOR<UserCreateWithoutAppOrdersInput, UserUncheckedCreateWithoutAppOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutAppOrdersInput
    upsert?: UserUpsertWithoutAppOrdersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAppOrdersInput, UserUpdateWithoutAppOrdersInput>, UserUncheckedUpdateWithoutAppOrdersInput>
  }

  export type OrderRevisionUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderRevisionCreateWithoutOrderInput, OrderRevisionUncheckedCreateWithoutOrderInput> | OrderRevisionCreateWithoutOrderInput[] | OrderRevisionUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderRevisionCreateOrConnectWithoutOrderInput | OrderRevisionCreateOrConnectWithoutOrderInput[]
    upsert?: OrderRevisionUpsertWithWhereUniqueWithoutOrderInput | OrderRevisionUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderRevisionCreateManyOrderInputEnvelope
    set?: OrderRevisionWhereUniqueInput | OrderRevisionWhereUniqueInput[]
    disconnect?: OrderRevisionWhereUniqueInput | OrderRevisionWhereUniqueInput[]
    delete?: OrderRevisionWhereUniqueInput | OrderRevisionWhereUniqueInput[]
    connect?: OrderRevisionWhereUniqueInput | OrderRevisionWhereUniqueInput[]
    update?: OrderRevisionUpdateWithWhereUniqueWithoutOrderInput | OrderRevisionUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderRevisionUpdateManyWithWhereWithoutOrderInput | OrderRevisionUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderRevisionScalarWhereInput | OrderRevisionScalarWhereInput[]
  }

  export type OrderCommunicationUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderCommunicationCreateWithoutOrderInput, OrderCommunicationUncheckedCreateWithoutOrderInput> | OrderCommunicationCreateWithoutOrderInput[] | OrderCommunicationUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderCommunicationCreateOrConnectWithoutOrderInput | OrderCommunicationCreateOrConnectWithoutOrderInput[]
    upsert?: OrderCommunicationUpsertWithWhereUniqueWithoutOrderInput | OrderCommunicationUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderCommunicationCreateManyOrderInputEnvelope
    set?: OrderCommunicationWhereUniqueInput | OrderCommunicationWhereUniqueInput[]
    disconnect?: OrderCommunicationWhereUniqueInput | OrderCommunicationWhereUniqueInput[]
    delete?: OrderCommunicationWhereUniqueInput | OrderCommunicationWhereUniqueInput[]
    connect?: OrderCommunicationWhereUniqueInput | OrderCommunicationWhereUniqueInput[]
    update?: OrderCommunicationUpdateWithWhereUniqueWithoutOrderInput | OrderCommunicationUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderCommunicationUpdateManyWithWhereWithoutOrderInput | OrderCommunicationUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderCommunicationScalarWhereInput | OrderCommunicationScalarWhereInput[]
  }

  export type OrderDeliverableUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderDeliverableCreateWithoutOrderInput, OrderDeliverableUncheckedCreateWithoutOrderInput> | OrderDeliverableCreateWithoutOrderInput[] | OrderDeliverableUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderDeliverableCreateOrConnectWithoutOrderInput | OrderDeliverableCreateOrConnectWithoutOrderInput[]
    upsert?: OrderDeliverableUpsertWithWhereUniqueWithoutOrderInput | OrderDeliverableUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderDeliverableCreateManyOrderInputEnvelope
    set?: OrderDeliverableWhereUniqueInput | OrderDeliverableWhereUniqueInput[]
    disconnect?: OrderDeliverableWhereUniqueInput | OrderDeliverableWhereUniqueInput[]
    delete?: OrderDeliverableWhereUniqueInput | OrderDeliverableWhereUniqueInput[]
    connect?: OrderDeliverableWhereUniqueInput | OrderDeliverableWhereUniqueInput[]
    update?: OrderDeliverableUpdateWithWhereUniqueWithoutOrderInput | OrderDeliverableUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderDeliverableUpdateManyWithWhereWithoutOrderInput | OrderDeliverableUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderDeliverableScalarWhereInput | OrderDeliverableScalarWhereInput[]
  }

  export type OrderRevisionUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderRevisionCreateWithoutOrderInput, OrderRevisionUncheckedCreateWithoutOrderInput> | OrderRevisionCreateWithoutOrderInput[] | OrderRevisionUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderRevisionCreateOrConnectWithoutOrderInput | OrderRevisionCreateOrConnectWithoutOrderInput[]
    upsert?: OrderRevisionUpsertWithWhereUniqueWithoutOrderInput | OrderRevisionUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderRevisionCreateManyOrderInputEnvelope
    set?: OrderRevisionWhereUniqueInput | OrderRevisionWhereUniqueInput[]
    disconnect?: OrderRevisionWhereUniqueInput | OrderRevisionWhereUniqueInput[]
    delete?: OrderRevisionWhereUniqueInput | OrderRevisionWhereUniqueInput[]
    connect?: OrderRevisionWhereUniqueInput | OrderRevisionWhereUniqueInput[]
    update?: OrderRevisionUpdateWithWhereUniqueWithoutOrderInput | OrderRevisionUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderRevisionUpdateManyWithWhereWithoutOrderInput | OrderRevisionUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderRevisionScalarWhereInput | OrderRevisionScalarWhereInput[]
  }

  export type OrderCommunicationUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderCommunicationCreateWithoutOrderInput, OrderCommunicationUncheckedCreateWithoutOrderInput> | OrderCommunicationCreateWithoutOrderInput[] | OrderCommunicationUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderCommunicationCreateOrConnectWithoutOrderInput | OrderCommunicationCreateOrConnectWithoutOrderInput[]
    upsert?: OrderCommunicationUpsertWithWhereUniqueWithoutOrderInput | OrderCommunicationUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderCommunicationCreateManyOrderInputEnvelope
    set?: OrderCommunicationWhereUniqueInput | OrderCommunicationWhereUniqueInput[]
    disconnect?: OrderCommunicationWhereUniqueInput | OrderCommunicationWhereUniqueInput[]
    delete?: OrderCommunicationWhereUniqueInput | OrderCommunicationWhereUniqueInput[]
    connect?: OrderCommunicationWhereUniqueInput | OrderCommunicationWhereUniqueInput[]
    update?: OrderCommunicationUpdateWithWhereUniqueWithoutOrderInput | OrderCommunicationUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderCommunicationUpdateManyWithWhereWithoutOrderInput | OrderCommunicationUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderCommunicationScalarWhereInput | OrderCommunicationScalarWhereInput[]
  }

  export type OrderDeliverableUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderDeliverableCreateWithoutOrderInput, OrderDeliverableUncheckedCreateWithoutOrderInput> | OrderDeliverableCreateWithoutOrderInput[] | OrderDeliverableUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderDeliverableCreateOrConnectWithoutOrderInput | OrderDeliverableCreateOrConnectWithoutOrderInput[]
    upsert?: OrderDeliverableUpsertWithWhereUniqueWithoutOrderInput | OrderDeliverableUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderDeliverableCreateManyOrderInputEnvelope
    set?: OrderDeliverableWhereUniqueInput | OrderDeliverableWhereUniqueInput[]
    disconnect?: OrderDeliverableWhereUniqueInput | OrderDeliverableWhereUniqueInput[]
    delete?: OrderDeliverableWhereUniqueInput | OrderDeliverableWhereUniqueInput[]
    connect?: OrderDeliverableWhereUniqueInput | OrderDeliverableWhereUniqueInput[]
    update?: OrderDeliverableUpdateWithWhereUniqueWithoutOrderInput | OrderDeliverableUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderDeliverableUpdateManyWithWhereWithoutOrderInput | OrderDeliverableUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderDeliverableScalarWhereInput | OrderDeliverableScalarWhereInput[]
  }

  export type AppOrderCreateNestedOneWithoutRevisionsInput = {
    create?: XOR<AppOrderCreateWithoutRevisionsInput, AppOrderUncheckedCreateWithoutRevisionsInput>
    connectOrCreate?: AppOrderCreateOrConnectWithoutRevisionsInput
    connect?: AppOrderWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOrderRevisionsInput = {
    create?: XOR<UserCreateWithoutOrderRevisionsInput, UserUncheckedCreateWithoutOrderRevisionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrderRevisionsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumRevisionStatusFieldUpdateOperationsInput = {
    set?: $Enums.RevisionStatus
  }

  export type AppOrderUpdateOneRequiredWithoutRevisionsNestedInput = {
    create?: XOR<AppOrderCreateWithoutRevisionsInput, AppOrderUncheckedCreateWithoutRevisionsInput>
    connectOrCreate?: AppOrderCreateOrConnectWithoutRevisionsInput
    upsert?: AppOrderUpsertWithoutRevisionsInput
    connect?: AppOrderWhereUniqueInput
    update?: XOR<XOR<AppOrderUpdateToOneWithWhereWithoutRevisionsInput, AppOrderUpdateWithoutRevisionsInput>, AppOrderUncheckedUpdateWithoutRevisionsInput>
  }

  export type UserUpdateOneRequiredWithoutOrderRevisionsNestedInput = {
    create?: XOR<UserCreateWithoutOrderRevisionsInput, UserUncheckedCreateWithoutOrderRevisionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrderRevisionsInput
    upsert?: UserUpsertWithoutOrderRevisionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrderRevisionsInput, UserUpdateWithoutOrderRevisionsInput>, UserUncheckedUpdateWithoutOrderRevisionsInput>
  }

  export type AppOrderCreateNestedOneWithoutCommunicationsInput = {
    create?: XOR<AppOrderCreateWithoutCommunicationsInput, AppOrderUncheckedCreateWithoutCommunicationsInput>
    connectOrCreate?: AppOrderCreateOrConnectWithoutCommunicationsInput
    connect?: AppOrderWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOrderCommunicationsInput = {
    create?: XOR<UserCreateWithoutOrderCommunicationsInput, UserUncheckedCreateWithoutOrderCommunicationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrderCommunicationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumCommunicationTypeFieldUpdateOperationsInput = {
    set?: $Enums.CommunicationType
  }

  export type AppOrderUpdateOneRequiredWithoutCommunicationsNestedInput = {
    create?: XOR<AppOrderCreateWithoutCommunicationsInput, AppOrderUncheckedCreateWithoutCommunicationsInput>
    connectOrCreate?: AppOrderCreateOrConnectWithoutCommunicationsInput
    upsert?: AppOrderUpsertWithoutCommunicationsInput
    connect?: AppOrderWhereUniqueInput
    update?: XOR<XOR<AppOrderUpdateToOneWithWhereWithoutCommunicationsInput, AppOrderUpdateWithoutCommunicationsInput>, AppOrderUncheckedUpdateWithoutCommunicationsInput>
  }

  export type UserUpdateOneRequiredWithoutOrderCommunicationsNestedInput = {
    create?: XOR<UserCreateWithoutOrderCommunicationsInput, UserUncheckedCreateWithoutOrderCommunicationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrderCommunicationsInput
    upsert?: UserUpsertWithoutOrderCommunicationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrderCommunicationsInput, UserUpdateWithoutOrderCommunicationsInput>, UserUncheckedUpdateWithoutOrderCommunicationsInput>
  }

  export type AppOrderCreateNestedOneWithoutDeliverablesInput = {
    create?: XOR<AppOrderCreateWithoutDeliverablesInput, AppOrderUncheckedCreateWithoutDeliverablesInput>
    connectOrCreate?: AppOrderCreateOrConnectWithoutDeliverablesInput
    connect?: AppOrderWhereUniqueInput
  }

  export type EnumDeliverableTypeFieldUpdateOperationsInput = {
    set?: $Enums.DeliverableType
  }

  export type EnumDeliverableStatusFieldUpdateOperationsInput = {
    set?: $Enums.DeliverableStatus
  }

  export type AppOrderUpdateOneRequiredWithoutDeliverablesNestedInput = {
    create?: XOR<AppOrderCreateWithoutDeliverablesInput, AppOrderUncheckedCreateWithoutDeliverablesInput>
    connectOrCreate?: AppOrderCreateOrConnectWithoutDeliverablesInput
    upsert?: AppOrderUpsertWithoutDeliverablesInput
    connect?: AppOrderWhereUniqueInput
    update?: XOR<XOR<AppOrderUpdateToOneWithWhereWithoutDeliverablesInput, AppOrderUpdateWithoutDeliverablesInput>, AppOrderUncheckedUpdateWithoutDeliverablesInput>
  }

  export type CardCreateNestedOneWithoutBettingMarketsInput = {
    create?: XOR<CardCreateWithoutBettingMarketsInput, CardUncheckedCreateWithoutBettingMarketsInput>
    connectOrCreate?: CardCreateOrConnectWithoutBettingMarketsInput
    connect?: CardWhereUniqueInput
  }

  export type BettingPositionCreateNestedManyWithoutMarketInput = {
    create?: XOR<BettingPositionCreateWithoutMarketInput, BettingPositionUncheckedCreateWithoutMarketInput> | BettingPositionCreateWithoutMarketInput[] | BettingPositionUncheckedCreateWithoutMarketInput[]
    connectOrCreate?: BettingPositionCreateOrConnectWithoutMarketInput | BettingPositionCreateOrConnectWithoutMarketInput[]
    createMany?: BettingPositionCreateManyMarketInputEnvelope
    connect?: BettingPositionWhereUniqueInput | BettingPositionWhereUniqueInput[]
  }

  export type BettingPayoutCreateNestedManyWithoutMarketInput = {
    create?: XOR<BettingPayoutCreateWithoutMarketInput, BettingPayoutUncheckedCreateWithoutMarketInput> | BettingPayoutCreateWithoutMarketInput[] | BettingPayoutUncheckedCreateWithoutMarketInput[]
    connectOrCreate?: BettingPayoutCreateOrConnectWithoutMarketInput | BettingPayoutCreateOrConnectWithoutMarketInput[]
    createMany?: BettingPayoutCreateManyMarketInputEnvelope
    connect?: BettingPayoutWhereUniqueInput | BettingPayoutWhereUniqueInput[]
  }

  export type MarketMetricsCreateNestedManyWithoutMarketInput = {
    create?: XOR<MarketMetricsCreateWithoutMarketInput, MarketMetricsUncheckedCreateWithoutMarketInput> | MarketMetricsCreateWithoutMarketInput[] | MarketMetricsUncheckedCreateWithoutMarketInput[]
    connectOrCreate?: MarketMetricsCreateOrConnectWithoutMarketInput | MarketMetricsCreateOrConnectWithoutMarketInput[]
    createMany?: MarketMetricsCreateManyMarketInputEnvelope
    connect?: MarketMetricsWhereUniqueInput | MarketMetricsWhereUniqueInput[]
  }

  export type BettingPositionUncheckedCreateNestedManyWithoutMarketInput = {
    create?: XOR<BettingPositionCreateWithoutMarketInput, BettingPositionUncheckedCreateWithoutMarketInput> | BettingPositionCreateWithoutMarketInput[] | BettingPositionUncheckedCreateWithoutMarketInput[]
    connectOrCreate?: BettingPositionCreateOrConnectWithoutMarketInput | BettingPositionCreateOrConnectWithoutMarketInput[]
    createMany?: BettingPositionCreateManyMarketInputEnvelope
    connect?: BettingPositionWhereUniqueInput | BettingPositionWhereUniqueInput[]
  }

  export type BettingPayoutUncheckedCreateNestedManyWithoutMarketInput = {
    create?: XOR<BettingPayoutCreateWithoutMarketInput, BettingPayoutUncheckedCreateWithoutMarketInput> | BettingPayoutCreateWithoutMarketInput[] | BettingPayoutUncheckedCreateWithoutMarketInput[]
    connectOrCreate?: BettingPayoutCreateOrConnectWithoutMarketInput | BettingPayoutCreateOrConnectWithoutMarketInput[]
    createMany?: BettingPayoutCreateManyMarketInputEnvelope
    connect?: BettingPayoutWhereUniqueInput | BettingPayoutWhereUniqueInput[]
  }

  export type MarketMetricsUncheckedCreateNestedManyWithoutMarketInput = {
    create?: XOR<MarketMetricsCreateWithoutMarketInput, MarketMetricsUncheckedCreateWithoutMarketInput> | MarketMetricsCreateWithoutMarketInput[] | MarketMetricsUncheckedCreateWithoutMarketInput[]
    connectOrCreate?: MarketMetricsCreateOrConnectWithoutMarketInput | MarketMetricsCreateOrConnectWithoutMarketInput[]
    createMany?: MarketMetricsCreateManyMarketInputEnvelope
    connect?: MarketMetricsWhereUniqueInput | MarketMetricsWhereUniqueInput[]
  }

  export type EnumMarketMetricTypeFieldUpdateOperationsInput = {
    set?: $Enums.MarketMetricType
  }

  export type EnumPredictionDirectionFieldUpdateOperationsInput = {
    set?: $Enums.PredictionDirection
  }

  export type EnumMarketStatusFieldUpdateOperationsInput = {
    set?: $Enums.MarketStatus
  }

  export type NullableEnumPredictionDirectionFieldUpdateOperationsInput = {
    set?: $Enums.PredictionDirection | null
  }

  export type CardUpdateOneRequiredWithoutBettingMarketsNestedInput = {
    create?: XOR<CardCreateWithoutBettingMarketsInput, CardUncheckedCreateWithoutBettingMarketsInput>
    connectOrCreate?: CardCreateOrConnectWithoutBettingMarketsInput
    upsert?: CardUpsertWithoutBettingMarketsInput
    connect?: CardWhereUniqueInput
    update?: XOR<XOR<CardUpdateToOneWithWhereWithoutBettingMarketsInput, CardUpdateWithoutBettingMarketsInput>, CardUncheckedUpdateWithoutBettingMarketsInput>
  }

  export type BettingPositionUpdateManyWithoutMarketNestedInput = {
    create?: XOR<BettingPositionCreateWithoutMarketInput, BettingPositionUncheckedCreateWithoutMarketInput> | BettingPositionCreateWithoutMarketInput[] | BettingPositionUncheckedCreateWithoutMarketInput[]
    connectOrCreate?: BettingPositionCreateOrConnectWithoutMarketInput | BettingPositionCreateOrConnectWithoutMarketInput[]
    upsert?: BettingPositionUpsertWithWhereUniqueWithoutMarketInput | BettingPositionUpsertWithWhereUniqueWithoutMarketInput[]
    createMany?: BettingPositionCreateManyMarketInputEnvelope
    set?: BettingPositionWhereUniqueInput | BettingPositionWhereUniqueInput[]
    disconnect?: BettingPositionWhereUniqueInput | BettingPositionWhereUniqueInput[]
    delete?: BettingPositionWhereUniqueInput | BettingPositionWhereUniqueInput[]
    connect?: BettingPositionWhereUniqueInput | BettingPositionWhereUniqueInput[]
    update?: BettingPositionUpdateWithWhereUniqueWithoutMarketInput | BettingPositionUpdateWithWhereUniqueWithoutMarketInput[]
    updateMany?: BettingPositionUpdateManyWithWhereWithoutMarketInput | BettingPositionUpdateManyWithWhereWithoutMarketInput[]
    deleteMany?: BettingPositionScalarWhereInput | BettingPositionScalarWhereInput[]
  }

  export type BettingPayoutUpdateManyWithoutMarketNestedInput = {
    create?: XOR<BettingPayoutCreateWithoutMarketInput, BettingPayoutUncheckedCreateWithoutMarketInput> | BettingPayoutCreateWithoutMarketInput[] | BettingPayoutUncheckedCreateWithoutMarketInput[]
    connectOrCreate?: BettingPayoutCreateOrConnectWithoutMarketInput | BettingPayoutCreateOrConnectWithoutMarketInput[]
    upsert?: BettingPayoutUpsertWithWhereUniqueWithoutMarketInput | BettingPayoutUpsertWithWhereUniqueWithoutMarketInput[]
    createMany?: BettingPayoutCreateManyMarketInputEnvelope
    set?: BettingPayoutWhereUniqueInput | BettingPayoutWhereUniqueInput[]
    disconnect?: BettingPayoutWhereUniqueInput | BettingPayoutWhereUniqueInput[]
    delete?: BettingPayoutWhereUniqueInput | BettingPayoutWhereUniqueInput[]
    connect?: BettingPayoutWhereUniqueInput | BettingPayoutWhereUniqueInput[]
    update?: BettingPayoutUpdateWithWhereUniqueWithoutMarketInput | BettingPayoutUpdateWithWhereUniqueWithoutMarketInput[]
    updateMany?: BettingPayoutUpdateManyWithWhereWithoutMarketInput | BettingPayoutUpdateManyWithWhereWithoutMarketInput[]
    deleteMany?: BettingPayoutScalarWhereInput | BettingPayoutScalarWhereInput[]
  }

  export type MarketMetricsUpdateManyWithoutMarketNestedInput = {
    create?: XOR<MarketMetricsCreateWithoutMarketInput, MarketMetricsUncheckedCreateWithoutMarketInput> | MarketMetricsCreateWithoutMarketInput[] | MarketMetricsUncheckedCreateWithoutMarketInput[]
    connectOrCreate?: MarketMetricsCreateOrConnectWithoutMarketInput | MarketMetricsCreateOrConnectWithoutMarketInput[]
    upsert?: MarketMetricsUpsertWithWhereUniqueWithoutMarketInput | MarketMetricsUpsertWithWhereUniqueWithoutMarketInput[]
    createMany?: MarketMetricsCreateManyMarketInputEnvelope
    set?: MarketMetricsWhereUniqueInput | MarketMetricsWhereUniqueInput[]
    disconnect?: MarketMetricsWhereUniqueInput | MarketMetricsWhereUniqueInput[]
    delete?: MarketMetricsWhereUniqueInput | MarketMetricsWhereUniqueInput[]
    connect?: MarketMetricsWhereUniqueInput | MarketMetricsWhereUniqueInput[]
    update?: MarketMetricsUpdateWithWhereUniqueWithoutMarketInput | MarketMetricsUpdateWithWhereUniqueWithoutMarketInput[]
    updateMany?: MarketMetricsUpdateManyWithWhereWithoutMarketInput | MarketMetricsUpdateManyWithWhereWithoutMarketInput[]
    deleteMany?: MarketMetricsScalarWhereInput | MarketMetricsScalarWhereInput[]
  }

  export type BettingPositionUncheckedUpdateManyWithoutMarketNestedInput = {
    create?: XOR<BettingPositionCreateWithoutMarketInput, BettingPositionUncheckedCreateWithoutMarketInput> | BettingPositionCreateWithoutMarketInput[] | BettingPositionUncheckedCreateWithoutMarketInput[]
    connectOrCreate?: BettingPositionCreateOrConnectWithoutMarketInput | BettingPositionCreateOrConnectWithoutMarketInput[]
    upsert?: BettingPositionUpsertWithWhereUniqueWithoutMarketInput | BettingPositionUpsertWithWhereUniqueWithoutMarketInput[]
    createMany?: BettingPositionCreateManyMarketInputEnvelope
    set?: BettingPositionWhereUniqueInput | BettingPositionWhereUniqueInput[]
    disconnect?: BettingPositionWhereUniqueInput | BettingPositionWhereUniqueInput[]
    delete?: BettingPositionWhereUniqueInput | BettingPositionWhereUniqueInput[]
    connect?: BettingPositionWhereUniqueInput | BettingPositionWhereUniqueInput[]
    update?: BettingPositionUpdateWithWhereUniqueWithoutMarketInput | BettingPositionUpdateWithWhereUniqueWithoutMarketInput[]
    updateMany?: BettingPositionUpdateManyWithWhereWithoutMarketInput | BettingPositionUpdateManyWithWhereWithoutMarketInput[]
    deleteMany?: BettingPositionScalarWhereInput | BettingPositionScalarWhereInput[]
  }

  export type BettingPayoutUncheckedUpdateManyWithoutMarketNestedInput = {
    create?: XOR<BettingPayoutCreateWithoutMarketInput, BettingPayoutUncheckedCreateWithoutMarketInput> | BettingPayoutCreateWithoutMarketInput[] | BettingPayoutUncheckedCreateWithoutMarketInput[]
    connectOrCreate?: BettingPayoutCreateOrConnectWithoutMarketInput | BettingPayoutCreateOrConnectWithoutMarketInput[]
    upsert?: BettingPayoutUpsertWithWhereUniqueWithoutMarketInput | BettingPayoutUpsertWithWhereUniqueWithoutMarketInput[]
    createMany?: BettingPayoutCreateManyMarketInputEnvelope
    set?: BettingPayoutWhereUniqueInput | BettingPayoutWhereUniqueInput[]
    disconnect?: BettingPayoutWhereUniqueInput | BettingPayoutWhereUniqueInput[]
    delete?: BettingPayoutWhereUniqueInput | BettingPayoutWhereUniqueInput[]
    connect?: BettingPayoutWhereUniqueInput | BettingPayoutWhereUniqueInput[]
    update?: BettingPayoutUpdateWithWhereUniqueWithoutMarketInput | BettingPayoutUpdateWithWhereUniqueWithoutMarketInput[]
    updateMany?: BettingPayoutUpdateManyWithWhereWithoutMarketInput | BettingPayoutUpdateManyWithWhereWithoutMarketInput[]
    deleteMany?: BettingPayoutScalarWhereInput | BettingPayoutScalarWhereInput[]
  }

  export type MarketMetricsUncheckedUpdateManyWithoutMarketNestedInput = {
    create?: XOR<MarketMetricsCreateWithoutMarketInput, MarketMetricsUncheckedCreateWithoutMarketInput> | MarketMetricsCreateWithoutMarketInput[] | MarketMetricsUncheckedCreateWithoutMarketInput[]
    connectOrCreate?: MarketMetricsCreateOrConnectWithoutMarketInput | MarketMetricsCreateOrConnectWithoutMarketInput[]
    upsert?: MarketMetricsUpsertWithWhereUniqueWithoutMarketInput | MarketMetricsUpsertWithWhereUniqueWithoutMarketInput[]
    createMany?: MarketMetricsCreateManyMarketInputEnvelope
    set?: MarketMetricsWhereUniqueInput | MarketMetricsWhereUniqueInput[]
    disconnect?: MarketMetricsWhereUniqueInput | MarketMetricsWhereUniqueInput[]
    delete?: MarketMetricsWhereUniqueInput | MarketMetricsWhereUniqueInput[]
    connect?: MarketMetricsWhereUniqueInput | MarketMetricsWhereUniqueInput[]
    update?: MarketMetricsUpdateWithWhereUniqueWithoutMarketInput | MarketMetricsUpdateWithWhereUniqueWithoutMarketInput[]
    updateMany?: MarketMetricsUpdateManyWithWhereWithoutMarketInput | MarketMetricsUpdateManyWithWhereWithoutMarketInput[]
    deleteMany?: MarketMetricsScalarWhereInput | MarketMetricsScalarWhereInput[]
  }

  export type BettingMarketCreateNestedOneWithoutPositionsInput = {
    create?: XOR<BettingMarketCreateWithoutPositionsInput, BettingMarketUncheckedCreateWithoutPositionsInput>
    connectOrCreate?: BettingMarketCreateOrConnectWithoutPositionsInput
    connect?: BettingMarketWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBettingPositionsInput = {
    create?: XOR<UserCreateWithoutBettingPositionsInput, UserUncheckedCreateWithoutBettingPositionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBettingPositionsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumPositionStatusFieldUpdateOperationsInput = {
    set?: $Enums.PositionStatus
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type BettingMarketUpdateOneRequiredWithoutPositionsNestedInput = {
    create?: XOR<BettingMarketCreateWithoutPositionsInput, BettingMarketUncheckedCreateWithoutPositionsInput>
    connectOrCreate?: BettingMarketCreateOrConnectWithoutPositionsInput
    upsert?: BettingMarketUpsertWithoutPositionsInput
    connect?: BettingMarketWhereUniqueInput
    update?: XOR<XOR<BettingMarketUpdateToOneWithWhereWithoutPositionsInput, BettingMarketUpdateWithoutPositionsInput>, BettingMarketUncheckedUpdateWithoutPositionsInput>
  }

  export type UserUpdateOneRequiredWithoutBettingPositionsNestedInput = {
    create?: XOR<UserCreateWithoutBettingPositionsInput, UserUncheckedCreateWithoutBettingPositionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBettingPositionsInput
    upsert?: UserUpsertWithoutBettingPositionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBettingPositionsInput, UserUpdateWithoutBettingPositionsInput>, UserUncheckedUpdateWithoutBettingPositionsInput>
  }

  export type CardCreateNestedOneWithoutMarketMetricsInput = {
    create?: XOR<CardCreateWithoutMarketMetricsInput, CardUncheckedCreateWithoutMarketMetricsInput>
    connectOrCreate?: CardCreateOrConnectWithoutMarketMetricsInput
    connect?: CardWhereUniqueInput
  }

  export type BettingMarketCreateNestedOneWithoutMetricsInput = {
    create?: XOR<BettingMarketCreateWithoutMetricsInput, BettingMarketUncheckedCreateWithoutMetricsInput>
    connectOrCreate?: BettingMarketCreateOrConnectWithoutMetricsInput
    connect?: BettingMarketWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CardUpdateOneRequiredWithoutMarketMetricsNestedInput = {
    create?: XOR<CardCreateWithoutMarketMetricsInput, CardUncheckedCreateWithoutMarketMetricsInput>
    connectOrCreate?: CardCreateOrConnectWithoutMarketMetricsInput
    upsert?: CardUpsertWithoutMarketMetricsInput
    connect?: CardWhereUniqueInput
    update?: XOR<XOR<CardUpdateToOneWithWhereWithoutMarketMetricsInput, CardUpdateWithoutMarketMetricsInput>, CardUncheckedUpdateWithoutMarketMetricsInput>
  }

  export type BettingMarketUpdateOneWithoutMetricsNestedInput = {
    create?: XOR<BettingMarketCreateWithoutMetricsInput, BettingMarketUncheckedCreateWithoutMetricsInput>
    connectOrCreate?: BettingMarketCreateOrConnectWithoutMetricsInput
    upsert?: BettingMarketUpsertWithoutMetricsInput
    disconnect?: BettingMarketWhereInput | boolean
    delete?: BettingMarketWhereInput | boolean
    connect?: BettingMarketWhereUniqueInput
    update?: XOR<XOR<BettingMarketUpdateToOneWithWhereWithoutMetricsInput, BettingMarketUpdateWithoutMetricsInput>, BettingMarketUncheckedUpdateWithoutMetricsInput>
  }

  export type BettingMarketCreateNestedOneWithoutPayoutsInput = {
    create?: XOR<BettingMarketCreateWithoutPayoutsInput, BettingMarketUncheckedCreateWithoutPayoutsInput>
    connectOrCreate?: BettingMarketCreateOrConnectWithoutPayoutsInput
    connect?: BettingMarketWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBettingPayoutsInput = {
    create?: XOR<UserCreateWithoutBettingPayoutsInput, UserUncheckedCreateWithoutBettingPayoutsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBettingPayoutsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumPayoutStatusFieldUpdateOperationsInput = {
    set?: $Enums.PayoutStatus
  }

  export type BettingMarketUpdateOneRequiredWithoutPayoutsNestedInput = {
    create?: XOR<BettingMarketCreateWithoutPayoutsInput, BettingMarketUncheckedCreateWithoutPayoutsInput>
    connectOrCreate?: BettingMarketCreateOrConnectWithoutPayoutsInput
    upsert?: BettingMarketUpsertWithoutPayoutsInput
    connect?: BettingMarketWhereUniqueInput
    update?: XOR<XOR<BettingMarketUpdateToOneWithWhereWithoutPayoutsInput, BettingMarketUpdateWithoutPayoutsInput>, BettingMarketUncheckedUpdateWithoutPayoutsInput>
  }

  export type UserUpdateOneRequiredWithoutBettingPayoutsNestedInput = {
    create?: XOR<UserCreateWithoutBettingPayoutsInput, UserUncheckedCreateWithoutBettingPayoutsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBettingPayoutsInput
    upsert?: UserUpsertWithoutBettingPayoutsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBettingPayoutsInput, UserUpdateWithoutBettingPayoutsInput>, UserUncheckedUpdateWithoutBettingPayoutsInput>
  }

  export type CardCreateNestedOneWithoutAuctionInput = {
    create?: XOR<CardCreateWithoutAuctionInput, CardUncheckedCreateWithoutAuctionInput>
    connectOrCreate?: CardCreateOrConnectWithoutAuctionInput
    connect?: CardWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOwnedAuctionsInput = {
    create?: XOR<UserCreateWithoutOwnedAuctionsInput, UserUncheckedCreateWithoutOwnedAuctionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedAuctionsInput
    connect?: UserWhereUniqueInput
  }

  export type AuctionConditionsCreateNestedOneWithoutAuctionInput = {
    create?: XOR<AuctionConditionsCreateWithoutAuctionInput, AuctionConditionsUncheckedCreateWithoutAuctionInput>
    connectOrCreate?: AuctionConditionsCreateOrConnectWithoutAuctionInput
    connect?: AuctionConditionsWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutWonAuctionsInput = {
    create?: XOR<UserCreateWithoutWonAuctionsInput, UserUncheckedCreateWithoutWonAuctionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWonAuctionsInput
    connect?: UserWhereUniqueInput
  }

  export type AuctionBidCreateNestedManyWithoutAuctionInput = {
    create?: XOR<AuctionBidCreateWithoutAuctionInput, AuctionBidUncheckedCreateWithoutAuctionInput> | AuctionBidCreateWithoutAuctionInput[] | AuctionBidUncheckedCreateWithoutAuctionInput[]
    connectOrCreate?: AuctionBidCreateOrConnectWithoutAuctionInput | AuctionBidCreateOrConnectWithoutAuctionInput[]
    createMany?: AuctionBidCreateManyAuctionInputEnvelope
    connect?: AuctionBidWhereUniqueInput | AuctionBidWhereUniqueInput[]
  }

  export type AuctionWatcherCreateNestedManyWithoutAuctionInput = {
    create?: XOR<AuctionWatcherCreateWithoutAuctionInput, AuctionWatcherUncheckedCreateWithoutAuctionInput> | AuctionWatcherCreateWithoutAuctionInput[] | AuctionWatcherUncheckedCreateWithoutAuctionInput[]
    connectOrCreate?: AuctionWatcherCreateOrConnectWithoutAuctionInput | AuctionWatcherCreateOrConnectWithoutAuctionInput[]
    createMany?: AuctionWatcherCreateManyAuctionInputEnvelope
    connect?: AuctionWatcherWhereUniqueInput | AuctionWatcherWhereUniqueInput[]
  }

  export type AuctionHistoryCreateNestedManyWithoutAuctionInput = {
    create?: XOR<AuctionHistoryCreateWithoutAuctionInput, AuctionHistoryUncheckedCreateWithoutAuctionInput> | AuctionHistoryCreateWithoutAuctionInput[] | AuctionHistoryUncheckedCreateWithoutAuctionInput[]
    connectOrCreate?: AuctionHistoryCreateOrConnectWithoutAuctionInput | AuctionHistoryCreateOrConnectWithoutAuctionInput[]
    createMany?: AuctionHistoryCreateManyAuctionInputEnvelope
    connect?: AuctionHistoryWhereUniqueInput | AuctionHistoryWhereUniqueInput[]
  }

  export type AuctionConditionsUncheckedCreateNestedOneWithoutAuctionInput = {
    create?: XOR<AuctionConditionsCreateWithoutAuctionInput, AuctionConditionsUncheckedCreateWithoutAuctionInput>
    connectOrCreate?: AuctionConditionsCreateOrConnectWithoutAuctionInput
    connect?: AuctionConditionsWhereUniqueInput
  }

  export type AuctionBidUncheckedCreateNestedManyWithoutAuctionInput = {
    create?: XOR<AuctionBidCreateWithoutAuctionInput, AuctionBidUncheckedCreateWithoutAuctionInput> | AuctionBidCreateWithoutAuctionInput[] | AuctionBidUncheckedCreateWithoutAuctionInput[]
    connectOrCreate?: AuctionBidCreateOrConnectWithoutAuctionInput | AuctionBidCreateOrConnectWithoutAuctionInput[]
    createMany?: AuctionBidCreateManyAuctionInputEnvelope
    connect?: AuctionBidWhereUniqueInput | AuctionBidWhereUniqueInput[]
  }

  export type AuctionWatcherUncheckedCreateNestedManyWithoutAuctionInput = {
    create?: XOR<AuctionWatcherCreateWithoutAuctionInput, AuctionWatcherUncheckedCreateWithoutAuctionInput> | AuctionWatcherCreateWithoutAuctionInput[] | AuctionWatcherUncheckedCreateWithoutAuctionInput[]
    connectOrCreate?: AuctionWatcherCreateOrConnectWithoutAuctionInput | AuctionWatcherCreateOrConnectWithoutAuctionInput[]
    createMany?: AuctionWatcherCreateManyAuctionInputEnvelope
    connect?: AuctionWatcherWhereUniqueInput | AuctionWatcherWhereUniqueInput[]
  }

  export type AuctionHistoryUncheckedCreateNestedManyWithoutAuctionInput = {
    create?: XOR<AuctionHistoryCreateWithoutAuctionInput, AuctionHistoryUncheckedCreateWithoutAuctionInput> | AuctionHistoryCreateWithoutAuctionInput[] | AuctionHistoryUncheckedCreateWithoutAuctionInput[]
    connectOrCreate?: AuctionHistoryCreateOrConnectWithoutAuctionInput | AuctionHistoryCreateOrConnectWithoutAuctionInput[]
    createMany?: AuctionHistoryCreateManyAuctionInputEnvelope
    connect?: AuctionHistoryWhereUniqueInput | AuctionHistoryWhereUniqueInput[]
  }

  export type EnumAuctionStatusFieldUpdateOperationsInput = {
    set?: $Enums.AuctionStatus
  }

  export type CardUpdateOneRequiredWithoutAuctionNestedInput = {
    create?: XOR<CardCreateWithoutAuctionInput, CardUncheckedCreateWithoutAuctionInput>
    connectOrCreate?: CardCreateOrConnectWithoutAuctionInput
    upsert?: CardUpsertWithoutAuctionInput
    connect?: CardWhereUniqueInput
    update?: XOR<XOR<CardUpdateToOneWithWhereWithoutAuctionInput, CardUpdateWithoutAuctionInput>, CardUncheckedUpdateWithoutAuctionInput>
  }

  export type UserUpdateOneRequiredWithoutOwnedAuctionsNestedInput = {
    create?: XOR<UserCreateWithoutOwnedAuctionsInput, UserUncheckedCreateWithoutOwnedAuctionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedAuctionsInput
    upsert?: UserUpsertWithoutOwnedAuctionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOwnedAuctionsInput, UserUpdateWithoutOwnedAuctionsInput>, UserUncheckedUpdateWithoutOwnedAuctionsInput>
  }

  export type AuctionConditionsUpdateOneWithoutAuctionNestedInput = {
    create?: XOR<AuctionConditionsCreateWithoutAuctionInput, AuctionConditionsUncheckedCreateWithoutAuctionInput>
    connectOrCreate?: AuctionConditionsCreateOrConnectWithoutAuctionInput
    upsert?: AuctionConditionsUpsertWithoutAuctionInput
    disconnect?: AuctionConditionsWhereInput | boolean
    delete?: AuctionConditionsWhereInput | boolean
    connect?: AuctionConditionsWhereUniqueInput
    update?: XOR<XOR<AuctionConditionsUpdateToOneWithWhereWithoutAuctionInput, AuctionConditionsUpdateWithoutAuctionInput>, AuctionConditionsUncheckedUpdateWithoutAuctionInput>
  }

  export type UserUpdateOneWithoutWonAuctionsNestedInput = {
    create?: XOR<UserCreateWithoutWonAuctionsInput, UserUncheckedCreateWithoutWonAuctionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWonAuctionsInput
    upsert?: UserUpsertWithoutWonAuctionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWonAuctionsInput, UserUpdateWithoutWonAuctionsInput>, UserUncheckedUpdateWithoutWonAuctionsInput>
  }

  export type AuctionBidUpdateManyWithoutAuctionNestedInput = {
    create?: XOR<AuctionBidCreateWithoutAuctionInput, AuctionBidUncheckedCreateWithoutAuctionInput> | AuctionBidCreateWithoutAuctionInput[] | AuctionBidUncheckedCreateWithoutAuctionInput[]
    connectOrCreate?: AuctionBidCreateOrConnectWithoutAuctionInput | AuctionBidCreateOrConnectWithoutAuctionInput[]
    upsert?: AuctionBidUpsertWithWhereUniqueWithoutAuctionInput | AuctionBidUpsertWithWhereUniqueWithoutAuctionInput[]
    createMany?: AuctionBidCreateManyAuctionInputEnvelope
    set?: AuctionBidWhereUniqueInput | AuctionBidWhereUniqueInput[]
    disconnect?: AuctionBidWhereUniqueInput | AuctionBidWhereUniqueInput[]
    delete?: AuctionBidWhereUniqueInput | AuctionBidWhereUniqueInput[]
    connect?: AuctionBidWhereUniqueInput | AuctionBidWhereUniqueInput[]
    update?: AuctionBidUpdateWithWhereUniqueWithoutAuctionInput | AuctionBidUpdateWithWhereUniqueWithoutAuctionInput[]
    updateMany?: AuctionBidUpdateManyWithWhereWithoutAuctionInput | AuctionBidUpdateManyWithWhereWithoutAuctionInput[]
    deleteMany?: AuctionBidScalarWhereInput | AuctionBidScalarWhereInput[]
  }

  export type AuctionWatcherUpdateManyWithoutAuctionNestedInput = {
    create?: XOR<AuctionWatcherCreateWithoutAuctionInput, AuctionWatcherUncheckedCreateWithoutAuctionInput> | AuctionWatcherCreateWithoutAuctionInput[] | AuctionWatcherUncheckedCreateWithoutAuctionInput[]
    connectOrCreate?: AuctionWatcherCreateOrConnectWithoutAuctionInput | AuctionWatcherCreateOrConnectWithoutAuctionInput[]
    upsert?: AuctionWatcherUpsertWithWhereUniqueWithoutAuctionInput | AuctionWatcherUpsertWithWhereUniqueWithoutAuctionInput[]
    createMany?: AuctionWatcherCreateManyAuctionInputEnvelope
    set?: AuctionWatcherWhereUniqueInput | AuctionWatcherWhereUniqueInput[]
    disconnect?: AuctionWatcherWhereUniqueInput | AuctionWatcherWhereUniqueInput[]
    delete?: AuctionWatcherWhereUniqueInput | AuctionWatcherWhereUniqueInput[]
    connect?: AuctionWatcherWhereUniqueInput | AuctionWatcherWhereUniqueInput[]
    update?: AuctionWatcherUpdateWithWhereUniqueWithoutAuctionInput | AuctionWatcherUpdateWithWhereUniqueWithoutAuctionInput[]
    updateMany?: AuctionWatcherUpdateManyWithWhereWithoutAuctionInput | AuctionWatcherUpdateManyWithWhereWithoutAuctionInput[]
    deleteMany?: AuctionWatcherScalarWhereInput | AuctionWatcherScalarWhereInput[]
  }

  export type AuctionHistoryUpdateManyWithoutAuctionNestedInput = {
    create?: XOR<AuctionHistoryCreateWithoutAuctionInput, AuctionHistoryUncheckedCreateWithoutAuctionInput> | AuctionHistoryCreateWithoutAuctionInput[] | AuctionHistoryUncheckedCreateWithoutAuctionInput[]
    connectOrCreate?: AuctionHistoryCreateOrConnectWithoutAuctionInput | AuctionHistoryCreateOrConnectWithoutAuctionInput[]
    upsert?: AuctionHistoryUpsertWithWhereUniqueWithoutAuctionInput | AuctionHistoryUpsertWithWhereUniqueWithoutAuctionInput[]
    createMany?: AuctionHistoryCreateManyAuctionInputEnvelope
    set?: AuctionHistoryWhereUniqueInput | AuctionHistoryWhereUniqueInput[]
    disconnect?: AuctionHistoryWhereUniqueInput | AuctionHistoryWhereUniqueInput[]
    delete?: AuctionHistoryWhereUniqueInput | AuctionHistoryWhereUniqueInput[]
    connect?: AuctionHistoryWhereUniqueInput | AuctionHistoryWhereUniqueInput[]
    update?: AuctionHistoryUpdateWithWhereUniqueWithoutAuctionInput | AuctionHistoryUpdateWithWhereUniqueWithoutAuctionInput[]
    updateMany?: AuctionHistoryUpdateManyWithWhereWithoutAuctionInput | AuctionHistoryUpdateManyWithWhereWithoutAuctionInput[]
    deleteMany?: AuctionHistoryScalarWhereInput | AuctionHistoryScalarWhereInput[]
  }

  export type AuctionConditionsUncheckedUpdateOneWithoutAuctionNestedInput = {
    create?: XOR<AuctionConditionsCreateWithoutAuctionInput, AuctionConditionsUncheckedCreateWithoutAuctionInput>
    connectOrCreate?: AuctionConditionsCreateOrConnectWithoutAuctionInput
    upsert?: AuctionConditionsUpsertWithoutAuctionInput
    disconnect?: AuctionConditionsWhereInput | boolean
    delete?: AuctionConditionsWhereInput | boolean
    connect?: AuctionConditionsWhereUniqueInput
    update?: XOR<XOR<AuctionConditionsUpdateToOneWithWhereWithoutAuctionInput, AuctionConditionsUpdateWithoutAuctionInput>, AuctionConditionsUncheckedUpdateWithoutAuctionInput>
  }

  export type AuctionBidUncheckedUpdateManyWithoutAuctionNestedInput = {
    create?: XOR<AuctionBidCreateWithoutAuctionInput, AuctionBidUncheckedCreateWithoutAuctionInput> | AuctionBidCreateWithoutAuctionInput[] | AuctionBidUncheckedCreateWithoutAuctionInput[]
    connectOrCreate?: AuctionBidCreateOrConnectWithoutAuctionInput | AuctionBidCreateOrConnectWithoutAuctionInput[]
    upsert?: AuctionBidUpsertWithWhereUniqueWithoutAuctionInput | AuctionBidUpsertWithWhereUniqueWithoutAuctionInput[]
    createMany?: AuctionBidCreateManyAuctionInputEnvelope
    set?: AuctionBidWhereUniqueInput | AuctionBidWhereUniqueInput[]
    disconnect?: AuctionBidWhereUniqueInput | AuctionBidWhereUniqueInput[]
    delete?: AuctionBidWhereUniqueInput | AuctionBidWhereUniqueInput[]
    connect?: AuctionBidWhereUniqueInput | AuctionBidWhereUniqueInput[]
    update?: AuctionBidUpdateWithWhereUniqueWithoutAuctionInput | AuctionBidUpdateWithWhereUniqueWithoutAuctionInput[]
    updateMany?: AuctionBidUpdateManyWithWhereWithoutAuctionInput | AuctionBidUpdateManyWithWhereWithoutAuctionInput[]
    deleteMany?: AuctionBidScalarWhereInput | AuctionBidScalarWhereInput[]
  }

  export type AuctionWatcherUncheckedUpdateManyWithoutAuctionNestedInput = {
    create?: XOR<AuctionWatcherCreateWithoutAuctionInput, AuctionWatcherUncheckedCreateWithoutAuctionInput> | AuctionWatcherCreateWithoutAuctionInput[] | AuctionWatcherUncheckedCreateWithoutAuctionInput[]
    connectOrCreate?: AuctionWatcherCreateOrConnectWithoutAuctionInput | AuctionWatcherCreateOrConnectWithoutAuctionInput[]
    upsert?: AuctionWatcherUpsertWithWhereUniqueWithoutAuctionInput | AuctionWatcherUpsertWithWhereUniqueWithoutAuctionInput[]
    createMany?: AuctionWatcherCreateManyAuctionInputEnvelope
    set?: AuctionWatcherWhereUniqueInput | AuctionWatcherWhereUniqueInput[]
    disconnect?: AuctionWatcherWhereUniqueInput | AuctionWatcherWhereUniqueInput[]
    delete?: AuctionWatcherWhereUniqueInput | AuctionWatcherWhereUniqueInput[]
    connect?: AuctionWatcherWhereUniqueInput | AuctionWatcherWhereUniqueInput[]
    update?: AuctionWatcherUpdateWithWhereUniqueWithoutAuctionInput | AuctionWatcherUpdateWithWhereUniqueWithoutAuctionInput[]
    updateMany?: AuctionWatcherUpdateManyWithWhereWithoutAuctionInput | AuctionWatcherUpdateManyWithWhereWithoutAuctionInput[]
    deleteMany?: AuctionWatcherScalarWhereInput | AuctionWatcherScalarWhereInput[]
  }

  export type AuctionHistoryUncheckedUpdateManyWithoutAuctionNestedInput = {
    create?: XOR<AuctionHistoryCreateWithoutAuctionInput, AuctionHistoryUncheckedCreateWithoutAuctionInput> | AuctionHistoryCreateWithoutAuctionInput[] | AuctionHistoryUncheckedCreateWithoutAuctionInput[]
    connectOrCreate?: AuctionHistoryCreateOrConnectWithoutAuctionInput | AuctionHistoryCreateOrConnectWithoutAuctionInput[]
    upsert?: AuctionHistoryUpsertWithWhereUniqueWithoutAuctionInput | AuctionHistoryUpsertWithWhereUniqueWithoutAuctionInput[]
    createMany?: AuctionHistoryCreateManyAuctionInputEnvelope
    set?: AuctionHistoryWhereUniqueInput | AuctionHistoryWhereUniqueInput[]
    disconnect?: AuctionHistoryWhereUniqueInput | AuctionHistoryWhereUniqueInput[]
    delete?: AuctionHistoryWhereUniqueInput | AuctionHistoryWhereUniqueInput[]
    connect?: AuctionHistoryWhereUniqueInput | AuctionHistoryWhereUniqueInput[]
    update?: AuctionHistoryUpdateWithWhereUniqueWithoutAuctionInput | AuctionHistoryUpdateWithWhereUniqueWithoutAuctionInput[]
    updateMany?: AuctionHistoryUpdateManyWithWhereWithoutAuctionInput | AuctionHistoryUpdateManyWithWhereWithoutAuctionInput[]
    deleteMany?: AuctionHistoryScalarWhereInput | AuctionHistoryScalarWhereInput[]
  }

  export type AuctionConditionsCreategeographicRestrictionsInput = {
    set: string[]
  }

  export type AuctionConditionsCreateindustryRestrictionsInput = {
    set: string[]
  }

  export type CardAuctionCreateNestedOneWithoutConditionsInput = {
    create?: XOR<CardAuctionCreateWithoutConditionsInput, CardAuctionUncheckedCreateWithoutConditionsInput>
    connectOrCreate?: CardAuctionCreateOrConnectWithoutConditionsInput
    connect?: CardAuctionWhereUniqueInput
  }

  export type AuctionConditionsUpdategeographicRestrictionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AuctionConditionsUpdateindustryRestrictionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CardAuctionUpdateOneRequiredWithoutConditionsNestedInput = {
    create?: XOR<CardAuctionCreateWithoutConditionsInput, CardAuctionUncheckedCreateWithoutConditionsInput>
    connectOrCreate?: CardAuctionCreateOrConnectWithoutConditionsInput
    upsert?: CardAuctionUpsertWithoutConditionsInput
    connect?: CardAuctionWhereUniqueInput
    update?: XOR<XOR<CardAuctionUpdateToOneWithWhereWithoutConditionsInput, CardAuctionUpdateWithoutConditionsInput>, CardAuctionUncheckedUpdateWithoutConditionsInput>
  }

  export type CardAuctionCreateNestedOneWithoutBidsInput = {
    create?: XOR<CardAuctionCreateWithoutBidsInput, CardAuctionUncheckedCreateWithoutBidsInput>
    connectOrCreate?: CardAuctionCreateOrConnectWithoutBidsInput
    connect?: CardAuctionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPlacedAuctionBidsInput = {
    create?: XOR<UserCreateWithoutPlacedAuctionBidsInput, UserUncheckedCreateWithoutPlacedAuctionBidsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlacedAuctionBidsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumBidTypeFieldUpdateOperationsInput = {
    set?: $Enums.BidType
  }

  export type EnumAuctionBidStatusFieldUpdateOperationsInput = {
    set?: $Enums.AuctionBidStatus
  }

  export type CardAuctionUpdateOneRequiredWithoutBidsNestedInput = {
    create?: XOR<CardAuctionCreateWithoutBidsInput, CardAuctionUncheckedCreateWithoutBidsInput>
    connectOrCreate?: CardAuctionCreateOrConnectWithoutBidsInput
    upsert?: CardAuctionUpsertWithoutBidsInput
    connect?: CardAuctionWhereUniqueInput
    update?: XOR<XOR<CardAuctionUpdateToOneWithWhereWithoutBidsInput, CardAuctionUpdateWithoutBidsInput>, CardAuctionUncheckedUpdateWithoutBidsInput>
  }

  export type UserUpdateOneRequiredWithoutPlacedAuctionBidsNestedInput = {
    create?: XOR<UserCreateWithoutPlacedAuctionBidsInput, UserUncheckedCreateWithoutPlacedAuctionBidsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlacedAuctionBidsInput
    upsert?: UserUpsertWithoutPlacedAuctionBidsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPlacedAuctionBidsInput, UserUpdateWithoutPlacedAuctionBidsInput>, UserUncheckedUpdateWithoutPlacedAuctionBidsInput>
  }

  export type CardAuctionCreateNestedOneWithoutWatchersInput = {
    create?: XOR<CardAuctionCreateWithoutWatchersInput, CardAuctionUncheckedCreateWithoutWatchersInput>
    connectOrCreate?: CardAuctionCreateOrConnectWithoutWatchersInput
    connect?: CardAuctionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutWatchedAuctionsInput = {
    create?: XOR<UserCreateWithoutWatchedAuctionsInput, UserUncheckedCreateWithoutWatchedAuctionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWatchedAuctionsInput
    connect?: UserWhereUniqueInput
  }

  export type CardAuctionUpdateOneRequiredWithoutWatchersNestedInput = {
    create?: XOR<CardAuctionCreateWithoutWatchersInput, CardAuctionUncheckedCreateWithoutWatchersInput>
    connectOrCreate?: CardAuctionCreateOrConnectWithoutWatchersInput
    upsert?: CardAuctionUpsertWithoutWatchersInput
    connect?: CardAuctionWhereUniqueInput
    update?: XOR<XOR<CardAuctionUpdateToOneWithWhereWithoutWatchersInput, CardAuctionUpdateWithoutWatchersInput>, CardAuctionUncheckedUpdateWithoutWatchersInput>
  }

  export type UserUpdateOneRequiredWithoutWatchedAuctionsNestedInput = {
    create?: XOR<UserCreateWithoutWatchedAuctionsInput, UserUncheckedCreateWithoutWatchedAuctionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWatchedAuctionsInput
    upsert?: UserUpsertWithoutWatchedAuctionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWatchedAuctionsInput, UserUpdateWithoutWatchedAuctionsInput>, UserUncheckedUpdateWithoutWatchedAuctionsInput>
  }

  export type CardCreateNestedOneWithoutAuctionHistoryInput = {
    create?: XOR<CardCreateWithoutAuctionHistoryInput, CardUncheckedCreateWithoutAuctionHistoryInput>
    connectOrCreate?: CardCreateOrConnectWithoutAuctionHistoryInput
    connect?: CardWhereUniqueInput
  }

  export type CardAuctionCreateNestedOneWithoutHistoryInput = {
    create?: XOR<CardAuctionCreateWithoutHistoryInput, CardAuctionUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: CardAuctionCreateOrConnectWithoutHistoryInput
    connect?: CardAuctionWhereUniqueInput
  }

  export type EnumSaleTypeFieldUpdateOperationsInput = {
    set?: $Enums.SaleType
  }

  export type CardUpdateOneRequiredWithoutAuctionHistoryNestedInput = {
    create?: XOR<CardCreateWithoutAuctionHistoryInput, CardUncheckedCreateWithoutAuctionHistoryInput>
    connectOrCreate?: CardCreateOrConnectWithoutAuctionHistoryInput
    upsert?: CardUpsertWithoutAuctionHistoryInput
    connect?: CardWhereUniqueInput
    update?: XOR<XOR<CardUpdateToOneWithWhereWithoutAuctionHistoryInput, CardUpdateWithoutAuctionHistoryInput>, CardUncheckedUpdateWithoutAuctionHistoryInput>
  }

  export type CardAuctionUpdateOneWithoutHistoryNestedInput = {
    create?: XOR<CardAuctionCreateWithoutHistoryInput, CardAuctionUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: CardAuctionCreateOrConnectWithoutHistoryInput
    upsert?: CardAuctionUpsertWithoutHistoryInput
    disconnect?: CardAuctionWhereInput | boolean
    delete?: CardAuctionWhereInput | boolean
    connect?: CardAuctionWhereUniqueInput
    update?: XOR<XOR<CardAuctionUpdateToOneWithWhereWithoutHistoryInput, CardAuctionUpdateWithoutHistoryInput>, CardAuctionUncheckedUpdateWithoutHistoryInput>
  }

  export type CardCreateNestedOneWithoutInitiatedBattlesInput = {
    create?: XOR<CardCreateWithoutInitiatedBattlesInput, CardUncheckedCreateWithoutInitiatedBattlesInput>
    connectOrCreate?: CardCreateOrConnectWithoutInitiatedBattlesInput
    connect?: CardWhereUniqueInput
  }

  export type CardCreateNestedOneWithoutTargetedBattlesInput = {
    create?: XOR<CardCreateWithoutTargetedBattlesInput, CardUncheckedCreateWithoutTargetedBattlesInput>
    connectOrCreate?: CardCreateOrConnectWithoutTargetedBattlesInput
    connect?: CardWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInitiatedMABattlesInput = {
    create?: XOR<UserCreateWithoutInitiatedMABattlesInput, UserUncheckedCreateWithoutInitiatedMABattlesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInitiatedMABattlesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTargetedMABattlesInput = {
    create?: XOR<UserCreateWithoutTargetedMABattlesInput, UserUncheckedCreateWithoutTargetedMABattlesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTargetedMABattlesInput
    connect?: UserWhereUniqueInput
  }

  export type BattleOutcomeCreateNestedOneWithoutWinningBattleInput = {
    create?: XOR<BattleOutcomeCreateWithoutWinningBattleInput, BattleOutcomeUncheckedCreateWithoutWinningBattleInput>
    connectOrCreate?: BattleOutcomeCreateOrConnectWithoutWinningBattleInput
    connect?: BattleOutcomeWhereUniqueInput
  }

  export type BattleProposalCreateNestedManyWithoutBattleInput = {
    create?: XOR<BattleProposalCreateWithoutBattleInput, BattleProposalUncheckedCreateWithoutBattleInput> | BattleProposalCreateWithoutBattleInput[] | BattleProposalUncheckedCreateWithoutBattleInput[]
    connectOrCreate?: BattleProposalCreateOrConnectWithoutBattleInput | BattleProposalCreateOrConnectWithoutBattleInput[]
    createMany?: BattleProposalCreateManyBattleInputEnvelope
    connect?: BattleProposalWhereUniqueInput | BattleProposalWhereUniqueInput[]
  }

  export type BattleVotingCreateNestedManyWithoutBattleInput = {
    create?: XOR<BattleVotingCreateWithoutBattleInput, BattleVotingUncheckedCreateWithoutBattleInput> | BattleVotingCreateWithoutBattleInput[] | BattleVotingUncheckedCreateWithoutBattleInput[]
    connectOrCreate?: BattleVotingCreateOrConnectWithoutBattleInput | BattleVotingCreateOrConnectWithoutBattleInput[]
    createMany?: BattleVotingCreateManyBattleInputEnvelope
    connect?: BattleVotingWhereUniqueInput | BattleVotingWhereUniqueInput[]
  }

  export type BattleOutcomeCreateNestedManyWithoutBattleInput = {
    create?: XOR<BattleOutcomeCreateWithoutBattleInput, BattleOutcomeUncheckedCreateWithoutBattleInput> | BattleOutcomeCreateWithoutBattleInput[] | BattleOutcomeUncheckedCreateWithoutBattleInput[]
    connectOrCreate?: BattleOutcomeCreateOrConnectWithoutBattleInput | BattleOutcomeCreateOrConnectWithoutBattleInput[]
    createMany?: BattleOutcomeCreateManyBattleInputEnvelope
    connect?: BattleOutcomeWhereUniqueInput | BattleOutcomeWhereUniqueInput[]
  }

  export type BattleOutcomeUncheckedCreateNestedOneWithoutWinningBattleInput = {
    create?: XOR<BattleOutcomeCreateWithoutWinningBattleInput, BattleOutcomeUncheckedCreateWithoutWinningBattleInput>
    connectOrCreate?: BattleOutcomeCreateOrConnectWithoutWinningBattleInput
    connect?: BattleOutcomeWhereUniqueInput
  }

  export type BattleProposalUncheckedCreateNestedManyWithoutBattleInput = {
    create?: XOR<BattleProposalCreateWithoutBattleInput, BattleProposalUncheckedCreateWithoutBattleInput> | BattleProposalCreateWithoutBattleInput[] | BattleProposalUncheckedCreateWithoutBattleInput[]
    connectOrCreate?: BattleProposalCreateOrConnectWithoutBattleInput | BattleProposalCreateOrConnectWithoutBattleInput[]
    createMany?: BattleProposalCreateManyBattleInputEnvelope
    connect?: BattleProposalWhereUniqueInput | BattleProposalWhereUniqueInput[]
  }

  export type BattleVotingUncheckedCreateNestedManyWithoutBattleInput = {
    create?: XOR<BattleVotingCreateWithoutBattleInput, BattleVotingUncheckedCreateWithoutBattleInput> | BattleVotingCreateWithoutBattleInput[] | BattleVotingUncheckedCreateWithoutBattleInput[]
    connectOrCreate?: BattleVotingCreateOrConnectWithoutBattleInput | BattleVotingCreateOrConnectWithoutBattleInput[]
    createMany?: BattleVotingCreateManyBattleInputEnvelope
    connect?: BattleVotingWhereUniqueInput | BattleVotingWhereUniqueInput[]
  }

  export type BattleOutcomeUncheckedCreateNestedManyWithoutBattleInput = {
    create?: XOR<BattleOutcomeCreateWithoutBattleInput, BattleOutcomeUncheckedCreateWithoutBattleInput> | BattleOutcomeCreateWithoutBattleInput[] | BattleOutcomeUncheckedCreateWithoutBattleInput[]
    connectOrCreate?: BattleOutcomeCreateOrConnectWithoutBattleInput | BattleOutcomeCreateOrConnectWithoutBattleInput[]
    createMany?: BattleOutcomeCreateManyBattleInputEnvelope
    connect?: BattleOutcomeWhereUniqueInput | BattleOutcomeWhereUniqueInput[]
  }

  export type EnumBattleTypeFieldUpdateOperationsInput = {
    set?: $Enums.BattleType
  }

  export type EnumBattleStatusFieldUpdateOperationsInput = {
    set?: $Enums.BattleStatus
  }

  export type CardUpdateOneRequiredWithoutInitiatedBattlesNestedInput = {
    create?: XOR<CardCreateWithoutInitiatedBattlesInput, CardUncheckedCreateWithoutInitiatedBattlesInput>
    connectOrCreate?: CardCreateOrConnectWithoutInitiatedBattlesInput
    upsert?: CardUpsertWithoutInitiatedBattlesInput
    connect?: CardWhereUniqueInput
    update?: XOR<XOR<CardUpdateToOneWithWhereWithoutInitiatedBattlesInput, CardUpdateWithoutInitiatedBattlesInput>, CardUncheckedUpdateWithoutInitiatedBattlesInput>
  }

  export type CardUpdateOneRequiredWithoutTargetedBattlesNestedInput = {
    create?: XOR<CardCreateWithoutTargetedBattlesInput, CardUncheckedCreateWithoutTargetedBattlesInput>
    connectOrCreate?: CardCreateOrConnectWithoutTargetedBattlesInput
    upsert?: CardUpsertWithoutTargetedBattlesInput
    connect?: CardWhereUniqueInput
    update?: XOR<XOR<CardUpdateToOneWithWhereWithoutTargetedBattlesInput, CardUpdateWithoutTargetedBattlesInput>, CardUncheckedUpdateWithoutTargetedBattlesInput>
  }

  export type UserUpdateOneRequiredWithoutInitiatedMABattlesNestedInput = {
    create?: XOR<UserCreateWithoutInitiatedMABattlesInput, UserUncheckedCreateWithoutInitiatedMABattlesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInitiatedMABattlesInput
    upsert?: UserUpsertWithoutInitiatedMABattlesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInitiatedMABattlesInput, UserUpdateWithoutInitiatedMABattlesInput>, UserUncheckedUpdateWithoutInitiatedMABattlesInput>
  }

  export type UserUpdateOneWithoutTargetedMABattlesNestedInput = {
    create?: XOR<UserCreateWithoutTargetedMABattlesInput, UserUncheckedCreateWithoutTargetedMABattlesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTargetedMABattlesInput
    upsert?: UserUpsertWithoutTargetedMABattlesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTargetedMABattlesInput, UserUpdateWithoutTargetedMABattlesInput>, UserUncheckedUpdateWithoutTargetedMABattlesInput>
  }

  export type BattleOutcomeUpdateOneWithoutWinningBattleNestedInput = {
    create?: XOR<BattleOutcomeCreateWithoutWinningBattleInput, BattleOutcomeUncheckedCreateWithoutWinningBattleInput>
    connectOrCreate?: BattleOutcomeCreateOrConnectWithoutWinningBattleInput
    upsert?: BattleOutcomeUpsertWithoutWinningBattleInput
    disconnect?: BattleOutcomeWhereInput | boolean
    delete?: BattleOutcomeWhereInput | boolean
    connect?: BattleOutcomeWhereUniqueInput
    update?: XOR<XOR<BattleOutcomeUpdateToOneWithWhereWithoutWinningBattleInput, BattleOutcomeUpdateWithoutWinningBattleInput>, BattleOutcomeUncheckedUpdateWithoutWinningBattleInput>
  }

  export type BattleProposalUpdateManyWithoutBattleNestedInput = {
    create?: XOR<BattleProposalCreateWithoutBattleInput, BattleProposalUncheckedCreateWithoutBattleInput> | BattleProposalCreateWithoutBattleInput[] | BattleProposalUncheckedCreateWithoutBattleInput[]
    connectOrCreate?: BattleProposalCreateOrConnectWithoutBattleInput | BattleProposalCreateOrConnectWithoutBattleInput[]
    upsert?: BattleProposalUpsertWithWhereUniqueWithoutBattleInput | BattleProposalUpsertWithWhereUniqueWithoutBattleInput[]
    createMany?: BattleProposalCreateManyBattleInputEnvelope
    set?: BattleProposalWhereUniqueInput | BattleProposalWhereUniqueInput[]
    disconnect?: BattleProposalWhereUniqueInput | BattleProposalWhereUniqueInput[]
    delete?: BattleProposalWhereUniqueInput | BattleProposalWhereUniqueInput[]
    connect?: BattleProposalWhereUniqueInput | BattleProposalWhereUniqueInput[]
    update?: BattleProposalUpdateWithWhereUniqueWithoutBattleInput | BattleProposalUpdateWithWhereUniqueWithoutBattleInput[]
    updateMany?: BattleProposalUpdateManyWithWhereWithoutBattleInput | BattleProposalUpdateManyWithWhereWithoutBattleInput[]
    deleteMany?: BattleProposalScalarWhereInput | BattleProposalScalarWhereInput[]
  }

  export type BattleVotingUpdateManyWithoutBattleNestedInput = {
    create?: XOR<BattleVotingCreateWithoutBattleInput, BattleVotingUncheckedCreateWithoutBattleInput> | BattleVotingCreateWithoutBattleInput[] | BattleVotingUncheckedCreateWithoutBattleInput[]
    connectOrCreate?: BattleVotingCreateOrConnectWithoutBattleInput | BattleVotingCreateOrConnectWithoutBattleInput[]
    upsert?: BattleVotingUpsertWithWhereUniqueWithoutBattleInput | BattleVotingUpsertWithWhereUniqueWithoutBattleInput[]
    createMany?: BattleVotingCreateManyBattleInputEnvelope
    set?: BattleVotingWhereUniqueInput | BattleVotingWhereUniqueInput[]
    disconnect?: BattleVotingWhereUniqueInput | BattleVotingWhereUniqueInput[]
    delete?: BattleVotingWhereUniqueInput | BattleVotingWhereUniqueInput[]
    connect?: BattleVotingWhereUniqueInput | BattleVotingWhereUniqueInput[]
    update?: BattleVotingUpdateWithWhereUniqueWithoutBattleInput | BattleVotingUpdateWithWhereUniqueWithoutBattleInput[]
    updateMany?: BattleVotingUpdateManyWithWhereWithoutBattleInput | BattleVotingUpdateManyWithWhereWithoutBattleInput[]
    deleteMany?: BattleVotingScalarWhereInput | BattleVotingScalarWhereInput[]
  }

  export type BattleOutcomeUpdateManyWithoutBattleNestedInput = {
    create?: XOR<BattleOutcomeCreateWithoutBattleInput, BattleOutcomeUncheckedCreateWithoutBattleInput> | BattleOutcomeCreateWithoutBattleInput[] | BattleOutcomeUncheckedCreateWithoutBattleInput[]
    connectOrCreate?: BattleOutcomeCreateOrConnectWithoutBattleInput | BattleOutcomeCreateOrConnectWithoutBattleInput[]
    upsert?: BattleOutcomeUpsertWithWhereUniqueWithoutBattleInput | BattleOutcomeUpsertWithWhereUniqueWithoutBattleInput[]
    createMany?: BattleOutcomeCreateManyBattleInputEnvelope
    set?: BattleOutcomeWhereUniqueInput | BattleOutcomeWhereUniqueInput[]
    disconnect?: BattleOutcomeWhereUniqueInput | BattleOutcomeWhereUniqueInput[]
    delete?: BattleOutcomeWhereUniqueInput | BattleOutcomeWhereUniqueInput[]
    connect?: BattleOutcomeWhereUniqueInput | BattleOutcomeWhereUniqueInput[]
    update?: BattleOutcomeUpdateWithWhereUniqueWithoutBattleInput | BattleOutcomeUpdateWithWhereUniqueWithoutBattleInput[]
    updateMany?: BattleOutcomeUpdateManyWithWhereWithoutBattleInput | BattleOutcomeUpdateManyWithWhereWithoutBattleInput[]
    deleteMany?: BattleOutcomeScalarWhereInput | BattleOutcomeScalarWhereInput[]
  }

  export type BattleOutcomeUncheckedUpdateOneWithoutWinningBattleNestedInput = {
    create?: XOR<BattleOutcomeCreateWithoutWinningBattleInput, BattleOutcomeUncheckedCreateWithoutWinningBattleInput>
    connectOrCreate?: BattleOutcomeCreateOrConnectWithoutWinningBattleInput
    upsert?: BattleOutcomeUpsertWithoutWinningBattleInput
    disconnect?: BattleOutcomeWhereInput | boolean
    delete?: BattleOutcomeWhereInput | boolean
    connect?: BattleOutcomeWhereUniqueInput
    update?: XOR<XOR<BattleOutcomeUpdateToOneWithWhereWithoutWinningBattleInput, BattleOutcomeUpdateWithoutWinningBattleInput>, BattleOutcomeUncheckedUpdateWithoutWinningBattleInput>
  }

  export type BattleProposalUncheckedUpdateManyWithoutBattleNestedInput = {
    create?: XOR<BattleProposalCreateWithoutBattleInput, BattleProposalUncheckedCreateWithoutBattleInput> | BattleProposalCreateWithoutBattleInput[] | BattleProposalUncheckedCreateWithoutBattleInput[]
    connectOrCreate?: BattleProposalCreateOrConnectWithoutBattleInput | BattleProposalCreateOrConnectWithoutBattleInput[]
    upsert?: BattleProposalUpsertWithWhereUniqueWithoutBattleInput | BattleProposalUpsertWithWhereUniqueWithoutBattleInput[]
    createMany?: BattleProposalCreateManyBattleInputEnvelope
    set?: BattleProposalWhereUniqueInput | BattleProposalWhereUniqueInput[]
    disconnect?: BattleProposalWhereUniqueInput | BattleProposalWhereUniqueInput[]
    delete?: BattleProposalWhereUniqueInput | BattleProposalWhereUniqueInput[]
    connect?: BattleProposalWhereUniqueInput | BattleProposalWhereUniqueInput[]
    update?: BattleProposalUpdateWithWhereUniqueWithoutBattleInput | BattleProposalUpdateWithWhereUniqueWithoutBattleInput[]
    updateMany?: BattleProposalUpdateManyWithWhereWithoutBattleInput | BattleProposalUpdateManyWithWhereWithoutBattleInput[]
    deleteMany?: BattleProposalScalarWhereInput | BattleProposalScalarWhereInput[]
  }

  export type BattleVotingUncheckedUpdateManyWithoutBattleNestedInput = {
    create?: XOR<BattleVotingCreateWithoutBattleInput, BattleVotingUncheckedCreateWithoutBattleInput> | BattleVotingCreateWithoutBattleInput[] | BattleVotingUncheckedCreateWithoutBattleInput[]
    connectOrCreate?: BattleVotingCreateOrConnectWithoutBattleInput | BattleVotingCreateOrConnectWithoutBattleInput[]
    upsert?: BattleVotingUpsertWithWhereUniqueWithoutBattleInput | BattleVotingUpsertWithWhereUniqueWithoutBattleInput[]
    createMany?: BattleVotingCreateManyBattleInputEnvelope
    set?: BattleVotingWhereUniqueInput | BattleVotingWhereUniqueInput[]
    disconnect?: BattleVotingWhereUniqueInput | BattleVotingWhereUniqueInput[]
    delete?: BattleVotingWhereUniqueInput | BattleVotingWhereUniqueInput[]
    connect?: BattleVotingWhereUniqueInput | BattleVotingWhereUniqueInput[]
    update?: BattleVotingUpdateWithWhereUniqueWithoutBattleInput | BattleVotingUpdateWithWhereUniqueWithoutBattleInput[]
    updateMany?: BattleVotingUpdateManyWithWhereWithoutBattleInput | BattleVotingUpdateManyWithWhereWithoutBattleInput[]
    deleteMany?: BattleVotingScalarWhereInput | BattleVotingScalarWhereInput[]
  }

  export type BattleOutcomeUncheckedUpdateManyWithoutBattleNestedInput = {
    create?: XOR<BattleOutcomeCreateWithoutBattleInput, BattleOutcomeUncheckedCreateWithoutBattleInput> | BattleOutcomeCreateWithoutBattleInput[] | BattleOutcomeUncheckedCreateWithoutBattleInput[]
    connectOrCreate?: BattleOutcomeCreateOrConnectWithoutBattleInput | BattleOutcomeCreateOrConnectWithoutBattleInput[]
    upsert?: BattleOutcomeUpsertWithWhereUniqueWithoutBattleInput | BattleOutcomeUpsertWithWhereUniqueWithoutBattleInput[]
    createMany?: BattleOutcomeCreateManyBattleInputEnvelope
    set?: BattleOutcomeWhereUniqueInput | BattleOutcomeWhereUniqueInput[]
    disconnect?: BattleOutcomeWhereUniqueInput | BattleOutcomeWhereUniqueInput[]
    delete?: BattleOutcomeWhereUniqueInput | BattleOutcomeWhereUniqueInput[]
    connect?: BattleOutcomeWhereUniqueInput | BattleOutcomeWhereUniqueInput[]
    update?: BattleOutcomeUpdateWithWhereUniqueWithoutBattleInput | BattleOutcomeUpdateWithWhereUniqueWithoutBattleInput[]
    updateMany?: BattleOutcomeUpdateManyWithWhereWithoutBattleInput | BattleOutcomeUpdateManyWithWhereWithoutBattleInput[]
    deleteMany?: BattleOutcomeScalarWhereInput | BattleOutcomeScalarWhereInput[]
  }

  export type MABattleCreateNestedOneWithoutProposalsInput = {
    create?: XOR<MABattleCreateWithoutProposalsInput, MABattleUncheckedCreateWithoutProposalsInput>
    connectOrCreate?: MABattleCreateOrConnectWithoutProposalsInput
    connect?: MABattleWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBattleProposalsInput = {
    create?: XOR<UserCreateWithoutBattleProposalsInput, UserUncheckedCreateWithoutBattleProposalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBattleProposalsInput
    connect?: UserWhereUniqueInput
  }

  export type BattleVotingCreateNestedManyWithoutProposalInput = {
    create?: XOR<BattleVotingCreateWithoutProposalInput, BattleVotingUncheckedCreateWithoutProposalInput> | BattleVotingCreateWithoutProposalInput[] | BattleVotingUncheckedCreateWithoutProposalInput[]
    connectOrCreate?: BattleVotingCreateOrConnectWithoutProposalInput | BattleVotingCreateOrConnectWithoutProposalInput[]
    createMany?: BattleVotingCreateManyProposalInputEnvelope
    connect?: BattleVotingWhereUniqueInput | BattleVotingWhereUniqueInput[]
  }

  export type BattleVotingUncheckedCreateNestedManyWithoutProposalInput = {
    create?: XOR<BattleVotingCreateWithoutProposalInput, BattleVotingUncheckedCreateWithoutProposalInput> | BattleVotingCreateWithoutProposalInput[] | BattleVotingUncheckedCreateWithoutProposalInput[]
    connectOrCreate?: BattleVotingCreateOrConnectWithoutProposalInput | BattleVotingCreateOrConnectWithoutProposalInput[]
    createMany?: BattleVotingCreateManyProposalInputEnvelope
    connect?: BattleVotingWhereUniqueInput | BattleVotingWhereUniqueInput[]
  }

  export type EnumProposalTypeFieldUpdateOperationsInput = {
    set?: $Enums.ProposalType
  }

  export type EnumProposalStatusFieldUpdateOperationsInput = {
    set?: $Enums.ProposalStatus
  }

  export type MABattleUpdateOneRequiredWithoutProposalsNestedInput = {
    create?: XOR<MABattleCreateWithoutProposalsInput, MABattleUncheckedCreateWithoutProposalsInput>
    connectOrCreate?: MABattleCreateOrConnectWithoutProposalsInput
    upsert?: MABattleUpsertWithoutProposalsInput
    connect?: MABattleWhereUniqueInput
    update?: XOR<XOR<MABattleUpdateToOneWithWhereWithoutProposalsInput, MABattleUpdateWithoutProposalsInput>, MABattleUncheckedUpdateWithoutProposalsInput>
  }

  export type UserUpdateOneRequiredWithoutBattleProposalsNestedInput = {
    create?: XOR<UserCreateWithoutBattleProposalsInput, UserUncheckedCreateWithoutBattleProposalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBattleProposalsInput
    upsert?: UserUpsertWithoutBattleProposalsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBattleProposalsInput, UserUpdateWithoutBattleProposalsInput>, UserUncheckedUpdateWithoutBattleProposalsInput>
  }

  export type BattleVotingUpdateManyWithoutProposalNestedInput = {
    create?: XOR<BattleVotingCreateWithoutProposalInput, BattleVotingUncheckedCreateWithoutProposalInput> | BattleVotingCreateWithoutProposalInput[] | BattleVotingUncheckedCreateWithoutProposalInput[]
    connectOrCreate?: BattleVotingCreateOrConnectWithoutProposalInput | BattleVotingCreateOrConnectWithoutProposalInput[]
    upsert?: BattleVotingUpsertWithWhereUniqueWithoutProposalInput | BattleVotingUpsertWithWhereUniqueWithoutProposalInput[]
    createMany?: BattleVotingCreateManyProposalInputEnvelope
    set?: BattleVotingWhereUniqueInput | BattleVotingWhereUniqueInput[]
    disconnect?: BattleVotingWhereUniqueInput | BattleVotingWhereUniqueInput[]
    delete?: BattleVotingWhereUniqueInput | BattleVotingWhereUniqueInput[]
    connect?: BattleVotingWhereUniqueInput | BattleVotingWhereUniqueInput[]
    update?: BattleVotingUpdateWithWhereUniqueWithoutProposalInput | BattleVotingUpdateWithWhereUniqueWithoutProposalInput[]
    updateMany?: BattleVotingUpdateManyWithWhereWithoutProposalInput | BattleVotingUpdateManyWithWhereWithoutProposalInput[]
    deleteMany?: BattleVotingScalarWhereInput | BattleVotingScalarWhereInput[]
  }

  export type BattleVotingUncheckedUpdateManyWithoutProposalNestedInput = {
    create?: XOR<BattleVotingCreateWithoutProposalInput, BattleVotingUncheckedCreateWithoutProposalInput> | BattleVotingCreateWithoutProposalInput[] | BattleVotingUncheckedCreateWithoutProposalInput[]
    connectOrCreate?: BattleVotingCreateOrConnectWithoutProposalInput | BattleVotingCreateOrConnectWithoutProposalInput[]
    upsert?: BattleVotingUpsertWithWhereUniqueWithoutProposalInput | BattleVotingUpsertWithWhereUniqueWithoutProposalInput[]
    createMany?: BattleVotingCreateManyProposalInputEnvelope
    set?: BattleVotingWhereUniqueInput | BattleVotingWhereUniqueInput[]
    disconnect?: BattleVotingWhereUniqueInput | BattleVotingWhereUniqueInput[]
    delete?: BattleVotingWhereUniqueInput | BattleVotingWhereUniqueInput[]
    connect?: BattleVotingWhereUniqueInput | BattleVotingWhereUniqueInput[]
    update?: BattleVotingUpdateWithWhereUniqueWithoutProposalInput | BattleVotingUpdateWithWhereUniqueWithoutProposalInput[]
    updateMany?: BattleVotingUpdateManyWithWhereWithoutProposalInput | BattleVotingUpdateManyWithWhereWithoutProposalInput[]
    deleteMany?: BattleVotingScalarWhereInput | BattleVotingScalarWhereInput[]
  }

  export type MABattleCreateNestedOneWithoutVotesInput = {
    create?: XOR<MABattleCreateWithoutVotesInput, MABattleUncheckedCreateWithoutVotesInput>
    connectOrCreate?: MABattleCreateOrConnectWithoutVotesInput
    connect?: MABattleWhereUniqueInput
  }

  export type BattleProposalCreateNestedOneWithoutVotesInput = {
    create?: XOR<BattleProposalCreateWithoutVotesInput, BattleProposalUncheckedCreateWithoutVotesInput>
    connectOrCreate?: BattleProposalCreateOrConnectWithoutVotesInput
    connect?: BattleProposalWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBattleVotesInput = {
    create?: XOR<UserCreateWithoutBattleVotesInput, UserUncheckedCreateWithoutBattleVotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutBattleVotesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumVoteDirectionFieldUpdateOperationsInput = {
    set?: $Enums.VoteDirection
  }

  export type MABattleUpdateOneRequiredWithoutVotesNestedInput = {
    create?: XOR<MABattleCreateWithoutVotesInput, MABattleUncheckedCreateWithoutVotesInput>
    connectOrCreate?: MABattleCreateOrConnectWithoutVotesInput
    upsert?: MABattleUpsertWithoutVotesInput
    connect?: MABattleWhereUniqueInput
    update?: XOR<XOR<MABattleUpdateToOneWithWhereWithoutVotesInput, MABattleUpdateWithoutVotesInput>, MABattleUncheckedUpdateWithoutVotesInput>
  }

  export type BattleProposalUpdateOneWithoutVotesNestedInput = {
    create?: XOR<BattleProposalCreateWithoutVotesInput, BattleProposalUncheckedCreateWithoutVotesInput>
    connectOrCreate?: BattleProposalCreateOrConnectWithoutVotesInput
    upsert?: BattleProposalUpsertWithoutVotesInput
    disconnect?: BattleProposalWhereInput | boolean
    delete?: BattleProposalWhereInput | boolean
    connect?: BattleProposalWhereUniqueInput
    update?: XOR<XOR<BattleProposalUpdateToOneWithWhereWithoutVotesInput, BattleProposalUpdateWithoutVotesInput>, BattleProposalUncheckedUpdateWithoutVotesInput>
  }

  export type UserUpdateOneRequiredWithoutBattleVotesNestedInput = {
    create?: XOR<UserCreateWithoutBattleVotesInput, UserUncheckedCreateWithoutBattleVotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutBattleVotesInput
    upsert?: UserUpsertWithoutBattleVotesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBattleVotesInput, UserUpdateWithoutBattleVotesInput>, UserUncheckedUpdateWithoutBattleVotesInput>
  }

  export type MABattleCreateNestedOneWithoutOutcomesInput = {
    create?: XOR<MABattleCreateWithoutOutcomesInput, MABattleUncheckedCreateWithoutOutcomesInput>
    connectOrCreate?: MABattleCreateOrConnectWithoutOutcomesInput
    connect?: MABattleWhereUniqueInput
  }

  export type MABattleCreateNestedOneWithoutWinnerInput = {
    create?: XOR<MABattleCreateWithoutWinnerInput, MABattleUncheckedCreateWithoutWinnerInput>
    connectOrCreate?: MABattleCreateOrConnectWithoutWinnerInput
    connect?: MABattleWhereUniqueInput
  }

  export type EnumBattleWinnerFieldUpdateOperationsInput = {
    set?: $Enums.BattleWinner
  }

  export type MABattleUpdateOneRequiredWithoutOutcomesNestedInput = {
    create?: XOR<MABattleCreateWithoutOutcomesInput, MABattleUncheckedCreateWithoutOutcomesInput>
    connectOrCreate?: MABattleCreateOrConnectWithoutOutcomesInput
    upsert?: MABattleUpsertWithoutOutcomesInput
    connect?: MABattleWhereUniqueInput
    update?: XOR<XOR<MABattleUpdateToOneWithWhereWithoutOutcomesInput, MABattleUpdateWithoutOutcomesInput>, MABattleUncheckedUpdateWithoutOutcomesInput>
  }

  export type MABattleUpdateOneWithoutWinnerNestedInput = {
    create?: XOR<MABattleCreateWithoutWinnerInput, MABattleUncheckedCreateWithoutWinnerInput>
    connectOrCreate?: MABattleCreateOrConnectWithoutWinnerInput
    upsert?: MABattleUpsertWithoutWinnerInput
    disconnect?: MABattleWhereInput | boolean
    delete?: MABattleWhereInput | boolean
    connect?: MABattleWhereUniqueInput
    update?: XOR<XOR<MABattleUpdateToOneWithWhereWithoutWinnerInput, MABattleUpdateWithoutWinnerInput>, MABattleUncheckedUpdateWithoutWinnerInput>
  }

  export type StakingPositionCreateNestedManyWithoutPoolInput = {
    create?: XOR<StakingPositionCreateWithoutPoolInput, StakingPositionUncheckedCreateWithoutPoolInput> | StakingPositionCreateWithoutPoolInput[] | StakingPositionUncheckedCreateWithoutPoolInput[]
    connectOrCreate?: StakingPositionCreateOrConnectWithoutPoolInput | StakingPositionCreateOrConnectWithoutPoolInput[]
    createMany?: StakingPositionCreateManyPoolInputEnvelope
    connect?: StakingPositionWhereUniqueInput | StakingPositionWhereUniqueInput[]
  }

  export type StakingRewardCreateNestedManyWithoutPoolInput = {
    create?: XOR<StakingRewardCreateWithoutPoolInput, StakingRewardUncheckedCreateWithoutPoolInput> | StakingRewardCreateWithoutPoolInput[] | StakingRewardUncheckedCreateWithoutPoolInput[]
    connectOrCreate?: StakingRewardCreateOrConnectWithoutPoolInput | StakingRewardCreateOrConnectWithoutPoolInput[]
    createMany?: StakingRewardCreateManyPoolInputEnvelope
    connect?: StakingRewardWhereUniqueInput | StakingRewardWhereUniqueInput[]
  }

  export type StakingPositionUncheckedCreateNestedManyWithoutPoolInput = {
    create?: XOR<StakingPositionCreateWithoutPoolInput, StakingPositionUncheckedCreateWithoutPoolInput> | StakingPositionCreateWithoutPoolInput[] | StakingPositionUncheckedCreateWithoutPoolInput[]
    connectOrCreate?: StakingPositionCreateOrConnectWithoutPoolInput | StakingPositionCreateOrConnectWithoutPoolInput[]
    createMany?: StakingPositionCreateManyPoolInputEnvelope
    connect?: StakingPositionWhereUniqueInput | StakingPositionWhereUniqueInput[]
  }

  export type StakingRewardUncheckedCreateNestedManyWithoutPoolInput = {
    create?: XOR<StakingRewardCreateWithoutPoolInput, StakingRewardUncheckedCreateWithoutPoolInput> | StakingRewardCreateWithoutPoolInput[] | StakingRewardUncheckedCreateWithoutPoolInput[]
    connectOrCreate?: StakingRewardCreateOrConnectWithoutPoolInput | StakingRewardCreateOrConnectWithoutPoolInput[]
    createMany?: StakingRewardCreateManyPoolInputEnvelope
    connect?: StakingRewardWhereUniqueInput | StakingRewardWhereUniqueInput[]
  }

  export type EnumStakingPoolTypeFieldUpdateOperationsInput = {
    set?: $Enums.StakingPoolType
  }

  export type StakingPositionUpdateManyWithoutPoolNestedInput = {
    create?: XOR<StakingPositionCreateWithoutPoolInput, StakingPositionUncheckedCreateWithoutPoolInput> | StakingPositionCreateWithoutPoolInput[] | StakingPositionUncheckedCreateWithoutPoolInput[]
    connectOrCreate?: StakingPositionCreateOrConnectWithoutPoolInput | StakingPositionCreateOrConnectWithoutPoolInput[]
    upsert?: StakingPositionUpsertWithWhereUniqueWithoutPoolInput | StakingPositionUpsertWithWhereUniqueWithoutPoolInput[]
    createMany?: StakingPositionCreateManyPoolInputEnvelope
    set?: StakingPositionWhereUniqueInput | StakingPositionWhereUniqueInput[]
    disconnect?: StakingPositionWhereUniqueInput | StakingPositionWhereUniqueInput[]
    delete?: StakingPositionWhereUniqueInput | StakingPositionWhereUniqueInput[]
    connect?: StakingPositionWhereUniqueInput | StakingPositionWhereUniqueInput[]
    update?: StakingPositionUpdateWithWhereUniqueWithoutPoolInput | StakingPositionUpdateWithWhereUniqueWithoutPoolInput[]
    updateMany?: StakingPositionUpdateManyWithWhereWithoutPoolInput | StakingPositionUpdateManyWithWhereWithoutPoolInput[]
    deleteMany?: StakingPositionScalarWhereInput | StakingPositionScalarWhereInput[]
  }

  export type StakingRewardUpdateManyWithoutPoolNestedInput = {
    create?: XOR<StakingRewardCreateWithoutPoolInput, StakingRewardUncheckedCreateWithoutPoolInput> | StakingRewardCreateWithoutPoolInput[] | StakingRewardUncheckedCreateWithoutPoolInput[]
    connectOrCreate?: StakingRewardCreateOrConnectWithoutPoolInput | StakingRewardCreateOrConnectWithoutPoolInput[]
    upsert?: StakingRewardUpsertWithWhereUniqueWithoutPoolInput | StakingRewardUpsertWithWhereUniqueWithoutPoolInput[]
    createMany?: StakingRewardCreateManyPoolInputEnvelope
    set?: StakingRewardWhereUniqueInput | StakingRewardWhereUniqueInput[]
    disconnect?: StakingRewardWhereUniqueInput | StakingRewardWhereUniqueInput[]
    delete?: StakingRewardWhereUniqueInput | StakingRewardWhereUniqueInput[]
    connect?: StakingRewardWhereUniqueInput | StakingRewardWhereUniqueInput[]
    update?: StakingRewardUpdateWithWhereUniqueWithoutPoolInput | StakingRewardUpdateWithWhereUniqueWithoutPoolInput[]
    updateMany?: StakingRewardUpdateManyWithWhereWithoutPoolInput | StakingRewardUpdateManyWithWhereWithoutPoolInput[]
    deleteMany?: StakingRewardScalarWhereInput | StakingRewardScalarWhereInput[]
  }

  export type StakingPositionUncheckedUpdateManyWithoutPoolNestedInput = {
    create?: XOR<StakingPositionCreateWithoutPoolInput, StakingPositionUncheckedCreateWithoutPoolInput> | StakingPositionCreateWithoutPoolInput[] | StakingPositionUncheckedCreateWithoutPoolInput[]
    connectOrCreate?: StakingPositionCreateOrConnectWithoutPoolInput | StakingPositionCreateOrConnectWithoutPoolInput[]
    upsert?: StakingPositionUpsertWithWhereUniqueWithoutPoolInput | StakingPositionUpsertWithWhereUniqueWithoutPoolInput[]
    createMany?: StakingPositionCreateManyPoolInputEnvelope
    set?: StakingPositionWhereUniqueInput | StakingPositionWhereUniqueInput[]
    disconnect?: StakingPositionWhereUniqueInput | StakingPositionWhereUniqueInput[]
    delete?: StakingPositionWhereUniqueInput | StakingPositionWhereUniqueInput[]
    connect?: StakingPositionWhereUniqueInput | StakingPositionWhereUniqueInput[]
    update?: StakingPositionUpdateWithWhereUniqueWithoutPoolInput | StakingPositionUpdateWithWhereUniqueWithoutPoolInput[]
    updateMany?: StakingPositionUpdateManyWithWhereWithoutPoolInput | StakingPositionUpdateManyWithWhereWithoutPoolInput[]
    deleteMany?: StakingPositionScalarWhereInput | StakingPositionScalarWhereInput[]
  }

  export type StakingRewardUncheckedUpdateManyWithoutPoolNestedInput = {
    create?: XOR<StakingRewardCreateWithoutPoolInput, StakingRewardUncheckedCreateWithoutPoolInput> | StakingRewardCreateWithoutPoolInput[] | StakingRewardUncheckedCreateWithoutPoolInput[]
    connectOrCreate?: StakingRewardCreateOrConnectWithoutPoolInput | StakingRewardCreateOrConnectWithoutPoolInput[]
    upsert?: StakingRewardUpsertWithWhereUniqueWithoutPoolInput | StakingRewardUpsertWithWhereUniqueWithoutPoolInput[]
    createMany?: StakingRewardCreateManyPoolInputEnvelope
    set?: StakingRewardWhereUniqueInput | StakingRewardWhereUniqueInput[]
    disconnect?: StakingRewardWhereUniqueInput | StakingRewardWhereUniqueInput[]
    delete?: StakingRewardWhereUniqueInput | StakingRewardWhereUniqueInput[]
    connect?: StakingRewardWhereUniqueInput | StakingRewardWhereUniqueInput[]
    update?: StakingRewardUpdateWithWhereUniqueWithoutPoolInput | StakingRewardUpdateWithWhereUniqueWithoutPoolInput[]
    updateMany?: StakingRewardUpdateManyWithWhereWithoutPoolInput | StakingRewardUpdateManyWithWhereWithoutPoolInput[]
    deleteMany?: StakingRewardScalarWhereInput | StakingRewardScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutStakingPositionsInput = {
    create?: XOR<UserCreateWithoutStakingPositionsInput, UserUncheckedCreateWithoutStakingPositionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStakingPositionsInput
    connect?: UserWhereUniqueInput
  }

  export type StakingPoolCreateNestedOneWithoutStakesInput = {
    create?: XOR<StakingPoolCreateWithoutStakesInput, StakingPoolUncheckedCreateWithoutStakesInput>
    connectOrCreate?: StakingPoolCreateOrConnectWithoutStakesInput
    connect?: StakingPoolWhereUniqueInput
  }

  export type StakingRewardCreateNestedManyWithoutPositionInput = {
    create?: XOR<StakingRewardCreateWithoutPositionInput, StakingRewardUncheckedCreateWithoutPositionInput> | StakingRewardCreateWithoutPositionInput[] | StakingRewardUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: StakingRewardCreateOrConnectWithoutPositionInput | StakingRewardCreateOrConnectWithoutPositionInput[]
    createMany?: StakingRewardCreateManyPositionInputEnvelope
    connect?: StakingRewardWhereUniqueInput | StakingRewardWhereUniqueInput[]
  }

  export type StakingRewardUncheckedCreateNestedManyWithoutPositionInput = {
    create?: XOR<StakingRewardCreateWithoutPositionInput, StakingRewardUncheckedCreateWithoutPositionInput> | StakingRewardCreateWithoutPositionInput[] | StakingRewardUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: StakingRewardCreateOrConnectWithoutPositionInput | StakingRewardCreateOrConnectWithoutPositionInput[]
    createMany?: StakingRewardCreateManyPositionInputEnvelope
    connect?: StakingRewardWhereUniqueInput | StakingRewardWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutStakingPositionsNestedInput = {
    create?: XOR<UserCreateWithoutStakingPositionsInput, UserUncheckedCreateWithoutStakingPositionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStakingPositionsInput
    upsert?: UserUpsertWithoutStakingPositionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStakingPositionsInput, UserUpdateWithoutStakingPositionsInput>, UserUncheckedUpdateWithoutStakingPositionsInput>
  }

  export type StakingPoolUpdateOneRequiredWithoutStakesNestedInput = {
    create?: XOR<StakingPoolCreateWithoutStakesInput, StakingPoolUncheckedCreateWithoutStakesInput>
    connectOrCreate?: StakingPoolCreateOrConnectWithoutStakesInput
    upsert?: StakingPoolUpsertWithoutStakesInput
    connect?: StakingPoolWhereUniqueInput
    update?: XOR<XOR<StakingPoolUpdateToOneWithWhereWithoutStakesInput, StakingPoolUpdateWithoutStakesInput>, StakingPoolUncheckedUpdateWithoutStakesInput>
  }

  export type StakingRewardUpdateManyWithoutPositionNestedInput = {
    create?: XOR<StakingRewardCreateWithoutPositionInput, StakingRewardUncheckedCreateWithoutPositionInput> | StakingRewardCreateWithoutPositionInput[] | StakingRewardUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: StakingRewardCreateOrConnectWithoutPositionInput | StakingRewardCreateOrConnectWithoutPositionInput[]
    upsert?: StakingRewardUpsertWithWhereUniqueWithoutPositionInput | StakingRewardUpsertWithWhereUniqueWithoutPositionInput[]
    createMany?: StakingRewardCreateManyPositionInputEnvelope
    set?: StakingRewardWhereUniqueInput | StakingRewardWhereUniqueInput[]
    disconnect?: StakingRewardWhereUniqueInput | StakingRewardWhereUniqueInput[]
    delete?: StakingRewardWhereUniqueInput | StakingRewardWhereUniqueInput[]
    connect?: StakingRewardWhereUniqueInput | StakingRewardWhereUniqueInput[]
    update?: StakingRewardUpdateWithWhereUniqueWithoutPositionInput | StakingRewardUpdateWithWhereUniqueWithoutPositionInput[]
    updateMany?: StakingRewardUpdateManyWithWhereWithoutPositionInput | StakingRewardUpdateManyWithWhereWithoutPositionInput[]
    deleteMany?: StakingRewardScalarWhereInput | StakingRewardScalarWhereInput[]
  }

  export type StakingRewardUncheckedUpdateManyWithoutPositionNestedInput = {
    create?: XOR<StakingRewardCreateWithoutPositionInput, StakingRewardUncheckedCreateWithoutPositionInput> | StakingRewardCreateWithoutPositionInput[] | StakingRewardUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: StakingRewardCreateOrConnectWithoutPositionInput | StakingRewardCreateOrConnectWithoutPositionInput[]
    upsert?: StakingRewardUpsertWithWhereUniqueWithoutPositionInput | StakingRewardUpsertWithWhereUniqueWithoutPositionInput[]
    createMany?: StakingRewardCreateManyPositionInputEnvelope
    set?: StakingRewardWhereUniqueInput | StakingRewardWhereUniqueInput[]
    disconnect?: StakingRewardWhereUniqueInput | StakingRewardWhereUniqueInput[]
    delete?: StakingRewardWhereUniqueInput | StakingRewardWhereUniqueInput[]
    connect?: StakingRewardWhereUniqueInput | StakingRewardWhereUniqueInput[]
    update?: StakingRewardUpdateWithWhereUniqueWithoutPositionInput | StakingRewardUpdateWithWhereUniqueWithoutPositionInput[]
    updateMany?: StakingRewardUpdateManyWithWhereWithoutPositionInput | StakingRewardUpdateManyWithWhereWithoutPositionInput[]
    deleteMany?: StakingRewardScalarWhereInput | StakingRewardScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutStakingRewardsInput = {
    create?: XOR<UserCreateWithoutStakingRewardsInput, UserUncheckedCreateWithoutStakingRewardsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStakingRewardsInput
    connect?: UserWhereUniqueInput
  }

  export type StakingPoolCreateNestedOneWithoutRewardsInput = {
    create?: XOR<StakingPoolCreateWithoutRewardsInput, StakingPoolUncheckedCreateWithoutRewardsInput>
    connectOrCreate?: StakingPoolCreateOrConnectWithoutRewardsInput
    connect?: StakingPoolWhereUniqueInput
  }

  export type StakingPositionCreateNestedOneWithoutRewardsInput = {
    create?: XOR<StakingPositionCreateWithoutRewardsInput, StakingPositionUncheckedCreateWithoutRewardsInput>
    connectOrCreate?: StakingPositionCreateOrConnectWithoutRewardsInput
    connect?: StakingPositionWhereUniqueInput
  }

  export type EnumStakingRewardTypeFieldUpdateOperationsInput = {
    set?: $Enums.StakingRewardType
  }

  export type UserUpdateOneRequiredWithoutStakingRewardsNestedInput = {
    create?: XOR<UserCreateWithoutStakingRewardsInput, UserUncheckedCreateWithoutStakingRewardsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStakingRewardsInput
    upsert?: UserUpsertWithoutStakingRewardsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStakingRewardsInput, UserUpdateWithoutStakingRewardsInput>, UserUncheckedUpdateWithoutStakingRewardsInput>
  }

  export type StakingPoolUpdateOneRequiredWithoutRewardsNestedInput = {
    create?: XOR<StakingPoolCreateWithoutRewardsInput, StakingPoolUncheckedCreateWithoutRewardsInput>
    connectOrCreate?: StakingPoolCreateOrConnectWithoutRewardsInput
    upsert?: StakingPoolUpsertWithoutRewardsInput
    connect?: StakingPoolWhereUniqueInput
    update?: XOR<XOR<StakingPoolUpdateToOneWithWhereWithoutRewardsInput, StakingPoolUpdateWithoutRewardsInput>, StakingPoolUncheckedUpdateWithoutRewardsInput>
  }

  export type StakingPositionUpdateOneRequiredWithoutRewardsNestedInput = {
    create?: XOR<StakingPositionCreateWithoutRewardsInput, StakingPositionUncheckedCreateWithoutRewardsInput>
    connectOrCreate?: StakingPositionCreateOrConnectWithoutRewardsInput
    upsert?: StakingPositionUpsertWithoutRewardsInput
    connect?: StakingPositionWhereUniqueInput
    update?: XOR<XOR<StakingPositionUpdateToOneWithWhereWithoutRewardsInput, StakingPositionUpdateWithoutRewardsInput>, StakingPositionUncheckedUpdateWithoutRewardsInput>
  }

  export type UserCreateNestedOneWithoutGovernanceProposalsInput = {
    create?: XOR<UserCreateWithoutGovernanceProposalsInput, UserUncheckedCreateWithoutGovernanceProposalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGovernanceProposalsInput
    connect?: UserWhereUniqueInput
  }

  export type GovernanceVoteCreateNestedManyWithoutProposalInput = {
    create?: XOR<GovernanceVoteCreateWithoutProposalInput, GovernanceVoteUncheckedCreateWithoutProposalInput> | GovernanceVoteCreateWithoutProposalInput[] | GovernanceVoteUncheckedCreateWithoutProposalInput[]
    connectOrCreate?: GovernanceVoteCreateOrConnectWithoutProposalInput | GovernanceVoteCreateOrConnectWithoutProposalInput[]
    createMany?: GovernanceVoteCreateManyProposalInputEnvelope
    connect?: GovernanceVoteWhereUniqueInput | GovernanceVoteWhereUniqueInput[]
  }

  export type GovernanceVoteUncheckedCreateNestedManyWithoutProposalInput = {
    create?: XOR<GovernanceVoteCreateWithoutProposalInput, GovernanceVoteUncheckedCreateWithoutProposalInput> | GovernanceVoteCreateWithoutProposalInput[] | GovernanceVoteUncheckedCreateWithoutProposalInput[]
    connectOrCreate?: GovernanceVoteCreateOrConnectWithoutProposalInput | GovernanceVoteCreateOrConnectWithoutProposalInput[]
    createMany?: GovernanceVoteCreateManyProposalInputEnvelope
    connect?: GovernanceVoteWhereUniqueInput | GovernanceVoteWhereUniqueInput[]
  }

  export type EnumGovernanceStatusFieldUpdateOperationsInput = {
    set?: $Enums.GovernanceStatus
  }

  export type UserUpdateOneRequiredWithoutGovernanceProposalsNestedInput = {
    create?: XOR<UserCreateWithoutGovernanceProposalsInput, UserUncheckedCreateWithoutGovernanceProposalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGovernanceProposalsInput
    upsert?: UserUpsertWithoutGovernanceProposalsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGovernanceProposalsInput, UserUpdateWithoutGovernanceProposalsInput>, UserUncheckedUpdateWithoutGovernanceProposalsInput>
  }

  export type GovernanceVoteUpdateManyWithoutProposalNestedInput = {
    create?: XOR<GovernanceVoteCreateWithoutProposalInput, GovernanceVoteUncheckedCreateWithoutProposalInput> | GovernanceVoteCreateWithoutProposalInput[] | GovernanceVoteUncheckedCreateWithoutProposalInput[]
    connectOrCreate?: GovernanceVoteCreateOrConnectWithoutProposalInput | GovernanceVoteCreateOrConnectWithoutProposalInput[]
    upsert?: GovernanceVoteUpsertWithWhereUniqueWithoutProposalInput | GovernanceVoteUpsertWithWhereUniqueWithoutProposalInput[]
    createMany?: GovernanceVoteCreateManyProposalInputEnvelope
    set?: GovernanceVoteWhereUniqueInput | GovernanceVoteWhereUniqueInput[]
    disconnect?: GovernanceVoteWhereUniqueInput | GovernanceVoteWhereUniqueInput[]
    delete?: GovernanceVoteWhereUniqueInput | GovernanceVoteWhereUniqueInput[]
    connect?: GovernanceVoteWhereUniqueInput | GovernanceVoteWhereUniqueInput[]
    update?: GovernanceVoteUpdateWithWhereUniqueWithoutProposalInput | GovernanceVoteUpdateWithWhereUniqueWithoutProposalInput[]
    updateMany?: GovernanceVoteUpdateManyWithWhereWithoutProposalInput | GovernanceVoteUpdateManyWithWhereWithoutProposalInput[]
    deleteMany?: GovernanceVoteScalarWhereInput | GovernanceVoteScalarWhereInput[]
  }

  export type GovernanceVoteUncheckedUpdateManyWithoutProposalNestedInput = {
    create?: XOR<GovernanceVoteCreateWithoutProposalInput, GovernanceVoteUncheckedCreateWithoutProposalInput> | GovernanceVoteCreateWithoutProposalInput[] | GovernanceVoteUncheckedCreateWithoutProposalInput[]
    connectOrCreate?: GovernanceVoteCreateOrConnectWithoutProposalInput | GovernanceVoteCreateOrConnectWithoutProposalInput[]
    upsert?: GovernanceVoteUpsertWithWhereUniqueWithoutProposalInput | GovernanceVoteUpsertWithWhereUniqueWithoutProposalInput[]
    createMany?: GovernanceVoteCreateManyProposalInputEnvelope
    set?: GovernanceVoteWhereUniqueInput | GovernanceVoteWhereUniqueInput[]
    disconnect?: GovernanceVoteWhereUniqueInput | GovernanceVoteWhereUniqueInput[]
    delete?: GovernanceVoteWhereUniqueInput | GovernanceVoteWhereUniqueInput[]
    connect?: GovernanceVoteWhereUniqueInput | GovernanceVoteWhereUniqueInput[]
    update?: GovernanceVoteUpdateWithWhereUniqueWithoutProposalInput | GovernanceVoteUpdateWithWhereUniqueWithoutProposalInput[]
    updateMany?: GovernanceVoteUpdateManyWithWhereWithoutProposalInput | GovernanceVoteUpdateManyWithWhereWithoutProposalInput[]
    deleteMany?: GovernanceVoteScalarWhereInput | GovernanceVoteScalarWhereInput[]
  }

  export type GovernanceProposalCreateNestedOneWithoutVotesInput = {
    create?: XOR<GovernanceProposalCreateWithoutVotesInput, GovernanceProposalUncheckedCreateWithoutVotesInput>
    connectOrCreate?: GovernanceProposalCreateOrConnectWithoutVotesInput
    connect?: GovernanceProposalWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutGovernanceVotesInput = {
    create?: XOR<UserCreateWithoutGovernanceVotesInput, UserUncheckedCreateWithoutGovernanceVotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutGovernanceVotesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumVoteChoiceFieldUpdateOperationsInput = {
    set?: $Enums.VoteChoice
  }

  export type GovernanceProposalUpdateOneRequiredWithoutVotesNestedInput = {
    create?: XOR<GovernanceProposalCreateWithoutVotesInput, GovernanceProposalUncheckedCreateWithoutVotesInput>
    connectOrCreate?: GovernanceProposalCreateOrConnectWithoutVotesInput
    upsert?: GovernanceProposalUpsertWithoutVotesInput
    connect?: GovernanceProposalWhereUniqueInput
    update?: XOR<XOR<GovernanceProposalUpdateToOneWithWhereWithoutVotesInput, GovernanceProposalUpdateWithoutVotesInput>, GovernanceProposalUncheckedUpdateWithoutVotesInput>
  }

  export type UserUpdateOneRequiredWithoutGovernanceVotesNestedInput = {
    create?: XOR<UserCreateWithoutGovernanceVotesInput, UserUncheckedCreateWithoutGovernanceVotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutGovernanceVotesInput
    upsert?: UserUpsertWithoutGovernanceVotesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGovernanceVotesInput, UserUpdateWithoutGovernanceVotesInput>, UserUncheckedUpdateWithoutGovernanceVotesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionPlanFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionPlanFilter<$PrismaModel> | $Enums.SubscriptionPlan
  }

  export type NestedEnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumSubscriptionPlanWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionPlanWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionPlan
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionPlanFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionPlanFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedEnumCardCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.CardCategory | EnumCardCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.CardCategory[] | ListEnumCardCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.CardCategory[] | ListEnumCardCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumCardCategoryFilter<$PrismaModel> | $Enums.CardCategory
  }

  export type NestedEnumCardRarityFilter<$PrismaModel = never> = {
    equals?: $Enums.CardRarity | EnumCardRarityFieldRefInput<$PrismaModel>
    in?: $Enums.CardRarity[] | ListEnumCardRarityFieldRefInput<$PrismaModel>
    notIn?: $Enums.CardRarity[] | ListEnumCardRarityFieldRefInput<$PrismaModel>
    not?: NestedEnumCardRarityFilter<$PrismaModel> | $Enums.CardRarity
  }

  export type NestedEnumCardCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CardCategory | EnumCardCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.CardCategory[] | ListEnumCardCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.CardCategory[] | ListEnumCardCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumCardCategoryWithAggregatesFilter<$PrismaModel> | $Enums.CardCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCardCategoryFilter<$PrismaModel>
    _max?: NestedEnumCardCategoryFilter<$PrismaModel>
  }

  export type NestedEnumCardRarityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CardRarity | EnumCardRarityFieldRefInput<$PrismaModel>
    in?: $Enums.CardRarity[] | ListEnumCardRarityFieldRefInput<$PrismaModel>
    notIn?: $Enums.CardRarity[] | ListEnumCardRarityFieldRefInput<$PrismaModel>
    not?: NestedEnumCardRarityWithAggregatesFilter<$PrismaModel> | $Enums.CardRarity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCardRarityFilter<$PrismaModel>
    _max?: NestedEnumCardRarityFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumListingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ListingType | EnumListingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ListingType[] | ListEnumListingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ListingType[] | ListEnumListingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumListingTypeFilter<$PrismaModel> | $Enums.ListingType
  }

  export type NestedEnumListingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ListingStatus | EnumListingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumListingStatusFilter<$PrismaModel> | $Enums.ListingStatus
  }

  export type NestedEnumListingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ListingType | EnumListingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ListingType[] | ListEnumListingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ListingType[] | ListEnumListingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumListingTypeWithAggregatesFilter<$PrismaModel> | $Enums.ListingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumListingTypeFilter<$PrismaModel>
    _max?: NestedEnumListingTypeFilter<$PrismaModel>
  }

  export type NestedEnumListingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ListingStatus | EnumListingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumListingStatusWithAggregatesFilter<$PrismaModel> | $Enums.ListingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumListingStatusFilter<$PrismaModel>
    _max?: NestedEnumListingStatusFilter<$PrismaModel>
  }

  export type NestedEnumBidStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BidStatus | EnumBidStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BidStatus[] | ListEnumBidStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BidStatus[] | ListEnumBidStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBidStatusFilter<$PrismaModel> | $Enums.BidStatus
  }

  export type NestedEnumBidStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BidStatus | EnumBidStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BidStatus[] | ListEnumBidStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BidStatus[] | ListEnumBidStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBidStatusWithAggregatesFilter<$PrismaModel> | $Enums.BidStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBidStatusFilter<$PrismaModel>
    _max?: NestedEnumBidStatusFilter<$PrismaModel>
  }

  export type NestedEnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type NestedEnumTransactionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusFilter<$PrismaModel> | $Enums.TransactionStatus
  }

  export type NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransactionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionStatusFilter<$PrismaModel>
    _max?: NestedEnumTransactionStatusFilter<$PrismaModel>
  }

  export type NestedEnumPhysicalCardStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PhysicalCardStatus | EnumPhysicalCardStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PhysicalCardStatus[] | ListEnumPhysicalCardStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PhysicalCardStatus[] | ListEnumPhysicalCardStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPhysicalCardStatusFilter<$PrismaModel> | $Enums.PhysicalCardStatus
  }

  export type NestedEnumPhysicalCardStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PhysicalCardStatus | EnumPhysicalCardStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PhysicalCardStatus[] | ListEnumPhysicalCardStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PhysicalCardStatus[] | ListEnumPhysicalCardStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPhysicalCardStatusWithAggregatesFilter<$PrismaModel> | $Enums.PhysicalCardStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPhysicalCardStatusFilter<$PrismaModel>
    _max?: NestedEnumPhysicalCardStatusFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationPriority | EnumNotificationPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationPriorityFilter<$PrismaModel> | $Enums.NotificationPriority
  }

  export type NestedEnumSubscriptionPlanNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel> | null
    in?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSubscriptionPlanNullableFilter<$PrismaModel> | $Enums.SubscriptionPlan | null
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumNotificationPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationPriority | EnumNotificationPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationPriorityWithAggregatesFilter<$PrismaModel> | $Enums.NotificationPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationPriorityFilter<$PrismaModel>
    _max?: NestedEnumNotificationPriorityFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionPlanNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel> | null
    in?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSubscriptionPlanNullableWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionPlan | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionPlanNullableFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionPlanNullableFilter<$PrismaModel>
  }

  export type NestedEnumSocialFeedTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SocialFeedType | EnumSocialFeedTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SocialFeedType[] | ListEnumSocialFeedTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SocialFeedType[] | ListEnumSocialFeedTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSocialFeedTypeFilter<$PrismaModel> | $Enums.SocialFeedType
  }

  export type NestedEnumSocialVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.SocialVisibility | EnumSocialVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.SocialVisibility[] | ListEnumSocialVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.SocialVisibility[] | ListEnumSocialVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumSocialVisibilityFilter<$PrismaModel> | $Enums.SocialVisibility
  }

  export type NestedEnumSocialFeedTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SocialFeedType | EnumSocialFeedTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SocialFeedType[] | ListEnumSocialFeedTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SocialFeedType[] | ListEnumSocialFeedTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSocialFeedTypeWithAggregatesFilter<$PrismaModel> | $Enums.SocialFeedType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSocialFeedTypeFilter<$PrismaModel>
    _max?: NestedEnumSocialFeedTypeFilter<$PrismaModel>
  }

  export type NestedEnumSocialVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SocialVisibility | EnumSocialVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.SocialVisibility[] | ListEnumSocialVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.SocialVisibility[] | ListEnumSocialVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumSocialVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.SocialVisibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSocialVisibilityFilter<$PrismaModel>
    _max?: NestedEnumSocialVisibilityFilter<$PrismaModel>
  }

  export type NestedEnumProjectTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectType | EnumProjectTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectType[] | ListEnumProjectTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectType[] | ListEnumProjectTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectTypeFilter<$PrismaModel> | $Enums.ProjectType
  }

  export type NestedEnumOrderTimelineFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderTimeline | EnumOrderTimelineFieldRefInput<$PrismaModel>
    in?: $Enums.OrderTimeline[] | ListEnumOrderTimelineFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderTimeline[] | ListEnumOrderTimelineFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderTimelineFilter<$PrismaModel> | $Enums.OrderTimeline
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type NestedEnumOrderPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderPriority | EnumOrderPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.OrderPriority[] | ListEnumOrderPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderPriority[] | ListEnumOrderPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderPriorityFilter<$PrismaModel> | $Enums.OrderPriority
  }

  export type NestedEnumProjectTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectType | EnumProjectTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectType[] | ListEnumProjectTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectType[] | ListEnumProjectTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProjectType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectTypeFilter<$PrismaModel>
    _max?: NestedEnumProjectTypeFilter<$PrismaModel>
  }

  export type NestedEnumOrderTimelineWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderTimeline | EnumOrderTimelineFieldRefInput<$PrismaModel>
    in?: $Enums.OrderTimeline[] | ListEnumOrderTimelineFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderTimeline[] | ListEnumOrderTimelineFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderTimelineWithAggregatesFilter<$PrismaModel> | $Enums.OrderTimeline
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderTimelineFilter<$PrismaModel>
    _max?: NestedEnumOrderTimelineFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type NestedEnumOrderPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderPriority | EnumOrderPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.OrderPriority[] | ListEnumOrderPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderPriority[] | ListEnumOrderPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderPriorityWithAggregatesFilter<$PrismaModel> | $Enums.OrderPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderPriorityFilter<$PrismaModel>
    _max?: NestedEnumOrderPriorityFilter<$PrismaModel>
  }

  export type NestedEnumRevisionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RevisionStatus | EnumRevisionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RevisionStatus[] | ListEnumRevisionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RevisionStatus[] | ListEnumRevisionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRevisionStatusFilter<$PrismaModel> | $Enums.RevisionStatus
  }

  export type NestedEnumRevisionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RevisionStatus | EnumRevisionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RevisionStatus[] | ListEnumRevisionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RevisionStatus[] | ListEnumRevisionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRevisionStatusWithAggregatesFilter<$PrismaModel> | $Enums.RevisionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRevisionStatusFilter<$PrismaModel>
    _max?: NestedEnumRevisionStatusFilter<$PrismaModel>
  }

  export type NestedEnumCommunicationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CommunicationType | EnumCommunicationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CommunicationType[] | ListEnumCommunicationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommunicationType[] | ListEnumCommunicationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCommunicationTypeFilter<$PrismaModel> | $Enums.CommunicationType
  }

  export type NestedEnumCommunicationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CommunicationType | EnumCommunicationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CommunicationType[] | ListEnumCommunicationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommunicationType[] | ListEnumCommunicationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCommunicationTypeWithAggregatesFilter<$PrismaModel> | $Enums.CommunicationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCommunicationTypeFilter<$PrismaModel>
    _max?: NestedEnumCommunicationTypeFilter<$PrismaModel>
  }

  export type NestedEnumDeliverableTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliverableType | EnumDeliverableTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DeliverableType[] | ListEnumDeliverableTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeliverableType[] | ListEnumDeliverableTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDeliverableTypeFilter<$PrismaModel> | $Enums.DeliverableType
  }

  export type NestedEnumDeliverableStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliverableStatus | EnumDeliverableStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeliverableStatus[] | ListEnumDeliverableStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeliverableStatus[] | ListEnumDeliverableStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDeliverableStatusFilter<$PrismaModel> | $Enums.DeliverableStatus
  }

  export type NestedEnumDeliverableTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliverableType | EnumDeliverableTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DeliverableType[] | ListEnumDeliverableTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeliverableType[] | ListEnumDeliverableTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDeliverableTypeWithAggregatesFilter<$PrismaModel> | $Enums.DeliverableType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeliverableTypeFilter<$PrismaModel>
    _max?: NestedEnumDeliverableTypeFilter<$PrismaModel>
  }

  export type NestedEnumDeliverableStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliverableStatus | EnumDeliverableStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeliverableStatus[] | ListEnumDeliverableStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeliverableStatus[] | ListEnumDeliverableStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDeliverableStatusWithAggregatesFilter<$PrismaModel> | $Enums.DeliverableStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeliverableStatusFilter<$PrismaModel>
    _max?: NestedEnumDeliverableStatusFilter<$PrismaModel>
  }

  export type NestedEnumMarketMetricTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MarketMetricType | EnumMarketMetricTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MarketMetricType[] | ListEnumMarketMetricTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MarketMetricType[] | ListEnumMarketMetricTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMarketMetricTypeFilter<$PrismaModel> | $Enums.MarketMetricType
  }

  export type NestedEnumPredictionDirectionFilter<$PrismaModel = never> = {
    equals?: $Enums.PredictionDirection | EnumPredictionDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.PredictionDirection[] | ListEnumPredictionDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.PredictionDirection[] | ListEnumPredictionDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumPredictionDirectionFilter<$PrismaModel> | $Enums.PredictionDirection
  }

  export type NestedEnumMarketStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MarketStatus | EnumMarketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MarketStatus[] | ListEnumMarketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MarketStatus[] | ListEnumMarketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMarketStatusFilter<$PrismaModel> | $Enums.MarketStatus
  }

  export type NestedEnumPredictionDirectionNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PredictionDirection | EnumPredictionDirectionFieldRefInput<$PrismaModel> | null
    in?: $Enums.PredictionDirection[] | ListEnumPredictionDirectionFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PredictionDirection[] | ListEnumPredictionDirectionFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPredictionDirectionNullableFilter<$PrismaModel> | $Enums.PredictionDirection | null
  }

  export type NestedEnumMarketMetricTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MarketMetricType | EnumMarketMetricTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MarketMetricType[] | ListEnumMarketMetricTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MarketMetricType[] | ListEnumMarketMetricTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMarketMetricTypeWithAggregatesFilter<$PrismaModel> | $Enums.MarketMetricType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMarketMetricTypeFilter<$PrismaModel>
    _max?: NestedEnumMarketMetricTypeFilter<$PrismaModel>
  }

  export type NestedEnumPredictionDirectionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PredictionDirection | EnumPredictionDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.PredictionDirection[] | ListEnumPredictionDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.PredictionDirection[] | ListEnumPredictionDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumPredictionDirectionWithAggregatesFilter<$PrismaModel> | $Enums.PredictionDirection
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPredictionDirectionFilter<$PrismaModel>
    _max?: NestedEnumPredictionDirectionFilter<$PrismaModel>
  }

  export type NestedEnumMarketStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MarketStatus | EnumMarketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MarketStatus[] | ListEnumMarketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MarketStatus[] | ListEnumMarketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMarketStatusWithAggregatesFilter<$PrismaModel> | $Enums.MarketStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMarketStatusFilter<$PrismaModel>
    _max?: NestedEnumMarketStatusFilter<$PrismaModel>
  }

  export type NestedEnumPredictionDirectionNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PredictionDirection | EnumPredictionDirectionFieldRefInput<$PrismaModel> | null
    in?: $Enums.PredictionDirection[] | ListEnumPredictionDirectionFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PredictionDirection[] | ListEnumPredictionDirectionFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPredictionDirectionNullableWithAggregatesFilter<$PrismaModel> | $Enums.PredictionDirection | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPredictionDirectionNullableFilter<$PrismaModel>
    _max?: NestedEnumPredictionDirectionNullableFilter<$PrismaModel>
  }

  export type NestedEnumPositionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PositionStatus | EnumPositionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PositionStatus[] | ListEnumPositionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PositionStatus[] | ListEnumPositionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPositionStatusFilter<$PrismaModel> | $Enums.PositionStatus
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedEnumPositionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PositionStatus | EnumPositionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PositionStatus[] | ListEnumPositionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PositionStatus[] | ListEnumPositionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPositionStatusWithAggregatesFilter<$PrismaModel> | $Enums.PositionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPositionStatusFilter<$PrismaModel>
    _max?: NestedEnumPositionStatusFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumPayoutStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PayoutStatus | EnumPayoutStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PayoutStatus[] | ListEnumPayoutStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayoutStatus[] | ListEnumPayoutStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPayoutStatusFilter<$PrismaModel> | $Enums.PayoutStatus
  }

  export type NestedEnumPayoutStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PayoutStatus | EnumPayoutStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PayoutStatus[] | ListEnumPayoutStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayoutStatus[] | ListEnumPayoutStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPayoutStatusWithAggregatesFilter<$PrismaModel> | $Enums.PayoutStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPayoutStatusFilter<$PrismaModel>
    _max?: NestedEnumPayoutStatusFilter<$PrismaModel>
  }

  export type NestedEnumAuctionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AuctionStatus | EnumAuctionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AuctionStatus[] | ListEnumAuctionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuctionStatus[] | ListEnumAuctionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAuctionStatusFilter<$PrismaModel> | $Enums.AuctionStatus
  }

  export type NestedEnumAuctionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuctionStatus | EnumAuctionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AuctionStatus[] | ListEnumAuctionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuctionStatus[] | ListEnumAuctionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAuctionStatusWithAggregatesFilter<$PrismaModel> | $Enums.AuctionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuctionStatusFilter<$PrismaModel>
    _max?: NestedEnumAuctionStatusFilter<$PrismaModel>
  }

  export type NestedEnumBidTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BidType | EnumBidTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BidType[] | ListEnumBidTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BidType[] | ListEnumBidTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBidTypeFilter<$PrismaModel> | $Enums.BidType
  }

  export type NestedEnumAuctionBidStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AuctionBidStatus | EnumAuctionBidStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AuctionBidStatus[] | ListEnumAuctionBidStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuctionBidStatus[] | ListEnumAuctionBidStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAuctionBidStatusFilter<$PrismaModel> | $Enums.AuctionBidStatus
  }

  export type NestedEnumBidTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BidType | EnumBidTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BidType[] | ListEnumBidTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BidType[] | ListEnumBidTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBidTypeWithAggregatesFilter<$PrismaModel> | $Enums.BidType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBidTypeFilter<$PrismaModel>
    _max?: NestedEnumBidTypeFilter<$PrismaModel>
  }

  export type NestedEnumAuctionBidStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuctionBidStatus | EnumAuctionBidStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AuctionBidStatus[] | ListEnumAuctionBidStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuctionBidStatus[] | ListEnumAuctionBidStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAuctionBidStatusWithAggregatesFilter<$PrismaModel> | $Enums.AuctionBidStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuctionBidStatusFilter<$PrismaModel>
    _max?: NestedEnumAuctionBidStatusFilter<$PrismaModel>
  }

  export type NestedEnumSaleTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SaleType | EnumSaleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SaleType[] | ListEnumSaleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SaleType[] | ListEnumSaleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSaleTypeFilter<$PrismaModel> | $Enums.SaleType
  }

  export type NestedEnumSaleTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SaleType | EnumSaleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SaleType[] | ListEnumSaleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SaleType[] | ListEnumSaleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSaleTypeWithAggregatesFilter<$PrismaModel> | $Enums.SaleType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSaleTypeFilter<$PrismaModel>
    _max?: NestedEnumSaleTypeFilter<$PrismaModel>
  }

  export type NestedEnumBattleTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BattleType | EnumBattleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BattleType[] | ListEnumBattleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BattleType[] | ListEnumBattleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBattleTypeFilter<$PrismaModel> | $Enums.BattleType
  }

  export type NestedEnumBattleStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BattleStatus | EnumBattleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BattleStatus[] | ListEnumBattleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BattleStatus[] | ListEnumBattleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBattleStatusFilter<$PrismaModel> | $Enums.BattleStatus
  }

  export type NestedEnumBattleTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BattleType | EnumBattleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BattleType[] | ListEnumBattleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BattleType[] | ListEnumBattleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBattleTypeWithAggregatesFilter<$PrismaModel> | $Enums.BattleType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBattleTypeFilter<$PrismaModel>
    _max?: NestedEnumBattleTypeFilter<$PrismaModel>
  }

  export type NestedEnumBattleStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BattleStatus | EnumBattleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BattleStatus[] | ListEnumBattleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BattleStatus[] | ListEnumBattleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBattleStatusWithAggregatesFilter<$PrismaModel> | $Enums.BattleStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBattleStatusFilter<$PrismaModel>
    _max?: NestedEnumBattleStatusFilter<$PrismaModel>
  }

  export type NestedEnumProposalTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProposalType | EnumProposalTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProposalType[] | ListEnumProposalTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProposalType[] | ListEnumProposalTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProposalTypeFilter<$PrismaModel> | $Enums.ProposalType
  }

  export type NestedEnumProposalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProposalStatus | EnumProposalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProposalStatus[] | ListEnumProposalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProposalStatus[] | ListEnumProposalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProposalStatusFilter<$PrismaModel> | $Enums.ProposalStatus
  }

  export type NestedEnumProposalTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProposalType | EnumProposalTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProposalType[] | ListEnumProposalTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProposalType[] | ListEnumProposalTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProposalTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProposalType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProposalTypeFilter<$PrismaModel>
    _max?: NestedEnumProposalTypeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumProposalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProposalStatus | EnumProposalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProposalStatus[] | ListEnumProposalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProposalStatus[] | ListEnumProposalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProposalStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProposalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProposalStatusFilter<$PrismaModel>
    _max?: NestedEnumProposalStatusFilter<$PrismaModel>
  }

  export type NestedEnumVoteDirectionFilter<$PrismaModel = never> = {
    equals?: $Enums.VoteDirection | EnumVoteDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.VoteDirection[] | ListEnumVoteDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.VoteDirection[] | ListEnumVoteDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumVoteDirectionFilter<$PrismaModel> | $Enums.VoteDirection
  }

  export type NestedEnumVoteDirectionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VoteDirection | EnumVoteDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.VoteDirection[] | ListEnumVoteDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.VoteDirection[] | ListEnumVoteDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumVoteDirectionWithAggregatesFilter<$PrismaModel> | $Enums.VoteDirection
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVoteDirectionFilter<$PrismaModel>
    _max?: NestedEnumVoteDirectionFilter<$PrismaModel>
  }

  export type NestedEnumBattleWinnerFilter<$PrismaModel = never> = {
    equals?: $Enums.BattleWinner | EnumBattleWinnerFieldRefInput<$PrismaModel>
    in?: $Enums.BattleWinner[] | ListEnumBattleWinnerFieldRefInput<$PrismaModel>
    notIn?: $Enums.BattleWinner[] | ListEnumBattleWinnerFieldRefInput<$PrismaModel>
    not?: NestedEnumBattleWinnerFilter<$PrismaModel> | $Enums.BattleWinner
  }

  export type NestedEnumBattleWinnerWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BattleWinner | EnumBattleWinnerFieldRefInput<$PrismaModel>
    in?: $Enums.BattleWinner[] | ListEnumBattleWinnerFieldRefInput<$PrismaModel>
    notIn?: $Enums.BattleWinner[] | ListEnumBattleWinnerFieldRefInput<$PrismaModel>
    not?: NestedEnumBattleWinnerWithAggregatesFilter<$PrismaModel> | $Enums.BattleWinner
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBattleWinnerFilter<$PrismaModel>
    _max?: NestedEnumBattleWinnerFilter<$PrismaModel>
  }

  export type NestedEnumStakingPoolTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StakingPoolType | EnumStakingPoolTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StakingPoolType[] | ListEnumStakingPoolTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StakingPoolType[] | ListEnumStakingPoolTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStakingPoolTypeFilter<$PrismaModel> | $Enums.StakingPoolType
  }

  export type NestedEnumStakingPoolTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StakingPoolType | EnumStakingPoolTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StakingPoolType[] | ListEnumStakingPoolTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StakingPoolType[] | ListEnumStakingPoolTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStakingPoolTypeWithAggregatesFilter<$PrismaModel> | $Enums.StakingPoolType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStakingPoolTypeFilter<$PrismaModel>
    _max?: NestedEnumStakingPoolTypeFilter<$PrismaModel>
  }

  export type NestedEnumStakingRewardTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StakingRewardType | EnumStakingRewardTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StakingRewardType[] | ListEnumStakingRewardTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StakingRewardType[] | ListEnumStakingRewardTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStakingRewardTypeFilter<$PrismaModel> | $Enums.StakingRewardType
  }

  export type NestedEnumStakingRewardTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StakingRewardType | EnumStakingRewardTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StakingRewardType[] | ListEnumStakingRewardTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StakingRewardType[] | ListEnumStakingRewardTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStakingRewardTypeWithAggregatesFilter<$PrismaModel> | $Enums.StakingRewardType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStakingRewardTypeFilter<$PrismaModel>
    _max?: NestedEnumStakingRewardTypeFilter<$PrismaModel>
  }

  export type NestedEnumGovernanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.GovernanceStatus | EnumGovernanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GovernanceStatus[] | ListEnumGovernanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GovernanceStatus[] | ListEnumGovernanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGovernanceStatusFilter<$PrismaModel> | $Enums.GovernanceStatus
  }

  export type NestedEnumGovernanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GovernanceStatus | EnumGovernanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GovernanceStatus[] | ListEnumGovernanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GovernanceStatus[] | ListEnumGovernanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGovernanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.GovernanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGovernanceStatusFilter<$PrismaModel>
    _max?: NestedEnumGovernanceStatusFilter<$PrismaModel>
  }

  export type NestedEnumVoteChoiceFilter<$PrismaModel = never> = {
    equals?: $Enums.VoteChoice | EnumVoteChoiceFieldRefInput<$PrismaModel>
    in?: $Enums.VoteChoice[] | ListEnumVoteChoiceFieldRefInput<$PrismaModel>
    notIn?: $Enums.VoteChoice[] | ListEnumVoteChoiceFieldRefInput<$PrismaModel>
    not?: NestedEnumVoteChoiceFilter<$PrismaModel> | $Enums.VoteChoice
  }

  export type NestedEnumVoteChoiceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VoteChoice | EnumVoteChoiceFieldRefInput<$PrismaModel>
    in?: $Enums.VoteChoice[] | ListEnumVoteChoiceFieldRefInput<$PrismaModel>
    notIn?: $Enums.VoteChoice[] | ListEnumVoteChoiceFieldRefInput<$PrismaModel>
    not?: NestedEnumVoteChoiceWithAggregatesFilter<$PrismaModel> | $Enums.VoteChoice
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVoteChoiceFilter<$PrismaModel>
    _max?: NestedEnumVoteChoiceFilter<$PrismaModel>
  }

  export type UserSubscriptionCreateWithoutUserInput = {
    id?: string
    plan?: $Enums.SubscriptionPlan
    status?: $Enums.SubscriptionStatus
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: SubscriptionFeaturesCreateNestedOneWithoutSubscriptionInput
    usage?: SubscriptionUsageCreateNestedOneWithoutSubscriptionInput
  }

  export type UserSubscriptionUncheckedCreateWithoutUserInput = {
    id?: string
    plan?: $Enums.SubscriptionPlan
    status?: $Enums.SubscriptionStatus
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: SubscriptionFeaturesUncheckedCreateNestedOneWithoutSubscriptionInput
    usage?: SubscriptionUsageUncheckedCreateNestedOneWithoutSubscriptionInput
  }

  export type UserSubscriptionCreateOrConnectWithoutUserInput = {
    where: UserSubscriptionWhereUniqueInput
    create: XOR<UserSubscriptionCreateWithoutUserInput, UserSubscriptionUncheckedCreateWithoutUserInput>
  }

  export type CryptoWalletCreateWithoutUserInput = {
    id?: string
    currency: string
    address: string
    balance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CryptoWalletUncheckedCreateWithoutUserInput = {
    id?: string
    currency: string
    address: string
    balance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CryptoWalletCreateOrConnectWithoutUserInput = {
    where: CryptoWalletWhereUniqueInput
    create: XOR<CryptoWalletCreateWithoutUserInput, CryptoWalletUncheckedCreateWithoutUserInput>
  }

  export type CryptoWalletCreateManyUserInputEnvelope = {
    data: CryptoWalletCreateManyUserInput | CryptoWalletCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PhysicalCardCreateWithoutUserInput = {
    id?: string
    cardNumber: string
    expiryDate: string
    cvv: string
    status?: $Enums.PhysicalCardStatus
    appleWalletPassId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PhysicalCardUncheckedCreateWithoutUserInput = {
    id?: string
    cardNumber: string
    expiryDate: string
    cvv: string
    status?: $Enums.PhysicalCardStatus
    appleWalletPassId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PhysicalCardCreateOrConnectWithoutUserInput = {
    where: PhysicalCardWhereUniqueInput
    create: XOR<PhysicalCardCreateWithoutUserInput, PhysicalCardUncheckedCreateWithoutUserInput>
  }

  export type CardCreateWithoutOwnerInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.CardCategory
    rarity: $Enums.CardRarity
    company?: string | null
    currentPrice: number
    historicalPrices?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    stats?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    listing?: MarketplaceListingCreateNestedOneWithoutCardInput
    bids?: BidCreateNestedManyWithoutCardInput
    transactions?: TransactionCreateNestedManyWithoutCardInput
    bettingMarkets?: BettingMarketCreateNestedManyWithoutCardInput
    marketMetrics?: MarketMetricsCreateNestedManyWithoutCardInput
    auction?: CardAuctionCreateNestedOneWithoutCardInput
    auctionHistory?: AuctionHistoryCreateNestedManyWithoutCardInput
    initiatedBattles?: MABattleCreateNestedManyWithoutInitiatorCardInput
    targetedBattles?: MABattleCreateNestedManyWithoutTargetCardInput
  }

  export type CardUncheckedCreateWithoutOwnerInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.CardCategory
    rarity: $Enums.CardRarity
    company?: string | null
    currentPrice: number
    historicalPrices?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    stats?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    listing?: MarketplaceListingUncheckedCreateNestedOneWithoutCardInput
    bids?: BidUncheckedCreateNestedManyWithoutCardInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCardInput
    bettingMarkets?: BettingMarketUncheckedCreateNestedManyWithoutCardInput
    marketMetrics?: MarketMetricsUncheckedCreateNestedManyWithoutCardInput
    auction?: CardAuctionUncheckedCreateNestedOneWithoutCardInput
    auctionHistory?: AuctionHistoryUncheckedCreateNestedManyWithoutCardInput
    initiatedBattles?: MABattleUncheckedCreateNestedManyWithoutInitiatorCardInput
    targetedBattles?: MABattleUncheckedCreateNestedManyWithoutTargetCardInput
  }

  export type CardCreateOrConnectWithoutOwnerInput = {
    where: CardWhereUniqueInput
    create: XOR<CardCreateWithoutOwnerInput, CardUncheckedCreateWithoutOwnerInput>
  }

  export type CardCreateManyOwnerInputEnvelope = {
    data: CardCreateManyOwnerInput | CardCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutUserInput = {
    id?: string
    type: $Enums.TransactionType
    amount: number
    currency?: string
    status?: $Enums.TransactionStatus
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: string | null
    paymentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    card?: CardCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutUserInput = {
    id?: string
    cardId?: string | null
    type: $Enums.TransactionType
    amount: number
    currency?: string
    status?: $Enums.TransactionStatus
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: string | null
    paymentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutUserInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput>
  }

  export type TransactionCreateManyUserInputEnvelope = {
    data: TransactionCreateManyUserInput | TransactionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BidCreateWithoutBidderInput = {
    id?: string
    amount: number
    status?: $Enums.BidStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    listing: MarketplaceListingCreateNestedOneWithoutBidsInput
    card: CardCreateNestedOneWithoutBidsInput
  }

  export type BidUncheckedCreateWithoutBidderInput = {
    id?: string
    listingId: string
    cardId: string
    amount: number
    status?: $Enums.BidStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BidCreateOrConnectWithoutBidderInput = {
    where: BidWhereUniqueInput
    create: XOR<BidCreateWithoutBidderInput, BidUncheckedCreateWithoutBidderInput>
  }

  export type BidCreateManyBidderInputEnvelope = {
    data: BidCreateManyBidderInput | BidCreateManyBidderInput[]
    skipDuplicates?: boolean
  }

  export type MarketplaceListingCreateWithoutSellerInput = {
    id?: string
    price: number
    listingType?: $Enums.ListingType
    auctionEnd?: Date | string | null
    status?: $Enums.ListingStatus
    featured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    card: CardCreateNestedOneWithoutListingInput
    bids?: BidCreateNestedManyWithoutListingInput
  }

  export type MarketplaceListingUncheckedCreateWithoutSellerInput = {
    id?: string
    cardId: string
    price: number
    listingType?: $Enums.ListingType
    auctionEnd?: Date | string | null
    status?: $Enums.ListingStatus
    featured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bids?: BidUncheckedCreateNestedManyWithoutListingInput
  }

  export type MarketplaceListingCreateOrConnectWithoutSellerInput = {
    where: MarketplaceListingWhereUniqueInput
    create: XOR<MarketplaceListingCreateWithoutSellerInput, MarketplaceListingUncheckedCreateWithoutSellerInput>
  }

  export type MarketplaceListingCreateManySellerInputEnvelope = {
    data: MarketplaceListingCreateManySellerInput | MarketplaceListingCreateManySellerInput[]
    skipDuplicates?: boolean
  }

  export type AppOrderCreateWithoutUserInput = {
    id?: string
    projectType: $Enums.ProjectType
    title: string
    description: string
    requirements?: NullableJsonNullValueInput | InputJsonValue
    timeline: $Enums.OrderTimeline
    estimatedCost: number
    actualCost?: number | null
    currency?: string
    status?: $Enums.OrderStatus
    priority?: $Enums.OrderPriority
    deliveryDate?: Date | string | null
    githubRepo?: string | null
    vercelLink?: string | null
    downloadLink?: string | null
    progressPercentage?: number
    currentMilestone?: string | null
    assignedAdminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    revisions?: OrderRevisionCreateNestedManyWithoutOrderInput
    communications?: OrderCommunicationCreateNestedManyWithoutOrderInput
    deliverables?: OrderDeliverableCreateNestedManyWithoutOrderInput
  }

  export type AppOrderUncheckedCreateWithoutUserInput = {
    id?: string
    projectType: $Enums.ProjectType
    title: string
    description: string
    requirements?: NullableJsonNullValueInput | InputJsonValue
    timeline: $Enums.OrderTimeline
    estimatedCost: number
    actualCost?: number | null
    currency?: string
    status?: $Enums.OrderStatus
    priority?: $Enums.OrderPriority
    deliveryDate?: Date | string | null
    githubRepo?: string | null
    vercelLink?: string | null
    downloadLink?: string | null
    progressPercentage?: number
    currentMilestone?: string | null
    assignedAdminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    revisions?: OrderRevisionUncheckedCreateNestedManyWithoutOrderInput
    communications?: OrderCommunicationUncheckedCreateNestedManyWithoutOrderInput
    deliverables?: OrderDeliverableUncheckedCreateNestedManyWithoutOrderInput
  }

  export type AppOrderCreateOrConnectWithoutUserInput = {
    where: AppOrderWhereUniqueInput
    create: XOR<AppOrderCreateWithoutUserInput, AppOrderUncheckedCreateWithoutUserInput>
  }

  export type AppOrderCreateManyUserInputEnvelope = {
    data: AppOrderCreateManyUserInput | AppOrderCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OrderRevisionCreateWithoutUserInput = {
    id?: string
    revisionNumber: number
    title: string
    description: string
    status?: $Enums.RevisionStatus
    adminResponse?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order: AppOrderCreateNestedOneWithoutRevisionsInput
  }

  export type OrderRevisionUncheckedCreateWithoutUserInput = {
    id?: string
    orderId: string
    revisionNumber: number
    title: string
    description: string
    status?: $Enums.RevisionStatus
    adminResponse?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderRevisionCreateOrConnectWithoutUserInput = {
    where: OrderRevisionWhereUniqueInput
    create: XOR<OrderRevisionCreateWithoutUserInput, OrderRevisionUncheckedCreateWithoutUserInput>
  }

  export type OrderRevisionCreateManyUserInputEnvelope = {
    data: OrderRevisionCreateManyUserInput | OrderRevisionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OrderCommunicationCreateWithoutUserInput = {
    id?: string
    messageType: $Enums.CommunicationType
    subject?: string | null
    message: string
    isFromAdmin?: boolean
    attachments?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    important?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    order: AppOrderCreateNestedOneWithoutCommunicationsInput
  }

  export type OrderCommunicationUncheckedCreateWithoutUserInput = {
    id?: string
    orderId: string
    messageType: $Enums.CommunicationType
    subject?: string | null
    message: string
    isFromAdmin?: boolean
    attachments?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    important?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCommunicationCreateOrConnectWithoutUserInput = {
    where: OrderCommunicationWhereUniqueInput
    create: XOR<OrderCommunicationCreateWithoutUserInput, OrderCommunicationUncheckedCreateWithoutUserInput>
  }

  export type OrderCommunicationCreateManyUserInputEnvelope = {
    data: OrderCommunicationCreateManyUserInput | OrderCommunicationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BettingPositionCreateWithoutUserInput = {
    id?: string
    position: $Enums.PredictionDirection
    amount: number
    odds: number
    potentialWinning: number
    pickGroupId?: string | null
    multiplier?: number
    powerPlay?: boolean
    status?: $Enums.PositionStatus
    settled?: boolean
    won?: boolean | null
    payout?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    market: BettingMarketCreateNestedOneWithoutPositionsInput
  }

  export type BettingPositionUncheckedCreateWithoutUserInput = {
    id?: string
    marketId: string
    position: $Enums.PredictionDirection
    amount: number
    odds: number
    potentialWinning: number
    pickGroupId?: string | null
    multiplier?: number
    powerPlay?: boolean
    status?: $Enums.PositionStatus
    settled?: boolean
    won?: boolean | null
    payout?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BettingPositionCreateOrConnectWithoutUserInput = {
    where: BettingPositionWhereUniqueInput
    create: XOR<BettingPositionCreateWithoutUserInput, BettingPositionUncheckedCreateWithoutUserInput>
  }

  export type BettingPositionCreateManyUserInputEnvelope = {
    data: BettingPositionCreateManyUserInput | BettingPositionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BettingPayoutCreateWithoutUserInput = {
    id?: string
    positionId: string
    winnings: number
    originalBet: number
    multiplier: number
    status?: $Enums.PayoutStatus
    payoutDate?: Date | string | null
    transactionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    market: BettingMarketCreateNestedOneWithoutPayoutsInput
  }

  export type BettingPayoutUncheckedCreateWithoutUserInput = {
    id?: string
    marketId: string
    positionId: string
    winnings: number
    originalBet: number
    multiplier: number
    status?: $Enums.PayoutStatus
    payoutDate?: Date | string | null
    transactionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BettingPayoutCreateOrConnectWithoutUserInput = {
    where: BettingPayoutWhereUniqueInput
    create: XOR<BettingPayoutCreateWithoutUserInput, BettingPayoutUncheckedCreateWithoutUserInput>
  }

  export type BettingPayoutCreateManyUserInputEnvelope = {
    data: BettingPayoutCreateManyUserInput | BettingPayoutCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CardAuctionCreateWithoutOwnerInput = {
    id?: string
    title: string
    description?: string | null
    startPrice: number
    reservePrice?: number | null
    currentBid?: number | null
    bidIncrement?: number
    startTime?: Date | string
    endTime: Date | string
    autoExtend?: boolean
    status?: $Enums.AuctionStatus
    finalized?: boolean
    viewCount?: number
    watcherCount?: number
    bidCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    card: CardCreateNestedOneWithoutAuctionInput
    conditions?: AuctionConditionsCreateNestedOneWithoutAuctionInput
    winner?: UserCreateNestedOneWithoutWonAuctionsInput
    bids?: AuctionBidCreateNestedManyWithoutAuctionInput
    watchers?: AuctionWatcherCreateNestedManyWithoutAuctionInput
    history?: AuctionHistoryCreateNestedManyWithoutAuctionInput
  }

  export type CardAuctionUncheckedCreateWithoutOwnerInput = {
    id?: string
    cardId: string
    title: string
    description?: string | null
    startPrice: number
    reservePrice?: number | null
    currentBid?: number | null
    bidIncrement?: number
    startTime?: Date | string
    endTime: Date | string
    autoExtend?: boolean
    status?: $Enums.AuctionStatus
    finalized?: boolean
    winnerId?: string | null
    viewCount?: number
    watcherCount?: number
    bidCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    conditions?: AuctionConditionsUncheckedCreateNestedOneWithoutAuctionInput
    bids?: AuctionBidUncheckedCreateNestedManyWithoutAuctionInput
    watchers?: AuctionWatcherUncheckedCreateNestedManyWithoutAuctionInput
    history?: AuctionHistoryUncheckedCreateNestedManyWithoutAuctionInput
  }

  export type CardAuctionCreateOrConnectWithoutOwnerInput = {
    where: CardAuctionWhereUniqueInput
    create: XOR<CardAuctionCreateWithoutOwnerInput, CardAuctionUncheckedCreateWithoutOwnerInput>
  }

  export type CardAuctionCreateManyOwnerInputEnvelope = {
    data: CardAuctionCreateManyOwnerInput | CardAuctionCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type CardAuctionCreateWithoutWinnerInput = {
    id?: string
    title: string
    description?: string | null
    startPrice: number
    reservePrice?: number | null
    currentBid?: number | null
    bidIncrement?: number
    startTime?: Date | string
    endTime: Date | string
    autoExtend?: boolean
    status?: $Enums.AuctionStatus
    finalized?: boolean
    viewCount?: number
    watcherCount?: number
    bidCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    card: CardCreateNestedOneWithoutAuctionInput
    owner: UserCreateNestedOneWithoutOwnedAuctionsInput
    conditions?: AuctionConditionsCreateNestedOneWithoutAuctionInput
    bids?: AuctionBidCreateNestedManyWithoutAuctionInput
    watchers?: AuctionWatcherCreateNestedManyWithoutAuctionInput
    history?: AuctionHistoryCreateNestedManyWithoutAuctionInput
  }

  export type CardAuctionUncheckedCreateWithoutWinnerInput = {
    id?: string
    cardId: string
    ownerId: string
    title: string
    description?: string | null
    startPrice: number
    reservePrice?: number | null
    currentBid?: number | null
    bidIncrement?: number
    startTime?: Date | string
    endTime: Date | string
    autoExtend?: boolean
    status?: $Enums.AuctionStatus
    finalized?: boolean
    viewCount?: number
    watcherCount?: number
    bidCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    conditions?: AuctionConditionsUncheckedCreateNestedOneWithoutAuctionInput
    bids?: AuctionBidUncheckedCreateNestedManyWithoutAuctionInput
    watchers?: AuctionWatcherUncheckedCreateNestedManyWithoutAuctionInput
    history?: AuctionHistoryUncheckedCreateNestedManyWithoutAuctionInput
  }

  export type CardAuctionCreateOrConnectWithoutWinnerInput = {
    where: CardAuctionWhereUniqueInput
    create: XOR<CardAuctionCreateWithoutWinnerInput, CardAuctionUncheckedCreateWithoutWinnerInput>
  }

  export type CardAuctionCreateManyWinnerInputEnvelope = {
    data: CardAuctionCreateManyWinnerInput | CardAuctionCreateManyWinnerInput[]
    skipDuplicates?: boolean
  }

  export type AuctionBidCreateWithoutBidderInput = {
    id?: string
    bidAmount: number
    maxAutoBid?: number | null
    bidType?: $Enums.BidType
    status?: $Enums.AuctionBidStatus
    isWinning?: boolean
    outbidNotified?: boolean
    userAgent?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auction: CardAuctionCreateNestedOneWithoutBidsInput
  }

  export type AuctionBidUncheckedCreateWithoutBidderInput = {
    id?: string
    auctionId: string
    bidAmount: number
    maxAutoBid?: number | null
    bidType?: $Enums.BidType
    status?: $Enums.AuctionBidStatus
    isWinning?: boolean
    outbidNotified?: boolean
    userAgent?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuctionBidCreateOrConnectWithoutBidderInput = {
    where: AuctionBidWhereUniqueInput
    create: XOR<AuctionBidCreateWithoutBidderInput, AuctionBidUncheckedCreateWithoutBidderInput>
  }

  export type AuctionBidCreateManyBidderInputEnvelope = {
    data: AuctionBidCreateManyBidderInput | AuctionBidCreateManyBidderInput[]
    skipDuplicates?: boolean
  }

  export type AuctionWatcherCreateWithoutUserInput = {
    id?: string
    bidNotifications?: boolean
    endingNotifications?: boolean
    priceAlerts?: boolean
    alertThreshold?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auction: CardAuctionCreateNestedOneWithoutWatchersInput
  }

  export type AuctionWatcherUncheckedCreateWithoutUserInput = {
    id?: string
    auctionId: string
    bidNotifications?: boolean
    endingNotifications?: boolean
    priceAlerts?: boolean
    alertThreshold?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuctionWatcherCreateOrConnectWithoutUserInput = {
    where: AuctionWatcherWhereUniqueInput
    create: XOR<AuctionWatcherCreateWithoutUserInput, AuctionWatcherUncheckedCreateWithoutUserInput>
  }

  export type AuctionWatcherCreateManyUserInputEnvelope = {
    data: AuctionWatcherCreateManyUserInput | AuctionWatcherCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MABattleCreateWithoutInitiatorInput = {
    id?: string
    battleType: $Enums.BattleType
    title: string
    description: string
    stakes: number
    timeline: Date | string
    votingPeriod: Date | string
    status?: $Enums.BattleStatus
    resolved?: boolean
    viewCount?: number
    participantCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    initiatorCard: CardCreateNestedOneWithoutInitiatedBattlesInput
    targetCard: CardCreateNestedOneWithoutTargetedBattlesInput
    target?: UserCreateNestedOneWithoutTargetedMABattlesInput
    winner?: BattleOutcomeCreateNestedOneWithoutWinningBattleInput
    proposals?: BattleProposalCreateNestedManyWithoutBattleInput
    votes?: BattleVotingCreateNestedManyWithoutBattleInput
    outcomes?: BattleOutcomeCreateNestedManyWithoutBattleInput
  }

  export type MABattleUncheckedCreateWithoutInitiatorInput = {
    id?: string
    initiatorCardId: string
    targetCardId: string
    targetUserId?: string | null
    battleType: $Enums.BattleType
    title: string
    description: string
    stakes: number
    timeline: Date | string
    votingPeriod: Date | string
    status?: $Enums.BattleStatus
    resolved?: boolean
    viewCount?: number
    participantCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    winner?: BattleOutcomeUncheckedCreateNestedOneWithoutWinningBattleInput
    proposals?: BattleProposalUncheckedCreateNestedManyWithoutBattleInput
    votes?: BattleVotingUncheckedCreateNestedManyWithoutBattleInput
    outcomes?: BattleOutcomeUncheckedCreateNestedManyWithoutBattleInput
  }

  export type MABattleCreateOrConnectWithoutInitiatorInput = {
    where: MABattleWhereUniqueInput
    create: XOR<MABattleCreateWithoutInitiatorInput, MABattleUncheckedCreateWithoutInitiatorInput>
  }

  export type MABattleCreateManyInitiatorInputEnvelope = {
    data: MABattleCreateManyInitiatorInput | MABattleCreateManyInitiatorInput[]
    skipDuplicates?: boolean
  }

  export type MABattleCreateWithoutTargetInput = {
    id?: string
    battleType: $Enums.BattleType
    title: string
    description: string
    stakes: number
    timeline: Date | string
    votingPeriod: Date | string
    status?: $Enums.BattleStatus
    resolved?: boolean
    viewCount?: number
    participantCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    initiatorCard: CardCreateNestedOneWithoutInitiatedBattlesInput
    targetCard: CardCreateNestedOneWithoutTargetedBattlesInput
    initiator: UserCreateNestedOneWithoutInitiatedMABattlesInput
    winner?: BattleOutcomeCreateNestedOneWithoutWinningBattleInput
    proposals?: BattleProposalCreateNestedManyWithoutBattleInput
    votes?: BattleVotingCreateNestedManyWithoutBattleInput
    outcomes?: BattleOutcomeCreateNestedManyWithoutBattleInput
  }

  export type MABattleUncheckedCreateWithoutTargetInput = {
    id?: string
    initiatorCardId: string
    targetCardId: string
    initiatorUserId: string
    battleType: $Enums.BattleType
    title: string
    description: string
    stakes: number
    timeline: Date | string
    votingPeriod: Date | string
    status?: $Enums.BattleStatus
    resolved?: boolean
    viewCount?: number
    participantCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    winner?: BattleOutcomeUncheckedCreateNestedOneWithoutWinningBattleInput
    proposals?: BattleProposalUncheckedCreateNestedManyWithoutBattleInput
    votes?: BattleVotingUncheckedCreateNestedManyWithoutBattleInput
    outcomes?: BattleOutcomeUncheckedCreateNestedManyWithoutBattleInput
  }

  export type MABattleCreateOrConnectWithoutTargetInput = {
    where: MABattleWhereUniqueInput
    create: XOR<MABattleCreateWithoutTargetInput, MABattleUncheckedCreateWithoutTargetInput>
  }

  export type MABattleCreateManyTargetInputEnvelope = {
    data: MABattleCreateManyTargetInput | MABattleCreateManyTargetInput[]
    skipDuplicates?: boolean
  }

  export type BattleProposalCreateWithoutProposerInput = {
    id?: string
    proposalType: $Enums.ProposalType
    title: string
    description: string
    terms: JsonNullValueInput | InputJsonValue
    valuation: number
    paymentStructure: JsonNullValueInput | InputJsonValue
    timeline: JsonNullValueInput | InputJsonValue
    synergies: JsonNullValueInput | InputJsonValue
    conditions: JsonNullValueInput | InputJsonValue
    contingencies: JsonNullValueInput | InputJsonValue
    status?: $Enums.ProposalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    battle: MABattleCreateNestedOneWithoutProposalsInput
    votes?: BattleVotingCreateNestedManyWithoutProposalInput
  }

  export type BattleProposalUncheckedCreateWithoutProposerInput = {
    id?: string
    battleId: string
    proposalType: $Enums.ProposalType
    title: string
    description: string
    terms: JsonNullValueInput | InputJsonValue
    valuation: number
    paymentStructure: JsonNullValueInput | InputJsonValue
    timeline: JsonNullValueInput | InputJsonValue
    synergies: JsonNullValueInput | InputJsonValue
    conditions: JsonNullValueInput | InputJsonValue
    contingencies: JsonNullValueInput | InputJsonValue
    status?: $Enums.ProposalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: BattleVotingUncheckedCreateNestedManyWithoutProposalInput
  }

  export type BattleProposalCreateOrConnectWithoutProposerInput = {
    where: BattleProposalWhereUniqueInput
    create: XOR<BattleProposalCreateWithoutProposerInput, BattleProposalUncheckedCreateWithoutProposerInput>
  }

  export type BattleProposalCreateManyProposerInputEnvelope = {
    data: BattleProposalCreateManyProposerInput | BattleProposalCreateManyProposerInput[]
    skipDuplicates?: boolean
  }

  export type BattleVotingCreateWithoutVoterInput = {
    id?: string
    vote: $Enums.VoteDirection
    voteWeight: number
    reasoning?: string | null
    confidence?: number | null
    eceStaked?: number | null
    expertRating?: number | null
    portfolioValue?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    battle: MABattleCreateNestedOneWithoutVotesInput
    proposal?: BattleProposalCreateNestedOneWithoutVotesInput
  }

  export type BattleVotingUncheckedCreateWithoutVoterInput = {
    id?: string
    battleId: string
    proposalId?: string | null
    vote: $Enums.VoteDirection
    voteWeight: number
    reasoning?: string | null
    confidence?: number | null
    eceStaked?: number | null
    expertRating?: number | null
    portfolioValue?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BattleVotingCreateOrConnectWithoutVoterInput = {
    where: BattleVotingWhereUniqueInput
    create: XOR<BattleVotingCreateWithoutVoterInput, BattleVotingUncheckedCreateWithoutVoterInput>
  }

  export type BattleVotingCreateManyVoterInputEnvelope = {
    data: BattleVotingCreateManyVoterInput | BattleVotingCreateManyVoterInput[]
    skipDuplicates?: boolean
  }

  export type StakingPositionCreateWithoutUserInput = {
    id?: string
    amount: number
    stakedAt?: Date | string
    unstakedAt?: Date | string | null
    lockupEndsAt?: Date | string | null
    isActive?: boolean
    pool: StakingPoolCreateNestedOneWithoutStakesInput
    rewards?: StakingRewardCreateNestedManyWithoutPositionInput
  }

  export type StakingPositionUncheckedCreateWithoutUserInput = {
    id?: string
    poolId: string
    amount: number
    stakedAt?: Date | string
    unstakedAt?: Date | string | null
    lockupEndsAt?: Date | string | null
    isActive?: boolean
    rewards?: StakingRewardUncheckedCreateNestedManyWithoutPositionInput
  }

  export type StakingPositionCreateOrConnectWithoutUserInput = {
    where: StakingPositionWhereUniqueInput
    create: XOR<StakingPositionCreateWithoutUserInput, StakingPositionUncheckedCreateWithoutUserInput>
  }

  export type StakingPositionCreateManyUserInputEnvelope = {
    data: StakingPositionCreateManyUserInput | StakingPositionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type StakingRewardCreateWithoutUserInput = {
    id?: string
    amount: number
    rewardType: $Enums.StakingRewardType
    claimedAt?: Date | string | null
    createdAt?: Date | string
    pool: StakingPoolCreateNestedOneWithoutRewardsInput
    position: StakingPositionCreateNestedOneWithoutRewardsInput
  }

  export type StakingRewardUncheckedCreateWithoutUserInput = {
    id?: string
    poolId: string
    positionId: string
    amount: number
    rewardType: $Enums.StakingRewardType
    claimedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type StakingRewardCreateOrConnectWithoutUserInput = {
    where: StakingRewardWhereUniqueInput
    create: XOR<StakingRewardCreateWithoutUserInput, StakingRewardUncheckedCreateWithoutUserInput>
  }

  export type StakingRewardCreateManyUserInputEnvelope = {
    data: StakingRewardCreateManyUserInput | StakingRewardCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type GovernanceProposalCreateWithoutProposerInput = {
    id?: string
    title: string
    description: string
    proposalType: $Enums.ProposalType
    status?: $Enums.GovernanceStatus
    votingStartsAt: Date | string
    votingEndsAt: Date | string
    executionDate?: Date | string | null
    minQuorum?: number
    minApproval?: number
    totalVotes?: number
    yesVotes?: number
    noVotes?: number
    abstainVotes?: number
    isExecuted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    votes?: GovernanceVoteCreateNestedManyWithoutProposalInput
  }

  export type GovernanceProposalUncheckedCreateWithoutProposerInput = {
    id?: string
    title: string
    description: string
    proposalType: $Enums.ProposalType
    status?: $Enums.GovernanceStatus
    votingStartsAt: Date | string
    votingEndsAt: Date | string
    executionDate?: Date | string | null
    minQuorum?: number
    minApproval?: number
    totalVotes?: number
    yesVotes?: number
    noVotes?: number
    abstainVotes?: number
    isExecuted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    votes?: GovernanceVoteUncheckedCreateNestedManyWithoutProposalInput
  }

  export type GovernanceProposalCreateOrConnectWithoutProposerInput = {
    where: GovernanceProposalWhereUniqueInput
    create: XOR<GovernanceProposalCreateWithoutProposerInput, GovernanceProposalUncheckedCreateWithoutProposerInput>
  }

  export type GovernanceProposalCreateManyProposerInputEnvelope = {
    data: GovernanceProposalCreateManyProposerInput | GovernanceProposalCreateManyProposerInput[]
    skipDuplicates?: boolean
  }

  export type GovernanceVoteCreateWithoutUserInput = {
    id?: string
    voteChoice: $Enums.VoteChoice
    votingPower: number
    reason?: string | null
    votedAt?: Date | string
    proposal: GovernanceProposalCreateNestedOneWithoutVotesInput
  }

  export type GovernanceVoteUncheckedCreateWithoutUserInput = {
    id?: string
    proposalId: string
    voteChoice: $Enums.VoteChoice
    votingPower: number
    reason?: string | null
    votedAt?: Date | string
  }

  export type GovernanceVoteCreateOrConnectWithoutUserInput = {
    where: GovernanceVoteWhereUniqueInput
    create: XOR<GovernanceVoteCreateWithoutUserInput, GovernanceVoteUncheckedCreateWithoutUserInput>
  }

  export type GovernanceVoteCreateManyUserInputEnvelope = {
    data: GovernanceVoteCreateManyUserInput | GovernanceVoteCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    priority?: $Enums.NotificationPriority
    requiresSubscription?: $Enums.SubscriptionPlan | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    priority?: $Enums.NotificationPriority
    requiresSubscription?: $Enums.SubscriptionPlan | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SocialFeedCreateWithoutUserInput = {
    id?: string
    type: $Enums.SocialFeedType
    content: string
    data?: NullableJsonNullValueInput | InputJsonValue
    likes?: number
    comments?: number
    shares?: number
    visibility?: $Enums.SocialVisibility
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SocialFeedUncheckedCreateWithoutUserInput = {
    id?: string
    type: $Enums.SocialFeedType
    content: string
    data?: NullableJsonNullValueInput | InputJsonValue
    likes?: number
    comments?: number
    shares?: number
    visibility?: $Enums.SocialVisibility
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SocialFeedCreateOrConnectWithoutUserInput = {
    where: SocialFeedWhereUniqueInput
    create: XOR<SocialFeedCreateWithoutUserInput, SocialFeedUncheckedCreateWithoutUserInput>
  }

  export type SocialFeedCreateManyUserInputEnvelope = {
    data: SocialFeedCreateManyUserInput | SocialFeedCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FollowCreateWithoutFollowerInput = {
    id?: string
    createdAt?: Date | string
    following: UserCreateNestedOneWithoutFollowingInput
  }

  export type FollowUncheckedCreateWithoutFollowerInput = {
    id?: string
    followingId: string
    createdAt?: Date | string
  }

  export type FollowCreateOrConnectWithoutFollowerInput = {
    where: FollowWhereUniqueInput
    create: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput>
  }

  export type FollowCreateManyFollowerInputEnvelope = {
    data: FollowCreateManyFollowerInput | FollowCreateManyFollowerInput[]
    skipDuplicates?: boolean
  }

  export type FollowCreateWithoutFollowingInput = {
    id?: string
    createdAt?: Date | string
    follower: UserCreateNestedOneWithoutFollowersInput
  }

  export type FollowUncheckedCreateWithoutFollowingInput = {
    id?: string
    followerId: string
    createdAt?: Date | string
  }

  export type FollowCreateOrConnectWithoutFollowingInput = {
    where: FollowWhereUniqueInput
    create: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput>
  }

  export type FollowCreateManyFollowingInputEnvelope = {
    data: FollowCreateManyFollowingInput | FollowCreateManyFollowingInput[]
    skipDuplicates?: boolean
  }

  export type UserSubscriptionUpsertWithoutUserInput = {
    update: XOR<UserSubscriptionUpdateWithoutUserInput, UserSubscriptionUncheckedUpdateWithoutUserInput>
    create: XOR<UserSubscriptionCreateWithoutUserInput, UserSubscriptionUncheckedCreateWithoutUserInput>
    where?: UserSubscriptionWhereInput
  }

  export type UserSubscriptionUpdateToOneWithWhereWithoutUserInput = {
    where?: UserSubscriptionWhereInput
    data: XOR<UserSubscriptionUpdateWithoutUserInput, UserSubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type UserSubscriptionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: SubscriptionFeaturesUpdateOneWithoutSubscriptionNestedInput
    usage?: SubscriptionUsageUpdateOneWithoutSubscriptionNestedInput
  }

  export type UserSubscriptionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: SubscriptionFeaturesUncheckedUpdateOneWithoutSubscriptionNestedInput
    usage?: SubscriptionUsageUncheckedUpdateOneWithoutSubscriptionNestedInput
  }

  export type CryptoWalletUpsertWithWhereUniqueWithoutUserInput = {
    where: CryptoWalletWhereUniqueInput
    update: XOR<CryptoWalletUpdateWithoutUserInput, CryptoWalletUncheckedUpdateWithoutUserInput>
    create: XOR<CryptoWalletCreateWithoutUserInput, CryptoWalletUncheckedCreateWithoutUserInput>
  }

  export type CryptoWalletUpdateWithWhereUniqueWithoutUserInput = {
    where: CryptoWalletWhereUniqueInput
    data: XOR<CryptoWalletUpdateWithoutUserInput, CryptoWalletUncheckedUpdateWithoutUserInput>
  }

  export type CryptoWalletUpdateManyWithWhereWithoutUserInput = {
    where: CryptoWalletScalarWhereInput
    data: XOR<CryptoWalletUpdateManyMutationInput, CryptoWalletUncheckedUpdateManyWithoutUserInput>
  }

  export type CryptoWalletScalarWhereInput = {
    AND?: CryptoWalletScalarWhereInput | CryptoWalletScalarWhereInput[]
    OR?: CryptoWalletScalarWhereInput[]
    NOT?: CryptoWalletScalarWhereInput | CryptoWalletScalarWhereInput[]
    id?: StringFilter<"CryptoWallet"> | string
    userId?: StringFilter<"CryptoWallet"> | string
    currency?: StringFilter<"CryptoWallet"> | string
    address?: StringFilter<"CryptoWallet"> | string
    balance?: FloatFilter<"CryptoWallet"> | number
    createdAt?: DateTimeFilter<"CryptoWallet"> | Date | string
    updatedAt?: DateTimeFilter<"CryptoWallet"> | Date | string
  }

  export type PhysicalCardUpsertWithoutUserInput = {
    update: XOR<PhysicalCardUpdateWithoutUserInput, PhysicalCardUncheckedUpdateWithoutUserInput>
    create: XOR<PhysicalCardCreateWithoutUserInput, PhysicalCardUncheckedCreateWithoutUserInput>
    where?: PhysicalCardWhereInput
  }

  export type PhysicalCardUpdateToOneWithWhereWithoutUserInput = {
    where?: PhysicalCardWhereInput
    data: XOR<PhysicalCardUpdateWithoutUserInput, PhysicalCardUncheckedUpdateWithoutUserInput>
  }

  export type PhysicalCardUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardNumber?: StringFieldUpdateOperationsInput | string
    expiryDate?: StringFieldUpdateOperationsInput | string
    cvv?: StringFieldUpdateOperationsInput | string
    status?: EnumPhysicalCardStatusFieldUpdateOperationsInput | $Enums.PhysicalCardStatus
    appleWalletPassId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhysicalCardUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardNumber?: StringFieldUpdateOperationsInput | string
    expiryDate?: StringFieldUpdateOperationsInput | string
    cvv?: StringFieldUpdateOperationsInput | string
    status?: EnumPhysicalCardStatusFieldUpdateOperationsInput | $Enums.PhysicalCardStatus
    appleWalletPassId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CardUpsertWithWhereUniqueWithoutOwnerInput = {
    where: CardWhereUniqueInput
    update: XOR<CardUpdateWithoutOwnerInput, CardUncheckedUpdateWithoutOwnerInput>
    create: XOR<CardCreateWithoutOwnerInput, CardUncheckedCreateWithoutOwnerInput>
  }

  export type CardUpdateWithWhereUniqueWithoutOwnerInput = {
    where: CardWhereUniqueInput
    data: XOR<CardUpdateWithoutOwnerInput, CardUncheckedUpdateWithoutOwnerInput>
  }

  export type CardUpdateManyWithWhereWithoutOwnerInput = {
    where: CardScalarWhereInput
    data: XOR<CardUpdateManyMutationInput, CardUncheckedUpdateManyWithoutOwnerInput>
  }

  export type CardScalarWhereInput = {
    AND?: CardScalarWhereInput | CardScalarWhereInput[]
    OR?: CardScalarWhereInput[]
    NOT?: CardScalarWhereInput | CardScalarWhereInput[]
    id?: StringFilter<"Card"> | string
    name?: StringFilter<"Card"> | string
    description?: StringNullableFilter<"Card"> | string | null
    category?: EnumCardCategoryFilter<"Card"> | $Enums.CardCategory
    rarity?: EnumCardRarityFilter<"Card"> | $Enums.CardRarity
    company?: StringNullableFilter<"Card"> | string | null
    currentPrice?: FloatFilter<"Card"> | number
    historicalPrices?: JsonNullableFilter<"Card">
    imageUrl?: StringNullableFilter<"Card"> | string | null
    metadata?: JsonNullableFilter<"Card">
    stats?: JsonNullableFilter<"Card">
    ownerId?: StringFilter<"Card"> | string
    createdAt?: DateTimeFilter<"Card"> | Date | string
    updatedAt?: DateTimeFilter<"Card"> | Date | string
  }

  export type TransactionUpsertWithWhereUniqueWithoutUserInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutUserInput, TransactionUncheckedUpdateWithoutUserInput>
    create: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutUserInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutUserInput, TransactionUncheckedUpdateWithoutUserInput>
  }

  export type TransactionUpdateManyWithWhereWithoutUserInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutUserInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: StringFilter<"Transaction"> | string
    userId?: StringFilter<"Transaction"> | string
    cardId?: StringNullableFilter<"Transaction"> | string | null
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    amount?: FloatFilter<"Transaction"> | number
    currency?: StringFilter<"Transaction"> | string
    status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    description?: StringNullableFilter<"Transaction"> | string | null
    metadata?: JsonNullableFilter<"Transaction">
    paymentMethod?: StringNullableFilter<"Transaction"> | string | null
    paymentId?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
  }

  export type BidUpsertWithWhereUniqueWithoutBidderInput = {
    where: BidWhereUniqueInput
    update: XOR<BidUpdateWithoutBidderInput, BidUncheckedUpdateWithoutBidderInput>
    create: XOR<BidCreateWithoutBidderInput, BidUncheckedCreateWithoutBidderInput>
  }

  export type BidUpdateWithWhereUniqueWithoutBidderInput = {
    where: BidWhereUniqueInput
    data: XOR<BidUpdateWithoutBidderInput, BidUncheckedUpdateWithoutBidderInput>
  }

  export type BidUpdateManyWithWhereWithoutBidderInput = {
    where: BidScalarWhereInput
    data: XOR<BidUpdateManyMutationInput, BidUncheckedUpdateManyWithoutBidderInput>
  }

  export type BidScalarWhereInput = {
    AND?: BidScalarWhereInput | BidScalarWhereInput[]
    OR?: BidScalarWhereInput[]
    NOT?: BidScalarWhereInput | BidScalarWhereInput[]
    id?: StringFilter<"Bid"> | string
    listingId?: StringFilter<"Bid"> | string
    bidderId?: StringFilter<"Bid"> | string
    cardId?: StringFilter<"Bid"> | string
    amount?: FloatFilter<"Bid"> | number
    status?: EnumBidStatusFilter<"Bid"> | $Enums.BidStatus
    createdAt?: DateTimeFilter<"Bid"> | Date | string
    updatedAt?: DateTimeFilter<"Bid"> | Date | string
  }

  export type MarketplaceListingUpsertWithWhereUniqueWithoutSellerInput = {
    where: MarketplaceListingWhereUniqueInput
    update: XOR<MarketplaceListingUpdateWithoutSellerInput, MarketplaceListingUncheckedUpdateWithoutSellerInput>
    create: XOR<MarketplaceListingCreateWithoutSellerInput, MarketplaceListingUncheckedCreateWithoutSellerInput>
  }

  export type MarketplaceListingUpdateWithWhereUniqueWithoutSellerInput = {
    where: MarketplaceListingWhereUniqueInput
    data: XOR<MarketplaceListingUpdateWithoutSellerInput, MarketplaceListingUncheckedUpdateWithoutSellerInput>
  }

  export type MarketplaceListingUpdateManyWithWhereWithoutSellerInput = {
    where: MarketplaceListingScalarWhereInput
    data: XOR<MarketplaceListingUpdateManyMutationInput, MarketplaceListingUncheckedUpdateManyWithoutSellerInput>
  }

  export type MarketplaceListingScalarWhereInput = {
    AND?: MarketplaceListingScalarWhereInput | MarketplaceListingScalarWhereInput[]
    OR?: MarketplaceListingScalarWhereInput[]
    NOT?: MarketplaceListingScalarWhereInput | MarketplaceListingScalarWhereInput[]
    id?: StringFilter<"MarketplaceListing"> | string
    cardId?: StringFilter<"MarketplaceListing"> | string
    sellerId?: StringFilter<"MarketplaceListing"> | string
    price?: FloatFilter<"MarketplaceListing"> | number
    listingType?: EnumListingTypeFilter<"MarketplaceListing"> | $Enums.ListingType
    auctionEnd?: DateTimeNullableFilter<"MarketplaceListing"> | Date | string | null
    status?: EnumListingStatusFilter<"MarketplaceListing"> | $Enums.ListingStatus
    featured?: BoolFilter<"MarketplaceListing"> | boolean
    createdAt?: DateTimeFilter<"MarketplaceListing"> | Date | string
    updatedAt?: DateTimeFilter<"MarketplaceListing"> | Date | string
  }

  export type AppOrderUpsertWithWhereUniqueWithoutUserInput = {
    where: AppOrderWhereUniqueInput
    update: XOR<AppOrderUpdateWithoutUserInput, AppOrderUncheckedUpdateWithoutUserInput>
    create: XOR<AppOrderCreateWithoutUserInput, AppOrderUncheckedCreateWithoutUserInput>
  }

  export type AppOrderUpdateWithWhereUniqueWithoutUserInput = {
    where: AppOrderWhereUniqueInput
    data: XOR<AppOrderUpdateWithoutUserInput, AppOrderUncheckedUpdateWithoutUserInput>
  }

  export type AppOrderUpdateManyWithWhereWithoutUserInput = {
    where: AppOrderScalarWhereInput
    data: XOR<AppOrderUpdateManyMutationInput, AppOrderUncheckedUpdateManyWithoutUserInput>
  }

  export type AppOrderScalarWhereInput = {
    AND?: AppOrderScalarWhereInput | AppOrderScalarWhereInput[]
    OR?: AppOrderScalarWhereInput[]
    NOT?: AppOrderScalarWhereInput | AppOrderScalarWhereInput[]
    id?: StringFilter<"AppOrder"> | string
    userId?: StringFilter<"AppOrder"> | string
    projectType?: EnumProjectTypeFilter<"AppOrder"> | $Enums.ProjectType
    title?: StringFilter<"AppOrder"> | string
    description?: StringFilter<"AppOrder"> | string
    requirements?: JsonNullableFilter<"AppOrder">
    timeline?: EnumOrderTimelineFilter<"AppOrder"> | $Enums.OrderTimeline
    estimatedCost?: FloatFilter<"AppOrder"> | number
    actualCost?: FloatNullableFilter<"AppOrder"> | number | null
    currency?: StringFilter<"AppOrder"> | string
    status?: EnumOrderStatusFilter<"AppOrder"> | $Enums.OrderStatus
    priority?: EnumOrderPriorityFilter<"AppOrder"> | $Enums.OrderPriority
    deliveryDate?: DateTimeNullableFilter<"AppOrder"> | Date | string | null
    githubRepo?: StringNullableFilter<"AppOrder"> | string | null
    vercelLink?: StringNullableFilter<"AppOrder"> | string | null
    downloadLink?: StringNullableFilter<"AppOrder"> | string | null
    progressPercentage?: IntFilter<"AppOrder"> | number
    currentMilestone?: StringNullableFilter<"AppOrder"> | string | null
    assignedAdminId?: StringNullableFilter<"AppOrder"> | string | null
    createdAt?: DateTimeFilter<"AppOrder"> | Date | string
    updatedAt?: DateTimeFilter<"AppOrder"> | Date | string
  }

  export type OrderRevisionUpsertWithWhereUniqueWithoutUserInput = {
    where: OrderRevisionWhereUniqueInput
    update: XOR<OrderRevisionUpdateWithoutUserInput, OrderRevisionUncheckedUpdateWithoutUserInput>
    create: XOR<OrderRevisionCreateWithoutUserInput, OrderRevisionUncheckedCreateWithoutUserInput>
  }

  export type OrderRevisionUpdateWithWhereUniqueWithoutUserInput = {
    where: OrderRevisionWhereUniqueInput
    data: XOR<OrderRevisionUpdateWithoutUserInput, OrderRevisionUncheckedUpdateWithoutUserInput>
  }

  export type OrderRevisionUpdateManyWithWhereWithoutUserInput = {
    where: OrderRevisionScalarWhereInput
    data: XOR<OrderRevisionUpdateManyMutationInput, OrderRevisionUncheckedUpdateManyWithoutUserInput>
  }

  export type OrderRevisionScalarWhereInput = {
    AND?: OrderRevisionScalarWhereInput | OrderRevisionScalarWhereInput[]
    OR?: OrderRevisionScalarWhereInput[]
    NOT?: OrderRevisionScalarWhereInput | OrderRevisionScalarWhereInput[]
    id?: StringFilter<"OrderRevision"> | string
    orderId?: StringFilter<"OrderRevision"> | string
    userId?: StringFilter<"OrderRevision"> | string
    revisionNumber?: IntFilter<"OrderRevision"> | number
    title?: StringFilter<"OrderRevision"> | string
    description?: StringFilter<"OrderRevision"> | string
    status?: EnumRevisionStatusFilter<"OrderRevision"> | $Enums.RevisionStatus
    adminResponse?: StringNullableFilter<"OrderRevision"> | string | null
    adminId?: StringNullableFilter<"OrderRevision"> | string | null
    createdAt?: DateTimeFilter<"OrderRevision"> | Date | string
    updatedAt?: DateTimeFilter<"OrderRevision"> | Date | string
  }

  export type OrderCommunicationUpsertWithWhereUniqueWithoutUserInput = {
    where: OrderCommunicationWhereUniqueInput
    update: XOR<OrderCommunicationUpdateWithoutUserInput, OrderCommunicationUncheckedUpdateWithoutUserInput>
    create: XOR<OrderCommunicationCreateWithoutUserInput, OrderCommunicationUncheckedCreateWithoutUserInput>
  }

  export type OrderCommunicationUpdateWithWhereUniqueWithoutUserInput = {
    where: OrderCommunicationWhereUniqueInput
    data: XOR<OrderCommunicationUpdateWithoutUserInput, OrderCommunicationUncheckedUpdateWithoutUserInput>
  }

  export type OrderCommunicationUpdateManyWithWhereWithoutUserInput = {
    where: OrderCommunicationScalarWhereInput
    data: XOR<OrderCommunicationUpdateManyMutationInput, OrderCommunicationUncheckedUpdateManyWithoutUserInput>
  }

  export type OrderCommunicationScalarWhereInput = {
    AND?: OrderCommunicationScalarWhereInput | OrderCommunicationScalarWhereInput[]
    OR?: OrderCommunicationScalarWhereInput[]
    NOT?: OrderCommunicationScalarWhereInput | OrderCommunicationScalarWhereInput[]
    id?: StringFilter<"OrderCommunication"> | string
    orderId?: StringFilter<"OrderCommunication"> | string
    userId?: StringFilter<"OrderCommunication"> | string
    messageType?: EnumCommunicationTypeFilter<"OrderCommunication"> | $Enums.CommunicationType
    subject?: StringNullableFilter<"OrderCommunication"> | string | null
    message?: StringFilter<"OrderCommunication"> | string
    isFromAdmin?: BoolFilter<"OrderCommunication"> | boolean
    attachments?: JsonNullableFilter<"OrderCommunication">
    read?: BoolFilter<"OrderCommunication"> | boolean
    important?: BoolFilter<"OrderCommunication"> | boolean
    createdAt?: DateTimeFilter<"OrderCommunication"> | Date | string
    updatedAt?: DateTimeFilter<"OrderCommunication"> | Date | string
  }

  export type BettingPositionUpsertWithWhereUniqueWithoutUserInput = {
    where: BettingPositionWhereUniqueInput
    update: XOR<BettingPositionUpdateWithoutUserInput, BettingPositionUncheckedUpdateWithoutUserInput>
    create: XOR<BettingPositionCreateWithoutUserInput, BettingPositionUncheckedCreateWithoutUserInput>
  }

  export type BettingPositionUpdateWithWhereUniqueWithoutUserInput = {
    where: BettingPositionWhereUniqueInput
    data: XOR<BettingPositionUpdateWithoutUserInput, BettingPositionUncheckedUpdateWithoutUserInput>
  }

  export type BettingPositionUpdateManyWithWhereWithoutUserInput = {
    where: BettingPositionScalarWhereInput
    data: XOR<BettingPositionUpdateManyMutationInput, BettingPositionUncheckedUpdateManyWithoutUserInput>
  }

  export type BettingPositionScalarWhereInput = {
    AND?: BettingPositionScalarWhereInput | BettingPositionScalarWhereInput[]
    OR?: BettingPositionScalarWhereInput[]
    NOT?: BettingPositionScalarWhereInput | BettingPositionScalarWhereInput[]
    id?: StringFilter<"BettingPosition"> | string
    marketId?: StringFilter<"BettingPosition"> | string
    userId?: StringFilter<"BettingPosition"> | string
    position?: EnumPredictionDirectionFilter<"BettingPosition"> | $Enums.PredictionDirection
    amount?: FloatFilter<"BettingPosition"> | number
    odds?: FloatFilter<"BettingPosition"> | number
    potentialWinning?: FloatFilter<"BettingPosition"> | number
    pickGroupId?: StringNullableFilter<"BettingPosition"> | string | null
    multiplier?: FloatFilter<"BettingPosition"> | number
    powerPlay?: BoolFilter<"BettingPosition"> | boolean
    status?: EnumPositionStatusFilter<"BettingPosition"> | $Enums.PositionStatus
    settled?: BoolFilter<"BettingPosition"> | boolean
    won?: BoolNullableFilter<"BettingPosition"> | boolean | null
    payout?: FloatNullableFilter<"BettingPosition"> | number | null
    createdAt?: DateTimeFilter<"BettingPosition"> | Date | string
    updatedAt?: DateTimeFilter<"BettingPosition"> | Date | string
  }

  export type BettingPayoutUpsertWithWhereUniqueWithoutUserInput = {
    where: BettingPayoutWhereUniqueInput
    update: XOR<BettingPayoutUpdateWithoutUserInput, BettingPayoutUncheckedUpdateWithoutUserInput>
    create: XOR<BettingPayoutCreateWithoutUserInput, BettingPayoutUncheckedCreateWithoutUserInput>
  }

  export type BettingPayoutUpdateWithWhereUniqueWithoutUserInput = {
    where: BettingPayoutWhereUniqueInput
    data: XOR<BettingPayoutUpdateWithoutUserInput, BettingPayoutUncheckedUpdateWithoutUserInput>
  }

  export type BettingPayoutUpdateManyWithWhereWithoutUserInput = {
    where: BettingPayoutScalarWhereInput
    data: XOR<BettingPayoutUpdateManyMutationInput, BettingPayoutUncheckedUpdateManyWithoutUserInput>
  }

  export type BettingPayoutScalarWhereInput = {
    AND?: BettingPayoutScalarWhereInput | BettingPayoutScalarWhereInput[]
    OR?: BettingPayoutScalarWhereInput[]
    NOT?: BettingPayoutScalarWhereInput | BettingPayoutScalarWhereInput[]
    id?: StringFilter<"BettingPayout"> | string
    marketId?: StringFilter<"BettingPayout"> | string
    userId?: StringFilter<"BettingPayout"> | string
    positionId?: StringFilter<"BettingPayout"> | string
    winnings?: FloatFilter<"BettingPayout"> | number
    originalBet?: FloatFilter<"BettingPayout"> | number
    multiplier?: FloatFilter<"BettingPayout"> | number
    status?: EnumPayoutStatusFilter<"BettingPayout"> | $Enums.PayoutStatus
    payoutDate?: DateTimeNullableFilter<"BettingPayout"> | Date | string | null
    transactionId?: StringNullableFilter<"BettingPayout"> | string | null
    createdAt?: DateTimeFilter<"BettingPayout"> | Date | string
    updatedAt?: DateTimeFilter<"BettingPayout"> | Date | string
  }

  export type CardAuctionUpsertWithWhereUniqueWithoutOwnerInput = {
    where: CardAuctionWhereUniqueInput
    update: XOR<CardAuctionUpdateWithoutOwnerInput, CardAuctionUncheckedUpdateWithoutOwnerInput>
    create: XOR<CardAuctionCreateWithoutOwnerInput, CardAuctionUncheckedCreateWithoutOwnerInput>
  }

  export type CardAuctionUpdateWithWhereUniqueWithoutOwnerInput = {
    where: CardAuctionWhereUniqueInput
    data: XOR<CardAuctionUpdateWithoutOwnerInput, CardAuctionUncheckedUpdateWithoutOwnerInput>
  }

  export type CardAuctionUpdateManyWithWhereWithoutOwnerInput = {
    where: CardAuctionScalarWhereInput
    data: XOR<CardAuctionUpdateManyMutationInput, CardAuctionUncheckedUpdateManyWithoutOwnerInput>
  }

  export type CardAuctionScalarWhereInput = {
    AND?: CardAuctionScalarWhereInput | CardAuctionScalarWhereInput[]
    OR?: CardAuctionScalarWhereInput[]
    NOT?: CardAuctionScalarWhereInput | CardAuctionScalarWhereInput[]
    id?: StringFilter<"CardAuction"> | string
    cardId?: StringFilter<"CardAuction"> | string
    ownerId?: StringFilter<"CardAuction"> | string
    title?: StringFilter<"CardAuction"> | string
    description?: StringNullableFilter<"CardAuction"> | string | null
    startPrice?: FloatFilter<"CardAuction"> | number
    reservePrice?: FloatNullableFilter<"CardAuction"> | number | null
    currentBid?: FloatNullableFilter<"CardAuction"> | number | null
    bidIncrement?: FloatFilter<"CardAuction"> | number
    startTime?: DateTimeFilter<"CardAuction"> | Date | string
    endTime?: DateTimeFilter<"CardAuction"> | Date | string
    autoExtend?: BoolFilter<"CardAuction"> | boolean
    status?: EnumAuctionStatusFilter<"CardAuction"> | $Enums.AuctionStatus
    finalized?: BoolFilter<"CardAuction"> | boolean
    winnerId?: StringNullableFilter<"CardAuction"> | string | null
    viewCount?: IntFilter<"CardAuction"> | number
    watcherCount?: IntFilter<"CardAuction"> | number
    bidCount?: IntFilter<"CardAuction"> | number
    createdAt?: DateTimeFilter<"CardAuction"> | Date | string
    updatedAt?: DateTimeFilter<"CardAuction"> | Date | string
  }

  export type CardAuctionUpsertWithWhereUniqueWithoutWinnerInput = {
    where: CardAuctionWhereUniqueInput
    update: XOR<CardAuctionUpdateWithoutWinnerInput, CardAuctionUncheckedUpdateWithoutWinnerInput>
    create: XOR<CardAuctionCreateWithoutWinnerInput, CardAuctionUncheckedCreateWithoutWinnerInput>
  }

  export type CardAuctionUpdateWithWhereUniqueWithoutWinnerInput = {
    where: CardAuctionWhereUniqueInput
    data: XOR<CardAuctionUpdateWithoutWinnerInput, CardAuctionUncheckedUpdateWithoutWinnerInput>
  }

  export type CardAuctionUpdateManyWithWhereWithoutWinnerInput = {
    where: CardAuctionScalarWhereInput
    data: XOR<CardAuctionUpdateManyMutationInput, CardAuctionUncheckedUpdateManyWithoutWinnerInput>
  }

  export type AuctionBidUpsertWithWhereUniqueWithoutBidderInput = {
    where: AuctionBidWhereUniqueInput
    update: XOR<AuctionBidUpdateWithoutBidderInput, AuctionBidUncheckedUpdateWithoutBidderInput>
    create: XOR<AuctionBidCreateWithoutBidderInput, AuctionBidUncheckedCreateWithoutBidderInput>
  }

  export type AuctionBidUpdateWithWhereUniqueWithoutBidderInput = {
    where: AuctionBidWhereUniqueInput
    data: XOR<AuctionBidUpdateWithoutBidderInput, AuctionBidUncheckedUpdateWithoutBidderInput>
  }

  export type AuctionBidUpdateManyWithWhereWithoutBidderInput = {
    where: AuctionBidScalarWhereInput
    data: XOR<AuctionBidUpdateManyMutationInput, AuctionBidUncheckedUpdateManyWithoutBidderInput>
  }

  export type AuctionBidScalarWhereInput = {
    AND?: AuctionBidScalarWhereInput | AuctionBidScalarWhereInput[]
    OR?: AuctionBidScalarWhereInput[]
    NOT?: AuctionBidScalarWhereInput | AuctionBidScalarWhereInput[]
    id?: StringFilter<"AuctionBid"> | string
    auctionId?: StringFilter<"AuctionBid"> | string
    bidderId?: StringFilter<"AuctionBid"> | string
    bidAmount?: FloatFilter<"AuctionBid"> | number
    maxAutoBid?: FloatNullableFilter<"AuctionBid"> | number | null
    bidType?: EnumBidTypeFilter<"AuctionBid"> | $Enums.BidType
    status?: EnumAuctionBidStatusFilter<"AuctionBid"> | $Enums.AuctionBidStatus
    isWinning?: BoolFilter<"AuctionBid"> | boolean
    outbidNotified?: BoolFilter<"AuctionBid"> | boolean
    userAgent?: StringNullableFilter<"AuctionBid"> | string | null
    ipAddress?: StringNullableFilter<"AuctionBid"> | string | null
    createdAt?: DateTimeFilter<"AuctionBid"> | Date | string
    updatedAt?: DateTimeFilter<"AuctionBid"> | Date | string
  }

  export type AuctionWatcherUpsertWithWhereUniqueWithoutUserInput = {
    where: AuctionWatcherWhereUniqueInput
    update: XOR<AuctionWatcherUpdateWithoutUserInput, AuctionWatcherUncheckedUpdateWithoutUserInput>
    create: XOR<AuctionWatcherCreateWithoutUserInput, AuctionWatcherUncheckedCreateWithoutUserInput>
  }

  export type AuctionWatcherUpdateWithWhereUniqueWithoutUserInput = {
    where: AuctionWatcherWhereUniqueInput
    data: XOR<AuctionWatcherUpdateWithoutUserInput, AuctionWatcherUncheckedUpdateWithoutUserInput>
  }

  export type AuctionWatcherUpdateManyWithWhereWithoutUserInput = {
    where: AuctionWatcherScalarWhereInput
    data: XOR<AuctionWatcherUpdateManyMutationInput, AuctionWatcherUncheckedUpdateManyWithoutUserInput>
  }

  export type AuctionWatcherScalarWhereInput = {
    AND?: AuctionWatcherScalarWhereInput | AuctionWatcherScalarWhereInput[]
    OR?: AuctionWatcherScalarWhereInput[]
    NOT?: AuctionWatcherScalarWhereInput | AuctionWatcherScalarWhereInput[]
    id?: StringFilter<"AuctionWatcher"> | string
    auctionId?: StringFilter<"AuctionWatcher"> | string
    userId?: StringFilter<"AuctionWatcher"> | string
    bidNotifications?: BoolFilter<"AuctionWatcher"> | boolean
    endingNotifications?: BoolFilter<"AuctionWatcher"> | boolean
    priceAlerts?: BoolFilter<"AuctionWatcher"> | boolean
    alertThreshold?: FloatNullableFilter<"AuctionWatcher"> | number | null
    createdAt?: DateTimeFilter<"AuctionWatcher"> | Date | string
    updatedAt?: DateTimeFilter<"AuctionWatcher"> | Date | string
  }

  export type MABattleUpsertWithWhereUniqueWithoutInitiatorInput = {
    where: MABattleWhereUniqueInput
    update: XOR<MABattleUpdateWithoutInitiatorInput, MABattleUncheckedUpdateWithoutInitiatorInput>
    create: XOR<MABattleCreateWithoutInitiatorInput, MABattleUncheckedCreateWithoutInitiatorInput>
  }

  export type MABattleUpdateWithWhereUniqueWithoutInitiatorInput = {
    where: MABattleWhereUniqueInput
    data: XOR<MABattleUpdateWithoutInitiatorInput, MABattleUncheckedUpdateWithoutInitiatorInput>
  }

  export type MABattleUpdateManyWithWhereWithoutInitiatorInput = {
    where: MABattleScalarWhereInput
    data: XOR<MABattleUpdateManyMutationInput, MABattleUncheckedUpdateManyWithoutInitiatorInput>
  }

  export type MABattleScalarWhereInput = {
    AND?: MABattleScalarWhereInput | MABattleScalarWhereInput[]
    OR?: MABattleScalarWhereInput[]
    NOT?: MABattleScalarWhereInput | MABattleScalarWhereInput[]
    id?: StringFilter<"MABattle"> | string
    initiatorCardId?: StringFilter<"MABattle"> | string
    targetCardId?: StringFilter<"MABattle"> | string
    initiatorUserId?: StringFilter<"MABattle"> | string
    targetUserId?: StringNullableFilter<"MABattle"> | string | null
    battleType?: EnumBattleTypeFilter<"MABattle"> | $Enums.BattleType
    title?: StringFilter<"MABattle"> | string
    description?: StringFilter<"MABattle"> | string
    stakes?: FloatFilter<"MABattle"> | number
    timeline?: DateTimeFilter<"MABattle"> | Date | string
    votingPeriod?: DateTimeFilter<"MABattle"> | Date | string
    status?: EnumBattleStatusFilter<"MABattle"> | $Enums.BattleStatus
    resolved?: BoolFilter<"MABattle"> | boolean
    viewCount?: IntFilter<"MABattle"> | number
    participantCount?: IntFilter<"MABattle"> | number
    createdAt?: DateTimeFilter<"MABattle"> | Date | string
    updatedAt?: DateTimeFilter<"MABattle"> | Date | string
  }

  export type MABattleUpsertWithWhereUniqueWithoutTargetInput = {
    where: MABattleWhereUniqueInput
    update: XOR<MABattleUpdateWithoutTargetInput, MABattleUncheckedUpdateWithoutTargetInput>
    create: XOR<MABattleCreateWithoutTargetInput, MABattleUncheckedCreateWithoutTargetInput>
  }

  export type MABattleUpdateWithWhereUniqueWithoutTargetInput = {
    where: MABattleWhereUniqueInput
    data: XOR<MABattleUpdateWithoutTargetInput, MABattleUncheckedUpdateWithoutTargetInput>
  }

  export type MABattleUpdateManyWithWhereWithoutTargetInput = {
    where: MABattleScalarWhereInput
    data: XOR<MABattleUpdateManyMutationInput, MABattleUncheckedUpdateManyWithoutTargetInput>
  }

  export type BattleProposalUpsertWithWhereUniqueWithoutProposerInput = {
    where: BattleProposalWhereUniqueInput
    update: XOR<BattleProposalUpdateWithoutProposerInput, BattleProposalUncheckedUpdateWithoutProposerInput>
    create: XOR<BattleProposalCreateWithoutProposerInput, BattleProposalUncheckedCreateWithoutProposerInput>
  }

  export type BattleProposalUpdateWithWhereUniqueWithoutProposerInput = {
    where: BattleProposalWhereUniqueInput
    data: XOR<BattleProposalUpdateWithoutProposerInput, BattleProposalUncheckedUpdateWithoutProposerInput>
  }

  export type BattleProposalUpdateManyWithWhereWithoutProposerInput = {
    where: BattleProposalScalarWhereInput
    data: XOR<BattleProposalUpdateManyMutationInput, BattleProposalUncheckedUpdateManyWithoutProposerInput>
  }

  export type BattleProposalScalarWhereInput = {
    AND?: BattleProposalScalarWhereInput | BattleProposalScalarWhereInput[]
    OR?: BattleProposalScalarWhereInput[]
    NOT?: BattleProposalScalarWhereInput | BattleProposalScalarWhereInput[]
    id?: StringFilter<"BattleProposal"> | string
    battleId?: StringFilter<"BattleProposal"> | string
    proposerId?: StringFilter<"BattleProposal"> | string
    proposalType?: EnumProposalTypeFilter<"BattleProposal"> | $Enums.ProposalType
    title?: StringFilter<"BattleProposal"> | string
    description?: StringFilter<"BattleProposal"> | string
    terms?: JsonFilter<"BattleProposal">
    valuation?: FloatFilter<"BattleProposal"> | number
    paymentStructure?: JsonFilter<"BattleProposal">
    timeline?: JsonFilter<"BattleProposal">
    synergies?: JsonFilter<"BattleProposal">
    conditions?: JsonFilter<"BattleProposal">
    contingencies?: JsonFilter<"BattleProposal">
    status?: EnumProposalStatusFilter<"BattleProposal"> | $Enums.ProposalStatus
    createdAt?: DateTimeFilter<"BattleProposal"> | Date | string
    updatedAt?: DateTimeFilter<"BattleProposal"> | Date | string
  }

  export type BattleVotingUpsertWithWhereUniqueWithoutVoterInput = {
    where: BattleVotingWhereUniqueInput
    update: XOR<BattleVotingUpdateWithoutVoterInput, BattleVotingUncheckedUpdateWithoutVoterInput>
    create: XOR<BattleVotingCreateWithoutVoterInput, BattleVotingUncheckedCreateWithoutVoterInput>
  }

  export type BattleVotingUpdateWithWhereUniqueWithoutVoterInput = {
    where: BattleVotingWhereUniqueInput
    data: XOR<BattleVotingUpdateWithoutVoterInput, BattleVotingUncheckedUpdateWithoutVoterInput>
  }

  export type BattleVotingUpdateManyWithWhereWithoutVoterInput = {
    where: BattleVotingScalarWhereInput
    data: XOR<BattleVotingUpdateManyMutationInput, BattleVotingUncheckedUpdateManyWithoutVoterInput>
  }

  export type BattleVotingScalarWhereInput = {
    AND?: BattleVotingScalarWhereInput | BattleVotingScalarWhereInput[]
    OR?: BattleVotingScalarWhereInput[]
    NOT?: BattleVotingScalarWhereInput | BattleVotingScalarWhereInput[]
    id?: StringFilter<"BattleVoting"> | string
    battleId?: StringFilter<"BattleVoting"> | string
    proposalId?: StringNullableFilter<"BattleVoting"> | string | null
    voterId?: StringFilter<"BattleVoting"> | string
    vote?: EnumVoteDirectionFilter<"BattleVoting"> | $Enums.VoteDirection
    voteWeight?: FloatFilter<"BattleVoting"> | number
    reasoning?: StringNullableFilter<"BattleVoting"> | string | null
    confidence?: FloatNullableFilter<"BattleVoting"> | number | null
    eceStaked?: FloatNullableFilter<"BattleVoting"> | number | null
    expertRating?: FloatNullableFilter<"BattleVoting"> | number | null
    portfolioValue?: FloatNullableFilter<"BattleVoting"> | number | null
    createdAt?: DateTimeFilter<"BattleVoting"> | Date | string
    updatedAt?: DateTimeFilter<"BattleVoting"> | Date | string
  }

  export type StakingPositionUpsertWithWhereUniqueWithoutUserInput = {
    where: StakingPositionWhereUniqueInput
    update: XOR<StakingPositionUpdateWithoutUserInput, StakingPositionUncheckedUpdateWithoutUserInput>
    create: XOR<StakingPositionCreateWithoutUserInput, StakingPositionUncheckedCreateWithoutUserInput>
  }

  export type StakingPositionUpdateWithWhereUniqueWithoutUserInput = {
    where: StakingPositionWhereUniqueInput
    data: XOR<StakingPositionUpdateWithoutUserInput, StakingPositionUncheckedUpdateWithoutUserInput>
  }

  export type StakingPositionUpdateManyWithWhereWithoutUserInput = {
    where: StakingPositionScalarWhereInput
    data: XOR<StakingPositionUpdateManyMutationInput, StakingPositionUncheckedUpdateManyWithoutUserInput>
  }

  export type StakingPositionScalarWhereInput = {
    AND?: StakingPositionScalarWhereInput | StakingPositionScalarWhereInput[]
    OR?: StakingPositionScalarWhereInput[]
    NOT?: StakingPositionScalarWhereInput | StakingPositionScalarWhereInput[]
    id?: StringFilter<"StakingPosition"> | string
    userId?: StringFilter<"StakingPosition"> | string
    poolId?: StringFilter<"StakingPosition"> | string
    amount?: FloatFilter<"StakingPosition"> | number
    stakedAt?: DateTimeFilter<"StakingPosition"> | Date | string
    unstakedAt?: DateTimeNullableFilter<"StakingPosition"> | Date | string | null
    lockupEndsAt?: DateTimeNullableFilter<"StakingPosition"> | Date | string | null
    isActive?: BoolFilter<"StakingPosition"> | boolean
  }

  export type StakingRewardUpsertWithWhereUniqueWithoutUserInput = {
    where: StakingRewardWhereUniqueInput
    update: XOR<StakingRewardUpdateWithoutUserInput, StakingRewardUncheckedUpdateWithoutUserInput>
    create: XOR<StakingRewardCreateWithoutUserInput, StakingRewardUncheckedCreateWithoutUserInput>
  }

  export type StakingRewardUpdateWithWhereUniqueWithoutUserInput = {
    where: StakingRewardWhereUniqueInput
    data: XOR<StakingRewardUpdateWithoutUserInput, StakingRewardUncheckedUpdateWithoutUserInput>
  }

  export type StakingRewardUpdateManyWithWhereWithoutUserInput = {
    where: StakingRewardScalarWhereInput
    data: XOR<StakingRewardUpdateManyMutationInput, StakingRewardUncheckedUpdateManyWithoutUserInput>
  }

  export type StakingRewardScalarWhereInput = {
    AND?: StakingRewardScalarWhereInput | StakingRewardScalarWhereInput[]
    OR?: StakingRewardScalarWhereInput[]
    NOT?: StakingRewardScalarWhereInput | StakingRewardScalarWhereInput[]
    id?: StringFilter<"StakingReward"> | string
    userId?: StringFilter<"StakingReward"> | string
    poolId?: StringFilter<"StakingReward"> | string
    positionId?: StringFilter<"StakingReward"> | string
    amount?: FloatFilter<"StakingReward"> | number
    rewardType?: EnumStakingRewardTypeFilter<"StakingReward"> | $Enums.StakingRewardType
    claimedAt?: DateTimeNullableFilter<"StakingReward"> | Date | string | null
    createdAt?: DateTimeFilter<"StakingReward"> | Date | string
  }

  export type GovernanceProposalUpsertWithWhereUniqueWithoutProposerInput = {
    where: GovernanceProposalWhereUniqueInput
    update: XOR<GovernanceProposalUpdateWithoutProposerInput, GovernanceProposalUncheckedUpdateWithoutProposerInput>
    create: XOR<GovernanceProposalCreateWithoutProposerInput, GovernanceProposalUncheckedCreateWithoutProposerInput>
  }

  export type GovernanceProposalUpdateWithWhereUniqueWithoutProposerInput = {
    where: GovernanceProposalWhereUniqueInput
    data: XOR<GovernanceProposalUpdateWithoutProposerInput, GovernanceProposalUncheckedUpdateWithoutProposerInput>
  }

  export type GovernanceProposalUpdateManyWithWhereWithoutProposerInput = {
    where: GovernanceProposalScalarWhereInput
    data: XOR<GovernanceProposalUpdateManyMutationInput, GovernanceProposalUncheckedUpdateManyWithoutProposerInput>
  }

  export type GovernanceProposalScalarWhereInput = {
    AND?: GovernanceProposalScalarWhereInput | GovernanceProposalScalarWhereInput[]
    OR?: GovernanceProposalScalarWhereInput[]
    NOT?: GovernanceProposalScalarWhereInput | GovernanceProposalScalarWhereInput[]
    id?: StringFilter<"GovernanceProposal"> | string
    title?: StringFilter<"GovernanceProposal"> | string
    description?: StringFilter<"GovernanceProposal"> | string
    proposalType?: EnumProposalTypeFilter<"GovernanceProposal"> | $Enums.ProposalType
    proposerId?: StringFilter<"GovernanceProposal"> | string
    status?: EnumGovernanceStatusFilter<"GovernanceProposal"> | $Enums.GovernanceStatus
    votingStartsAt?: DateTimeFilter<"GovernanceProposal"> | Date | string
    votingEndsAt?: DateTimeFilter<"GovernanceProposal"> | Date | string
    executionDate?: DateTimeNullableFilter<"GovernanceProposal"> | Date | string | null
    minQuorum?: FloatFilter<"GovernanceProposal"> | number
    minApproval?: FloatFilter<"GovernanceProposal"> | number
    totalVotes?: FloatFilter<"GovernanceProposal"> | number
    yesVotes?: FloatFilter<"GovernanceProposal"> | number
    noVotes?: FloatFilter<"GovernanceProposal"> | number
    abstainVotes?: FloatFilter<"GovernanceProposal"> | number
    isExecuted?: BoolFilter<"GovernanceProposal"> | boolean
    createdAt?: DateTimeFilter<"GovernanceProposal"> | Date | string
    updatedAt?: DateTimeFilter<"GovernanceProposal"> | Date | string
    parameters?: JsonNullableFilter<"GovernanceProposal">
  }

  export type GovernanceVoteUpsertWithWhereUniqueWithoutUserInput = {
    where: GovernanceVoteWhereUniqueInput
    update: XOR<GovernanceVoteUpdateWithoutUserInput, GovernanceVoteUncheckedUpdateWithoutUserInput>
    create: XOR<GovernanceVoteCreateWithoutUserInput, GovernanceVoteUncheckedCreateWithoutUserInput>
  }

  export type GovernanceVoteUpdateWithWhereUniqueWithoutUserInput = {
    where: GovernanceVoteWhereUniqueInput
    data: XOR<GovernanceVoteUpdateWithoutUserInput, GovernanceVoteUncheckedUpdateWithoutUserInput>
  }

  export type GovernanceVoteUpdateManyWithWhereWithoutUserInput = {
    where: GovernanceVoteScalarWhereInput
    data: XOR<GovernanceVoteUpdateManyMutationInput, GovernanceVoteUncheckedUpdateManyWithoutUserInput>
  }

  export type GovernanceVoteScalarWhereInput = {
    AND?: GovernanceVoteScalarWhereInput | GovernanceVoteScalarWhereInput[]
    OR?: GovernanceVoteScalarWhereInput[]
    NOT?: GovernanceVoteScalarWhereInput | GovernanceVoteScalarWhereInput[]
    id?: StringFilter<"GovernanceVote"> | string
    proposalId?: StringFilter<"GovernanceVote"> | string
    userId?: StringFilter<"GovernanceVote"> | string
    voteChoice?: EnumVoteChoiceFilter<"GovernanceVote"> | $Enums.VoteChoice
    votingPower?: FloatFilter<"GovernanceVote"> | number
    reason?: StringNullableFilter<"GovernanceVote"> | string | null
    votedAt?: DateTimeFilter<"GovernanceVote"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    data?: JsonNullableFilter<"Notification">
    read?: BoolFilter<"Notification"> | boolean
    priority?: EnumNotificationPriorityFilter<"Notification"> | $Enums.NotificationPriority
    requiresSubscription?: EnumSubscriptionPlanNullableFilter<"Notification"> | $Enums.SubscriptionPlan | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type SocialFeedUpsertWithWhereUniqueWithoutUserInput = {
    where: SocialFeedWhereUniqueInput
    update: XOR<SocialFeedUpdateWithoutUserInput, SocialFeedUncheckedUpdateWithoutUserInput>
    create: XOR<SocialFeedCreateWithoutUserInput, SocialFeedUncheckedCreateWithoutUserInput>
  }

  export type SocialFeedUpdateWithWhereUniqueWithoutUserInput = {
    where: SocialFeedWhereUniqueInput
    data: XOR<SocialFeedUpdateWithoutUserInput, SocialFeedUncheckedUpdateWithoutUserInput>
  }

  export type SocialFeedUpdateManyWithWhereWithoutUserInput = {
    where: SocialFeedScalarWhereInput
    data: XOR<SocialFeedUpdateManyMutationInput, SocialFeedUncheckedUpdateManyWithoutUserInput>
  }

  export type SocialFeedScalarWhereInput = {
    AND?: SocialFeedScalarWhereInput | SocialFeedScalarWhereInput[]
    OR?: SocialFeedScalarWhereInput[]
    NOT?: SocialFeedScalarWhereInput | SocialFeedScalarWhereInput[]
    id?: StringFilter<"SocialFeed"> | string
    userId?: StringFilter<"SocialFeed"> | string
    type?: EnumSocialFeedTypeFilter<"SocialFeed"> | $Enums.SocialFeedType
    content?: StringFilter<"SocialFeed"> | string
    data?: JsonNullableFilter<"SocialFeed">
    likes?: IntFilter<"SocialFeed"> | number
    comments?: IntFilter<"SocialFeed"> | number
    shares?: IntFilter<"SocialFeed"> | number
    visibility?: EnumSocialVisibilityFilter<"SocialFeed"> | $Enums.SocialVisibility
    createdAt?: DateTimeFilter<"SocialFeed"> | Date | string
    updatedAt?: DateTimeFilter<"SocialFeed"> | Date | string
  }

  export type FollowUpsertWithWhereUniqueWithoutFollowerInput = {
    where: FollowWhereUniqueInput
    update: XOR<FollowUpdateWithoutFollowerInput, FollowUncheckedUpdateWithoutFollowerInput>
    create: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput>
  }

  export type FollowUpdateWithWhereUniqueWithoutFollowerInput = {
    where: FollowWhereUniqueInput
    data: XOR<FollowUpdateWithoutFollowerInput, FollowUncheckedUpdateWithoutFollowerInput>
  }

  export type FollowUpdateManyWithWhereWithoutFollowerInput = {
    where: FollowScalarWhereInput
    data: XOR<FollowUpdateManyMutationInput, FollowUncheckedUpdateManyWithoutFollowerInput>
  }

  export type FollowScalarWhereInput = {
    AND?: FollowScalarWhereInput | FollowScalarWhereInput[]
    OR?: FollowScalarWhereInput[]
    NOT?: FollowScalarWhereInput | FollowScalarWhereInput[]
    id?: StringFilter<"Follow"> | string
    followerId?: StringFilter<"Follow"> | string
    followingId?: StringFilter<"Follow"> | string
    createdAt?: DateTimeFilter<"Follow"> | Date | string
  }

  export type FollowUpsertWithWhereUniqueWithoutFollowingInput = {
    where: FollowWhereUniqueInput
    update: XOR<FollowUpdateWithoutFollowingInput, FollowUncheckedUpdateWithoutFollowingInput>
    create: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput>
  }

  export type FollowUpdateWithWhereUniqueWithoutFollowingInput = {
    where: FollowWhereUniqueInput
    data: XOR<FollowUpdateWithoutFollowingInput, FollowUncheckedUpdateWithoutFollowingInput>
  }

  export type FollowUpdateManyWithWhereWithoutFollowingInput = {
    where: FollowScalarWhereInput
    data: XOR<FollowUpdateManyMutationInput, FollowUncheckedUpdateManyWithoutFollowingInput>
  }

  export type UserCreateWithoutSubscriptionInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    passwordHash?: string | null
    emailVerified?: Date | string | null
    eceBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string
    cryptoWallets?: CryptoWalletCreateNestedManyWithoutUserInput
    physicalCard?: PhysicalCardCreateNestedOneWithoutUserInput
    ownedCards?: CardCreateNestedManyWithoutOwnerInput
    tradingHistory?: TransactionCreateNestedManyWithoutUserInput
    bids?: BidCreateNestedManyWithoutBidderInput
    listings?: MarketplaceListingCreateNestedManyWithoutSellerInput
    appOrders?: AppOrderCreateNestedManyWithoutUserInput
    orderRevisions?: OrderRevisionCreateNestedManyWithoutUserInput
    orderCommunications?: OrderCommunicationCreateNestedManyWithoutUserInput
    bettingPositions?: BettingPositionCreateNestedManyWithoutUserInput
    bettingPayouts?: BettingPayoutCreateNestedManyWithoutUserInput
    ownedAuctions?: CardAuctionCreateNestedManyWithoutOwnerInput
    wonAuctions?: CardAuctionCreateNestedManyWithoutWinnerInput
    placedAuctionBids?: AuctionBidCreateNestedManyWithoutBidderInput
    watchedAuctions?: AuctionWatcherCreateNestedManyWithoutUserInput
    initiatedMABattles?: MABattleCreateNestedManyWithoutInitiatorInput
    targetedMABattles?: MABattleCreateNestedManyWithoutTargetInput
    battleProposals?: BattleProposalCreateNestedManyWithoutProposerInput
    battleVotes?: BattleVotingCreateNestedManyWithoutVoterInput
    stakingPositions?: StakingPositionCreateNestedManyWithoutUserInput
    stakingRewards?: StakingRewardCreateNestedManyWithoutUserInput
    governanceProposals?: GovernanceProposalCreateNestedManyWithoutProposerInput
    governanceVotes?: GovernanceVoteCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    socialFeeds?: SocialFeedCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    passwordHash?: string | null
    emailVerified?: Date | string | null
    eceBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string
    cryptoWallets?: CryptoWalletUncheckedCreateNestedManyWithoutUserInput
    physicalCard?: PhysicalCardUncheckedCreateNestedOneWithoutUserInput
    ownedCards?: CardUncheckedCreateNestedManyWithoutOwnerInput
    tradingHistory?: TransactionUncheckedCreateNestedManyWithoutUserInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderInput
    listings?: MarketplaceListingUncheckedCreateNestedManyWithoutSellerInput
    appOrders?: AppOrderUncheckedCreateNestedManyWithoutUserInput
    orderRevisions?: OrderRevisionUncheckedCreateNestedManyWithoutUserInput
    orderCommunications?: OrderCommunicationUncheckedCreateNestedManyWithoutUserInput
    bettingPositions?: BettingPositionUncheckedCreateNestedManyWithoutUserInput
    bettingPayouts?: BettingPayoutUncheckedCreateNestedManyWithoutUserInput
    ownedAuctions?: CardAuctionUncheckedCreateNestedManyWithoutOwnerInput
    wonAuctions?: CardAuctionUncheckedCreateNestedManyWithoutWinnerInput
    placedAuctionBids?: AuctionBidUncheckedCreateNestedManyWithoutBidderInput
    watchedAuctions?: AuctionWatcherUncheckedCreateNestedManyWithoutUserInput
    initiatedMABattles?: MABattleUncheckedCreateNestedManyWithoutInitiatorInput
    targetedMABattles?: MABattleUncheckedCreateNestedManyWithoutTargetInput
    battleProposals?: BattleProposalUncheckedCreateNestedManyWithoutProposerInput
    battleVotes?: BattleVotingUncheckedCreateNestedManyWithoutVoterInput
    stakingPositions?: StakingPositionUncheckedCreateNestedManyWithoutUserInput
    stakingRewards?: StakingRewardUncheckedCreateNestedManyWithoutUserInput
    governanceProposals?: GovernanceProposalUncheckedCreateNestedManyWithoutProposerInput
    governanceVotes?: GovernanceVoteUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    socialFeeds?: SocialFeedUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutSubscriptionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
  }

  export type SubscriptionFeaturesCreateWithoutSubscriptionInput = {
    id?: string
    maxTrades?: number
    advancedAnalytics?: boolean
    prioritySupport?: boolean
    marketplaceAccess?: boolean
    premiumListings?: boolean
    bulkOperations?: boolean
    cryptoPayments?: boolean
    physicalCard?: boolean
    businessStipend?: number
    withdrawalLimit?: number
  }

  export type SubscriptionFeaturesUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    maxTrades?: number
    advancedAnalytics?: boolean
    prioritySupport?: boolean
    marketplaceAccess?: boolean
    premiumListings?: boolean
    bulkOperations?: boolean
    cryptoPayments?: boolean
    physicalCard?: boolean
    businessStipend?: number
    withdrawalLimit?: number
  }

  export type SubscriptionFeaturesCreateOrConnectWithoutSubscriptionInput = {
    where: SubscriptionFeaturesWhereUniqueInput
    create: XOR<SubscriptionFeaturesCreateWithoutSubscriptionInput, SubscriptionFeaturesUncheckedCreateWithoutSubscriptionInput>
  }

  export type SubscriptionUsageCreateWithoutSubscriptionInput = {
    id?: string
    tradesThisMonth?: number
    listingsThisMonth?: number
    stipendUsed?: number
    lastResetAt?: Date | string
  }

  export type SubscriptionUsageUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    tradesThisMonth?: number
    listingsThisMonth?: number
    stipendUsed?: number
    lastResetAt?: Date | string
  }

  export type SubscriptionUsageCreateOrConnectWithoutSubscriptionInput = {
    where: SubscriptionUsageWhereUniqueInput
    create: XOR<SubscriptionUsageCreateWithoutSubscriptionInput, SubscriptionUsageUncheckedCreateWithoutSubscriptionInput>
  }

  export type UserUpsertWithoutSubscriptionInput = {
    update: XOR<UserUpdateWithoutSubscriptionInput, UserUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSubscriptionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSubscriptionInput, UserUncheckedUpdateWithoutSubscriptionInput>
  }

  export type UserUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eceBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    cryptoWallets?: CryptoWalletUpdateManyWithoutUserNestedInput
    physicalCard?: PhysicalCardUpdateOneWithoutUserNestedInput
    ownedCards?: CardUpdateManyWithoutOwnerNestedInput
    tradingHistory?: TransactionUpdateManyWithoutUserNestedInput
    bids?: BidUpdateManyWithoutBidderNestedInput
    listings?: MarketplaceListingUpdateManyWithoutSellerNestedInput
    appOrders?: AppOrderUpdateManyWithoutUserNestedInput
    orderRevisions?: OrderRevisionUpdateManyWithoutUserNestedInput
    orderCommunications?: OrderCommunicationUpdateManyWithoutUserNestedInput
    bettingPositions?: BettingPositionUpdateManyWithoutUserNestedInput
    bettingPayouts?: BettingPayoutUpdateManyWithoutUserNestedInput
    ownedAuctions?: CardAuctionUpdateManyWithoutOwnerNestedInput
    wonAuctions?: CardAuctionUpdateManyWithoutWinnerNestedInput
    placedAuctionBids?: AuctionBidUpdateManyWithoutBidderNestedInput
    watchedAuctions?: AuctionWatcherUpdateManyWithoutUserNestedInput
    initiatedMABattles?: MABattleUpdateManyWithoutInitiatorNestedInput
    targetedMABattles?: MABattleUpdateManyWithoutTargetNestedInput
    battleProposals?: BattleProposalUpdateManyWithoutProposerNestedInput
    battleVotes?: BattleVotingUpdateManyWithoutVoterNestedInput
    stakingPositions?: StakingPositionUpdateManyWithoutUserNestedInput
    stakingRewards?: StakingRewardUpdateManyWithoutUserNestedInput
    governanceProposals?: GovernanceProposalUpdateManyWithoutProposerNestedInput
    governanceVotes?: GovernanceVoteUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    socialFeeds?: SocialFeedUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eceBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    cryptoWallets?: CryptoWalletUncheckedUpdateManyWithoutUserNestedInput
    physicalCard?: PhysicalCardUncheckedUpdateOneWithoutUserNestedInput
    ownedCards?: CardUncheckedUpdateManyWithoutOwnerNestedInput
    tradingHistory?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderNestedInput
    listings?: MarketplaceListingUncheckedUpdateManyWithoutSellerNestedInput
    appOrders?: AppOrderUncheckedUpdateManyWithoutUserNestedInput
    orderRevisions?: OrderRevisionUncheckedUpdateManyWithoutUserNestedInput
    orderCommunications?: OrderCommunicationUncheckedUpdateManyWithoutUserNestedInput
    bettingPositions?: BettingPositionUncheckedUpdateManyWithoutUserNestedInput
    bettingPayouts?: BettingPayoutUncheckedUpdateManyWithoutUserNestedInput
    ownedAuctions?: CardAuctionUncheckedUpdateManyWithoutOwnerNestedInput
    wonAuctions?: CardAuctionUncheckedUpdateManyWithoutWinnerNestedInput
    placedAuctionBids?: AuctionBidUncheckedUpdateManyWithoutBidderNestedInput
    watchedAuctions?: AuctionWatcherUncheckedUpdateManyWithoutUserNestedInput
    initiatedMABattles?: MABattleUncheckedUpdateManyWithoutInitiatorNestedInput
    targetedMABattles?: MABattleUncheckedUpdateManyWithoutTargetNestedInput
    battleProposals?: BattleProposalUncheckedUpdateManyWithoutProposerNestedInput
    battleVotes?: BattleVotingUncheckedUpdateManyWithoutVoterNestedInput
    stakingPositions?: StakingPositionUncheckedUpdateManyWithoutUserNestedInput
    stakingRewards?: StakingRewardUncheckedUpdateManyWithoutUserNestedInput
    governanceProposals?: GovernanceProposalUncheckedUpdateManyWithoutProposerNestedInput
    governanceVotes?: GovernanceVoteUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    socialFeeds?: SocialFeedUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type SubscriptionFeaturesUpsertWithoutSubscriptionInput = {
    update: XOR<SubscriptionFeaturesUpdateWithoutSubscriptionInput, SubscriptionFeaturesUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<SubscriptionFeaturesCreateWithoutSubscriptionInput, SubscriptionFeaturesUncheckedCreateWithoutSubscriptionInput>
    where?: SubscriptionFeaturesWhereInput
  }

  export type SubscriptionFeaturesUpdateToOneWithWhereWithoutSubscriptionInput = {
    where?: SubscriptionFeaturesWhereInput
    data: XOR<SubscriptionFeaturesUpdateWithoutSubscriptionInput, SubscriptionFeaturesUncheckedUpdateWithoutSubscriptionInput>
  }

  export type SubscriptionFeaturesUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    maxTrades?: IntFieldUpdateOperationsInput | number
    advancedAnalytics?: BoolFieldUpdateOperationsInput | boolean
    prioritySupport?: BoolFieldUpdateOperationsInput | boolean
    marketplaceAccess?: BoolFieldUpdateOperationsInput | boolean
    premiumListings?: BoolFieldUpdateOperationsInput | boolean
    bulkOperations?: BoolFieldUpdateOperationsInput | boolean
    cryptoPayments?: BoolFieldUpdateOperationsInput | boolean
    physicalCard?: BoolFieldUpdateOperationsInput | boolean
    businessStipend?: FloatFieldUpdateOperationsInput | number
    withdrawalLimit?: FloatFieldUpdateOperationsInput | number
  }

  export type SubscriptionFeaturesUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    maxTrades?: IntFieldUpdateOperationsInput | number
    advancedAnalytics?: BoolFieldUpdateOperationsInput | boolean
    prioritySupport?: BoolFieldUpdateOperationsInput | boolean
    marketplaceAccess?: BoolFieldUpdateOperationsInput | boolean
    premiumListings?: BoolFieldUpdateOperationsInput | boolean
    bulkOperations?: BoolFieldUpdateOperationsInput | boolean
    cryptoPayments?: BoolFieldUpdateOperationsInput | boolean
    physicalCard?: BoolFieldUpdateOperationsInput | boolean
    businessStipend?: FloatFieldUpdateOperationsInput | number
    withdrawalLimit?: FloatFieldUpdateOperationsInput | number
  }

  export type SubscriptionUsageUpsertWithoutSubscriptionInput = {
    update: XOR<SubscriptionUsageUpdateWithoutSubscriptionInput, SubscriptionUsageUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<SubscriptionUsageCreateWithoutSubscriptionInput, SubscriptionUsageUncheckedCreateWithoutSubscriptionInput>
    where?: SubscriptionUsageWhereInput
  }

  export type SubscriptionUsageUpdateToOneWithWhereWithoutSubscriptionInput = {
    where?: SubscriptionUsageWhereInput
    data: XOR<SubscriptionUsageUpdateWithoutSubscriptionInput, SubscriptionUsageUncheckedUpdateWithoutSubscriptionInput>
  }

  export type SubscriptionUsageUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    tradesThisMonth?: IntFieldUpdateOperationsInput | number
    listingsThisMonth?: IntFieldUpdateOperationsInput | number
    stipendUsed?: FloatFieldUpdateOperationsInput | number
    lastResetAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUsageUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    tradesThisMonth?: IntFieldUpdateOperationsInput | number
    listingsThisMonth?: IntFieldUpdateOperationsInput | number
    stipendUsed?: FloatFieldUpdateOperationsInput | number
    lastResetAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSubscriptionCreateWithoutFeaturesInput = {
    id?: string
    plan?: $Enums.SubscriptionPlan
    status?: $Enums.SubscriptionStatus
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSubscriptionInput
    usage?: SubscriptionUsageCreateNestedOneWithoutSubscriptionInput
  }

  export type UserSubscriptionUncheckedCreateWithoutFeaturesInput = {
    id?: string
    userId: string
    plan?: $Enums.SubscriptionPlan
    status?: $Enums.SubscriptionStatus
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    usage?: SubscriptionUsageUncheckedCreateNestedOneWithoutSubscriptionInput
  }

  export type UserSubscriptionCreateOrConnectWithoutFeaturesInput = {
    where: UserSubscriptionWhereUniqueInput
    create: XOR<UserSubscriptionCreateWithoutFeaturesInput, UserSubscriptionUncheckedCreateWithoutFeaturesInput>
  }

  export type UserSubscriptionUpsertWithoutFeaturesInput = {
    update: XOR<UserSubscriptionUpdateWithoutFeaturesInput, UserSubscriptionUncheckedUpdateWithoutFeaturesInput>
    create: XOR<UserSubscriptionCreateWithoutFeaturesInput, UserSubscriptionUncheckedCreateWithoutFeaturesInput>
    where?: UserSubscriptionWhereInput
  }

  export type UserSubscriptionUpdateToOneWithWhereWithoutFeaturesInput = {
    where?: UserSubscriptionWhereInput
    data: XOR<UserSubscriptionUpdateWithoutFeaturesInput, UserSubscriptionUncheckedUpdateWithoutFeaturesInput>
  }

  export type UserSubscriptionUpdateWithoutFeaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSubscriptionNestedInput
    usage?: SubscriptionUsageUpdateOneWithoutSubscriptionNestedInput
  }

  export type UserSubscriptionUncheckedUpdateWithoutFeaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usage?: SubscriptionUsageUncheckedUpdateOneWithoutSubscriptionNestedInput
  }

  export type UserSubscriptionCreateWithoutUsageInput = {
    id?: string
    plan?: $Enums.SubscriptionPlan
    status?: $Enums.SubscriptionStatus
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSubscriptionInput
    features?: SubscriptionFeaturesCreateNestedOneWithoutSubscriptionInput
  }

  export type UserSubscriptionUncheckedCreateWithoutUsageInput = {
    id?: string
    userId: string
    plan?: $Enums.SubscriptionPlan
    status?: $Enums.SubscriptionStatus
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: SubscriptionFeaturesUncheckedCreateNestedOneWithoutSubscriptionInput
  }

  export type UserSubscriptionCreateOrConnectWithoutUsageInput = {
    where: UserSubscriptionWhereUniqueInput
    create: XOR<UserSubscriptionCreateWithoutUsageInput, UserSubscriptionUncheckedCreateWithoutUsageInput>
  }

  export type UserSubscriptionUpsertWithoutUsageInput = {
    update: XOR<UserSubscriptionUpdateWithoutUsageInput, UserSubscriptionUncheckedUpdateWithoutUsageInput>
    create: XOR<UserSubscriptionCreateWithoutUsageInput, UserSubscriptionUncheckedCreateWithoutUsageInput>
    where?: UserSubscriptionWhereInput
  }

  export type UserSubscriptionUpdateToOneWithWhereWithoutUsageInput = {
    where?: UserSubscriptionWhereInput
    data: XOR<UserSubscriptionUpdateWithoutUsageInput, UserSubscriptionUncheckedUpdateWithoutUsageInput>
  }

  export type UserSubscriptionUpdateWithoutUsageInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSubscriptionNestedInput
    features?: SubscriptionFeaturesUpdateOneWithoutSubscriptionNestedInput
  }

  export type UserSubscriptionUncheckedUpdateWithoutUsageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: SubscriptionFeaturesUncheckedUpdateOneWithoutSubscriptionNestedInput
  }

  export type UserCreateWithoutOwnedCardsInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    passwordHash?: string | null
    emailVerified?: Date | string | null
    eceBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string
    subscription?: UserSubscriptionCreateNestedOneWithoutUserInput
    cryptoWallets?: CryptoWalletCreateNestedManyWithoutUserInput
    physicalCard?: PhysicalCardCreateNestedOneWithoutUserInput
    tradingHistory?: TransactionCreateNestedManyWithoutUserInput
    bids?: BidCreateNestedManyWithoutBidderInput
    listings?: MarketplaceListingCreateNestedManyWithoutSellerInput
    appOrders?: AppOrderCreateNestedManyWithoutUserInput
    orderRevisions?: OrderRevisionCreateNestedManyWithoutUserInput
    orderCommunications?: OrderCommunicationCreateNestedManyWithoutUserInput
    bettingPositions?: BettingPositionCreateNestedManyWithoutUserInput
    bettingPayouts?: BettingPayoutCreateNestedManyWithoutUserInput
    ownedAuctions?: CardAuctionCreateNestedManyWithoutOwnerInput
    wonAuctions?: CardAuctionCreateNestedManyWithoutWinnerInput
    placedAuctionBids?: AuctionBidCreateNestedManyWithoutBidderInput
    watchedAuctions?: AuctionWatcherCreateNestedManyWithoutUserInput
    initiatedMABattles?: MABattleCreateNestedManyWithoutInitiatorInput
    targetedMABattles?: MABattleCreateNestedManyWithoutTargetInput
    battleProposals?: BattleProposalCreateNestedManyWithoutProposerInput
    battleVotes?: BattleVotingCreateNestedManyWithoutVoterInput
    stakingPositions?: StakingPositionCreateNestedManyWithoutUserInput
    stakingRewards?: StakingRewardCreateNestedManyWithoutUserInput
    governanceProposals?: GovernanceProposalCreateNestedManyWithoutProposerInput
    governanceVotes?: GovernanceVoteCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    socialFeeds?: SocialFeedCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutOwnedCardsInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    passwordHash?: string | null
    emailVerified?: Date | string | null
    eceBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string
    subscription?: UserSubscriptionUncheckedCreateNestedOneWithoutUserInput
    cryptoWallets?: CryptoWalletUncheckedCreateNestedManyWithoutUserInput
    physicalCard?: PhysicalCardUncheckedCreateNestedOneWithoutUserInput
    tradingHistory?: TransactionUncheckedCreateNestedManyWithoutUserInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderInput
    listings?: MarketplaceListingUncheckedCreateNestedManyWithoutSellerInput
    appOrders?: AppOrderUncheckedCreateNestedManyWithoutUserInput
    orderRevisions?: OrderRevisionUncheckedCreateNestedManyWithoutUserInput
    orderCommunications?: OrderCommunicationUncheckedCreateNestedManyWithoutUserInput
    bettingPositions?: BettingPositionUncheckedCreateNestedManyWithoutUserInput
    bettingPayouts?: BettingPayoutUncheckedCreateNestedManyWithoutUserInput
    ownedAuctions?: CardAuctionUncheckedCreateNestedManyWithoutOwnerInput
    wonAuctions?: CardAuctionUncheckedCreateNestedManyWithoutWinnerInput
    placedAuctionBids?: AuctionBidUncheckedCreateNestedManyWithoutBidderInput
    watchedAuctions?: AuctionWatcherUncheckedCreateNestedManyWithoutUserInput
    initiatedMABattles?: MABattleUncheckedCreateNestedManyWithoutInitiatorInput
    targetedMABattles?: MABattleUncheckedCreateNestedManyWithoutTargetInput
    battleProposals?: BattleProposalUncheckedCreateNestedManyWithoutProposerInput
    battleVotes?: BattleVotingUncheckedCreateNestedManyWithoutVoterInput
    stakingPositions?: StakingPositionUncheckedCreateNestedManyWithoutUserInput
    stakingRewards?: StakingRewardUncheckedCreateNestedManyWithoutUserInput
    governanceProposals?: GovernanceProposalUncheckedCreateNestedManyWithoutProposerInput
    governanceVotes?: GovernanceVoteUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    socialFeeds?: SocialFeedUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutOwnedCardsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOwnedCardsInput, UserUncheckedCreateWithoutOwnedCardsInput>
  }

  export type MarketplaceListingCreateWithoutCardInput = {
    id?: string
    price: number
    listingType?: $Enums.ListingType
    auctionEnd?: Date | string | null
    status?: $Enums.ListingStatus
    featured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    seller: UserCreateNestedOneWithoutListingsInput
    bids?: BidCreateNestedManyWithoutListingInput
  }

  export type MarketplaceListingUncheckedCreateWithoutCardInput = {
    id?: string
    sellerId: string
    price: number
    listingType?: $Enums.ListingType
    auctionEnd?: Date | string | null
    status?: $Enums.ListingStatus
    featured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bids?: BidUncheckedCreateNestedManyWithoutListingInput
  }

  export type MarketplaceListingCreateOrConnectWithoutCardInput = {
    where: MarketplaceListingWhereUniqueInput
    create: XOR<MarketplaceListingCreateWithoutCardInput, MarketplaceListingUncheckedCreateWithoutCardInput>
  }

  export type BidCreateWithoutCardInput = {
    id?: string
    amount: number
    status?: $Enums.BidStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    listing: MarketplaceListingCreateNestedOneWithoutBidsInput
    bidder: UserCreateNestedOneWithoutBidsInput
  }

  export type BidUncheckedCreateWithoutCardInput = {
    id?: string
    listingId: string
    bidderId: string
    amount: number
    status?: $Enums.BidStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BidCreateOrConnectWithoutCardInput = {
    where: BidWhereUniqueInput
    create: XOR<BidCreateWithoutCardInput, BidUncheckedCreateWithoutCardInput>
  }

  export type BidCreateManyCardInputEnvelope = {
    data: BidCreateManyCardInput | BidCreateManyCardInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutCardInput = {
    id?: string
    type: $Enums.TransactionType
    amount: number
    currency?: string
    status?: $Enums.TransactionStatus
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: string | null
    paymentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTradingHistoryInput
  }

  export type TransactionUncheckedCreateWithoutCardInput = {
    id?: string
    userId: string
    type: $Enums.TransactionType
    amount: number
    currency?: string
    status?: $Enums.TransactionStatus
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: string | null
    paymentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutCardInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutCardInput, TransactionUncheckedCreateWithoutCardInput>
  }

  export type TransactionCreateManyCardInputEnvelope = {
    data: TransactionCreateManyCardInput | TransactionCreateManyCardInput[]
    skipDuplicates?: boolean
  }

  export type BettingMarketCreateWithoutCardInput = {
    id?: string
    metricType: $Enums.MarketMetricType
    title: string
    description: string
    currentValue: number
    predictionTarget: number
    targetDirection: $Enums.PredictionDirection
    odds?: number
    totalPot?: number
    minimumBet?: number
    maximumBet?: number | null
    startTime?: Date | string
    expiryDate: Date | string
    settlementDate?: Date | string | null
    status?: $Enums.MarketStatus
    settled?: boolean
    settledValue?: number | null
    winningDirection?: $Enums.PredictionDirection | null
    marketMakerFee?: number
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    positions?: BettingPositionCreateNestedManyWithoutMarketInput
    payouts?: BettingPayoutCreateNestedManyWithoutMarketInput
    metrics?: MarketMetricsCreateNestedManyWithoutMarketInput
  }

  export type BettingMarketUncheckedCreateWithoutCardInput = {
    id?: string
    metricType: $Enums.MarketMetricType
    title: string
    description: string
    currentValue: number
    predictionTarget: number
    targetDirection: $Enums.PredictionDirection
    odds?: number
    totalPot?: number
    minimumBet?: number
    maximumBet?: number | null
    startTime?: Date | string
    expiryDate: Date | string
    settlementDate?: Date | string | null
    status?: $Enums.MarketStatus
    settled?: boolean
    settledValue?: number | null
    winningDirection?: $Enums.PredictionDirection | null
    marketMakerFee?: number
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    positions?: BettingPositionUncheckedCreateNestedManyWithoutMarketInput
    payouts?: BettingPayoutUncheckedCreateNestedManyWithoutMarketInput
    metrics?: MarketMetricsUncheckedCreateNestedManyWithoutMarketInput
  }

  export type BettingMarketCreateOrConnectWithoutCardInput = {
    where: BettingMarketWhereUniqueInput
    create: XOR<BettingMarketCreateWithoutCardInput, BettingMarketUncheckedCreateWithoutCardInput>
  }

  export type BettingMarketCreateManyCardInputEnvelope = {
    data: BettingMarketCreateManyCardInput | BettingMarketCreateManyCardInput[]
    skipDuplicates?: boolean
  }

  export type MarketMetricsCreateWithoutCardInput = {
    id?: string
    revenue?: number | null
    userGrowth?: number | null
    valuation?: number | null
    marketCap?: number | null
    quarterlyGrowth?: number | null
    userEngagement?: number | null
    productLaunches?: number | null
    competitorRank?: number | null
    sentimentScore?: number | null
    trendingScore?: number | null
    socialMentions?: number | null
    recordDate?: Date | string
    dataSource?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    market?: BettingMarketCreateNestedOneWithoutMetricsInput
  }

  export type MarketMetricsUncheckedCreateWithoutCardInput = {
    id?: string
    marketId?: string | null
    revenue?: number | null
    userGrowth?: number | null
    valuation?: number | null
    marketCap?: number | null
    quarterlyGrowth?: number | null
    userEngagement?: number | null
    productLaunches?: number | null
    competitorRank?: number | null
    sentimentScore?: number | null
    trendingScore?: number | null
    socialMentions?: number | null
    recordDate?: Date | string
    dataSource?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketMetricsCreateOrConnectWithoutCardInput = {
    where: MarketMetricsWhereUniqueInput
    create: XOR<MarketMetricsCreateWithoutCardInput, MarketMetricsUncheckedCreateWithoutCardInput>
  }

  export type MarketMetricsCreateManyCardInputEnvelope = {
    data: MarketMetricsCreateManyCardInput | MarketMetricsCreateManyCardInput[]
    skipDuplicates?: boolean
  }

  export type CardAuctionCreateWithoutCardInput = {
    id?: string
    title: string
    description?: string | null
    startPrice: number
    reservePrice?: number | null
    currentBid?: number | null
    bidIncrement?: number
    startTime?: Date | string
    endTime: Date | string
    autoExtend?: boolean
    status?: $Enums.AuctionStatus
    finalized?: boolean
    viewCount?: number
    watcherCount?: number
    bidCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedAuctionsInput
    conditions?: AuctionConditionsCreateNestedOneWithoutAuctionInput
    winner?: UserCreateNestedOneWithoutWonAuctionsInput
    bids?: AuctionBidCreateNestedManyWithoutAuctionInput
    watchers?: AuctionWatcherCreateNestedManyWithoutAuctionInput
    history?: AuctionHistoryCreateNestedManyWithoutAuctionInput
  }

  export type CardAuctionUncheckedCreateWithoutCardInput = {
    id?: string
    ownerId: string
    title: string
    description?: string | null
    startPrice: number
    reservePrice?: number | null
    currentBid?: number | null
    bidIncrement?: number
    startTime?: Date | string
    endTime: Date | string
    autoExtend?: boolean
    status?: $Enums.AuctionStatus
    finalized?: boolean
    winnerId?: string | null
    viewCount?: number
    watcherCount?: number
    bidCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    conditions?: AuctionConditionsUncheckedCreateNestedOneWithoutAuctionInput
    bids?: AuctionBidUncheckedCreateNestedManyWithoutAuctionInput
    watchers?: AuctionWatcherUncheckedCreateNestedManyWithoutAuctionInput
    history?: AuctionHistoryUncheckedCreateNestedManyWithoutAuctionInput
  }

  export type CardAuctionCreateOrConnectWithoutCardInput = {
    where: CardAuctionWhereUniqueInput
    create: XOR<CardAuctionCreateWithoutCardInput, CardAuctionUncheckedCreateWithoutCardInput>
  }

  export type AuctionHistoryCreateWithoutCardInput = {
    id?: string
    salePrice: number
    sellerId: string
    buyerId: string
    saleType: $Enums.SaleType
    marketTrends?: NullableJsonNullValueInput | InputJsonValue
    priceHistory?: NullableJsonNullValueInput | InputJsonValue
    daysSinceListing?: number | null
    numberOfBids?: number | null
    highestBid?: number | null
    saleDate?: Date | string
    createdAt?: Date | string
    auction?: CardAuctionCreateNestedOneWithoutHistoryInput
  }

  export type AuctionHistoryUncheckedCreateWithoutCardInput = {
    id?: string
    auctionId?: string | null
    salePrice: number
    sellerId: string
    buyerId: string
    saleType: $Enums.SaleType
    marketTrends?: NullableJsonNullValueInput | InputJsonValue
    priceHistory?: NullableJsonNullValueInput | InputJsonValue
    daysSinceListing?: number | null
    numberOfBids?: number | null
    highestBid?: number | null
    saleDate?: Date | string
    createdAt?: Date | string
  }

  export type AuctionHistoryCreateOrConnectWithoutCardInput = {
    where: AuctionHistoryWhereUniqueInput
    create: XOR<AuctionHistoryCreateWithoutCardInput, AuctionHistoryUncheckedCreateWithoutCardInput>
  }

  export type AuctionHistoryCreateManyCardInputEnvelope = {
    data: AuctionHistoryCreateManyCardInput | AuctionHistoryCreateManyCardInput[]
    skipDuplicates?: boolean
  }

  export type MABattleCreateWithoutInitiatorCardInput = {
    id?: string
    battleType: $Enums.BattleType
    title: string
    description: string
    stakes: number
    timeline: Date | string
    votingPeriod: Date | string
    status?: $Enums.BattleStatus
    resolved?: boolean
    viewCount?: number
    participantCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    targetCard: CardCreateNestedOneWithoutTargetedBattlesInput
    initiator: UserCreateNestedOneWithoutInitiatedMABattlesInput
    target?: UserCreateNestedOneWithoutTargetedMABattlesInput
    winner?: BattleOutcomeCreateNestedOneWithoutWinningBattleInput
    proposals?: BattleProposalCreateNestedManyWithoutBattleInput
    votes?: BattleVotingCreateNestedManyWithoutBattleInput
    outcomes?: BattleOutcomeCreateNestedManyWithoutBattleInput
  }

  export type MABattleUncheckedCreateWithoutInitiatorCardInput = {
    id?: string
    targetCardId: string
    initiatorUserId: string
    targetUserId?: string | null
    battleType: $Enums.BattleType
    title: string
    description: string
    stakes: number
    timeline: Date | string
    votingPeriod: Date | string
    status?: $Enums.BattleStatus
    resolved?: boolean
    viewCount?: number
    participantCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    winner?: BattleOutcomeUncheckedCreateNestedOneWithoutWinningBattleInput
    proposals?: BattleProposalUncheckedCreateNestedManyWithoutBattleInput
    votes?: BattleVotingUncheckedCreateNestedManyWithoutBattleInput
    outcomes?: BattleOutcomeUncheckedCreateNestedManyWithoutBattleInput
  }

  export type MABattleCreateOrConnectWithoutInitiatorCardInput = {
    where: MABattleWhereUniqueInput
    create: XOR<MABattleCreateWithoutInitiatorCardInput, MABattleUncheckedCreateWithoutInitiatorCardInput>
  }

  export type MABattleCreateManyInitiatorCardInputEnvelope = {
    data: MABattleCreateManyInitiatorCardInput | MABattleCreateManyInitiatorCardInput[]
    skipDuplicates?: boolean
  }

  export type MABattleCreateWithoutTargetCardInput = {
    id?: string
    battleType: $Enums.BattleType
    title: string
    description: string
    stakes: number
    timeline: Date | string
    votingPeriod: Date | string
    status?: $Enums.BattleStatus
    resolved?: boolean
    viewCount?: number
    participantCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    initiatorCard: CardCreateNestedOneWithoutInitiatedBattlesInput
    initiator: UserCreateNestedOneWithoutInitiatedMABattlesInput
    target?: UserCreateNestedOneWithoutTargetedMABattlesInput
    winner?: BattleOutcomeCreateNestedOneWithoutWinningBattleInput
    proposals?: BattleProposalCreateNestedManyWithoutBattleInput
    votes?: BattleVotingCreateNestedManyWithoutBattleInput
    outcomes?: BattleOutcomeCreateNestedManyWithoutBattleInput
  }

  export type MABattleUncheckedCreateWithoutTargetCardInput = {
    id?: string
    initiatorCardId: string
    initiatorUserId: string
    targetUserId?: string | null
    battleType: $Enums.BattleType
    title: string
    description: string
    stakes: number
    timeline: Date | string
    votingPeriod: Date | string
    status?: $Enums.BattleStatus
    resolved?: boolean
    viewCount?: number
    participantCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    winner?: BattleOutcomeUncheckedCreateNestedOneWithoutWinningBattleInput
    proposals?: BattleProposalUncheckedCreateNestedManyWithoutBattleInput
    votes?: BattleVotingUncheckedCreateNestedManyWithoutBattleInput
    outcomes?: BattleOutcomeUncheckedCreateNestedManyWithoutBattleInput
  }

  export type MABattleCreateOrConnectWithoutTargetCardInput = {
    where: MABattleWhereUniqueInput
    create: XOR<MABattleCreateWithoutTargetCardInput, MABattleUncheckedCreateWithoutTargetCardInput>
  }

  export type MABattleCreateManyTargetCardInputEnvelope = {
    data: MABattleCreateManyTargetCardInput | MABattleCreateManyTargetCardInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutOwnedCardsInput = {
    update: XOR<UserUpdateWithoutOwnedCardsInput, UserUncheckedUpdateWithoutOwnedCardsInput>
    create: XOR<UserCreateWithoutOwnedCardsInput, UserUncheckedCreateWithoutOwnedCardsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOwnedCardsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOwnedCardsInput, UserUncheckedUpdateWithoutOwnedCardsInput>
  }

  export type UserUpdateWithoutOwnedCardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eceBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: UserSubscriptionUpdateOneWithoutUserNestedInput
    cryptoWallets?: CryptoWalletUpdateManyWithoutUserNestedInput
    physicalCard?: PhysicalCardUpdateOneWithoutUserNestedInput
    tradingHistory?: TransactionUpdateManyWithoutUserNestedInput
    bids?: BidUpdateManyWithoutBidderNestedInput
    listings?: MarketplaceListingUpdateManyWithoutSellerNestedInput
    appOrders?: AppOrderUpdateManyWithoutUserNestedInput
    orderRevisions?: OrderRevisionUpdateManyWithoutUserNestedInput
    orderCommunications?: OrderCommunicationUpdateManyWithoutUserNestedInput
    bettingPositions?: BettingPositionUpdateManyWithoutUserNestedInput
    bettingPayouts?: BettingPayoutUpdateManyWithoutUserNestedInput
    ownedAuctions?: CardAuctionUpdateManyWithoutOwnerNestedInput
    wonAuctions?: CardAuctionUpdateManyWithoutWinnerNestedInput
    placedAuctionBids?: AuctionBidUpdateManyWithoutBidderNestedInput
    watchedAuctions?: AuctionWatcherUpdateManyWithoutUserNestedInput
    initiatedMABattles?: MABattleUpdateManyWithoutInitiatorNestedInput
    targetedMABattles?: MABattleUpdateManyWithoutTargetNestedInput
    battleProposals?: BattleProposalUpdateManyWithoutProposerNestedInput
    battleVotes?: BattleVotingUpdateManyWithoutVoterNestedInput
    stakingPositions?: StakingPositionUpdateManyWithoutUserNestedInput
    stakingRewards?: StakingRewardUpdateManyWithoutUserNestedInput
    governanceProposals?: GovernanceProposalUpdateManyWithoutProposerNestedInput
    governanceVotes?: GovernanceVoteUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    socialFeeds?: SocialFeedUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutOwnedCardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eceBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: UserSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    cryptoWallets?: CryptoWalletUncheckedUpdateManyWithoutUserNestedInput
    physicalCard?: PhysicalCardUncheckedUpdateOneWithoutUserNestedInput
    tradingHistory?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderNestedInput
    listings?: MarketplaceListingUncheckedUpdateManyWithoutSellerNestedInput
    appOrders?: AppOrderUncheckedUpdateManyWithoutUserNestedInput
    orderRevisions?: OrderRevisionUncheckedUpdateManyWithoutUserNestedInput
    orderCommunications?: OrderCommunicationUncheckedUpdateManyWithoutUserNestedInput
    bettingPositions?: BettingPositionUncheckedUpdateManyWithoutUserNestedInput
    bettingPayouts?: BettingPayoutUncheckedUpdateManyWithoutUserNestedInput
    ownedAuctions?: CardAuctionUncheckedUpdateManyWithoutOwnerNestedInput
    wonAuctions?: CardAuctionUncheckedUpdateManyWithoutWinnerNestedInput
    placedAuctionBids?: AuctionBidUncheckedUpdateManyWithoutBidderNestedInput
    watchedAuctions?: AuctionWatcherUncheckedUpdateManyWithoutUserNestedInput
    initiatedMABattles?: MABattleUncheckedUpdateManyWithoutInitiatorNestedInput
    targetedMABattles?: MABattleUncheckedUpdateManyWithoutTargetNestedInput
    battleProposals?: BattleProposalUncheckedUpdateManyWithoutProposerNestedInput
    battleVotes?: BattleVotingUncheckedUpdateManyWithoutVoterNestedInput
    stakingPositions?: StakingPositionUncheckedUpdateManyWithoutUserNestedInput
    stakingRewards?: StakingRewardUncheckedUpdateManyWithoutUserNestedInput
    governanceProposals?: GovernanceProposalUncheckedUpdateManyWithoutProposerNestedInput
    governanceVotes?: GovernanceVoteUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    socialFeeds?: SocialFeedUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type MarketplaceListingUpsertWithoutCardInput = {
    update: XOR<MarketplaceListingUpdateWithoutCardInput, MarketplaceListingUncheckedUpdateWithoutCardInput>
    create: XOR<MarketplaceListingCreateWithoutCardInput, MarketplaceListingUncheckedCreateWithoutCardInput>
    where?: MarketplaceListingWhereInput
  }

  export type MarketplaceListingUpdateToOneWithWhereWithoutCardInput = {
    where?: MarketplaceListingWhereInput
    data: XOR<MarketplaceListingUpdateWithoutCardInput, MarketplaceListingUncheckedUpdateWithoutCardInput>
  }

  export type MarketplaceListingUpdateWithoutCardInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    listingType?: EnumListingTypeFieldUpdateOperationsInput | $Enums.ListingType
    auctionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    featured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seller?: UserUpdateOneRequiredWithoutListingsNestedInput
    bids?: BidUpdateManyWithoutListingNestedInput
  }

  export type MarketplaceListingUncheckedUpdateWithoutCardInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    listingType?: EnumListingTypeFieldUpdateOperationsInput | $Enums.ListingType
    auctionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    featured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bids?: BidUncheckedUpdateManyWithoutListingNestedInput
  }

  export type BidUpsertWithWhereUniqueWithoutCardInput = {
    where: BidWhereUniqueInput
    update: XOR<BidUpdateWithoutCardInput, BidUncheckedUpdateWithoutCardInput>
    create: XOR<BidCreateWithoutCardInput, BidUncheckedCreateWithoutCardInput>
  }

  export type BidUpdateWithWhereUniqueWithoutCardInput = {
    where: BidWhereUniqueInput
    data: XOR<BidUpdateWithoutCardInput, BidUncheckedUpdateWithoutCardInput>
  }

  export type BidUpdateManyWithWhereWithoutCardInput = {
    where: BidScalarWhereInput
    data: XOR<BidUpdateManyMutationInput, BidUncheckedUpdateManyWithoutCardInput>
  }

  export type TransactionUpsertWithWhereUniqueWithoutCardInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutCardInput, TransactionUncheckedUpdateWithoutCardInput>
    create: XOR<TransactionCreateWithoutCardInput, TransactionUncheckedCreateWithoutCardInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutCardInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutCardInput, TransactionUncheckedUpdateWithoutCardInput>
  }

  export type TransactionUpdateManyWithWhereWithoutCardInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutCardInput>
  }

  export type BettingMarketUpsertWithWhereUniqueWithoutCardInput = {
    where: BettingMarketWhereUniqueInput
    update: XOR<BettingMarketUpdateWithoutCardInput, BettingMarketUncheckedUpdateWithoutCardInput>
    create: XOR<BettingMarketCreateWithoutCardInput, BettingMarketUncheckedCreateWithoutCardInput>
  }

  export type BettingMarketUpdateWithWhereUniqueWithoutCardInput = {
    where: BettingMarketWhereUniqueInput
    data: XOR<BettingMarketUpdateWithoutCardInput, BettingMarketUncheckedUpdateWithoutCardInput>
  }

  export type BettingMarketUpdateManyWithWhereWithoutCardInput = {
    where: BettingMarketScalarWhereInput
    data: XOR<BettingMarketUpdateManyMutationInput, BettingMarketUncheckedUpdateManyWithoutCardInput>
  }

  export type BettingMarketScalarWhereInput = {
    AND?: BettingMarketScalarWhereInput | BettingMarketScalarWhereInput[]
    OR?: BettingMarketScalarWhereInput[]
    NOT?: BettingMarketScalarWhereInput | BettingMarketScalarWhereInput[]
    id?: StringFilter<"BettingMarket"> | string
    cardId?: StringFilter<"BettingMarket"> | string
    metricType?: EnumMarketMetricTypeFilter<"BettingMarket"> | $Enums.MarketMetricType
    title?: StringFilter<"BettingMarket"> | string
    description?: StringFilter<"BettingMarket"> | string
    currentValue?: FloatFilter<"BettingMarket"> | number
    predictionTarget?: FloatFilter<"BettingMarket"> | number
    targetDirection?: EnumPredictionDirectionFilter<"BettingMarket"> | $Enums.PredictionDirection
    odds?: FloatFilter<"BettingMarket"> | number
    totalPot?: FloatFilter<"BettingMarket"> | number
    minimumBet?: FloatFilter<"BettingMarket"> | number
    maximumBet?: FloatNullableFilter<"BettingMarket"> | number | null
    startTime?: DateTimeFilter<"BettingMarket"> | Date | string
    expiryDate?: DateTimeFilter<"BettingMarket"> | Date | string
    settlementDate?: DateTimeNullableFilter<"BettingMarket"> | Date | string | null
    status?: EnumMarketStatusFilter<"BettingMarket"> | $Enums.MarketStatus
    settled?: BoolFilter<"BettingMarket"> | boolean
    settledValue?: FloatNullableFilter<"BettingMarket"> | number | null
    winningDirection?: EnumPredictionDirectionNullableFilter<"BettingMarket"> | $Enums.PredictionDirection | null
    marketMakerFee?: FloatFilter<"BettingMarket"> | number
    createdBy?: StringNullableFilter<"BettingMarket"> | string | null
    createdAt?: DateTimeFilter<"BettingMarket"> | Date | string
    updatedAt?: DateTimeFilter<"BettingMarket"> | Date | string
  }

  export type MarketMetricsUpsertWithWhereUniqueWithoutCardInput = {
    where: MarketMetricsWhereUniqueInput
    update: XOR<MarketMetricsUpdateWithoutCardInput, MarketMetricsUncheckedUpdateWithoutCardInput>
    create: XOR<MarketMetricsCreateWithoutCardInput, MarketMetricsUncheckedCreateWithoutCardInput>
  }

  export type MarketMetricsUpdateWithWhereUniqueWithoutCardInput = {
    where: MarketMetricsWhereUniqueInput
    data: XOR<MarketMetricsUpdateWithoutCardInput, MarketMetricsUncheckedUpdateWithoutCardInput>
  }

  export type MarketMetricsUpdateManyWithWhereWithoutCardInput = {
    where: MarketMetricsScalarWhereInput
    data: XOR<MarketMetricsUpdateManyMutationInput, MarketMetricsUncheckedUpdateManyWithoutCardInput>
  }

  export type MarketMetricsScalarWhereInput = {
    AND?: MarketMetricsScalarWhereInput | MarketMetricsScalarWhereInput[]
    OR?: MarketMetricsScalarWhereInput[]
    NOT?: MarketMetricsScalarWhereInput | MarketMetricsScalarWhereInput[]
    id?: StringFilter<"MarketMetrics"> | string
    cardId?: StringFilter<"MarketMetrics"> | string
    marketId?: StringNullableFilter<"MarketMetrics"> | string | null
    revenue?: FloatNullableFilter<"MarketMetrics"> | number | null
    userGrowth?: FloatNullableFilter<"MarketMetrics"> | number | null
    valuation?: FloatNullableFilter<"MarketMetrics"> | number | null
    marketCap?: FloatNullableFilter<"MarketMetrics"> | number | null
    quarterlyGrowth?: FloatNullableFilter<"MarketMetrics"> | number | null
    userEngagement?: FloatNullableFilter<"MarketMetrics"> | number | null
    productLaunches?: IntNullableFilter<"MarketMetrics"> | number | null
    competitorRank?: IntNullableFilter<"MarketMetrics"> | number | null
    sentimentScore?: FloatNullableFilter<"MarketMetrics"> | number | null
    trendingScore?: FloatNullableFilter<"MarketMetrics"> | number | null
    socialMentions?: IntNullableFilter<"MarketMetrics"> | number | null
    recordDate?: DateTimeFilter<"MarketMetrics"> | Date | string
    dataSource?: StringNullableFilter<"MarketMetrics"> | string | null
    createdAt?: DateTimeFilter<"MarketMetrics"> | Date | string
    updatedAt?: DateTimeFilter<"MarketMetrics"> | Date | string
  }

  export type CardAuctionUpsertWithoutCardInput = {
    update: XOR<CardAuctionUpdateWithoutCardInput, CardAuctionUncheckedUpdateWithoutCardInput>
    create: XOR<CardAuctionCreateWithoutCardInput, CardAuctionUncheckedCreateWithoutCardInput>
    where?: CardAuctionWhereInput
  }

  export type CardAuctionUpdateToOneWithWhereWithoutCardInput = {
    where?: CardAuctionWhereInput
    data: XOR<CardAuctionUpdateWithoutCardInput, CardAuctionUncheckedUpdateWithoutCardInput>
  }

  export type CardAuctionUpdateWithoutCardInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startPrice?: FloatFieldUpdateOperationsInput | number
    reservePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currentBid?: NullableFloatFieldUpdateOperationsInput | number | null
    bidIncrement?: FloatFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    autoExtend?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAuctionStatusFieldUpdateOperationsInput | $Enums.AuctionStatus
    finalized?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    watcherCount?: IntFieldUpdateOperationsInput | number
    bidCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedAuctionsNestedInput
    conditions?: AuctionConditionsUpdateOneWithoutAuctionNestedInput
    winner?: UserUpdateOneWithoutWonAuctionsNestedInput
    bids?: AuctionBidUpdateManyWithoutAuctionNestedInput
    watchers?: AuctionWatcherUpdateManyWithoutAuctionNestedInput
    history?: AuctionHistoryUpdateManyWithoutAuctionNestedInput
  }

  export type CardAuctionUncheckedUpdateWithoutCardInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startPrice?: FloatFieldUpdateOperationsInput | number
    reservePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currentBid?: NullableFloatFieldUpdateOperationsInput | number | null
    bidIncrement?: FloatFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    autoExtend?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAuctionStatusFieldUpdateOperationsInput | $Enums.AuctionStatus
    finalized?: BoolFieldUpdateOperationsInput | boolean
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    watcherCount?: IntFieldUpdateOperationsInput | number
    bidCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conditions?: AuctionConditionsUncheckedUpdateOneWithoutAuctionNestedInput
    bids?: AuctionBidUncheckedUpdateManyWithoutAuctionNestedInput
    watchers?: AuctionWatcherUncheckedUpdateManyWithoutAuctionNestedInput
    history?: AuctionHistoryUncheckedUpdateManyWithoutAuctionNestedInput
  }

  export type AuctionHistoryUpsertWithWhereUniqueWithoutCardInput = {
    where: AuctionHistoryWhereUniqueInput
    update: XOR<AuctionHistoryUpdateWithoutCardInput, AuctionHistoryUncheckedUpdateWithoutCardInput>
    create: XOR<AuctionHistoryCreateWithoutCardInput, AuctionHistoryUncheckedCreateWithoutCardInput>
  }

  export type AuctionHistoryUpdateWithWhereUniqueWithoutCardInput = {
    where: AuctionHistoryWhereUniqueInput
    data: XOR<AuctionHistoryUpdateWithoutCardInput, AuctionHistoryUncheckedUpdateWithoutCardInput>
  }

  export type AuctionHistoryUpdateManyWithWhereWithoutCardInput = {
    where: AuctionHistoryScalarWhereInput
    data: XOR<AuctionHistoryUpdateManyMutationInput, AuctionHistoryUncheckedUpdateManyWithoutCardInput>
  }

  export type AuctionHistoryScalarWhereInput = {
    AND?: AuctionHistoryScalarWhereInput | AuctionHistoryScalarWhereInput[]
    OR?: AuctionHistoryScalarWhereInput[]
    NOT?: AuctionHistoryScalarWhereInput | AuctionHistoryScalarWhereInput[]
    id?: StringFilter<"AuctionHistory"> | string
    cardId?: StringFilter<"AuctionHistory"> | string
    auctionId?: StringNullableFilter<"AuctionHistory"> | string | null
    salePrice?: FloatFilter<"AuctionHistory"> | number
    sellerId?: StringFilter<"AuctionHistory"> | string
    buyerId?: StringFilter<"AuctionHistory"> | string
    saleType?: EnumSaleTypeFilter<"AuctionHistory"> | $Enums.SaleType
    marketTrends?: JsonNullableFilter<"AuctionHistory">
    priceHistory?: JsonNullableFilter<"AuctionHistory">
    daysSinceListing?: IntNullableFilter<"AuctionHistory"> | number | null
    numberOfBids?: IntNullableFilter<"AuctionHistory"> | number | null
    highestBid?: FloatNullableFilter<"AuctionHistory"> | number | null
    saleDate?: DateTimeFilter<"AuctionHistory"> | Date | string
    createdAt?: DateTimeFilter<"AuctionHistory"> | Date | string
  }

  export type MABattleUpsertWithWhereUniqueWithoutInitiatorCardInput = {
    where: MABattleWhereUniqueInput
    update: XOR<MABattleUpdateWithoutInitiatorCardInput, MABattleUncheckedUpdateWithoutInitiatorCardInput>
    create: XOR<MABattleCreateWithoutInitiatorCardInput, MABattleUncheckedCreateWithoutInitiatorCardInput>
  }

  export type MABattleUpdateWithWhereUniqueWithoutInitiatorCardInput = {
    where: MABattleWhereUniqueInput
    data: XOR<MABattleUpdateWithoutInitiatorCardInput, MABattleUncheckedUpdateWithoutInitiatorCardInput>
  }

  export type MABattleUpdateManyWithWhereWithoutInitiatorCardInput = {
    where: MABattleScalarWhereInput
    data: XOR<MABattleUpdateManyMutationInput, MABattleUncheckedUpdateManyWithoutInitiatorCardInput>
  }

  export type MABattleUpsertWithWhereUniqueWithoutTargetCardInput = {
    where: MABattleWhereUniqueInput
    update: XOR<MABattleUpdateWithoutTargetCardInput, MABattleUncheckedUpdateWithoutTargetCardInput>
    create: XOR<MABattleCreateWithoutTargetCardInput, MABattleUncheckedCreateWithoutTargetCardInput>
  }

  export type MABattleUpdateWithWhereUniqueWithoutTargetCardInput = {
    where: MABattleWhereUniqueInput
    data: XOR<MABattleUpdateWithoutTargetCardInput, MABattleUncheckedUpdateWithoutTargetCardInput>
  }

  export type MABattleUpdateManyWithWhereWithoutTargetCardInput = {
    where: MABattleScalarWhereInput
    data: XOR<MABattleUpdateManyMutationInput, MABattleUncheckedUpdateManyWithoutTargetCardInput>
  }

  export type CardCreateWithoutListingInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.CardCategory
    rarity: $Enums.CardRarity
    company?: string | null
    currentPrice: number
    historicalPrices?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    stats?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedCardsInput
    bids?: BidCreateNestedManyWithoutCardInput
    transactions?: TransactionCreateNestedManyWithoutCardInput
    bettingMarkets?: BettingMarketCreateNestedManyWithoutCardInput
    marketMetrics?: MarketMetricsCreateNestedManyWithoutCardInput
    auction?: CardAuctionCreateNestedOneWithoutCardInput
    auctionHistory?: AuctionHistoryCreateNestedManyWithoutCardInput
    initiatedBattles?: MABattleCreateNestedManyWithoutInitiatorCardInput
    targetedBattles?: MABattleCreateNestedManyWithoutTargetCardInput
  }

  export type CardUncheckedCreateWithoutListingInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.CardCategory
    rarity: $Enums.CardRarity
    company?: string | null
    currentPrice: number
    historicalPrices?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    stats?: NullableJsonNullValueInput | InputJsonValue
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bids?: BidUncheckedCreateNestedManyWithoutCardInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCardInput
    bettingMarkets?: BettingMarketUncheckedCreateNestedManyWithoutCardInput
    marketMetrics?: MarketMetricsUncheckedCreateNestedManyWithoutCardInput
    auction?: CardAuctionUncheckedCreateNestedOneWithoutCardInput
    auctionHistory?: AuctionHistoryUncheckedCreateNestedManyWithoutCardInput
    initiatedBattles?: MABattleUncheckedCreateNestedManyWithoutInitiatorCardInput
    targetedBattles?: MABattleUncheckedCreateNestedManyWithoutTargetCardInput
  }

  export type CardCreateOrConnectWithoutListingInput = {
    where: CardWhereUniqueInput
    create: XOR<CardCreateWithoutListingInput, CardUncheckedCreateWithoutListingInput>
  }

  export type UserCreateWithoutListingsInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    passwordHash?: string | null
    emailVerified?: Date | string | null
    eceBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string
    subscription?: UserSubscriptionCreateNestedOneWithoutUserInput
    cryptoWallets?: CryptoWalletCreateNestedManyWithoutUserInput
    physicalCard?: PhysicalCardCreateNestedOneWithoutUserInput
    ownedCards?: CardCreateNestedManyWithoutOwnerInput
    tradingHistory?: TransactionCreateNestedManyWithoutUserInput
    bids?: BidCreateNestedManyWithoutBidderInput
    appOrders?: AppOrderCreateNestedManyWithoutUserInput
    orderRevisions?: OrderRevisionCreateNestedManyWithoutUserInput
    orderCommunications?: OrderCommunicationCreateNestedManyWithoutUserInput
    bettingPositions?: BettingPositionCreateNestedManyWithoutUserInput
    bettingPayouts?: BettingPayoutCreateNestedManyWithoutUserInput
    ownedAuctions?: CardAuctionCreateNestedManyWithoutOwnerInput
    wonAuctions?: CardAuctionCreateNestedManyWithoutWinnerInput
    placedAuctionBids?: AuctionBidCreateNestedManyWithoutBidderInput
    watchedAuctions?: AuctionWatcherCreateNestedManyWithoutUserInput
    initiatedMABattles?: MABattleCreateNestedManyWithoutInitiatorInput
    targetedMABattles?: MABattleCreateNestedManyWithoutTargetInput
    battleProposals?: BattleProposalCreateNestedManyWithoutProposerInput
    battleVotes?: BattleVotingCreateNestedManyWithoutVoterInput
    stakingPositions?: StakingPositionCreateNestedManyWithoutUserInput
    stakingRewards?: StakingRewardCreateNestedManyWithoutUserInput
    governanceProposals?: GovernanceProposalCreateNestedManyWithoutProposerInput
    governanceVotes?: GovernanceVoteCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    socialFeeds?: SocialFeedCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutListingsInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    passwordHash?: string | null
    emailVerified?: Date | string | null
    eceBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string
    subscription?: UserSubscriptionUncheckedCreateNestedOneWithoutUserInput
    cryptoWallets?: CryptoWalletUncheckedCreateNestedManyWithoutUserInput
    physicalCard?: PhysicalCardUncheckedCreateNestedOneWithoutUserInput
    ownedCards?: CardUncheckedCreateNestedManyWithoutOwnerInput
    tradingHistory?: TransactionUncheckedCreateNestedManyWithoutUserInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderInput
    appOrders?: AppOrderUncheckedCreateNestedManyWithoutUserInput
    orderRevisions?: OrderRevisionUncheckedCreateNestedManyWithoutUserInput
    orderCommunications?: OrderCommunicationUncheckedCreateNestedManyWithoutUserInput
    bettingPositions?: BettingPositionUncheckedCreateNestedManyWithoutUserInput
    bettingPayouts?: BettingPayoutUncheckedCreateNestedManyWithoutUserInput
    ownedAuctions?: CardAuctionUncheckedCreateNestedManyWithoutOwnerInput
    wonAuctions?: CardAuctionUncheckedCreateNestedManyWithoutWinnerInput
    placedAuctionBids?: AuctionBidUncheckedCreateNestedManyWithoutBidderInput
    watchedAuctions?: AuctionWatcherUncheckedCreateNestedManyWithoutUserInput
    initiatedMABattles?: MABattleUncheckedCreateNestedManyWithoutInitiatorInput
    targetedMABattles?: MABattleUncheckedCreateNestedManyWithoutTargetInput
    battleProposals?: BattleProposalUncheckedCreateNestedManyWithoutProposerInput
    battleVotes?: BattleVotingUncheckedCreateNestedManyWithoutVoterInput
    stakingPositions?: StakingPositionUncheckedCreateNestedManyWithoutUserInput
    stakingRewards?: StakingRewardUncheckedCreateNestedManyWithoutUserInput
    governanceProposals?: GovernanceProposalUncheckedCreateNestedManyWithoutProposerInput
    governanceVotes?: GovernanceVoteUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    socialFeeds?: SocialFeedUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutListingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutListingsInput, UserUncheckedCreateWithoutListingsInput>
  }

  export type BidCreateWithoutListingInput = {
    id?: string
    amount: number
    status?: $Enums.BidStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    bidder: UserCreateNestedOneWithoutBidsInput
    card: CardCreateNestedOneWithoutBidsInput
  }

  export type BidUncheckedCreateWithoutListingInput = {
    id?: string
    bidderId: string
    cardId: string
    amount: number
    status?: $Enums.BidStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BidCreateOrConnectWithoutListingInput = {
    where: BidWhereUniqueInput
    create: XOR<BidCreateWithoutListingInput, BidUncheckedCreateWithoutListingInput>
  }

  export type BidCreateManyListingInputEnvelope = {
    data: BidCreateManyListingInput | BidCreateManyListingInput[]
    skipDuplicates?: boolean
  }

  export type CardUpsertWithoutListingInput = {
    update: XOR<CardUpdateWithoutListingInput, CardUncheckedUpdateWithoutListingInput>
    create: XOR<CardCreateWithoutListingInput, CardUncheckedCreateWithoutListingInput>
    where?: CardWhereInput
  }

  export type CardUpdateToOneWithWhereWithoutListingInput = {
    where?: CardWhereInput
    data: XOR<CardUpdateWithoutListingInput, CardUncheckedUpdateWithoutListingInput>
  }

  export type CardUpdateWithoutListingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCardCategoryFieldUpdateOperationsInput | $Enums.CardCategory
    rarity?: EnumCardRarityFieldUpdateOperationsInput | $Enums.CardRarity
    company?: NullableStringFieldUpdateOperationsInput | string | null
    currentPrice?: FloatFieldUpdateOperationsInput | number
    historicalPrices?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    stats?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedCardsNestedInput
    bids?: BidUpdateManyWithoutCardNestedInput
    transactions?: TransactionUpdateManyWithoutCardNestedInput
    bettingMarkets?: BettingMarketUpdateManyWithoutCardNestedInput
    marketMetrics?: MarketMetricsUpdateManyWithoutCardNestedInput
    auction?: CardAuctionUpdateOneWithoutCardNestedInput
    auctionHistory?: AuctionHistoryUpdateManyWithoutCardNestedInput
    initiatedBattles?: MABattleUpdateManyWithoutInitiatorCardNestedInput
    targetedBattles?: MABattleUpdateManyWithoutTargetCardNestedInput
  }

  export type CardUncheckedUpdateWithoutListingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCardCategoryFieldUpdateOperationsInput | $Enums.CardCategory
    rarity?: EnumCardRarityFieldUpdateOperationsInput | $Enums.CardRarity
    company?: NullableStringFieldUpdateOperationsInput | string | null
    currentPrice?: FloatFieldUpdateOperationsInput | number
    historicalPrices?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    stats?: NullableJsonNullValueInput | InputJsonValue
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bids?: BidUncheckedUpdateManyWithoutCardNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCardNestedInput
    bettingMarkets?: BettingMarketUncheckedUpdateManyWithoutCardNestedInput
    marketMetrics?: MarketMetricsUncheckedUpdateManyWithoutCardNestedInput
    auction?: CardAuctionUncheckedUpdateOneWithoutCardNestedInput
    auctionHistory?: AuctionHistoryUncheckedUpdateManyWithoutCardNestedInput
    initiatedBattles?: MABattleUncheckedUpdateManyWithoutInitiatorCardNestedInput
    targetedBattles?: MABattleUncheckedUpdateManyWithoutTargetCardNestedInput
  }

  export type UserUpsertWithoutListingsInput = {
    update: XOR<UserUpdateWithoutListingsInput, UserUncheckedUpdateWithoutListingsInput>
    create: XOR<UserCreateWithoutListingsInput, UserUncheckedCreateWithoutListingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutListingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutListingsInput, UserUncheckedUpdateWithoutListingsInput>
  }

  export type UserUpdateWithoutListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eceBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: UserSubscriptionUpdateOneWithoutUserNestedInput
    cryptoWallets?: CryptoWalletUpdateManyWithoutUserNestedInput
    physicalCard?: PhysicalCardUpdateOneWithoutUserNestedInput
    ownedCards?: CardUpdateManyWithoutOwnerNestedInput
    tradingHistory?: TransactionUpdateManyWithoutUserNestedInput
    bids?: BidUpdateManyWithoutBidderNestedInput
    appOrders?: AppOrderUpdateManyWithoutUserNestedInput
    orderRevisions?: OrderRevisionUpdateManyWithoutUserNestedInput
    orderCommunications?: OrderCommunicationUpdateManyWithoutUserNestedInput
    bettingPositions?: BettingPositionUpdateManyWithoutUserNestedInput
    bettingPayouts?: BettingPayoutUpdateManyWithoutUserNestedInput
    ownedAuctions?: CardAuctionUpdateManyWithoutOwnerNestedInput
    wonAuctions?: CardAuctionUpdateManyWithoutWinnerNestedInput
    placedAuctionBids?: AuctionBidUpdateManyWithoutBidderNestedInput
    watchedAuctions?: AuctionWatcherUpdateManyWithoutUserNestedInput
    initiatedMABattles?: MABattleUpdateManyWithoutInitiatorNestedInput
    targetedMABattles?: MABattleUpdateManyWithoutTargetNestedInput
    battleProposals?: BattleProposalUpdateManyWithoutProposerNestedInput
    battleVotes?: BattleVotingUpdateManyWithoutVoterNestedInput
    stakingPositions?: StakingPositionUpdateManyWithoutUserNestedInput
    stakingRewards?: StakingRewardUpdateManyWithoutUserNestedInput
    governanceProposals?: GovernanceProposalUpdateManyWithoutProposerNestedInput
    governanceVotes?: GovernanceVoteUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    socialFeeds?: SocialFeedUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eceBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: UserSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    cryptoWallets?: CryptoWalletUncheckedUpdateManyWithoutUserNestedInput
    physicalCard?: PhysicalCardUncheckedUpdateOneWithoutUserNestedInput
    ownedCards?: CardUncheckedUpdateManyWithoutOwnerNestedInput
    tradingHistory?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderNestedInput
    appOrders?: AppOrderUncheckedUpdateManyWithoutUserNestedInput
    orderRevisions?: OrderRevisionUncheckedUpdateManyWithoutUserNestedInput
    orderCommunications?: OrderCommunicationUncheckedUpdateManyWithoutUserNestedInput
    bettingPositions?: BettingPositionUncheckedUpdateManyWithoutUserNestedInput
    bettingPayouts?: BettingPayoutUncheckedUpdateManyWithoutUserNestedInput
    ownedAuctions?: CardAuctionUncheckedUpdateManyWithoutOwnerNestedInput
    wonAuctions?: CardAuctionUncheckedUpdateManyWithoutWinnerNestedInput
    placedAuctionBids?: AuctionBidUncheckedUpdateManyWithoutBidderNestedInput
    watchedAuctions?: AuctionWatcherUncheckedUpdateManyWithoutUserNestedInput
    initiatedMABattles?: MABattleUncheckedUpdateManyWithoutInitiatorNestedInput
    targetedMABattles?: MABattleUncheckedUpdateManyWithoutTargetNestedInput
    battleProposals?: BattleProposalUncheckedUpdateManyWithoutProposerNestedInput
    battleVotes?: BattleVotingUncheckedUpdateManyWithoutVoterNestedInput
    stakingPositions?: StakingPositionUncheckedUpdateManyWithoutUserNestedInput
    stakingRewards?: StakingRewardUncheckedUpdateManyWithoutUserNestedInput
    governanceProposals?: GovernanceProposalUncheckedUpdateManyWithoutProposerNestedInput
    governanceVotes?: GovernanceVoteUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    socialFeeds?: SocialFeedUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type BidUpsertWithWhereUniqueWithoutListingInput = {
    where: BidWhereUniqueInput
    update: XOR<BidUpdateWithoutListingInput, BidUncheckedUpdateWithoutListingInput>
    create: XOR<BidCreateWithoutListingInput, BidUncheckedCreateWithoutListingInput>
  }

  export type BidUpdateWithWhereUniqueWithoutListingInput = {
    where: BidWhereUniqueInput
    data: XOR<BidUpdateWithoutListingInput, BidUncheckedUpdateWithoutListingInput>
  }

  export type BidUpdateManyWithWhereWithoutListingInput = {
    where: BidScalarWhereInput
    data: XOR<BidUpdateManyMutationInput, BidUncheckedUpdateManyWithoutListingInput>
  }

  export type MarketplaceListingCreateWithoutBidsInput = {
    id?: string
    price: number
    listingType?: $Enums.ListingType
    auctionEnd?: Date | string | null
    status?: $Enums.ListingStatus
    featured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    card: CardCreateNestedOneWithoutListingInput
    seller: UserCreateNestedOneWithoutListingsInput
  }

  export type MarketplaceListingUncheckedCreateWithoutBidsInput = {
    id?: string
    cardId: string
    sellerId: string
    price: number
    listingType?: $Enums.ListingType
    auctionEnd?: Date | string | null
    status?: $Enums.ListingStatus
    featured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketplaceListingCreateOrConnectWithoutBidsInput = {
    where: MarketplaceListingWhereUniqueInput
    create: XOR<MarketplaceListingCreateWithoutBidsInput, MarketplaceListingUncheckedCreateWithoutBidsInput>
  }

  export type UserCreateWithoutBidsInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    passwordHash?: string | null
    emailVerified?: Date | string | null
    eceBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string
    subscription?: UserSubscriptionCreateNestedOneWithoutUserInput
    cryptoWallets?: CryptoWalletCreateNestedManyWithoutUserInput
    physicalCard?: PhysicalCardCreateNestedOneWithoutUserInput
    ownedCards?: CardCreateNestedManyWithoutOwnerInput
    tradingHistory?: TransactionCreateNestedManyWithoutUserInput
    listings?: MarketplaceListingCreateNestedManyWithoutSellerInput
    appOrders?: AppOrderCreateNestedManyWithoutUserInput
    orderRevisions?: OrderRevisionCreateNestedManyWithoutUserInput
    orderCommunications?: OrderCommunicationCreateNestedManyWithoutUserInput
    bettingPositions?: BettingPositionCreateNestedManyWithoutUserInput
    bettingPayouts?: BettingPayoutCreateNestedManyWithoutUserInput
    ownedAuctions?: CardAuctionCreateNestedManyWithoutOwnerInput
    wonAuctions?: CardAuctionCreateNestedManyWithoutWinnerInput
    placedAuctionBids?: AuctionBidCreateNestedManyWithoutBidderInput
    watchedAuctions?: AuctionWatcherCreateNestedManyWithoutUserInput
    initiatedMABattles?: MABattleCreateNestedManyWithoutInitiatorInput
    targetedMABattles?: MABattleCreateNestedManyWithoutTargetInput
    battleProposals?: BattleProposalCreateNestedManyWithoutProposerInput
    battleVotes?: BattleVotingCreateNestedManyWithoutVoterInput
    stakingPositions?: StakingPositionCreateNestedManyWithoutUserInput
    stakingRewards?: StakingRewardCreateNestedManyWithoutUserInput
    governanceProposals?: GovernanceProposalCreateNestedManyWithoutProposerInput
    governanceVotes?: GovernanceVoteCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    socialFeeds?: SocialFeedCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutBidsInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    passwordHash?: string | null
    emailVerified?: Date | string | null
    eceBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string
    subscription?: UserSubscriptionUncheckedCreateNestedOneWithoutUserInput
    cryptoWallets?: CryptoWalletUncheckedCreateNestedManyWithoutUserInput
    physicalCard?: PhysicalCardUncheckedCreateNestedOneWithoutUserInput
    ownedCards?: CardUncheckedCreateNestedManyWithoutOwnerInput
    tradingHistory?: TransactionUncheckedCreateNestedManyWithoutUserInput
    listings?: MarketplaceListingUncheckedCreateNestedManyWithoutSellerInput
    appOrders?: AppOrderUncheckedCreateNestedManyWithoutUserInput
    orderRevisions?: OrderRevisionUncheckedCreateNestedManyWithoutUserInput
    orderCommunications?: OrderCommunicationUncheckedCreateNestedManyWithoutUserInput
    bettingPositions?: BettingPositionUncheckedCreateNestedManyWithoutUserInput
    bettingPayouts?: BettingPayoutUncheckedCreateNestedManyWithoutUserInput
    ownedAuctions?: CardAuctionUncheckedCreateNestedManyWithoutOwnerInput
    wonAuctions?: CardAuctionUncheckedCreateNestedManyWithoutWinnerInput
    placedAuctionBids?: AuctionBidUncheckedCreateNestedManyWithoutBidderInput
    watchedAuctions?: AuctionWatcherUncheckedCreateNestedManyWithoutUserInput
    initiatedMABattles?: MABattleUncheckedCreateNestedManyWithoutInitiatorInput
    targetedMABattles?: MABattleUncheckedCreateNestedManyWithoutTargetInput
    battleProposals?: BattleProposalUncheckedCreateNestedManyWithoutProposerInput
    battleVotes?: BattleVotingUncheckedCreateNestedManyWithoutVoterInput
    stakingPositions?: StakingPositionUncheckedCreateNestedManyWithoutUserInput
    stakingRewards?: StakingRewardUncheckedCreateNestedManyWithoutUserInput
    governanceProposals?: GovernanceProposalUncheckedCreateNestedManyWithoutProposerInput
    governanceVotes?: GovernanceVoteUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    socialFeeds?: SocialFeedUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutBidsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBidsInput, UserUncheckedCreateWithoutBidsInput>
  }

  export type CardCreateWithoutBidsInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.CardCategory
    rarity: $Enums.CardRarity
    company?: string | null
    currentPrice: number
    historicalPrices?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    stats?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedCardsInput
    listing?: MarketplaceListingCreateNestedOneWithoutCardInput
    transactions?: TransactionCreateNestedManyWithoutCardInput
    bettingMarkets?: BettingMarketCreateNestedManyWithoutCardInput
    marketMetrics?: MarketMetricsCreateNestedManyWithoutCardInput
    auction?: CardAuctionCreateNestedOneWithoutCardInput
    auctionHistory?: AuctionHistoryCreateNestedManyWithoutCardInput
    initiatedBattles?: MABattleCreateNestedManyWithoutInitiatorCardInput
    targetedBattles?: MABattleCreateNestedManyWithoutTargetCardInput
  }

  export type CardUncheckedCreateWithoutBidsInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.CardCategory
    rarity: $Enums.CardRarity
    company?: string | null
    currentPrice: number
    historicalPrices?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    stats?: NullableJsonNullValueInput | InputJsonValue
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    listing?: MarketplaceListingUncheckedCreateNestedOneWithoutCardInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCardInput
    bettingMarkets?: BettingMarketUncheckedCreateNestedManyWithoutCardInput
    marketMetrics?: MarketMetricsUncheckedCreateNestedManyWithoutCardInput
    auction?: CardAuctionUncheckedCreateNestedOneWithoutCardInput
    auctionHistory?: AuctionHistoryUncheckedCreateNestedManyWithoutCardInput
    initiatedBattles?: MABattleUncheckedCreateNestedManyWithoutInitiatorCardInput
    targetedBattles?: MABattleUncheckedCreateNestedManyWithoutTargetCardInput
  }

  export type CardCreateOrConnectWithoutBidsInput = {
    where: CardWhereUniqueInput
    create: XOR<CardCreateWithoutBidsInput, CardUncheckedCreateWithoutBidsInput>
  }

  export type MarketplaceListingUpsertWithoutBidsInput = {
    update: XOR<MarketplaceListingUpdateWithoutBidsInput, MarketplaceListingUncheckedUpdateWithoutBidsInput>
    create: XOR<MarketplaceListingCreateWithoutBidsInput, MarketplaceListingUncheckedCreateWithoutBidsInput>
    where?: MarketplaceListingWhereInput
  }

  export type MarketplaceListingUpdateToOneWithWhereWithoutBidsInput = {
    where?: MarketplaceListingWhereInput
    data: XOR<MarketplaceListingUpdateWithoutBidsInput, MarketplaceListingUncheckedUpdateWithoutBidsInput>
  }

  export type MarketplaceListingUpdateWithoutBidsInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    listingType?: EnumListingTypeFieldUpdateOperationsInput | $Enums.ListingType
    auctionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    featured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    card?: CardUpdateOneRequiredWithoutListingNestedInput
    seller?: UserUpdateOneRequiredWithoutListingsNestedInput
  }

  export type MarketplaceListingUncheckedUpdateWithoutBidsInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    listingType?: EnumListingTypeFieldUpdateOperationsInput | $Enums.ListingType
    auctionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    featured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutBidsInput = {
    update: XOR<UserUpdateWithoutBidsInput, UserUncheckedUpdateWithoutBidsInput>
    create: XOR<UserCreateWithoutBidsInput, UserUncheckedCreateWithoutBidsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBidsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBidsInput, UserUncheckedUpdateWithoutBidsInput>
  }

  export type UserUpdateWithoutBidsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eceBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: UserSubscriptionUpdateOneWithoutUserNestedInput
    cryptoWallets?: CryptoWalletUpdateManyWithoutUserNestedInput
    physicalCard?: PhysicalCardUpdateOneWithoutUserNestedInput
    ownedCards?: CardUpdateManyWithoutOwnerNestedInput
    tradingHistory?: TransactionUpdateManyWithoutUserNestedInput
    listings?: MarketplaceListingUpdateManyWithoutSellerNestedInput
    appOrders?: AppOrderUpdateManyWithoutUserNestedInput
    orderRevisions?: OrderRevisionUpdateManyWithoutUserNestedInput
    orderCommunications?: OrderCommunicationUpdateManyWithoutUserNestedInput
    bettingPositions?: BettingPositionUpdateManyWithoutUserNestedInput
    bettingPayouts?: BettingPayoutUpdateManyWithoutUserNestedInput
    ownedAuctions?: CardAuctionUpdateManyWithoutOwnerNestedInput
    wonAuctions?: CardAuctionUpdateManyWithoutWinnerNestedInput
    placedAuctionBids?: AuctionBidUpdateManyWithoutBidderNestedInput
    watchedAuctions?: AuctionWatcherUpdateManyWithoutUserNestedInput
    initiatedMABattles?: MABattleUpdateManyWithoutInitiatorNestedInput
    targetedMABattles?: MABattleUpdateManyWithoutTargetNestedInput
    battleProposals?: BattleProposalUpdateManyWithoutProposerNestedInput
    battleVotes?: BattleVotingUpdateManyWithoutVoterNestedInput
    stakingPositions?: StakingPositionUpdateManyWithoutUserNestedInput
    stakingRewards?: StakingRewardUpdateManyWithoutUserNestedInput
    governanceProposals?: GovernanceProposalUpdateManyWithoutProposerNestedInput
    governanceVotes?: GovernanceVoteUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    socialFeeds?: SocialFeedUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutBidsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eceBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: UserSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    cryptoWallets?: CryptoWalletUncheckedUpdateManyWithoutUserNestedInput
    physicalCard?: PhysicalCardUncheckedUpdateOneWithoutUserNestedInput
    ownedCards?: CardUncheckedUpdateManyWithoutOwnerNestedInput
    tradingHistory?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    listings?: MarketplaceListingUncheckedUpdateManyWithoutSellerNestedInput
    appOrders?: AppOrderUncheckedUpdateManyWithoutUserNestedInput
    orderRevisions?: OrderRevisionUncheckedUpdateManyWithoutUserNestedInput
    orderCommunications?: OrderCommunicationUncheckedUpdateManyWithoutUserNestedInput
    bettingPositions?: BettingPositionUncheckedUpdateManyWithoutUserNestedInput
    bettingPayouts?: BettingPayoutUncheckedUpdateManyWithoutUserNestedInput
    ownedAuctions?: CardAuctionUncheckedUpdateManyWithoutOwnerNestedInput
    wonAuctions?: CardAuctionUncheckedUpdateManyWithoutWinnerNestedInput
    placedAuctionBids?: AuctionBidUncheckedUpdateManyWithoutBidderNestedInput
    watchedAuctions?: AuctionWatcherUncheckedUpdateManyWithoutUserNestedInput
    initiatedMABattles?: MABattleUncheckedUpdateManyWithoutInitiatorNestedInput
    targetedMABattles?: MABattleUncheckedUpdateManyWithoutTargetNestedInput
    battleProposals?: BattleProposalUncheckedUpdateManyWithoutProposerNestedInput
    battleVotes?: BattleVotingUncheckedUpdateManyWithoutVoterNestedInput
    stakingPositions?: StakingPositionUncheckedUpdateManyWithoutUserNestedInput
    stakingRewards?: StakingRewardUncheckedUpdateManyWithoutUserNestedInput
    governanceProposals?: GovernanceProposalUncheckedUpdateManyWithoutProposerNestedInput
    governanceVotes?: GovernanceVoteUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    socialFeeds?: SocialFeedUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type CardUpsertWithoutBidsInput = {
    update: XOR<CardUpdateWithoutBidsInput, CardUncheckedUpdateWithoutBidsInput>
    create: XOR<CardCreateWithoutBidsInput, CardUncheckedCreateWithoutBidsInput>
    where?: CardWhereInput
  }

  export type CardUpdateToOneWithWhereWithoutBidsInput = {
    where?: CardWhereInput
    data: XOR<CardUpdateWithoutBidsInput, CardUncheckedUpdateWithoutBidsInput>
  }

  export type CardUpdateWithoutBidsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCardCategoryFieldUpdateOperationsInput | $Enums.CardCategory
    rarity?: EnumCardRarityFieldUpdateOperationsInput | $Enums.CardRarity
    company?: NullableStringFieldUpdateOperationsInput | string | null
    currentPrice?: FloatFieldUpdateOperationsInput | number
    historicalPrices?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    stats?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedCardsNestedInput
    listing?: MarketplaceListingUpdateOneWithoutCardNestedInput
    transactions?: TransactionUpdateManyWithoutCardNestedInput
    bettingMarkets?: BettingMarketUpdateManyWithoutCardNestedInput
    marketMetrics?: MarketMetricsUpdateManyWithoutCardNestedInput
    auction?: CardAuctionUpdateOneWithoutCardNestedInput
    auctionHistory?: AuctionHistoryUpdateManyWithoutCardNestedInput
    initiatedBattles?: MABattleUpdateManyWithoutInitiatorCardNestedInput
    targetedBattles?: MABattleUpdateManyWithoutTargetCardNestedInput
  }

  export type CardUncheckedUpdateWithoutBidsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCardCategoryFieldUpdateOperationsInput | $Enums.CardCategory
    rarity?: EnumCardRarityFieldUpdateOperationsInput | $Enums.CardRarity
    company?: NullableStringFieldUpdateOperationsInput | string | null
    currentPrice?: FloatFieldUpdateOperationsInput | number
    historicalPrices?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    stats?: NullableJsonNullValueInput | InputJsonValue
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listing?: MarketplaceListingUncheckedUpdateOneWithoutCardNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCardNestedInput
    bettingMarkets?: BettingMarketUncheckedUpdateManyWithoutCardNestedInput
    marketMetrics?: MarketMetricsUncheckedUpdateManyWithoutCardNestedInput
    auction?: CardAuctionUncheckedUpdateOneWithoutCardNestedInput
    auctionHistory?: AuctionHistoryUncheckedUpdateManyWithoutCardNestedInput
    initiatedBattles?: MABattleUncheckedUpdateManyWithoutInitiatorCardNestedInput
    targetedBattles?: MABattleUncheckedUpdateManyWithoutTargetCardNestedInput
  }

  export type UserCreateWithoutTradingHistoryInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    passwordHash?: string | null
    emailVerified?: Date | string | null
    eceBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string
    subscription?: UserSubscriptionCreateNestedOneWithoutUserInput
    cryptoWallets?: CryptoWalletCreateNestedManyWithoutUserInput
    physicalCard?: PhysicalCardCreateNestedOneWithoutUserInput
    ownedCards?: CardCreateNestedManyWithoutOwnerInput
    bids?: BidCreateNestedManyWithoutBidderInput
    listings?: MarketplaceListingCreateNestedManyWithoutSellerInput
    appOrders?: AppOrderCreateNestedManyWithoutUserInput
    orderRevisions?: OrderRevisionCreateNestedManyWithoutUserInput
    orderCommunications?: OrderCommunicationCreateNestedManyWithoutUserInput
    bettingPositions?: BettingPositionCreateNestedManyWithoutUserInput
    bettingPayouts?: BettingPayoutCreateNestedManyWithoutUserInput
    ownedAuctions?: CardAuctionCreateNestedManyWithoutOwnerInput
    wonAuctions?: CardAuctionCreateNestedManyWithoutWinnerInput
    placedAuctionBids?: AuctionBidCreateNestedManyWithoutBidderInput
    watchedAuctions?: AuctionWatcherCreateNestedManyWithoutUserInput
    initiatedMABattles?: MABattleCreateNestedManyWithoutInitiatorInput
    targetedMABattles?: MABattleCreateNestedManyWithoutTargetInput
    battleProposals?: BattleProposalCreateNestedManyWithoutProposerInput
    battleVotes?: BattleVotingCreateNestedManyWithoutVoterInput
    stakingPositions?: StakingPositionCreateNestedManyWithoutUserInput
    stakingRewards?: StakingRewardCreateNestedManyWithoutUserInput
    governanceProposals?: GovernanceProposalCreateNestedManyWithoutProposerInput
    governanceVotes?: GovernanceVoteCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    socialFeeds?: SocialFeedCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutTradingHistoryInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    passwordHash?: string | null
    emailVerified?: Date | string | null
    eceBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string
    subscription?: UserSubscriptionUncheckedCreateNestedOneWithoutUserInput
    cryptoWallets?: CryptoWalletUncheckedCreateNestedManyWithoutUserInput
    physicalCard?: PhysicalCardUncheckedCreateNestedOneWithoutUserInput
    ownedCards?: CardUncheckedCreateNestedManyWithoutOwnerInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderInput
    listings?: MarketplaceListingUncheckedCreateNestedManyWithoutSellerInput
    appOrders?: AppOrderUncheckedCreateNestedManyWithoutUserInput
    orderRevisions?: OrderRevisionUncheckedCreateNestedManyWithoutUserInput
    orderCommunications?: OrderCommunicationUncheckedCreateNestedManyWithoutUserInput
    bettingPositions?: BettingPositionUncheckedCreateNestedManyWithoutUserInput
    bettingPayouts?: BettingPayoutUncheckedCreateNestedManyWithoutUserInput
    ownedAuctions?: CardAuctionUncheckedCreateNestedManyWithoutOwnerInput
    wonAuctions?: CardAuctionUncheckedCreateNestedManyWithoutWinnerInput
    placedAuctionBids?: AuctionBidUncheckedCreateNestedManyWithoutBidderInput
    watchedAuctions?: AuctionWatcherUncheckedCreateNestedManyWithoutUserInput
    initiatedMABattles?: MABattleUncheckedCreateNestedManyWithoutInitiatorInput
    targetedMABattles?: MABattleUncheckedCreateNestedManyWithoutTargetInput
    battleProposals?: BattleProposalUncheckedCreateNestedManyWithoutProposerInput
    battleVotes?: BattleVotingUncheckedCreateNestedManyWithoutVoterInput
    stakingPositions?: StakingPositionUncheckedCreateNestedManyWithoutUserInput
    stakingRewards?: StakingRewardUncheckedCreateNestedManyWithoutUserInput
    governanceProposals?: GovernanceProposalUncheckedCreateNestedManyWithoutProposerInput
    governanceVotes?: GovernanceVoteUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    socialFeeds?: SocialFeedUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutTradingHistoryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTradingHistoryInput, UserUncheckedCreateWithoutTradingHistoryInput>
  }

  export type CardCreateWithoutTransactionsInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.CardCategory
    rarity: $Enums.CardRarity
    company?: string | null
    currentPrice: number
    historicalPrices?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    stats?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedCardsInput
    listing?: MarketplaceListingCreateNestedOneWithoutCardInput
    bids?: BidCreateNestedManyWithoutCardInput
    bettingMarkets?: BettingMarketCreateNestedManyWithoutCardInput
    marketMetrics?: MarketMetricsCreateNestedManyWithoutCardInput
    auction?: CardAuctionCreateNestedOneWithoutCardInput
    auctionHistory?: AuctionHistoryCreateNestedManyWithoutCardInput
    initiatedBattles?: MABattleCreateNestedManyWithoutInitiatorCardInput
    targetedBattles?: MABattleCreateNestedManyWithoutTargetCardInput
  }

  export type CardUncheckedCreateWithoutTransactionsInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.CardCategory
    rarity: $Enums.CardRarity
    company?: string | null
    currentPrice: number
    historicalPrices?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    stats?: NullableJsonNullValueInput | InputJsonValue
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    listing?: MarketplaceListingUncheckedCreateNestedOneWithoutCardInput
    bids?: BidUncheckedCreateNestedManyWithoutCardInput
    bettingMarkets?: BettingMarketUncheckedCreateNestedManyWithoutCardInput
    marketMetrics?: MarketMetricsUncheckedCreateNestedManyWithoutCardInput
    auction?: CardAuctionUncheckedCreateNestedOneWithoutCardInput
    auctionHistory?: AuctionHistoryUncheckedCreateNestedManyWithoutCardInput
    initiatedBattles?: MABattleUncheckedCreateNestedManyWithoutInitiatorCardInput
    targetedBattles?: MABattleUncheckedCreateNestedManyWithoutTargetCardInput
  }

  export type CardCreateOrConnectWithoutTransactionsInput = {
    where: CardWhereUniqueInput
    create: XOR<CardCreateWithoutTransactionsInput, CardUncheckedCreateWithoutTransactionsInput>
  }

  export type UserUpsertWithoutTradingHistoryInput = {
    update: XOR<UserUpdateWithoutTradingHistoryInput, UserUncheckedUpdateWithoutTradingHistoryInput>
    create: XOR<UserCreateWithoutTradingHistoryInput, UserUncheckedCreateWithoutTradingHistoryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTradingHistoryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTradingHistoryInput, UserUncheckedUpdateWithoutTradingHistoryInput>
  }

  export type UserUpdateWithoutTradingHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eceBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: UserSubscriptionUpdateOneWithoutUserNestedInput
    cryptoWallets?: CryptoWalletUpdateManyWithoutUserNestedInput
    physicalCard?: PhysicalCardUpdateOneWithoutUserNestedInput
    ownedCards?: CardUpdateManyWithoutOwnerNestedInput
    bids?: BidUpdateManyWithoutBidderNestedInput
    listings?: MarketplaceListingUpdateManyWithoutSellerNestedInput
    appOrders?: AppOrderUpdateManyWithoutUserNestedInput
    orderRevisions?: OrderRevisionUpdateManyWithoutUserNestedInput
    orderCommunications?: OrderCommunicationUpdateManyWithoutUserNestedInput
    bettingPositions?: BettingPositionUpdateManyWithoutUserNestedInput
    bettingPayouts?: BettingPayoutUpdateManyWithoutUserNestedInput
    ownedAuctions?: CardAuctionUpdateManyWithoutOwnerNestedInput
    wonAuctions?: CardAuctionUpdateManyWithoutWinnerNestedInput
    placedAuctionBids?: AuctionBidUpdateManyWithoutBidderNestedInput
    watchedAuctions?: AuctionWatcherUpdateManyWithoutUserNestedInput
    initiatedMABattles?: MABattleUpdateManyWithoutInitiatorNestedInput
    targetedMABattles?: MABattleUpdateManyWithoutTargetNestedInput
    battleProposals?: BattleProposalUpdateManyWithoutProposerNestedInput
    battleVotes?: BattleVotingUpdateManyWithoutVoterNestedInput
    stakingPositions?: StakingPositionUpdateManyWithoutUserNestedInput
    stakingRewards?: StakingRewardUpdateManyWithoutUserNestedInput
    governanceProposals?: GovernanceProposalUpdateManyWithoutProposerNestedInput
    governanceVotes?: GovernanceVoteUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    socialFeeds?: SocialFeedUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutTradingHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eceBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: UserSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    cryptoWallets?: CryptoWalletUncheckedUpdateManyWithoutUserNestedInput
    physicalCard?: PhysicalCardUncheckedUpdateOneWithoutUserNestedInput
    ownedCards?: CardUncheckedUpdateManyWithoutOwnerNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderNestedInput
    listings?: MarketplaceListingUncheckedUpdateManyWithoutSellerNestedInput
    appOrders?: AppOrderUncheckedUpdateManyWithoutUserNestedInput
    orderRevisions?: OrderRevisionUncheckedUpdateManyWithoutUserNestedInput
    orderCommunications?: OrderCommunicationUncheckedUpdateManyWithoutUserNestedInput
    bettingPositions?: BettingPositionUncheckedUpdateManyWithoutUserNestedInput
    bettingPayouts?: BettingPayoutUncheckedUpdateManyWithoutUserNestedInput
    ownedAuctions?: CardAuctionUncheckedUpdateManyWithoutOwnerNestedInput
    wonAuctions?: CardAuctionUncheckedUpdateManyWithoutWinnerNestedInput
    placedAuctionBids?: AuctionBidUncheckedUpdateManyWithoutBidderNestedInput
    watchedAuctions?: AuctionWatcherUncheckedUpdateManyWithoutUserNestedInput
    initiatedMABattles?: MABattleUncheckedUpdateManyWithoutInitiatorNestedInput
    targetedMABattles?: MABattleUncheckedUpdateManyWithoutTargetNestedInput
    battleProposals?: BattleProposalUncheckedUpdateManyWithoutProposerNestedInput
    battleVotes?: BattleVotingUncheckedUpdateManyWithoutVoterNestedInput
    stakingPositions?: StakingPositionUncheckedUpdateManyWithoutUserNestedInput
    stakingRewards?: StakingRewardUncheckedUpdateManyWithoutUserNestedInput
    governanceProposals?: GovernanceProposalUncheckedUpdateManyWithoutProposerNestedInput
    governanceVotes?: GovernanceVoteUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    socialFeeds?: SocialFeedUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type CardUpsertWithoutTransactionsInput = {
    update: XOR<CardUpdateWithoutTransactionsInput, CardUncheckedUpdateWithoutTransactionsInput>
    create: XOR<CardCreateWithoutTransactionsInput, CardUncheckedCreateWithoutTransactionsInput>
    where?: CardWhereInput
  }

  export type CardUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: CardWhereInput
    data: XOR<CardUpdateWithoutTransactionsInput, CardUncheckedUpdateWithoutTransactionsInput>
  }

  export type CardUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCardCategoryFieldUpdateOperationsInput | $Enums.CardCategory
    rarity?: EnumCardRarityFieldUpdateOperationsInput | $Enums.CardRarity
    company?: NullableStringFieldUpdateOperationsInput | string | null
    currentPrice?: FloatFieldUpdateOperationsInput | number
    historicalPrices?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    stats?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedCardsNestedInput
    listing?: MarketplaceListingUpdateOneWithoutCardNestedInput
    bids?: BidUpdateManyWithoutCardNestedInput
    bettingMarkets?: BettingMarketUpdateManyWithoutCardNestedInput
    marketMetrics?: MarketMetricsUpdateManyWithoutCardNestedInput
    auction?: CardAuctionUpdateOneWithoutCardNestedInput
    auctionHistory?: AuctionHistoryUpdateManyWithoutCardNestedInput
    initiatedBattles?: MABattleUpdateManyWithoutInitiatorCardNestedInput
    targetedBattles?: MABattleUpdateManyWithoutTargetCardNestedInput
  }

  export type CardUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCardCategoryFieldUpdateOperationsInput | $Enums.CardCategory
    rarity?: EnumCardRarityFieldUpdateOperationsInput | $Enums.CardRarity
    company?: NullableStringFieldUpdateOperationsInput | string | null
    currentPrice?: FloatFieldUpdateOperationsInput | number
    historicalPrices?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    stats?: NullableJsonNullValueInput | InputJsonValue
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listing?: MarketplaceListingUncheckedUpdateOneWithoutCardNestedInput
    bids?: BidUncheckedUpdateManyWithoutCardNestedInput
    bettingMarkets?: BettingMarketUncheckedUpdateManyWithoutCardNestedInput
    marketMetrics?: MarketMetricsUncheckedUpdateManyWithoutCardNestedInput
    auction?: CardAuctionUncheckedUpdateOneWithoutCardNestedInput
    auctionHistory?: AuctionHistoryUncheckedUpdateManyWithoutCardNestedInput
    initiatedBattles?: MABattleUncheckedUpdateManyWithoutInitiatorCardNestedInput
    targetedBattles?: MABattleUncheckedUpdateManyWithoutTargetCardNestedInput
  }

  export type UserCreateWithoutCryptoWalletsInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    passwordHash?: string | null
    emailVerified?: Date | string | null
    eceBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string
    subscription?: UserSubscriptionCreateNestedOneWithoutUserInput
    physicalCard?: PhysicalCardCreateNestedOneWithoutUserInput
    ownedCards?: CardCreateNestedManyWithoutOwnerInput
    tradingHistory?: TransactionCreateNestedManyWithoutUserInput
    bids?: BidCreateNestedManyWithoutBidderInput
    listings?: MarketplaceListingCreateNestedManyWithoutSellerInput
    appOrders?: AppOrderCreateNestedManyWithoutUserInput
    orderRevisions?: OrderRevisionCreateNestedManyWithoutUserInput
    orderCommunications?: OrderCommunicationCreateNestedManyWithoutUserInput
    bettingPositions?: BettingPositionCreateNestedManyWithoutUserInput
    bettingPayouts?: BettingPayoutCreateNestedManyWithoutUserInput
    ownedAuctions?: CardAuctionCreateNestedManyWithoutOwnerInput
    wonAuctions?: CardAuctionCreateNestedManyWithoutWinnerInput
    placedAuctionBids?: AuctionBidCreateNestedManyWithoutBidderInput
    watchedAuctions?: AuctionWatcherCreateNestedManyWithoutUserInput
    initiatedMABattles?: MABattleCreateNestedManyWithoutInitiatorInput
    targetedMABattles?: MABattleCreateNestedManyWithoutTargetInput
    battleProposals?: BattleProposalCreateNestedManyWithoutProposerInput
    battleVotes?: BattleVotingCreateNestedManyWithoutVoterInput
    stakingPositions?: StakingPositionCreateNestedManyWithoutUserInput
    stakingRewards?: StakingRewardCreateNestedManyWithoutUserInput
    governanceProposals?: GovernanceProposalCreateNestedManyWithoutProposerInput
    governanceVotes?: GovernanceVoteCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    socialFeeds?: SocialFeedCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutCryptoWalletsInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    passwordHash?: string | null
    emailVerified?: Date | string | null
    eceBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string
    subscription?: UserSubscriptionUncheckedCreateNestedOneWithoutUserInput
    physicalCard?: PhysicalCardUncheckedCreateNestedOneWithoutUserInput
    ownedCards?: CardUncheckedCreateNestedManyWithoutOwnerInput
    tradingHistory?: TransactionUncheckedCreateNestedManyWithoutUserInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderInput
    listings?: MarketplaceListingUncheckedCreateNestedManyWithoutSellerInput
    appOrders?: AppOrderUncheckedCreateNestedManyWithoutUserInput
    orderRevisions?: OrderRevisionUncheckedCreateNestedManyWithoutUserInput
    orderCommunications?: OrderCommunicationUncheckedCreateNestedManyWithoutUserInput
    bettingPositions?: BettingPositionUncheckedCreateNestedManyWithoutUserInput
    bettingPayouts?: BettingPayoutUncheckedCreateNestedManyWithoutUserInput
    ownedAuctions?: CardAuctionUncheckedCreateNestedManyWithoutOwnerInput
    wonAuctions?: CardAuctionUncheckedCreateNestedManyWithoutWinnerInput
    placedAuctionBids?: AuctionBidUncheckedCreateNestedManyWithoutBidderInput
    watchedAuctions?: AuctionWatcherUncheckedCreateNestedManyWithoutUserInput
    initiatedMABattles?: MABattleUncheckedCreateNestedManyWithoutInitiatorInput
    targetedMABattles?: MABattleUncheckedCreateNestedManyWithoutTargetInput
    battleProposals?: BattleProposalUncheckedCreateNestedManyWithoutProposerInput
    battleVotes?: BattleVotingUncheckedCreateNestedManyWithoutVoterInput
    stakingPositions?: StakingPositionUncheckedCreateNestedManyWithoutUserInput
    stakingRewards?: StakingRewardUncheckedCreateNestedManyWithoutUserInput
    governanceProposals?: GovernanceProposalUncheckedCreateNestedManyWithoutProposerInput
    governanceVotes?: GovernanceVoteUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    socialFeeds?: SocialFeedUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutCryptoWalletsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCryptoWalletsInput, UserUncheckedCreateWithoutCryptoWalletsInput>
  }

  export type UserUpsertWithoutCryptoWalletsInput = {
    update: XOR<UserUpdateWithoutCryptoWalletsInput, UserUncheckedUpdateWithoutCryptoWalletsInput>
    create: XOR<UserCreateWithoutCryptoWalletsInput, UserUncheckedCreateWithoutCryptoWalletsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCryptoWalletsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCryptoWalletsInput, UserUncheckedUpdateWithoutCryptoWalletsInput>
  }

  export type UserUpdateWithoutCryptoWalletsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eceBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: UserSubscriptionUpdateOneWithoutUserNestedInput
    physicalCard?: PhysicalCardUpdateOneWithoutUserNestedInput
    ownedCards?: CardUpdateManyWithoutOwnerNestedInput
    tradingHistory?: TransactionUpdateManyWithoutUserNestedInput
    bids?: BidUpdateManyWithoutBidderNestedInput
    listings?: MarketplaceListingUpdateManyWithoutSellerNestedInput
    appOrders?: AppOrderUpdateManyWithoutUserNestedInput
    orderRevisions?: OrderRevisionUpdateManyWithoutUserNestedInput
    orderCommunications?: OrderCommunicationUpdateManyWithoutUserNestedInput
    bettingPositions?: BettingPositionUpdateManyWithoutUserNestedInput
    bettingPayouts?: BettingPayoutUpdateManyWithoutUserNestedInput
    ownedAuctions?: CardAuctionUpdateManyWithoutOwnerNestedInput
    wonAuctions?: CardAuctionUpdateManyWithoutWinnerNestedInput
    placedAuctionBids?: AuctionBidUpdateManyWithoutBidderNestedInput
    watchedAuctions?: AuctionWatcherUpdateManyWithoutUserNestedInput
    initiatedMABattles?: MABattleUpdateManyWithoutInitiatorNestedInput
    targetedMABattles?: MABattleUpdateManyWithoutTargetNestedInput
    battleProposals?: BattleProposalUpdateManyWithoutProposerNestedInput
    battleVotes?: BattleVotingUpdateManyWithoutVoterNestedInput
    stakingPositions?: StakingPositionUpdateManyWithoutUserNestedInput
    stakingRewards?: StakingRewardUpdateManyWithoutUserNestedInput
    governanceProposals?: GovernanceProposalUpdateManyWithoutProposerNestedInput
    governanceVotes?: GovernanceVoteUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    socialFeeds?: SocialFeedUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutCryptoWalletsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eceBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: UserSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    physicalCard?: PhysicalCardUncheckedUpdateOneWithoutUserNestedInput
    ownedCards?: CardUncheckedUpdateManyWithoutOwnerNestedInput
    tradingHistory?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderNestedInput
    listings?: MarketplaceListingUncheckedUpdateManyWithoutSellerNestedInput
    appOrders?: AppOrderUncheckedUpdateManyWithoutUserNestedInput
    orderRevisions?: OrderRevisionUncheckedUpdateManyWithoutUserNestedInput
    orderCommunications?: OrderCommunicationUncheckedUpdateManyWithoutUserNestedInput
    bettingPositions?: BettingPositionUncheckedUpdateManyWithoutUserNestedInput
    bettingPayouts?: BettingPayoutUncheckedUpdateManyWithoutUserNestedInput
    ownedAuctions?: CardAuctionUncheckedUpdateManyWithoutOwnerNestedInput
    wonAuctions?: CardAuctionUncheckedUpdateManyWithoutWinnerNestedInput
    placedAuctionBids?: AuctionBidUncheckedUpdateManyWithoutBidderNestedInput
    watchedAuctions?: AuctionWatcherUncheckedUpdateManyWithoutUserNestedInput
    initiatedMABattles?: MABattleUncheckedUpdateManyWithoutInitiatorNestedInput
    targetedMABattles?: MABattleUncheckedUpdateManyWithoutTargetNestedInput
    battleProposals?: BattleProposalUncheckedUpdateManyWithoutProposerNestedInput
    battleVotes?: BattleVotingUncheckedUpdateManyWithoutVoterNestedInput
    stakingPositions?: StakingPositionUncheckedUpdateManyWithoutUserNestedInput
    stakingRewards?: StakingRewardUncheckedUpdateManyWithoutUserNestedInput
    governanceProposals?: GovernanceProposalUncheckedUpdateManyWithoutProposerNestedInput
    governanceVotes?: GovernanceVoteUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    socialFeeds?: SocialFeedUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type UserCreateWithoutPhysicalCardInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    passwordHash?: string | null
    emailVerified?: Date | string | null
    eceBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string
    subscription?: UserSubscriptionCreateNestedOneWithoutUserInput
    cryptoWallets?: CryptoWalletCreateNestedManyWithoutUserInput
    ownedCards?: CardCreateNestedManyWithoutOwnerInput
    tradingHistory?: TransactionCreateNestedManyWithoutUserInput
    bids?: BidCreateNestedManyWithoutBidderInput
    listings?: MarketplaceListingCreateNestedManyWithoutSellerInput
    appOrders?: AppOrderCreateNestedManyWithoutUserInput
    orderRevisions?: OrderRevisionCreateNestedManyWithoutUserInput
    orderCommunications?: OrderCommunicationCreateNestedManyWithoutUserInput
    bettingPositions?: BettingPositionCreateNestedManyWithoutUserInput
    bettingPayouts?: BettingPayoutCreateNestedManyWithoutUserInput
    ownedAuctions?: CardAuctionCreateNestedManyWithoutOwnerInput
    wonAuctions?: CardAuctionCreateNestedManyWithoutWinnerInput
    placedAuctionBids?: AuctionBidCreateNestedManyWithoutBidderInput
    watchedAuctions?: AuctionWatcherCreateNestedManyWithoutUserInput
    initiatedMABattles?: MABattleCreateNestedManyWithoutInitiatorInput
    targetedMABattles?: MABattleCreateNestedManyWithoutTargetInput
    battleProposals?: BattleProposalCreateNestedManyWithoutProposerInput
    battleVotes?: BattleVotingCreateNestedManyWithoutVoterInput
    stakingPositions?: StakingPositionCreateNestedManyWithoutUserInput
    stakingRewards?: StakingRewardCreateNestedManyWithoutUserInput
    governanceProposals?: GovernanceProposalCreateNestedManyWithoutProposerInput
    governanceVotes?: GovernanceVoteCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    socialFeeds?: SocialFeedCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutPhysicalCardInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    passwordHash?: string | null
    emailVerified?: Date | string | null
    eceBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string
    subscription?: UserSubscriptionUncheckedCreateNestedOneWithoutUserInput
    cryptoWallets?: CryptoWalletUncheckedCreateNestedManyWithoutUserInput
    ownedCards?: CardUncheckedCreateNestedManyWithoutOwnerInput
    tradingHistory?: TransactionUncheckedCreateNestedManyWithoutUserInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderInput
    listings?: MarketplaceListingUncheckedCreateNestedManyWithoutSellerInput
    appOrders?: AppOrderUncheckedCreateNestedManyWithoutUserInput
    orderRevisions?: OrderRevisionUncheckedCreateNestedManyWithoutUserInput
    orderCommunications?: OrderCommunicationUncheckedCreateNestedManyWithoutUserInput
    bettingPositions?: BettingPositionUncheckedCreateNestedManyWithoutUserInput
    bettingPayouts?: BettingPayoutUncheckedCreateNestedManyWithoutUserInput
    ownedAuctions?: CardAuctionUncheckedCreateNestedManyWithoutOwnerInput
    wonAuctions?: CardAuctionUncheckedCreateNestedManyWithoutWinnerInput
    placedAuctionBids?: AuctionBidUncheckedCreateNestedManyWithoutBidderInput
    watchedAuctions?: AuctionWatcherUncheckedCreateNestedManyWithoutUserInput
    initiatedMABattles?: MABattleUncheckedCreateNestedManyWithoutInitiatorInput
    targetedMABattles?: MABattleUncheckedCreateNestedManyWithoutTargetInput
    battleProposals?: BattleProposalUncheckedCreateNestedManyWithoutProposerInput
    battleVotes?: BattleVotingUncheckedCreateNestedManyWithoutVoterInput
    stakingPositions?: StakingPositionUncheckedCreateNestedManyWithoutUserInput
    stakingRewards?: StakingRewardUncheckedCreateNestedManyWithoutUserInput
    governanceProposals?: GovernanceProposalUncheckedCreateNestedManyWithoutProposerInput
    governanceVotes?: GovernanceVoteUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    socialFeeds?: SocialFeedUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutPhysicalCardInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPhysicalCardInput, UserUncheckedCreateWithoutPhysicalCardInput>
  }

  export type UserUpsertWithoutPhysicalCardInput = {
    update: XOR<UserUpdateWithoutPhysicalCardInput, UserUncheckedUpdateWithoutPhysicalCardInput>
    create: XOR<UserCreateWithoutPhysicalCardInput, UserUncheckedCreateWithoutPhysicalCardInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPhysicalCardInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPhysicalCardInput, UserUncheckedUpdateWithoutPhysicalCardInput>
  }

  export type UserUpdateWithoutPhysicalCardInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eceBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: UserSubscriptionUpdateOneWithoutUserNestedInput
    cryptoWallets?: CryptoWalletUpdateManyWithoutUserNestedInput
    ownedCards?: CardUpdateManyWithoutOwnerNestedInput
    tradingHistory?: TransactionUpdateManyWithoutUserNestedInput
    bids?: BidUpdateManyWithoutBidderNestedInput
    listings?: MarketplaceListingUpdateManyWithoutSellerNestedInput
    appOrders?: AppOrderUpdateManyWithoutUserNestedInput
    orderRevisions?: OrderRevisionUpdateManyWithoutUserNestedInput
    orderCommunications?: OrderCommunicationUpdateManyWithoutUserNestedInput
    bettingPositions?: BettingPositionUpdateManyWithoutUserNestedInput
    bettingPayouts?: BettingPayoutUpdateManyWithoutUserNestedInput
    ownedAuctions?: CardAuctionUpdateManyWithoutOwnerNestedInput
    wonAuctions?: CardAuctionUpdateManyWithoutWinnerNestedInput
    placedAuctionBids?: AuctionBidUpdateManyWithoutBidderNestedInput
    watchedAuctions?: AuctionWatcherUpdateManyWithoutUserNestedInput
    initiatedMABattles?: MABattleUpdateManyWithoutInitiatorNestedInput
    targetedMABattles?: MABattleUpdateManyWithoutTargetNestedInput
    battleProposals?: BattleProposalUpdateManyWithoutProposerNestedInput
    battleVotes?: BattleVotingUpdateManyWithoutVoterNestedInput
    stakingPositions?: StakingPositionUpdateManyWithoutUserNestedInput
    stakingRewards?: StakingRewardUpdateManyWithoutUserNestedInput
    governanceProposals?: GovernanceProposalUpdateManyWithoutProposerNestedInput
    governanceVotes?: GovernanceVoteUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    socialFeeds?: SocialFeedUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutPhysicalCardInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eceBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: UserSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    cryptoWallets?: CryptoWalletUncheckedUpdateManyWithoutUserNestedInput
    ownedCards?: CardUncheckedUpdateManyWithoutOwnerNestedInput
    tradingHistory?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderNestedInput
    listings?: MarketplaceListingUncheckedUpdateManyWithoutSellerNestedInput
    appOrders?: AppOrderUncheckedUpdateManyWithoutUserNestedInput
    orderRevisions?: OrderRevisionUncheckedUpdateManyWithoutUserNestedInput
    orderCommunications?: OrderCommunicationUncheckedUpdateManyWithoutUserNestedInput
    bettingPositions?: BettingPositionUncheckedUpdateManyWithoutUserNestedInput
    bettingPayouts?: BettingPayoutUncheckedUpdateManyWithoutUserNestedInput
    ownedAuctions?: CardAuctionUncheckedUpdateManyWithoutOwnerNestedInput
    wonAuctions?: CardAuctionUncheckedUpdateManyWithoutWinnerNestedInput
    placedAuctionBids?: AuctionBidUncheckedUpdateManyWithoutBidderNestedInput
    watchedAuctions?: AuctionWatcherUncheckedUpdateManyWithoutUserNestedInput
    initiatedMABattles?: MABattleUncheckedUpdateManyWithoutInitiatorNestedInput
    targetedMABattles?: MABattleUncheckedUpdateManyWithoutTargetNestedInput
    battleProposals?: BattleProposalUncheckedUpdateManyWithoutProposerNestedInput
    battleVotes?: BattleVotingUncheckedUpdateManyWithoutVoterNestedInput
    stakingPositions?: StakingPositionUncheckedUpdateManyWithoutUserNestedInput
    stakingRewards?: StakingRewardUncheckedUpdateManyWithoutUserNestedInput
    governanceProposals?: GovernanceProposalUncheckedUpdateManyWithoutProposerNestedInput
    governanceVotes?: GovernanceVoteUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    socialFeeds?: SocialFeedUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    passwordHash?: string | null
    emailVerified?: Date | string | null
    eceBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string
    subscription?: UserSubscriptionCreateNestedOneWithoutUserInput
    cryptoWallets?: CryptoWalletCreateNestedManyWithoutUserInput
    physicalCard?: PhysicalCardCreateNestedOneWithoutUserInput
    ownedCards?: CardCreateNestedManyWithoutOwnerInput
    tradingHistory?: TransactionCreateNestedManyWithoutUserInput
    bids?: BidCreateNestedManyWithoutBidderInput
    listings?: MarketplaceListingCreateNestedManyWithoutSellerInput
    appOrders?: AppOrderCreateNestedManyWithoutUserInput
    orderRevisions?: OrderRevisionCreateNestedManyWithoutUserInput
    orderCommunications?: OrderCommunicationCreateNestedManyWithoutUserInput
    bettingPositions?: BettingPositionCreateNestedManyWithoutUserInput
    bettingPayouts?: BettingPayoutCreateNestedManyWithoutUserInput
    ownedAuctions?: CardAuctionCreateNestedManyWithoutOwnerInput
    wonAuctions?: CardAuctionCreateNestedManyWithoutWinnerInput
    placedAuctionBids?: AuctionBidCreateNestedManyWithoutBidderInput
    watchedAuctions?: AuctionWatcherCreateNestedManyWithoutUserInput
    initiatedMABattles?: MABattleCreateNestedManyWithoutInitiatorInput
    targetedMABattles?: MABattleCreateNestedManyWithoutTargetInput
    battleProposals?: BattleProposalCreateNestedManyWithoutProposerInput
    battleVotes?: BattleVotingCreateNestedManyWithoutVoterInput
    stakingPositions?: StakingPositionCreateNestedManyWithoutUserInput
    stakingRewards?: StakingRewardCreateNestedManyWithoutUserInput
    governanceProposals?: GovernanceProposalCreateNestedManyWithoutProposerInput
    governanceVotes?: GovernanceVoteCreateNestedManyWithoutUserInput
    socialFeeds?: SocialFeedCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    passwordHash?: string | null
    emailVerified?: Date | string | null
    eceBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string
    subscription?: UserSubscriptionUncheckedCreateNestedOneWithoutUserInput
    cryptoWallets?: CryptoWalletUncheckedCreateNestedManyWithoutUserInput
    physicalCard?: PhysicalCardUncheckedCreateNestedOneWithoutUserInput
    ownedCards?: CardUncheckedCreateNestedManyWithoutOwnerInput
    tradingHistory?: TransactionUncheckedCreateNestedManyWithoutUserInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderInput
    listings?: MarketplaceListingUncheckedCreateNestedManyWithoutSellerInput
    appOrders?: AppOrderUncheckedCreateNestedManyWithoutUserInput
    orderRevisions?: OrderRevisionUncheckedCreateNestedManyWithoutUserInput
    orderCommunications?: OrderCommunicationUncheckedCreateNestedManyWithoutUserInput
    bettingPositions?: BettingPositionUncheckedCreateNestedManyWithoutUserInput
    bettingPayouts?: BettingPayoutUncheckedCreateNestedManyWithoutUserInput
    ownedAuctions?: CardAuctionUncheckedCreateNestedManyWithoutOwnerInput
    wonAuctions?: CardAuctionUncheckedCreateNestedManyWithoutWinnerInput
    placedAuctionBids?: AuctionBidUncheckedCreateNestedManyWithoutBidderInput
    watchedAuctions?: AuctionWatcherUncheckedCreateNestedManyWithoutUserInput
    initiatedMABattles?: MABattleUncheckedCreateNestedManyWithoutInitiatorInput
    targetedMABattles?: MABattleUncheckedCreateNestedManyWithoutTargetInput
    battleProposals?: BattleProposalUncheckedCreateNestedManyWithoutProposerInput
    battleVotes?: BattleVotingUncheckedCreateNestedManyWithoutVoterInput
    stakingPositions?: StakingPositionUncheckedCreateNestedManyWithoutUserInput
    stakingRewards?: StakingRewardUncheckedCreateNestedManyWithoutUserInput
    governanceProposals?: GovernanceProposalUncheckedCreateNestedManyWithoutProposerInput
    governanceVotes?: GovernanceVoteUncheckedCreateNestedManyWithoutUserInput
    socialFeeds?: SocialFeedUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eceBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: UserSubscriptionUpdateOneWithoutUserNestedInput
    cryptoWallets?: CryptoWalletUpdateManyWithoutUserNestedInput
    physicalCard?: PhysicalCardUpdateOneWithoutUserNestedInput
    ownedCards?: CardUpdateManyWithoutOwnerNestedInput
    tradingHistory?: TransactionUpdateManyWithoutUserNestedInput
    bids?: BidUpdateManyWithoutBidderNestedInput
    listings?: MarketplaceListingUpdateManyWithoutSellerNestedInput
    appOrders?: AppOrderUpdateManyWithoutUserNestedInput
    orderRevisions?: OrderRevisionUpdateManyWithoutUserNestedInput
    orderCommunications?: OrderCommunicationUpdateManyWithoutUserNestedInput
    bettingPositions?: BettingPositionUpdateManyWithoutUserNestedInput
    bettingPayouts?: BettingPayoutUpdateManyWithoutUserNestedInput
    ownedAuctions?: CardAuctionUpdateManyWithoutOwnerNestedInput
    wonAuctions?: CardAuctionUpdateManyWithoutWinnerNestedInput
    placedAuctionBids?: AuctionBidUpdateManyWithoutBidderNestedInput
    watchedAuctions?: AuctionWatcherUpdateManyWithoutUserNestedInput
    initiatedMABattles?: MABattleUpdateManyWithoutInitiatorNestedInput
    targetedMABattles?: MABattleUpdateManyWithoutTargetNestedInput
    battleProposals?: BattleProposalUpdateManyWithoutProposerNestedInput
    battleVotes?: BattleVotingUpdateManyWithoutVoterNestedInput
    stakingPositions?: StakingPositionUpdateManyWithoutUserNestedInput
    stakingRewards?: StakingRewardUpdateManyWithoutUserNestedInput
    governanceProposals?: GovernanceProposalUpdateManyWithoutProposerNestedInput
    governanceVotes?: GovernanceVoteUpdateManyWithoutUserNestedInput
    socialFeeds?: SocialFeedUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eceBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: UserSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    cryptoWallets?: CryptoWalletUncheckedUpdateManyWithoutUserNestedInput
    physicalCard?: PhysicalCardUncheckedUpdateOneWithoutUserNestedInput
    ownedCards?: CardUncheckedUpdateManyWithoutOwnerNestedInput
    tradingHistory?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderNestedInput
    listings?: MarketplaceListingUncheckedUpdateManyWithoutSellerNestedInput
    appOrders?: AppOrderUncheckedUpdateManyWithoutUserNestedInput
    orderRevisions?: OrderRevisionUncheckedUpdateManyWithoutUserNestedInput
    orderCommunications?: OrderCommunicationUncheckedUpdateManyWithoutUserNestedInput
    bettingPositions?: BettingPositionUncheckedUpdateManyWithoutUserNestedInput
    bettingPayouts?: BettingPayoutUncheckedUpdateManyWithoutUserNestedInput
    ownedAuctions?: CardAuctionUncheckedUpdateManyWithoutOwnerNestedInput
    wonAuctions?: CardAuctionUncheckedUpdateManyWithoutWinnerNestedInput
    placedAuctionBids?: AuctionBidUncheckedUpdateManyWithoutBidderNestedInput
    watchedAuctions?: AuctionWatcherUncheckedUpdateManyWithoutUserNestedInput
    initiatedMABattles?: MABattleUncheckedUpdateManyWithoutInitiatorNestedInput
    targetedMABattles?: MABattleUncheckedUpdateManyWithoutTargetNestedInput
    battleProposals?: BattleProposalUncheckedUpdateManyWithoutProposerNestedInput
    battleVotes?: BattleVotingUncheckedUpdateManyWithoutVoterNestedInput
    stakingPositions?: StakingPositionUncheckedUpdateManyWithoutUserNestedInput
    stakingRewards?: StakingRewardUncheckedUpdateManyWithoutUserNestedInput
    governanceProposals?: GovernanceProposalUncheckedUpdateManyWithoutProposerNestedInput
    governanceVotes?: GovernanceVoteUncheckedUpdateManyWithoutUserNestedInput
    socialFeeds?: SocialFeedUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type UserCreateWithoutSocialFeedsInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    passwordHash?: string | null
    emailVerified?: Date | string | null
    eceBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string
    subscription?: UserSubscriptionCreateNestedOneWithoutUserInput
    cryptoWallets?: CryptoWalletCreateNestedManyWithoutUserInput
    physicalCard?: PhysicalCardCreateNestedOneWithoutUserInput
    ownedCards?: CardCreateNestedManyWithoutOwnerInput
    tradingHistory?: TransactionCreateNestedManyWithoutUserInput
    bids?: BidCreateNestedManyWithoutBidderInput
    listings?: MarketplaceListingCreateNestedManyWithoutSellerInput
    appOrders?: AppOrderCreateNestedManyWithoutUserInput
    orderRevisions?: OrderRevisionCreateNestedManyWithoutUserInput
    orderCommunications?: OrderCommunicationCreateNestedManyWithoutUserInput
    bettingPositions?: BettingPositionCreateNestedManyWithoutUserInput
    bettingPayouts?: BettingPayoutCreateNestedManyWithoutUserInput
    ownedAuctions?: CardAuctionCreateNestedManyWithoutOwnerInput
    wonAuctions?: CardAuctionCreateNestedManyWithoutWinnerInput
    placedAuctionBids?: AuctionBidCreateNestedManyWithoutBidderInput
    watchedAuctions?: AuctionWatcherCreateNestedManyWithoutUserInput
    initiatedMABattles?: MABattleCreateNestedManyWithoutInitiatorInput
    targetedMABattles?: MABattleCreateNestedManyWithoutTargetInput
    battleProposals?: BattleProposalCreateNestedManyWithoutProposerInput
    battleVotes?: BattleVotingCreateNestedManyWithoutVoterInput
    stakingPositions?: StakingPositionCreateNestedManyWithoutUserInput
    stakingRewards?: StakingRewardCreateNestedManyWithoutUserInput
    governanceProposals?: GovernanceProposalCreateNestedManyWithoutProposerInput
    governanceVotes?: GovernanceVoteCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutSocialFeedsInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    passwordHash?: string | null
    emailVerified?: Date | string | null
    eceBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string
    subscription?: UserSubscriptionUncheckedCreateNestedOneWithoutUserInput
    cryptoWallets?: CryptoWalletUncheckedCreateNestedManyWithoutUserInput
    physicalCard?: PhysicalCardUncheckedCreateNestedOneWithoutUserInput
    ownedCards?: CardUncheckedCreateNestedManyWithoutOwnerInput
    tradingHistory?: TransactionUncheckedCreateNestedManyWithoutUserInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderInput
    listings?: MarketplaceListingUncheckedCreateNestedManyWithoutSellerInput
    appOrders?: AppOrderUncheckedCreateNestedManyWithoutUserInput
    orderRevisions?: OrderRevisionUncheckedCreateNestedManyWithoutUserInput
    orderCommunications?: OrderCommunicationUncheckedCreateNestedManyWithoutUserInput
    bettingPositions?: BettingPositionUncheckedCreateNestedManyWithoutUserInput
    bettingPayouts?: BettingPayoutUncheckedCreateNestedManyWithoutUserInput
    ownedAuctions?: CardAuctionUncheckedCreateNestedManyWithoutOwnerInput
    wonAuctions?: CardAuctionUncheckedCreateNestedManyWithoutWinnerInput
    placedAuctionBids?: AuctionBidUncheckedCreateNestedManyWithoutBidderInput
    watchedAuctions?: AuctionWatcherUncheckedCreateNestedManyWithoutUserInput
    initiatedMABattles?: MABattleUncheckedCreateNestedManyWithoutInitiatorInput
    targetedMABattles?: MABattleUncheckedCreateNestedManyWithoutTargetInput
    battleProposals?: BattleProposalUncheckedCreateNestedManyWithoutProposerInput
    battleVotes?: BattleVotingUncheckedCreateNestedManyWithoutVoterInput
    stakingPositions?: StakingPositionUncheckedCreateNestedManyWithoutUserInput
    stakingRewards?: StakingRewardUncheckedCreateNestedManyWithoutUserInput
    governanceProposals?: GovernanceProposalUncheckedCreateNestedManyWithoutProposerInput
    governanceVotes?: GovernanceVoteUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutSocialFeedsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSocialFeedsInput, UserUncheckedCreateWithoutSocialFeedsInput>
  }

  export type UserUpsertWithoutSocialFeedsInput = {
    update: XOR<UserUpdateWithoutSocialFeedsInput, UserUncheckedUpdateWithoutSocialFeedsInput>
    create: XOR<UserCreateWithoutSocialFeedsInput, UserUncheckedCreateWithoutSocialFeedsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSocialFeedsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSocialFeedsInput, UserUncheckedUpdateWithoutSocialFeedsInput>
  }

  export type UserUpdateWithoutSocialFeedsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eceBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: UserSubscriptionUpdateOneWithoutUserNestedInput
    cryptoWallets?: CryptoWalletUpdateManyWithoutUserNestedInput
    physicalCard?: PhysicalCardUpdateOneWithoutUserNestedInput
    ownedCards?: CardUpdateManyWithoutOwnerNestedInput
    tradingHistory?: TransactionUpdateManyWithoutUserNestedInput
    bids?: BidUpdateManyWithoutBidderNestedInput
    listings?: MarketplaceListingUpdateManyWithoutSellerNestedInput
    appOrders?: AppOrderUpdateManyWithoutUserNestedInput
    orderRevisions?: OrderRevisionUpdateManyWithoutUserNestedInput
    orderCommunications?: OrderCommunicationUpdateManyWithoutUserNestedInput
    bettingPositions?: BettingPositionUpdateManyWithoutUserNestedInput
    bettingPayouts?: BettingPayoutUpdateManyWithoutUserNestedInput
    ownedAuctions?: CardAuctionUpdateManyWithoutOwnerNestedInput
    wonAuctions?: CardAuctionUpdateManyWithoutWinnerNestedInput
    placedAuctionBids?: AuctionBidUpdateManyWithoutBidderNestedInput
    watchedAuctions?: AuctionWatcherUpdateManyWithoutUserNestedInput
    initiatedMABattles?: MABattleUpdateManyWithoutInitiatorNestedInput
    targetedMABattles?: MABattleUpdateManyWithoutTargetNestedInput
    battleProposals?: BattleProposalUpdateManyWithoutProposerNestedInput
    battleVotes?: BattleVotingUpdateManyWithoutVoterNestedInput
    stakingPositions?: StakingPositionUpdateManyWithoutUserNestedInput
    stakingRewards?: StakingRewardUpdateManyWithoutUserNestedInput
    governanceProposals?: GovernanceProposalUpdateManyWithoutProposerNestedInput
    governanceVotes?: GovernanceVoteUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutSocialFeedsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eceBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: UserSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    cryptoWallets?: CryptoWalletUncheckedUpdateManyWithoutUserNestedInput
    physicalCard?: PhysicalCardUncheckedUpdateOneWithoutUserNestedInput
    ownedCards?: CardUncheckedUpdateManyWithoutOwnerNestedInput
    tradingHistory?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderNestedInput
    listings?: MarketplaceListingUncheckedUpdateManyWithoutSellerNestedInput
    appOrders?: AppOrderUncheckedUpdateManyWithoutUserNestedInput
    orderRevisions?: OrderRevisionUncheckedUpdateManyWithoutUserNestedInput
    orderCommunications?: OrderCommunicationUncheckedUpdateManyWithoutUserNestedInput
    bettingPositions?: BettingPositionUncheckedUpdateManyWithoutUserNestedInput
    bettingPayouts?: BettingPayoutUncheckedUpdateManyWithoutUserNestedInput
    ownedAuctions?: CardAuctionUncheckedUpdateManyWithoutOwnerNestedInput
    wonAuctions?: CardAuctionUncheckedUpdateManyWithoutWinnerNestedInput
    placedAuctionBids?: AuctionBidUncheckedUpdateManyWithoutBidderNestedInput
    watchedAuctions?: AuctionWatcherUncheckedUpdateManyWithoutUserNestedInput
    initiatedMABattles?: MABattleUncheckedUpdateManyWithoutInitiatorNestedInput
    targetedMABattles?: MABattleUncheckedUpdateManyWithoutTargetNestedInput
    battleProposals?: BattleProposalUncheckedUpdateManyWithoutProposerNestedInput
    battleVotes?: BattleVotingUncheckedUpdateManyWithoutVoterNestedInput
    stakingPositions?: StakingPositionUncheckedUpdateManyWithoutUserNestedInput
    stakingRewards?: StakingRewardUncheckedUpdateManyWithoutUserNestedInput
    governanceProposals?: GovernanceProposalUncheckedUpdateManyWithoutProposerNestedInput
    governanceVotes?: GovernanceVoteUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type UserCreateWithoutFollowersInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    passwordHash?: string | null
    emailVerified?: Date | string | null
    eceBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string
    subscription?: UserSubscriptionCreateNestedOneWithoutUserInput
    cryptoWallets?: CryptoWalletCreateNestedManyWithoutUserInput
    physicalCard?: PhysicalCardCreateNestedOneWithoutUserInput
    ownedCards?: CardCreateNestedManyWithoutOwnerInput
    tradingHistory?: TransactionCreateNestedManyWithoutUserInput
    bids?: BidCreateNestedManyWithoutBidderInput
    listings?: MarketplaceListingCreateNestedManyWithoutSellerInput
    appOrders?: AppOrderCreateNestedManyWithoutUserInput
    orderRevisions?: OrderRevisionCreateNestedManyWithoutUserInput
    orderCommunications?: OrderCommunicationCreateNestedManyWithoutUserInput
    bettingPositions?: BettingPositionCreateNestedManyWithoutUserInput
    bettingPayouts?: BettingPayoutCreateNestedManyWithoutUserInput
    ownedAuctions?: CardAuctionCreateNestedManyWithoutOwnerInput
    wonAuctions?: CardAuctionCreateNestedManyWithoutWinnerInput
    placedAuctionBids?: AuctionBidCreateNestedManyWithoutBidderInput
    watchedAuctions?: AuctionWatcherCreateNestedManyWithoutUserInput
    initiatedMABattles?: MABattleCreateNestedManyWithoutInitiatorInput
    targetedMABattles?: MABattleCreateNestedManyWithoutTargetInput
    battleProposals?: BattleProposalCreateNestedManyWithoutProposerInput
    battleVotes?: BattleVotingCreateNestedManyWithoutVoterInput
    stakingPositions?: StakingPositionCreateNestedManyWithoutUserInput
    stakingRewards?: StakingRewardCreateNestedManyWithoutUserInput
    governanceProposals?: GovernanceProposalCreateNestedManyWithoutProposerInput
    governanceVotes?: GovernanceVoteCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    socialFeeds?: SocialFeedCreateNestedManyWithoutUserInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutFollowersInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    passwordHash?: string | null
    emailVerified?: Date | string | null
    eceBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string
    subscription?: UserSubscriptionUncheckedCreateNestedOneWithoutUserInput
    cryptoWallets?: CryptoWalletUncheckedCreateNestedManyWithoutUserInput
    physicalCard?: PhysicalCardUncheckedCreateNestedOneWithoutUserInput
    ownedCards?: CardUncheckedCreateNestedManyWithoutOwnerInput
    tradingHistory?: TransactionUncheckedCreateNestedManyWithoutUserInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderInput
    listings?: MarketplaceListingUncheckedCreateNestedManyWithoutSellerInput
    appOrders?: AppOrderUncheckedCreateNestedManyWithoutUserInput
    orderRevisions?: OrderRevisionUncheckedCreateNestedManyWithoutUserInput
    orderCommunications?: OrderCommunicationUncheckedCreateNestedManyWithoutUserInput
    bettingPositions?: BettingPositionUncheckedCreateNestedManyWithoutUserInput
    bettingPayouts?: BettingPayoutUncheckedCreateNestedManyWithoutUserInput
    ownedAuctions?: CardAuctionUncheckedCreateNestedManyWithoutOwnerInput
    wonAuctions?: CardAuctionUncheckedCreateNestedManyWithoutWinnerInput
    placedAuctionBids?: AuctionBidUncheckedCreateNestedManyWithoutBidderInput
    watchedAuctions?: AuctionWatcherUncheckedCreateNestedManyWithoutUserInput
    initiatedMABattles?: MABattleUncheckedCreateNestedManyWithoutInitiatorInput
    targetedMABattles?: MABattleUncheckedCreateNestedManyWithoutTargetInput
    battleProposals?: BattleProposalUncheckedCreateNestedManyWithoutProposerInput
    battleVotes?: BattleVotingUncheckedCreateNestedManyWithoutVoterInput
    stakingPositions?: StakingPositionUncheckedCreateNestedManyWithoutUserInput
    stakingRewards?: StakingRewardUncheckedCreateNestedManyWithoutUserInput
    governanceProposals?: GovernanceProposalUncheckedCreateNestedManyWithoutProposerInput
    governanceVotes?: GovernanceVoteUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    socialFeeds?: SocialFeedUncheckedCreateNestedManyWithoutUserInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutFollowersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFollowersInput, UserUncheckedCreateWithoutFollowersInput>
  }

  export type UserCreateWithoutFollowingInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    passwordHash?: string | null
    emailVerified?: Date | string | null
    eceBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string
    subscription?: UserSubscriptionCreateNestedOneWithoutUserInput
    cryptoWallets?: CryptoWalletCreateNestedManyWithoutUserInput
    physicalCard?: PhysicalCardCreateNestedOneWithoutUserInput
    ownedCards?: CardCreateNestedManyWithoutOwnerInput
    tradingHistory?: TransactionCreateNestedManyWithoutUserInput
    bids?: BidCreateNestedManyWithoutBidderInput
    listings?: MarketplaceListingCreateNestedManyWithoutSellerInput
    appOrders?: AppOrderCreateNestedManyWithoutUserInput
    orderRevisions?: OrderRevisionCreateNestedManyWithoutUserInput
    orderCommunications?: OrderCommunicationCreateNestedManyWithoutUserInput
    bettingPositions?: BettingPositionCreateNestedManyWithoutUserInput
    bettingPayouts?: BettingPayoutCreateNestedManyWithoutUserInput
    ownedAuctions?: CardAuctionCreateNestedManyWithoutOwnerInput
    wonAuctions?: CardAuctionCreateNestedManyWithoutWinnerInput
    placedAuctionBids?: AuctionBidCreateNestedManyWithoutBidderInput
    watchedAuctions?: AuctionWatcherCreateNestedManyWithoutUserInput
    initiatedMABattles?: MABattleCreateNestedManyWithoutInitiatorInput
    targetedMABattles?: MABattleCreateNestedManyWithoutTargetInput
    battleProposals?: BattleProposalCreateNestedManyWithoutProposerInput
    battleVotes?: BattleVotingCreateNestedManyWithoutVoterInput
    stakingPositions?: StakingPositionCreateNestedManyWithoutUserInput
    stakingRewards?: StakingRewardCreateNestedManyWithoutUserInput
    governanceProposals?: GovernanceProposalCreateNestedManyWithoutProposerInput
    governanceVotes?: GovernanceVoteCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    socialFeeds?: SocialFeedCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
  }

  export type UserUncheckedCreateWithoutFollowingInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    passwordHash?: string | null
    emailVerified?: Date | string | null
    eceBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string
    subscription?: UserSubscriptionUncheckedCreateNestedOneWithoutUserInput
    cryptoWallets?: CryptoWalletUncheckedCreateNestedManyWithoutUserInput
    physicalCard?: PhysicalCardUncheckedCreateNestedOneWithoutUserInput
    ownedCards?: CardUncheckedCreateNestedManyWithoutOwnerInput
    tradingHistory?: TransactionUncheckedCreateNestedManyWithoutUserInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderInput
    listings?: MarketplaceListingUncheckedCreateNestedManyWithoutSellerInput
    appOrders?: AppOrderUncheckedCreateNestedManyWithoutUserInput
    orderRevisions?: OrderRevisionUncheckedCreateNestedManyWithoutUserInput
    orderCommunications?: OrderCommunicationUncheckedCreateNestedManyWithoutUserInput
    bettingPositions?: BettingPositionUncheckedCreateNestedManyWithoutUserInput
    bettingPayouts?: BettingPayoutUncheckedCreateNestedManyWithoutUserInput
    ownedAuctions?: CardAuctionUncheckedCreateNestedManyWithoutOwnerInput
    wonAuctions?: CardAuctionUncheckedCreateNestedManyWithoutWinnerInput
    placedAuctionBids?: AuctionBidUncheckedCreateNestedManyWithoutBidderInput
    watchedAuctions?: AuctionWatcherUncheckedCreateNestedManyWithoutUserInput
    initiatedMABattles?: MABattleUncheckedCreateNestedManyWithoutInitiatorInput
    targetedMABattles?: MABattleUncheckedCreateNestedManyWithoutTargetInput
    battleProposals?: BattleProposalUncheckedCreateNestedManyWithoutProposerInput
    battleVotes?: BattleVotingUncheckedCreateNestedManyWithoutVoterInput
    stakingPositions?: StakingPositionUncheckedCreateNestedManyWithoutUserInput
    stakingRewards?: StakingRewardUncheckedCreateNestedManyWithoutUserInput
    governanceProposals?: GovernanceProposalUncheckedCreateNestedManyWithoutProposerInput
    governanceVotes?: GovernanceVoteUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    socialFeeds?: SocialFeedUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
  }

  export type UserCreateOrConnectWithoutFollowingInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFollowingInput, UserUncheckedCreateWithoutFollowingInput>
  }

  export type UserUpsertWithoutFollowersInput = {
    update: XOR<UserUpdateWithoutFollowersInput, UserUncheckedUpdateWithoutFollowersInput>
    create: XOR<UserCreateWithoutFollowersInput, UserUncheckedCreateWithoutFollowersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFollowersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFollowersInput, UserUncheckedUpdateWithoutFollowersInput>
  }

  export type UserUpdateWithoutFollowersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eceBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: UserSubscriptionUpdateOneWithoutUserNestedInput
    cryptoWallets?: CryptoWalletUpdateManyWithoutUserNestedInput
    physicalCard?: PhysicalCardUpdateOneWithoutUserNestedInput
    ownedCards?: CardUpdateManyWithoutOwnerNestedInput
    tradingHistory?: TransactionUpdateManyWithoutUserNestedInput
    bids?: BidUpdateManyWithoutBidderNestedInput
    listings?: MarketplaceListingUpdateManyWithoutSellerNestedInput
    appOrders?: AppOrderUpdateManyWithoutUserNestedInput
    orderRevisions?: OrderRevisionUpdateManyWithoutUserNestedInput
    orderCommunications?: OrderCommunicationUpdateManyWithoutUserNestedInput
    bettingPositions?: BettingPositionUpdateManyWithoutUserNestedInput
    bettingPayouts?: BettingPayoutUpdateManyWithoutUserNestedInput
    ownedAuctions?: CardAuctionUpdateManyWithoutOwnerNestedInput
    wonAuctions?: CardAuctionUpdateManyWithoutWinnerNestedInput
    placedAuctionBids?: AuctionBidUpdateManyWithoutBidderNestedInput
    watchedAuctions?: AuctionWatcherUpdateManyWithoutUserNestedInput
    initiatedMABattles?: MABattleUpdateManyWithoutInitiatorNestedInput
    targetedMABattles?: MABattleUpdateManyWithoutTargetNestedInput
    battleProposals?: BattleProposalUpdateManyWithoutProposerNestedInput
    battleVotes?: BattleVotingUpdateManyWithoutVoterNestedInput
    stakingPositions?: StakingPositionUpdateManyWithoutUserNestedInput
    stakingRewards?: StakingRewardUpdateManyWithoutUserNestedInput
    governanceProposals?: GovernanceProposalUpdateManyWithoutProposerNestedInput
    governanceVotes?: GovernanceVoteUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    socialFeeds?: SocialFeedUpdateManyWithoutUserNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutFollowersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eceBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: UserSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    cryptoWallets?: CryptoWalletUncheckedUpdateManyWithoutUserNestedInput
    physicalCard?: PhysicalCardUncheckedUpdateOneWithoutUserNestedInput
    ownedCards?: CardUncheckedUpdateManyWithoutOwnerNestedInput
    tradingHistory?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderNestedInput
    listings?: MarketplaceListingUncheckedUpdateManyWithoutSellerNestedInput
    appOrders?: AppOrderUncheckedUpdateManyWithoutUserNestedInput
    orderRevisions?: OrderRevisionUncheckedUpdateManyWithoutUserNestedInput
    orderCommunications?: OrderCommunicationUncheckedUpdateManyWithoutUserNestedInput
    bettingPositions?: BettingPositionUncheckedUpdateManyWithoutUserNestedInput
    bettingPayouts?: BettingPayoutUncheckedUpdateManyWithoutUserNestedInput
    ownedAuctions?: CardAuctionUncheckedUpdateManyWithoutOwnerNestedInput
    wonAuctions?: CardAuctionUncheckedUpdateManyWithoutWinnerNestedInput
    placedAuctionBids?: AuctionBidUncheckedUpdateManyWithoutBidderNestedInput
    watchedAuctions?: AuctionWatcherUncheckedUpdateManyWithoutUserNestedInput
    initiatedMABattles?: MABattleUncheckedUpdateManyWithoutInitiatorNestedInput
    targetedMABattles?: MABattleUncheckedUpdateManyWithoutTargetNestedInput
    battleProposals?: BattleProposalUncheckedUpdateManyWithoutProposerNestedInput
    battleVotes?: BattleVotingUncheckedUpdateManyWithoutVoterNestedInput
    stakingPositions?: StakingPositionUncheckedUpdateManyWithoutUserNestedInput
    stakingRewards?: StakingRewardUncheckedUpdateManyWithoutUserNestedInput
    governanceProposals?: GovernanceProposalUncheckedUpdateManyWithoutProposerNestedInput
    governanceVotes?: GovernanceVoteUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    socialFeeds?: SocialFeedUncheckedUpdateManyWithoutUserNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type UserUpsertWithoutFollowingInput = {
    update: XOR<UserUpdateWithoutFollowingInput, UserUncheckedUpdateWithoutFollowingInput>
    create: XOR<UserCreateWithoutFollowingInput, UserUncheckedCreateWithoutFollowingInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFollowingInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFollowingInput, UserUncheckedUpdateWithoutFollowingInput>
  }

  export type UserUpdateWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eceBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: UserSubscriptionUpdateOneWithoutUserNestedInput
    cryptoWallets?: CryptoWalletUpdateManyWithoutUserNestedInput
    physicalCard?: PhysicalCardUpdateOneWithoutUserNestedInput
    ownedCards?: CardUpdateManyWithoutOwnerNestedInput
    tradingHistory?: TransactionUpdateManyWithoutUserNestedInput
    bids?: BidUpdateManyWithoutBidderNestedInput
    listings?: MarketplaceListingUpdateManyWithoutSellerNestedInput
    appOrders?: AppOrderUpdateManyWithoutUserNestedInput
    orderRevisions?: OrderRevisionUpdateManyWithoutUserNestedInput
    orderCommunications?: OrderCommunicationUpdateManyWithoutUserNestedInput
    bettingPositions?: BettingPositionUpdateManyWithoutUserNestedInput
    bettingPayouts?: BettingPayoutUpdateManyWithoutUserNestedInput
    ownedAuctions?: CardAuctionUpdateManyWithoutOwnerNestedInput
    wonAuctions?: CardAuctionUpdateManyWithoutWinnerNestedInput
    placedAuctionBids?: AuctionBidUpdateManyWithoutBidderNestedInput
    watchedAuctions?: AuctionWatcherUpdateManyWithoutUserNestedInput
    initiatedMABattles?: MABattleUpdateManyWithoutInitiatorNestedInput
    targetedMABattles?: MABattleUpdateManyWithoutTargetNestedInput
    battleProposals?: BattleProposalUpdateManyWithoutProposerNestedInput
    battleVotes?: BattleVotingUpdateManyWithoutVoterNestedInput
    stakingPositions?: StakingPositionUpdateManyWithoutUserNestedInput
    stakingRewards?: StakingRewardUpdateManyWithoutUserNestedInput
    governanceProposals?: GovernanceProposalUpdateManyWithoutProposerNestedInput
    governanceVotes?: GovernanceVoteUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    socialFeeds?: SocialFeedUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
  }

  export type UserUncheckedUpdateWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eceBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: UserSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    cryptoWallets?: CryptoWalletUncheckedUpdateManyWithoutUserNestedInput
    physicalCard?: PhysicalCardUncheckedUpdateOneWithoutUserNestedInput
    ownedCards?: CardUncheckedUpdateManyWithoutOwnerNestedInput
    tradingHistory?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderNestedInput
    listings?: MarketplaceListingUncheckedUpdateManyWithoutSellerNestedInput
    appOrders?: AppOrderUncheckedUpdateManyWithoutUserNestedInput
    orderRevisions?: OrderRevisionUncheckedUpdateManyWithoutUserNestedInput
    orderCommunications?: OrderCommunicationUncheckedUpdateManyWithoutUserNestedInput
    bettingPositions?: BettingPositionUncheckedUpdateManyWithoutUserNestedInput
    bettingPayouts?: BettingPayoutUncheckedUpdateManyWithoutUserNestedInput
    ownedAuctions?: CardAuctionUncheckedUpdateManyWithoutOwnerNestedInput
    wonAuctions?: CardAuctionUncheckedUpdateManyWithoutWinnerNestedInput
    placedAuctionBids?: AuctionBidUncheckedUpdateManyWithoutBidderNestedInput
    watchedAuctions?: AuctionWatcherUncheckedUpdateManyWithoutUserNestedInput
    initiatedMABattles?: MABattleUncheckedUpdateManyWithoutInitiatorNestedInput
    targetedMABattles?: MABattleUncheckedUpdateManyWithoutTargetNestedInput
    battleProposals?: BattleProposalUncheckedUpdateManyWithoutProposerNestedInput
    battleVotes?: BattleVotingUncheckedUpdateManyWithoutVoterNestedInput
    stakingPositions?: StakingPositionUncheckedUpdateManyWithoutUserNestedInput
    stakingRewards?: StakingRewardUncheckedUpdateManyWithoutUserNestedInput
    governanceProposals?: GovernanceProposalUncheckedUpdateManyWithoutProposerNestedInput
    governanceVotes?: GovernanceVoteUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    socialFeeds?: SocialFeedUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
  }

  export type UserCreateWithoutAppOrdersInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    passwordHash?: string | null
    emailVerified?: Date | string | null
    eceBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string
    subscription?: UserSubscriptionCreateNestedOneWithoutUserInput
    cryptoWallets?: CryptoWalletCreateNestedManyWithoutUserInput
    physicalCard?: PhysicalCardCreateNestedOneWithoutUserInput
    ownedCards?: CardCreateNestedManyWithoutOwnerInput
    tradingHistory?: TransactionCreateNestedManyWithoutUserInput
    bids?: BidCreateNestedManyWithoutBidderInput
    listings?: MarketplaceListingCreateNestedManyWithoutSellerInput
    orderRevisions?: OrderRevisionCreateNestedManyWithoutUserInput
    orderCommunications?: OrderCommunicationCreateNestedManyWithoutUserInput
    bettingPositions?: BettingPositionCreateNestedManyWithoutUserInput
    bettingPayouts?: BettingPayoutCreateNestedManyWithoutUserInput
    ownedAuctions?: CardAuctionCreateNestedManyWithoutOwnerInput
    wonAuctions?: CardAuctionCreateNestedManyWithoutWinnerInput
    placedAuctionBids?: AuctionBidCreateNestedManyWithoutBidderInput
    watchedAuctions?: AuctionWatcherCreateNestedManyWithoutUserInput
    initiatedMABattles?: MABattleCreateNestedManyWithoutInitiatorInput
    targetedMABattles?: MABattleCreateNestedManyWithoutTargetInput
    battleProposals?: BattleProposalCreateNestedManyWithoutProposerInput
    battleVotes?: BattleVotingCreateNestedManyWithoutVoterInput
    stakingPositions?: StakingPositionCreateNestedManyWithoutUserInput
    stakingRewards?: StakingRewardCreateNestedManyWithoutUserInput
    governanceProposals?: GovernanceProposalCreateNestedManyWithoutProposerInput
    governanceVotes?: GovernanceVoteCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    socialFeeds?: SocialFeedCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutAppOrdersInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    passwordHash?: string | null
    emailVerified?: Date | string | null
    eceBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string
    subscription?: UserSubscriptionUncheckedCreateNestedOneWithoutUserInput
    cryptoWallets?: CryptoWalletUncheckedCreateNestedManyWithoutUserInput
    physicalCard?: PhysicalCardUncheckedCreateNestedOneWithoutUserInput
    ownedCards?: CardUncheckedCreateNestedManyWithoutOwnerInput
    tradingHistory?: TransactionUncheckedCreateNestedManyWithoutUserInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderInput
    listings?: MarketplaceListingUncheckedCreateNestedManyWithoutSellerInput
    orderRevisions?: OrderRevisionUncheckedCreateNestedManyWithoutUserInput
    orderCommunications?: OrderCommunicationUncheckedCreateNestedManyWithoutUserInput
    bettingPositions?: BettingPositionUncheckedCreateNestedManyWithoutUserInput
    bettingPayouts?: BettingPayoutUncheckedCreateNestedManyWithoutUserInput
    ownedAuctions?: CardAuctionUncheckedCreateNestedManyWithoutOwnerInput
    wonAuctions?: CardAuctionUncheckedCreateNestedManyWithoutWinnerInput
    placedAuctionBids?: AuctionBidUncheckedCreateNestedManyWithoutBidderInput
    watchedAuctions?: AuctionWatcherUncheckedCreateNestedManyWithoutUserInput
    initiatedMABattles?: MABattleUncheckedCreateNestedManyWithoutInitiatorInput
    targetedMABattles?: MABattleUncheckedCreateNestedManyWithoutTargetInput
    battleProposals?: BattleProposalUncheckedCreateNestedManyWithoutProposerInput
    battleVotes?: BattleVotingUncheckedCreateNestedManyWithoutVoterInput
    stakingPositions?: StakingPositionUncheckedCreateNestedManyWithoutUserInput
    stakingRewards?: StakingRewardUncheckedCreateNestedManyWithoutUserInput
    governanceProposals?: GovernanceProposalUncheckedCreateNestedManyWithoutProposerInput
    governanceVotes?: GovernanceVoteUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    socialFeeds?: SocialFeedUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutAppOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAppOrdersInput, UserUncheckedCreateWithoutAppOrdersInput>
  }

  export type OrderRevisionCreateWithoutOrderInput = {
    id?: string
    revisionNumber: number
    title: string
    description: string
    status?: $Enums.RevisionStatus
    adminResponse?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOrderRevisionsInput
  }

  export type OrderRevisionUncheckedCreateWithoutOrderInput = {
    id?: string
    userId: string
    revisionNumber: number
    title: string
    description: string
    status?: $Enums.RevisionStatus
    adminResponse?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderRevisionCreateOrConnectWithoutOrderInput = {
    where: OrderRevisionWhereUniqueInput
    create: XOR<OrderRevisionCreateWithoutOrderInput, OrderRevisionUncheckedCreateWithoutOrderInput>
  }

  export type OrderRevisionCreateManyOrderInputEnvelope = {
    data: OrderRevisionCreateManyOrderInput | OrderRevisionCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type OrderCommunicationCreateWithoutOrderInput = {
    id?: string
    messageType: $Enums.CommunicationType
    subject?: string | null
    message: string
    isFromAdmin?: boolean
    attachments?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    important?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOrderCommunicationsInput
  }

  export type OrderCommunicationUncheckedCreateWithoutOrderInput = {
    id?: string
    userId: string
    messageType: $Enums.CommunicationType
    subject?: string | null
    message: string
    isFromAdmin?: boolean
    attachments?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    important?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCommunicationCreateOrConnectWithoutOrderInput = {
    where: OrderCommunicationWhereUniqueInput
    create: XOR<OrderCommunicationCreateWithoutOrderInput, OrderCommunicationUncheckedCreateWithoutOrderInput>
  }

  export type OrderCommunicationCreateManyOrderInputEnvelope = {
    data: OrderCommunicationCreateManyOrderInput | OrderCommunicationCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type OrderDeliverableCreateWithoutOrderInput = {
    id?: string
    type: $Enums.DeliverableType
    title: string
    description?: string | null
    url?: string | null
    filePath?: string | null
    status?: $Enums.DeliverableStatus
    delivered?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderDeliverableUncheckedCreateWithoutOrderInput = {
    id?: string
    type: $Enums.DeliverableType
    title: string
    description?: string | null
    url?: string | null
    filePath?: string | null
    status?: $Enums.DeliverableStatus
    delivered?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderDeliverableCreateOrConnectWithoutOrderInput = {
    where: OrderDeliverableWhereUniqueInput
    create: XOR<OrderDeliverableCreateWithoutOrderInput, OrderDeliverableUncheckedCreateWithoutOrderInput>
  }

  export type OrderDeliverableCreateManyOrderInputEnvelope = {
    data: OrderDeliverableCreateManyOrderInput | OrderDeliverableCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAppOrdersInput = {
    update: XOR<UserUpdateWithoutAppOrdersInput, UserUncheckedUpdateWithoutAppOrdersInput>
    create: XOR<UserCreateWithoutAppOrdersInput, UserUncheckedCreateWithoutAppOrdersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAppOrdersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAppOrdersInput, UserUncheckedUpdateWithoutAppOrdersInput>
  }

  export type UserUpdateWithoutAppOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eceBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: UserSubscriptionUpdateOneWithoutUserNestedInput
    cryptoWallets?: CryptoWalletUpdateManyWithoutUserNestedInput
    physicalCard?: PhysicalCardUpdateOneWithoutUserNestedInput
    ownedCards?: CardUpdateManyWithoutOwnerNestedInput
    tradingHistory?: TransactionUpdateManyWithoutUserNestedInput
    bids?: BidUpdateManyWithoutBidderNestedInput
    listings?: MarketplaceListingUpdateManyWithoutSellerNestedInput
    orderRevisions?: OrderRevisionUpdateManyWithoutUserNestedInput
    orderCommunications?: OrderCommunicationUpdateManyWithoutUserNestedInput
    bettingPositions?: BettingPositionUpdateManyWithoutUserNestedInput
    bettingPayouts?: BettingPayoutUpdateManyWithoutUserNestedInput
    ownedAuctions?: CardAuctionUpdateManyWithoutOwnerNestedInput
    wonAuctions?: CardAuctionUpdateManyWithoutWinnerNestedInput
    placedAuctionBids?: AuctionBidUpdateManyWithoutBidderNestedInput
    watchedAuctions?: AuctionWatcherUpdateManyWithoutUserNestedInput
    initiatedMABattles?: MABattleUpdateManyWithoutInitiatorNestedInput
    targetedMABattles?: MABattleUpdateManyWithoutTargetNestedInput
    battleProposals?: BattleProposalUpdateManyWithoutProposerNestedInput
    battleVotes?: BattleVotingUpdateManyWithoutVoterNestedInput
    stakingPositions?: StakingPositionUpdateManyWithoutUserNestedInput
    stakingRewards?: StakingRewardUpdateManyWithoutUserNestedInput
    governanceProposals?: GovernanceProposalUpdateManyWithoutProposerNestedInput
    governanceVotes?: GovernanceVoteUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    socialFeeds?: SocialFeedUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutAppOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eceBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: UserSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    cryptoWallets?: CryptoWalletUncheckedUpdateManyWithoutUserNestedInput
    physicalCard?: PhysicalCardUncheckedUpdateOneWithoutUserNestedInput
    ownedCards?: CardUncheckedUpdateManyWithoutOwnerNestedInput
    tradingHistory?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderNestedInput
    listings?: MarketplaceListingUncheckedUpdateManyWithoutSellerNestedInput
    orderRevisions?: OrderRevisionUncheckedUpdateManyWithoutUserNestedInput
    orderCommunications?: OrderCommunicationUncheckedUpdateManyWithoutUserNestedInput
    bettingPositions?: BettingPositionUncheckedUpdateManyWithoutUserNestedInput
    bettingPayouts?: BettingPayoutUncheckedUpdateManyWithoutUserNestedInput
    ownedAuctions?: CardAuctionUncheckedUpdateManyWithoutOwnerNestedInput
    wonAuctions?: CardAuctionUncheckedUpdateManyWithoutWinnerNestedInput
    placedAuctionBids?: AuctionBidUncheckedUpdateManyWithoutBidderNestedInput
    watchedAuctions?: AuctionWatcherUncheckedUpdateManyWithoutUserNestedInput
    initiatedMABattles?: MABattleUncheckedUpdateManyWithoutInitiatorNestedInput
    targetedMABattles?: MABattleUncheckedUpdateManyWithoutTargetNestedInput
    battleProposals?: BattleProposalUncheckedUpdateManyWithoutProposerNestedInput
    battleVotes?: BattleVotingUncheckedUpdateManyWithoutVoterNestedInput
    stakingPositions?: StakingPositionUncheckedUpdateManyWithoutUserNestedInput
    stakingRewards?: StakingRewardUncheckedUpdateManyWithoutUserNestedInput
    governanceProposals?: GovernanceProposalUncheckedUpdateManyWithoutProposerNestedInput
    governanceVotes?: GovernanceVoteUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    socialFeeds?: SocialFeedUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type OrderRevisionUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderRevisionWhereUniqueInput
    update: XOR<OrderRevisionUpdateWithoutOrderInput, OrderRevisionUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderRevisionCreateWithoutOrderInput, OrderRevisionUncheckedCreateWithoutOrderInput>
  }

  export type OrderRevisionUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderRevisionWhereUniqueInput
    data: XOR<OrderRevisionUpdateWithoutOrderInput, OrderRevisionUncheckedUpdateWithoutOrderInput>
  }

  export type OrderRevisionUpdateManyWithWhereWithoutOrderInput = {
    where: OrderRevisionScalarWhereInput
    data: XOR<OrderRevisionUpdateManyMutationInput, OrderRevisionUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderCommunicationUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderCommunicationWhereUniqueInput
    update: XOR<OrderCommunicationUpdateWithoutOrderInput, OrderCommunicationUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderCommunicationCreateWithoutOrderInput, OrderCommunicationUncheckedCreateWithoutOrderInput>
  }

  export type OrderCommunicationUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderCommunicationWhereUniqueInput
    data: XOR<OrderCommunicationUpdateWithoutOrderInput, OrderCommunicationUncheckedUpdateWithoutOrderInput>
  }

  export type OrderCommunicationUpdateManyWithWhereWithoutOrderInput = {
    where: OrderCommunicationScalarWhereInput
    data: XOR<OrderCommunicationUpdateManyMutationInput, OrderCommunicationUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderDeliverableUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderDeliverableWhereUniqueInput
    update: XOR<OrderDeliverableUpdateWithoutOrderInput, OrderDeliverableUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderDeliverableCreateWithoutOrderInput, OrderDeliverableUncheckedCreateWithoutOrderInput>
  }

  export type OrderDeliverableUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderDeliverableWhereUniqueInput
    data: XOR<OrderDeliverableUpdateWithoutOrderInput, OrderDeliverableUncheckedUpdateWithoutOrderInput>
  }

  export type OrderDeliverableUpdateManyWithWhereWithoutOrderInput = {
    where: OrderDeliverableScalarWhereInput
    data: XOR<OrderDeliverableUpdateManyMutationInput, OrderDeliverableUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderDeliverableScalarWhereInput = {
    AND?: OrderDeliverableScalarWhereInput | OrderDeliverableScalarWhereInput[]
    OR?: OrderDeliverableScalarWhereInput[]
    NOT?: OrderDeliverableScalarWhereInput | OrderDeliverableScalarWhereInput[]
    id?: StringFilter<"OrderDeliverable"> | string
    orderId?: StringFilter<"OrderDeliverable"> | string
    type?: EnumDeliverableTypeFilter<"OrderDeliverable"> | $Enums.DeliverableType
    title?: StringFilter<"OrderDeliverable"> | string
    description?: StringNullableFilter<"OrderDeliverable"> | string | null
    url?: StringNullableFilter<"OrderDeliverable"> | string | null
    filePath?: StringNullableFilter<"OrderDeliverable"> | string | null
    status?: EnumDeliverableStatusFilter<"OrderDeliverable"> | $Enums.DeliverableStatus
    delivered?: BoolFilter<"OrderDeliverable"> | boolean
    createdAt?: DateTimeFilter<"OrderDeliverable"> | Date | string
    updatedAt?: DateTimeFilter<"OrderDeliverable"> | Date | string
  }

  export type AppOrderCreateWithoutRevisionsInput = {
    id?: string
    projectType: $Enums.ProjectType
    title: string
    description: string
    requirements?: NullableJsonNullValueInput | InputJsonValue
    timeline: $Enums.OrderTimeline
    estimatedCost: number
    actualCost?: number | null
    currency?: string
    status?: $Enums.OrderStatus
    priority?: $Enums.OrderPriority
    deliveryDate?: Date | string | null
    githubRepo?: string | null
    vercelLink?: string | null
    downloadLink?: string | null
    progressPercentage?: number
    currentMilestone?: string | null
    assignedAdminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAppOrdersInput
    communications?: OrderCommunicationCreateNestedManyWithoutOrderInput
    deliverables?: OrderDeliverableCreateNestedManyWithoutOrderInput
  }

  export type AppOrderUncheckedCreateWithoutRevisionsInput = {
    id?: string
    userId: string
    projectType: $Enums.ProjectType
    title: string
    description: string
    requirements?: NullableJsonNullValueInput | InputJsonValue
    timeline: $Enums.OrderTimeline
    estimatedCost: number
    actualCost?: number | null
    currency?: string
    status?: $Enums.OrderStatus
    priority?: $Enums.OrderPriority
    deliveryDate?: Date | string | null
    githubRepo?: string | null
    vercelLink?: string | null
    downloadLink?: string | null
    progressPercentage?: number
    currentMilestone?: string | null
    assignedAdminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    communications?: OrderCommunicationUncheckedCreateNestedManyWithoutOrderInput
    deliverables?: OrderDeliverableUncheckedCreateNestedManyWithoutOrderInput
  }

  export type AppOrderCreateOrConnectWithoutRevisionsInput = {
    where: AppOrderWhereUniqueInput
    create: XOR<AppOrderCreateWithoutRevisionsInput, AppOrderUncheckedCreateWithoutRevisionsInput>
  }

  export type UserCreateWithoutOrderRevisionsInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    passwordHash?: string | null
    emailVerified?: Date | string | null
    eceBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string
    subscription?: UserSubscriptionCreateNestedOneWithoutUserInput
    cryptoWallets?: CryptoWalletCreateNestedManyWithoutUserInput
    physicalCard?: PhysicalCardCreateNestedOneWithoutUserInput
    ownedCards?: CardCreateNestedManyWithoutOwnerInput
    tradingHistory?: TransactionCreateNestedManyWithoutUserInput
    bids?: BidCreateNestedManyWithoutBidderInput
    listings?: MarketplaceListingCreateNestedManyWithoutSellerInput
    appOrders?: AppOrderCreateNestedManyWithoutUserInput
    orderCommunications?: OrderCommunicationCreateNestedManyWithoutUserInput
    bettingPositions?: BettingPositionCreateNestedManyWithoutUserInput
    bettingPayouts?: BettingPayoutCreateNestedManyWithoutUserInput
    ownedAuctions?: CardAuctionCreateNestedManyWithoutOwnerInput
    wonAuctions?: CardAuctionCreateNestedManyWithoutWinnerInput
    placedAuctionBids?: AuctionBidCreateNestedManyWithoutBidderInput
    watchedAuctions?: AuctionWatcherCreateNestedManyWithoutUserInput
    initiatedMABattles?: MABattleCreateNestedManyWithoutInitiatorInput
    targetedMABattles?: MABattleCreateNestedManyWithoutTargetInput
    battleProposals?: BattleProposalCreateNestedManyWithoutProposerInput
    battleVotes?: BattleVotingCreateNestedManyWithoutVoterInput
    stakingPositions?: StakingPositionCreateNestedManyWithoutUserInput
    stakingRewards?: StakingRewardCreateNestedManyWithoutUserInput
    governanceProposals?: GovernanceProposalCreateNestedManyWithoutProposerInput
    governanceVotes?: GovernanceVoteCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    socialFeeds?: SocialFeedCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutOrderRevisionsInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    passwordHash?: string | null
    emailVerified?: Date | string | null
    eceBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string
    subscription?: UserSubscriptionUncheckedCreateNestedOneWithoutUserInput
    cryptoWallets?: CryptoWalletUncheckedCreateNestedManyWithoutUserInput
    physicalCard?: PhysicalCardUncheckedCreateNestedOneWithoutUserInput
    ownedCards?: CardUncheckedCreateNestedManyWithoutOwnerInput
    tradingHistory?: TransactionUncheckedCreateNestedManyWithoutUserInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderInput
    listings?: MarketplaceListingUncheckedCreateNestedManyWithoutSellerInput
    appOrders?: AppOrderUncheckedCreateNestedManyWithoutUserInput
    orderCommunications?: OrderCommunicationUncheckedCreateNestedManyWithoutUserInput
    bettingPositions?: BettingPositionUncheckedCreateNestedManyWithoutUserInput
    bettingPayouts?: BettingPayoutUncheckedCreateNestedManyWithoutUserInput
    ownedAuctions?: CardAuctionUncheckedCreateNestedManyWithoutOwnerInput
    wonAuctions?: CardAuctionUncheckedCreateNestedManyWithoutWinnerInput
    placedAuctionBids?: AuctionBidUncheckedCreateNestedManyWithoutBidderInput
    watchedAuctions?: AuctionWatcherUncheckedCreateNestedManyWithoutUserInput
    initiatedMABattles?: MABattleUncheckedCreateNestedManyWithoutInitiatorInput
    targetedMABattles?: MABattleUncheckedCreateNestedManyWithoutTargetInput
    battleProposals?: BattleProposalUncheckedCreateNestedManyWithoutProposerInput
    battleVotes?: BattleVotingUncheckedCreateNestedManyWithoutVoterInput
    stakingPositions?: StakingPositionUncheckedCreateNestedManyWithoutUserInput
    stakingRewards?: StakingRewardUncheckedCreateNestedManyWithoutUserInput
    governanceProposals?: GovernanceProposalUncheckedCreateNestedManyWithoutProposerInput
    governanceVotes?: GovernanceVoteUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    socialFeeds?: SocialFeedUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutOrderRevisionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrderRevisionsInput, UserUncheckedCreateWithoutOrderRevisionsInput>
  }

  export type AppOrderUpsertWithoutRevisionsInput = {
    update: XOR<AppOrderUpdateWithoutRevisionsInput, AppOrderUncheckedUpdateWithoutRevisionsInput>
    create: XOR<AppOrderCreateWithoutRevisionsInput, AppOrderUncheckedCreateWithoutRevisionsInput>
    where?: AppOrderWhereInput
  }

  export type AppOrderUpdateToOneWithWhereWithoutRevisionsInput = {
    where?: AppOrderWhereInput
    data: XOR<AppOrderUpdateWithoutRevisionsInput, AppOrderUncheckedUpdateWithoutRevisionsInput>
  }

  export type AppOrderUpdateWithoutRevisionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectType?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requirements?: NullableJsonNullValueInput | InputJsonValue
    timeline?: EnumOrderTimelineFieldUpdateOperationsInput | $Enums.OrderTimeline
    estimatedCost?: FloatFieldUpdateOperationsInput | number
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    priority?: EnumOrderPriorityFieldUpdateOperationsInput | $Enums.OrderPriority
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    githubRepo?: NullableStringFieldUpdateOperationsInput | string | null
    vercelLink?: NullableStringFieldUpdateOperationsInput | string | null
    downloadLink?: NullableStringFieldUpdateOperationsInput | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
    currentMilestone?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAppOrdersNestedInput
    communications?: OrderCommunicationUpdateManyWithoutOrderNestedInput
    deliverables?: OrderDeliverableUpdateManyWithoutOrderNestedInput
  }

  export type AppOrderUncheckedUpdateWithoutRevisionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    projectType?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requirements?: NullableJsonNullValueInput | InputJsonValue
    timeline?: EnumOrderTimelineFieldUpdateOperationsInput | $Enums.OrderTimeline
    estimatedCost?: FloatFieldUpdateOperationsInput | number
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    priority?: EnumOrderPriorityFieldUpdateOperationsInput | $Enums.OrderPriority
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    githubRepo?: NullableStringFieldUpdateOperationsInput | string | null
    vercelLink?: NullableStringFieldUpdateOperationsInput | string | null
    downloadLink?: NullableStringFieldUpdateOperationsInput | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
    currentMilestone?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    communications?: OrderCommunicationUncheckedUpdateManyWithoutOrderNestedInput
    deliverables?: OrderDeliverableUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type UserUpsertWithoutOrderRevisionsInput = {
    update: XOR<UserUpdateWithoutOrderRevisionsInput, UserUncheckedUpdateWithoutOrderRevisionsInput>
    create: XOR<UserCreateWithoutOrderRevisionsInput, UserUncheckedCreateWithoutOrderRevisionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrderRevisionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrderRevisionsInput, UserUncheckedUpdateWithoutOrderRevisionsInput>
  }

  export type UserUpdateWithoutOrderRevisionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eceBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: UserSubscriptionUpdateOneWithoutUserNestedInput
    cryptoWallets?: CryptoWalletUpdateManyWithoutUserNestedInput
    physicalCard?: PhysicalCardUpdateOneWithoutUserNestedInput
    ownedCards?: CardUpdateManyWithoutOwnerNestedInput
    tradingHistory?: TransactionUpdateManyWithoutUserNestedInput
    bids?: BidUpdateManyWithoutBidderNestedInput
    listings?: MarketplaceListingUpdateManyWithoutSellerNestedInput
    appOrders?: AppOrderUpdateManyWithoutUserNestedInput
    orderCommunications?: OrderCommunicationUpdateManyWithoutUserNestedInput
    bettingPositions?: BettingPositionUpdateManyWithoutUserNestedInput
    bettingPayouts?: BettingPayoutUpdateManyWithoutUserNestedInput
    ownedAuctions?: CardAuctionUpdateManyWithoutOwnerNestedInput
    wonAuctions?: CardAuctionUpdateManyWithoutWinnerNestedInput
    placedAuctionBids?: AuctionBidUpdateManyWithoutBidderNestedInput
    watchedAuctions?: AuctionWatcherUpdateManyWithoutUserNestedInput
    initiatedMABattles?: MABattleUpdateManyWithoutInitiatorNestedInput
    targetedMABattles?: MABattleUpdateManyWithoutTargetNestedInput
    battleProposals?: BattleProposalUpdateManyWithoutProposerNestedInput
    battleVotes?: BattleVotingUpdateManyWithoutVoterNestedInput
    stakingPositions?: StakingPositionUpdateManyWithoutUserNestedInput
    stakingRewards?: StakingRewardUpdateManyWithoutUserNestedInput
    governanceProposals?: GovernanceProposalUpdateManyWithoutProposerNestedInput
    governanceVotes?: GovernanceVoteUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    socialFeeds?: SocialFeedUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutOrderRevisionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eceBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: UserSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    cryptoWallets?: CryptoWalletUncheckedUpdateManyWithoutUserNestedInput
    physicalCard?: PhysicalCardUncheckedUpdateOneWithoutUserNestedInput
    ownedCards?: CardUncheckedUpdateManyWithoutOwnerNestedInput
    tradingHistory?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderNestedInput
    listings?: MarketplaceListingUncheckedUpdateManyWithoutSellerNestedInput
    appOrders?: AppOrderUncheckedUpdateManyWithoutUserNestedInput
    orderCommunications?: OrderCommunicationUncheckedUpdateManyWithoutUserNestedInput
    bettingPositions?: BettingPositionUncheckedUpdateManyWithoutUserNestedInput
    bettingPayouts?: BettingPayoutUncheckedUpdateManyWithoutUserNestedInput
    ownedAuctions?: CardAuctionUncheckedUpdateManyWithoutOwnerNestedInput
    wonAuctions?: CardAuctionUncheckedUpdateManyWithoutWinnerNestedInput
    placedAuctionBids?: AuctionBidUncheckedUpdateManyWithoutBidderNestedInput
    watchedAuctions?: AuctionWatcherUncheckedUpdateManyWithoutUserNestedInput
    initiatedMABattles?: MABattleUncheckedUpdateManyWithoutInitiatorNestedInput
    targetedMABattles?: MABattleUncheckedUpdateManyWithoutTargetNestedInput
    battleProposals?: BattleProposalUncheckedUpdateManyWithoutProposerNestedInput
    battleVotes?: BattleVotingUncheckedUpdateManyWithoutVoterNestedInput
    stakingPositions?: StakingPositionUncheckedUpdateManyWithoutUserNestedInput
    stakingRewards?: StakingRewardUncheckedUpdateManyWithoutUserNestedInput
    governanceProposals?: GovernanceProposalUncheckedUpdateManyWithoutProposerNestedInput
    governanceVotes?: GovernanceVoteUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    socialFeeds?: SocialFeedUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type AppOrderCreateWithoutCommunicationsInput = {
    id?: string
    projectType: $Enums.ProjectType
    title: string
    description: string
    requirements?: NullableJsonNullValueInput | InputJsonValue
    timeline: $Enums.OrderTimeline
    estimatedCost: number
    actualCost?: number | null
    currency?: string
    status?: $Enums.OrderStatus
    priority?: $Enums.OrderPriority
    deliveryDate?: Date | string | null
    githubRepo?: string | null
    vercelLink?: string | null
    downloadLink?: string | null
    progressPercentage?: number
    currentMilestone?: string | null
    assignedAdminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAppOrdersInput
    revisions?: OrderRevisionCreateNestedManyWithoutOrderInput
    deliverables?: OrderDeliverableCreateNestedManyWithoutOrderInput
  }

  export type AppOrderUncheckedCreateWithoutCommunicationsInput = {
    id?: string
    userId: string
    projectType: $Enums.ProjectType
    title: string
    description: string
    requirements?: NullableJsonNullValueInput | InputJsonValue
    timeline: $Enums.OrderTimeline
    estimatedCost: number
    actualCost?: number | null
    currency?: string
    status?: $Enums.OrderStatus
    priority?: $Enums.OrderPriority
    deliveryDate?: Date | string | null
    githubRepo?: string | null
    vercelLink?: string | null
    downloadLink?: string | null
    progressPercentage?: number
    currentMilestone?: string | null
    assignedAdminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    revisions?: OrderRevisionUncheckedCreateNestedManyWithoutOrderInput
    deliverables?: OrderDeliverableUncheckedCreateNestedManyWithoutOrderInput
  }

  export type AppOrderCreateOrConnectWithoutCommunicationsInput = {
    where: AppOrderWhereUniqueInput
    create: XOR<AppOrderCreateWithoutCommunicationsInput, AppOrderUncheckedCreateWithoutCommunicationsInput>
  }

  export type UserCreateWithoutOrderCommunicationsInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    passwordHash?: string | null
    emailVerified?: Date | string | null
    eceBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string
    subscription?: UserSubscriptionCreateNestedOneWithoutUserInput
    cryptoWallets?: CryptoWalletCreateNestedManyWithoutUserInput
    physicalCard?: PhysicalCardCreateNestedOneWithoutUserInput
    ownedCards?: CardCreateNestedManyWithoutOwnerInput
    tradingHistory?: TransactionCreateNestedManyWithoutUserInput
    bids?: BidCreateNestedManyWithoutBidderInput
    listings?: MarketplaceListingCreateNestedManyWithoutSellerInput
    appOrders?: AppOrderCreateNestedManyWithoutUserInput
    orderRevisions?: OrderRevisionCreateNestedManyWithoutUserInput
    bettingPositions?: BettingPositionCreateNestedManyWithoutUserInput
    bettingPayouts?: BettingPayoutCreateNestedManyWithoutUserInput
    ownedAuctions?: CardAuctionCreateNestedManyWithoutOwnerInput
    wonAuctions?: CardAuctionCreateNestedManyWithoutWinnerInput
    placedAuctionBids?: AuctionBidCreateNestedManyWithoutBidderInput
    watchedAuctions?: AuctionWatcherCreateNestedManyWithoutUserInput
    initiatedMABattles?: MABattleCreateNestedManyWithoutInitiatorInput
    targetedMABattles?: MABattleCreateNestedManyWithoutTargetInput
    battleProposals?: BattleProposalCreateNestedManyWithoutProposerInput
    battleVotes?: BattleVotingCreateNestedManyWithoutVoterInput
    stakingPositions?: StakingPositionCreateNestedManyWithoutUserInput
    stakingRewards?: StakingRewardCreateNestedManyWithoutUserInput
    governanceProposals?: GovernanceProposalCreateNestedManyWithoutProposerInput
    governanceVotes?: GovernanceVoteCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    socialFeeds?: SocialFeedCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutOrderCommunicationsInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    passwordHash?: string | null
    emailVerified?: Date | string | null
    eceBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string
    subscription?: UserSubscriptionUncheckedCreateNestedOneWithoutUserInput
    cryptoWallets?: CryptoWalletUncheckedCreateNestedManyWithoutUserInput
    physicalCard?: PhysicalCardUncheckedCreateNestedOneWithoutUserInput
    ownedCards?: CardUncheckedCreateNestedManyWithoutOwnerInput
    tradingHistory?: TransactionUncheckedCreateNestedManyWithoutUserInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderInput
    listings?: MarketplaceListingUncheckedCreateNestedManyWithoutSellerInput
    appOrders?: AppOrderUncheckedCreateNestedManyWithoutUserInput
    orderRevisions?: OrderRevisionUncheckedCreateNestedManyWithoutUserInput
    bettingPositions?: BettingPositionUncheckedCreateNestedManyWithoutUserInput
    bettingPayouts?: BettingPayoutUncheckedCreateNestedManyWithoutUserInput
    ownedAuctions?: CardAuctionUncheckedCreateNestedManyWithoutOwnerInput
    wonAuctions?: CardAuctionUncheckedCreateNestedManyWithoutWinnerInput
    placedAuctionBids?: AuctionBidUncheckedCreateNestedManyWithoutBidderInput
    watchedAuctions?: AuctionWatcherUncheckedCreateNestedManyWithoutUserInput
    initiatedMABattles?: MABattleUncheckedCreateNestedManyWithoutInitiatorInput
    targetedMABattles?: MABattleUncheckedCreateNestedManyWithoutTargetInput
    battleProposals?: BattleProposalUncheckedCreateNestedManyWithoutProposerInput
    battleVotes?: BattleVotingUncheckedCreateNestedManyWithoutVoterInput
    stakingPositions?: StakingPositionUncheckedCreateNestedManyWithoutUserInput
    stakingRewards?: StakingRewardUncheckedCreateNestedManyWithoutUserInput
    governanceProposals?: GovernanceProposalUncheckedCreateNestedManyWithoutProposerInput
    governanceVotes?: GovernanceVoteUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    socialFeeds?: SocialFeedUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutOrderCommunicationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrderCommunicationsInput, UserUncheckedCreateWithoutOrderCommunicationsInput>
  }

  export type AppOrderUpsertWithoutCommunicationsInput = {
    update: XOR<AppOrderUpdateWithoutCommunicationsInput, AppOrderUncheckedUpdateWithoutCommunicationsInput>
    create: XOR<AppOrderCreateWithoutCommunicationsInput, AppOrderUncheckedCreateWithoutCommunicationsInput>
    where?: AppOrderWhereInput
  }

  export type AppOrderUpdateToOneWithWhereWithoutCommunicationsInput = {
    where?: AppOrderWhereInput
    data: XOR<AppOrderUpdateWithoutCommunicationsInput, AppOrderUncheckedUpdateWithoutCommunicationsInput>
  }

  export type AppOrderUpdateWithoutCommunicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectType?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requirements?: NullableJsonNullValueInput | InputJsonValue
    timeline?: EnumOrderTimelineFieldUpdateOperationsInput | $Enums.OrderTimeline
    estimatedCost?: FloatFieldUpdateOperationsInput | number
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    priority?: EnumOrderPriorityFieldUpdateOperationsInput | $Enums.OrderPriority
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    githubRepo?: NullableStringFieldUpdateOperationsInput | string | null
    vercelLink?: NullableStringFieldUpdateOperationsInput | string | null
    downloadLink?: NullableStringFieldUpdateOperationsInput | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
    currentMilestone?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAppOrdersNestedInput
    revisions?: OrderRevisionUpdateManyWithoutOrderNestedInput
    deliverables?: OrderDeliverableUpdateManyWithoutOrderNestedInput
  }

  export type AppOrderUncheckedUpdateWithoutCommunicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    projectType?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requirements?: NullableJsonNullValueInput | InputJsonValue
    timeline?: EnumOrderTimelineFieldUpdateOperationsInput | $Enums.OrderTimeline
    estimatedCost?: FloatFieldUpdateOperationsInput | number
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    priority?: EnumOrderPriorityFieldUpdateOperationsInput | $Enums.OrderPriority
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    githubRepo?: NullableStringFieldUpdateOperationsInput | string | null
    vercelLink?: NullableStringFieldUpdateOperationsInput | string | null
    downloadLink?: NullableStringFieldUpdateOperationsInput | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
    currentMilestone?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revisions?: OrderRevisionUncheckedUpdateManyWithoutOrderNestedInput
    deliverables?: OrderDeliverableUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type UserUpsertWithoutOrderCommunicationsInput = {
    update: XOR<UserUpdateWithoutOrderCommunicationsInput, UserUncheckedUpdateWithoutOrderCommunicationsInput>
    create: XOR<UserCreateWithoutOrderCommunicationsInput, UserUncheckedCreateWithoutOrderCommunicationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrderCommunicationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrderCommunicationsInput, UserUncheckedUpdateWithoutOrderCommunicationsInput>
  }

  export type UserUpdateWithoutOrderCommunicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eceBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: UserSubscriptionUpdateOneWithoutUserNestedInput
    cryptoWallets?: CryptoWalletUpdateManyWithoutUserNestedInput
    physicalCard?: PhysicalCardUpdateOneWithoutUserNestedInput
    ownedCards?: CardUpdateManyWithoutOwnerNestedInput
    tradingHistory?: TransactionUpdateManyWithoutUserNestedInput
    bids?: BidUpdateManyWithoutBidderNestedInput
    listings?: MarketplaceListingUpdateManyWithoutSellerNestedInput
    appOrders?: AppOrderUpdateManyWithoutUserNestedInput
    orderRevisions?: OrderRevisionUpdateManyWithoutUserNestedInput
    bettingPositions?: BettingPositionUpdateManyWithoutUserNestedInput
    bettingPayouts?: BettingPayoutUpdateManyWithoutUserNestedInput
    ownedAuctions?: CardAuctionUpdateManyWithoutOwnerNestedInput
    wonAuctions?: CardAuctionUpdateManyWithoutWinnerNestedInput
    placedAuctionBids?: AuctionBidUpdateManyWithoutBidderNestedInput
    watchedAuctions?: AuctionWatcherUpdateManyWithoutUserNestedInput
    initiatedMABattles?: MABattleUpdateManyWithoutInitiatorNestedInput
    targetedMABattles?: MABattleUpdateManyWithoutTargetNestedInput
    battleProposals?: BattleProposalUpdateManyWithoutProposerNestedInput
    battleVotes?: BattleVotingUpdateManyWithoutVoterNestedInput
    stakingPositions?: StakingPositionUpdateManyWithoutUserNestedInput
    stakingRewards?: StakingRewardUpdateManyWithoutUserNestedInput
    governanceProposals?: GovernanceProposalUpdateManyWithoutProposerNestedInput
    governanceVotes?: GovernanceVoteUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    socialFeeds?: SocialFeedUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutOrderCommunicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eceBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: UserSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    cryptoWallets?: CryptoWalletUncheckedUpdateManyWithoutUserNestedInput
    physicalCard?: PhysicalCardUncheckedUpdateOneWithoutUserNestedInput
    ownedCards?: CardUncheckedUpdateManyWithoutOwnerNestedInput
    tradingHistory?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderNestedInput
    listings?: MarketplaceListingUncheckedUpdateManyWithoutSellerNestedInput
    appOrders?: AppOrderUncheckedUpdateManyWithoutUserNestedInput
    orderRevisions?: OrderRevisionUncheckedUpdateManyWithoutUserNestedInput
    bettingPositions?: BettingPositionUncheckedUpdateManyWithoutUserNestedInput
    bettingPayouts?: BettingPayoutUncheckedUpdateManyWithoutUserNestedInput
    ownedAuctions?: CardAuctionUncheckedUpdateManyWithoutOwnerNestedInput
    wonAuctions?: CardAuctionUncheckedUpdateManyWithoutWinnerNestedInput
    placedAuctionBids?: AuctionBidUncheckedUpdateManyWithoutBidderNestedInput
    watchedAuctions?: AuctionWatcherUncheckedUpdateManyWithoutUserNestedInput
    initiatedMABattles?: MABattleUncheckedUpdateManyWithoutInitiatorNestedInput
    targetedMABattles?: MABattleUncheckedUpdateManyWithoutTargetNestedInput
    battleProposals?: BattleProposalUncheckedUpdateManyWithoutProposerNestedInput
    battleVotes?: BattleVotingUncheckedUpdateManyWithoutVoterNestedInput
    stakingPositions?: StakingPositionUncheckedUpdateManyWithoutUserNestedInput
    stakingRewards?: StakingRewardUncheckedUpdateManyWithoutUserNestedInput
    governanceProposals?: GovernanceProposalUncheckedUpdateManyWithoutProposerNestedInput
    governanceVotes?: GovernanceVoteUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    socialFeeds?: SocialFeedUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type AppOrderCreateWithoutDeliverablesInput = {
    id?: string
    projectType: $Enums.ProjectType
    title: string
    description: string
    requirements?: NullableJsonNullValueInput | InputJsonValue
    timeline: $Enums.OrderTimeline
    estimatedCost: number
    actualCost?: number | null
    currency?: string
    status?: $Enums.OrderStatus
    priority?: $Enums.OrderPriority
    deliveryDate?: Date | string | null
    githubRepo?: string | null
    vercelLink?: string | null
    downloadLink?: string | null
    progressPercentage?: number
    currentMilestone?: string | null
    assignedAdminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAppOrdersInput
    revisions?: OrderRevisionCreateNestedManyWithoutOrderInput
    communications?: OrderCommunicationCreateNestedManyWithoutOrderInput
  }

  export type AppOrderUncheckedCreateWithoutDeliverablesInput = {
    id?: string
    userId: string
    projectType: $Enums.ProjectType
    title: string
    description: string
    requirements?: NullableJsonNullValueInput | InputJsonValue
    timeline: $Enums.OrderTimeline
    estimatedCost: number
    actualCost?: number | null
    currency?: string
    status?: $Enums.OrderStatus
    priority?: $Enums.OrderPriority
    deliveryDate?: Date | string | null
    githubRepo?: string | null
    vercelLink?: string | null
    downloadLink?: string | null
    progressPercentage?: number
    currentMilestone?: string | null
    assignedAdminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    revisions?: OrderRevisionUncheckedCreateNestedManyWithoutOrderInput
    communications?: OrderCommunicationUncheckedCreateNestedManyWithoutOrderInput
  }

  export type AppOrderCreateOrConnectWithoutDeliverablesInput = {
    where: AppOrderWhereUniqueInput
    create: XOR<AppOrderCreateWithoutDeliverablesInput, AppOrderUncheckedCreateWithoutDeliverablesInput>
  }

  export type AppOrderUpsertWithoutDeliverablesInput = {
    update: XOR<AppOrderUpdateWithoutDeliverablesInput, AppOrderUncheckedUpdateWithoutDeliverablesInput>
    create: XOR<AppOrderCreateWithoutDeliverablesInput, AppOrderUncheckedCreateWithoutDeliverablesInput>
    where?: AppOrderWhereInput
  }

  export type AppOrderUpdateToOneWithWhereWithoutDeliverablesInput = {
    where?: AppOrderWhereInput
    data: XOR<AppOrderUpdateWithoutDeliverablesInput, AppOrderUncheckedUpdateWithoutDeliverablesInput>
  }

  export type AppOrderUpdateWithoutDeliverablesInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectType?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requirements?: NullableJsonNullValueInput | InputJsonValue
    timeline?: EnumOrderTimelineFieldUpdateOperationsInput | $Enums.OrderTimeline
    estimatedCost?: FloatFieldUpdateOperationsInput | number
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    priority?: EnumOrderPriorityFieldUpdateOperationsInput | $Enums.OrderPriority
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    githubRepo?: NullableStringFieldUpdateOperationsInput | string | null
    vercelLink?: NullableStringFieldUpdateOperationsInput | string | null
    downloadLink?: NullableStringFieldUpdateOperationsInput | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
    currentMilestone?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAppOrdersNestedInput
    revisions?: OrderRevisionUpdateManyWithoutOrderNestedInput
    communications?: OrderCommunicationUpdateManyWithoutOrderNestedInput
  }

  export type AppOrderUncheckedUpdateWithoutDeliverablesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    projectType?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requirements?: NullableJsonNullValueInput | InputJsonValue
    timeline?: EnumOrderTimelineFieldUpdateOperationsInput | $Enums.OrderTimeline
    estimatedCost?: FloatFieldUpdateOperationsInput | number
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    priority?: EnumOrderPriorityFieldUpdateOperationsInput | $Enums.OrderPriority
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    githubRepo?: NullableStringFieldUpdateOperationsInput | string | null
    vercelLink?: NullableStringFieldUpdateOperationsInput | string | null
    downloadLink?: NullableStringFieldUpdateOperationsInput | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
    currentMilestone?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revisions?: OrderRevisionUncheckedUpdateManyWithoutOrderNestedInput
    communications?: OrderCommunicationUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type CardCreateWithoutBettingMarketsInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.CardCategory
    rarity: $Enums.CardRarity
    company?: string | null
    currentPrice: number
    historicalPrices?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    stats?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedCardsInput
    listing?: MarketplaceListingCreateNestedOneWithoutCardInput
    bids?: BidCreateNestedManyWithoutCardInput
    transactions?: TransactionCreateNestedManyWithoutCardInput
    marketMetrics?: MarketMetricsCreateNestedManyWithoutCardInput
    auction?: CardAuctionCreateNestedOneWithoutCardInput
    auctionHistory?: AuctionHistoryCreateNestedManyWithoutCardInput
    initiatedBattles?: MABattleCreateNestedManyWithoutInitiatorCardInput
    targetedBattles?: MABattleCreateNestedManyWithoutTargetCardInput
  }

  export type CardUncheckedCreateWithoutBettingMarketsInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.CardCategory
    rarity: $Enums.CardRarity
    company?: string | null
    currentPrice: number
    historicalPrices?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    stats?: NullableJsonNullValueInput | InputJsonValue
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    listing?: MarketplaceListingUncheckedCreateNestedOneWithoutCardInput
    bids?: BidUncheckedCreateNestedManyWithoutCardInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCardInput
    marketMetrics?: MarketMetricsUncheckedCreateNestedManyWithoutCardInput
    auction?: CardAuctionUncheckedCreateNestedOneWithoutCardInput
    auctionHistory?: AuctionHistoryUncheckedCreateNestedManyWithoutCardInput
    initiatedBattles?: MABattleUncheckedCreateNestedManyWithoutInitiatorCardInput
    targetedBattles?: MABattleUncheckedCreateNestedManyWithoutTargetCardInput
  }

  export type CardCreateOrConnectWithoutBettingMarketsInput = {
    where: CardWhereUniqueInput
    create: XOR<CardCreateWithoutBettingMarketsInput, CardUncheckedCreateWithoutBettingMarketsInput>
  }

  export type BettingPositionCreateWithoutMarketInput = {
    id?: string
    position: $Enums.PredictionDirection
    amount: number
    odds: number
    potentialWinning: number
    pickGroupId?: string | null
    multiplier?: number
    powerPlay?: boolean
    status?: $Enums.PositionStatus
    settled?: boolean
    won?: boolean | null
    payout?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBettingPositionsInput
  }

  export type BettingPositionUncheckedCreateWithoutMarketInput = {
    id?: string
    userId: string
    position: $Enums.PredictionDirection
    amount: number
    odds: number
    potentialWinning: number
    pickGroupId?: string | null
    multiplier?: number
    powerPlay?: boolean
    status?: $Enums.PositionStatus
    settled?: boolean
    won?: boolean | null
    payout?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BettingPositionCreateOrConnectWithoutMarketInput = {
    where: BettingPositionWhereUniqueInput
    create: XOR<BettingPositionCreateWithoutMarketInput, BettingPositionUncheckedCreateWithoutMarketInput>
  }

  export type BettingPositionCreateManyMarketInputEnvelope = {
    data: BettingPositionCreateManyMarketInput | BettingPositionCreateManyMarketInput[]
    skipDuplicates?: boolean
  }

  export type BettingPayoutCreateWithoutMarketInput = {
    id?: string
    positionId: string
    winnings: number
    originalBet: number
    multiplier: number
    status?: $Enums.PayoutStatus
    payoutDate?: Date | string | null
    transactionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBettingPayoutsInput
  }

  export type BettingPayoutUncheckedCreateWithoutMarketInput = {
    id?: string
    userId: string
    positionId: string
    winnings: number
    originalBet: number
    multiplier: number
    status?: $Enums.PayoutStatus
    payoutDate?: Date | string | null
    transactionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BettingPayoutCreateOrConnectWithoutMarketInput = {
    where: BettingPayoutWhereUniqueInput
    create: XOR<BettingPayoutCreateWithoutMarketInput, BettingPayoutUncheckedCreateWithoutMarketInput>
  }

  export type BettingPayoutCreateManyMarketInputEnvelope = {
    data: BettingPayoutCreateManyMarketInput | BettingPayoutCreateManyMarketInput[]
    skipDuplicates?: boolean
  }

  export type MarketMetricsCreateWithoutMarketInput = {
    id?: string
    revenue?: number | null
    userGrowth?: number | null
    valuation?: number | null
    marketCap?: number | null
    quarterlyGrowth?: number | null
    userEngagement?: number | null
    productLaunches?: number | null
    competitorRank?: number | null
    sentimentScore?: number | null
    trendingScore?: number | null
    socialMentions?: number | null
    recordDate?: Date | string
    dataSource?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    card: CardCreateNestedOneWithoutMarketMetricsInput
  }

  export type MarketMetricsUncheckedCreateWithoutMarketInput = {
    id?: string
    cardId: string
    revenue?: number | null
    userGrowth?: number | null
    valuation?: number | null
    marketCap?: number | null
    quarterlyGrowth?: number | null
    userEngagement?: number | null
    productLaunches?: number | null
    competitorRank?: number | null
    sentimentScore?: number | null
    trendingScore?: number | null
    socialMentions?: number | null
    recordDate?: Date | string
    dataSource?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketMetricsCreateOrConnectWithoutMarketInput = {
    where: MarketMetricsWhereUniqueInput
    create: XOR<MarketMetricsCreateWithoutMarketInput, MarketMetricsUncheckedCreateWithoutMarketInput>
  }

  export type MarketMetricsCreateManyMarketInputEnvelope = {
    data: MarketMetricsCreateManyMarketInput | MarketMetricsCreateManyMarketInput[]
    skipDuplicates?: boolean
  }

  export type CardUpsertWithoutBettingMarketsInput = {
    update: XOR<CardUpdateWithoutBettingMarketsInput, CardUncheckedUpdateWithoutBettingMarketsInput>
    create: XOR<CardCreateWithoutBettingMarketsInput, CardUncheckedCreateWithoutBettingMarketsInput>
    where?: CardWhereInput
  }

  export type CardUpdateToOneWithWhereWithoutBettingMarketsInput = {
    where?: CardWhereInput
    data: XOR<CardUpdateWithoutBettingMarketsInput, CardUncheckedUpdateWithoutBettingMarketsInput>
  }

  export type CardUpdateWithoutBettingMarketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCardCategoryFieldUpdateOperationsInput | $Enums.CardCategory
    rarity?: EnumCardRarityFieldUpdateOperationsInput | $Enums.CardRarity
    company?: NullableStringFieldUpdateOperationsInput | string | null
    currentPrice?: FloatFieldUpdateOperationsInput | number
    historicalPrices?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    stats?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedCardsNestedInput
    listing?: MarketplaceListingUpdateOneWithoutCardNestedInput
    bids?: BidUpdateManyWithoutCardNestedInput
    transactions?: TransactionUpdateManyWithoutCardNestedInput
    marketMetrics?: MarketMetricsUpdateManyWithoutCardNestedInput
    auction?: CardAuctionUpdateOneWithoutCardNestedInput
    auctionHistory?: AuctionHistoryUpdateManyWithoutCardNestedInput
    initiatedBattles?: MABattleUpdateManyWithoutInitiatorCardNestedInput
    targetedBattles?: MABattleUpdateManyWithoutTargetCardNestedInput
  }

  export type CardUncheckedUpdateWithoutBettingMarketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCardCategoryFieldUpdateOperationsInput | $Enums.CardCategory
    rarity?: EnumCardRarityFieldUpdateOperationsInput | $Enums.CardRarity
    company?: NullableStringFieldUpdateOperationsInput | string | null
    currentPrice?: FloatFieldUpdateOperationsInput | number
    historicalPrices?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    stats?: NullableJsonNullValueInput | InputJsonValue
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listing?: MarketplaceListingUncheckedUpdateOneWithoutCardNestedInput
    bids?: BidUncheckedUpdateManyWithoutCardNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCardNestedInput
    marketMetrics?: MarketMetricsUncheckedUpdateManyWithoutCardNestedInput
    auction?: CardAuctionUncheckedUpdateOneWithoutCardNestedInput
    auctionHistory?: AuctionHistoryUncheckedUpdateManyWithoutCardNestedInput
    initiatedBattles?: MABattleUncheckedUpdateManyWithoutInitiatorCardNestedInput
    targetedBattles?: MABattleUncheckedUpdateManyWithoutTargetCardNestedInput
  }

  export type BettingPositionUpsertWithWhereUniqueWithoutMarketInput = {
    where: BettingPositionWhereUniqueInput
    update: XOR<BettingPositionUpdateWithoutMarketInput, BettingPositionUncheckedUpdateWithoutMarketInput>
    create: XOR<BettingPositionCreateWithoutMarketInput, BettingPositionUncheckedCreateWithoutMarketInput>
  }

  export type BettingPositionUpdateWithWhereUniqueWithoutMarketInput = {
    where: BettingPositionWhereUniqueInput
    data: XOR<BettingPositionUpdateWithoutMarketInput, BettingPositionUncheckedUpdateWithoutMarketInput>
  }

  export type BettingPositionUpdateManyWithWhereWithoutMarketInput = {
    where: BettingPositionScalarWhereInput
    data: XOR<BettingPositionUpdateManyMutationInput, BettingPositionUncheckedUpdateManyWithoutMarketInput>
  }

  export type BettingPayoutUpsertWithWhereUniqueWithoutMarketInput = {
    where: BettingPayoutWhereUniqueInput
    update: XOR<BettingPayoutUpdateWithoutMarketInput, BettingPayoutUncheckedUpdateWithoutMarketInput>
    create: XOR<BettingPayoutCreateWithoutMarketInput, BettingPayoutUncheckedCreateWithoutMarketInput>
  }

  export type BettingPayoutUpdateWithWhereUniqueWithoutMarketInput = {
    where: BettingPayoutWhereUniqueInput
    data: XOR<BettingPayoutUpdateWithoutMarketInput, BettingPayoutUncheckedUpdateWithoutMarketInput>
  }

  export type BettingPayoutUpdateManyWithWhereWithoutMarketInput = {
    where: BettingPayoutScalarWhereInput
    data: XOR<BettingPayoutUpdateManyMutationInput, BettingPayoutUncheckedUpdateManyWithoutMarketInput>
  }

  export type MarketMetricsUpsertWithWhereUniqueWithoutMarketInput = {
    where: MarketMetricsWhereUniqueInput
    update: XOR<MarketMetricsUpdateWithoutMarketInput, MarketMetricsUncheckedUpdateWithoutMarketInput>
    create: XOR<MarketMetricsCreateWithoutMarketInput, MarketMetricsUncheckedCreateWithoutMarketInput>
  }

  export type MarketMetricsUpdateWithWhereUniqueWithoutMarketInput = {
    where: MarketMetricsWhereUniqueInput
    data: XOR<MarketMetricsUpdateWithoutMarketInput, MarketMetricsUncheckedUpdateWithoutMarketInput>
  }

  export type MarketMetricsUpdateManyWithWhereWithoutMarketInput = {
    where: MarketMetricsScalarWhereInput
    data: XOR<MarketMetricsUpdateManyMutationInput, MarketMetricsUncheckedUpdateManyWithoutMarketInput>
  }

  export type BettingMarketCreateWithoutPositionsInput = {
    id?: string
    metricType: $Enums.MarketMetricType
    title: string
    description: string
    currentValue: number
    predictionTarget: number
    targetDirection: $Enums.PredictionDirection
    odds?: number
    totalPot?: number
    minimumBet?: number
    maximumBet?: number | null
    startTime?: Date | string
    expiryDate: Date | string
    settlementDate?: Date | string | null
    status?: $Enums.MarketStatus
    settled?: boolean
    settledValue?: number | null
    winningDirection?: $Enums.PredictionDirection | null
    marketMakerFee?: number
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    card: CardCreateNestedOneWithoutBettingMarketsInput
    payouts?: BettingPayoutCreateNestedManyWithoutMarketInput
    metrics?: MarketMetricsCreateNestedManyWithoutMarketInput
  }

  export type BettingMarketUncheckedCreateWithoutPositionsInput = {
    id?: string
    cardId: string
    metricType: $Enums.MarketMetricType
    title: string
    description: string
    currentValue: number
    predictionTarget: number
    targetDirection: $Enums.PredictionDirection
    odds?: number
    totalPot?: number
    minimumBet?: number
    maximumBet?: number | null
    startTime?: Date | string
    expiryDate: Date | string
    settlementDate?: Date | string | null
    status?: $Enums.MarketStatus
    settled?: boolean
    settledValue?: number | null
    winningDirection?: $Enums.PredictionDirection | null
    marketMakerFee?: number
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payouts?: BettingPayoutUncheckedCreateNestedManyWithoutMarketInput
    metrics?: MarketMetricsUncheckedCreateNestedManyWithoutMarketInput
  }

  export type BettingMarketCreateOrConnectWithoutPositionsInput = {
    where: BettingMarketWhereUniqueInput
    create: XOR<BettingMarketCreateWithoutPositionsInput, BettingMarketUncheckedCreateWithoutPositionsInput>
  }

  export type UserCreateWithoutBettingPositionsInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    passwordHash?: string | null
    emailVerified?: Date | string | null
    eceBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string
    subscription?: UserSubscriptionCreateNestedOneWithoutUserInput
    cryptoWallets?: CryptoWalletCreateNestedManyWithoutUserInput
    physicalCard?: PhysicalCardCreateNestedOneWithoutUserInput
    ownedCards?: CardCreateNestedManyWithoutOwnerInput
    tradingHistory?: TransactionCreateNestedManyWithoutUserInput
    bids?: BidCreateNestedManyWithoutBidderInput
    listings?: MarketplaceListingCreateNestedManyWithoutSellerInput
    appOrders?: AppOrderCreateNestedManyWithoutUserInput
    orderRevisions?: OrderRevisionCreateNestedManyWithoutUserInput
    orderCommunications?: OrderCommunicationCreateNestedManyWithoutUserInput
    bettingPayouts?: BettingPayoutCreateNestedManyWithoutUserInput
    ownedAuctions?: CardAuctionCreateNestedManyWithoutOwnerInput
    wonAuctions?: CardAuctionCreateNestedManyWithoutWinnerInput
    placedAuctionBids?: AuctionBidCreateNestedManyWithoutBidderInput
    watchedAuctions?: AuctionWatcherCreateNestedManyWithoutUserInput
    initiatedMABattles?: MABattleCreateNestedManyWithoutInitiatorInput
    targetedMABattles?: MABattleCreateNestedManyWithoutTargetInput
    battleProposals?: BattleProposalCreateNestedManyWithoutProposerInput
    battleVotes?: BattleVotingCreateNestedManyWithoutVoterInput
    stakingPositions?: StakingPositionCreateNestedManyWithoutUserInput
    stakingRewards?: StakingRewardCreateNestedManyWithoutUserInput
    governanceProposals?: GovernanceProposalCreateNestedManyWithoutProposerInput
    governanceVotes?: GovernanceVoteCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    socialFeeds?: SocialFeedCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutBettingPositionsInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    passwordHash?: string | null
    emailVerified?: Date | string | null
    eceBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string
    subscription?: UserSubscriptionUncheckedCreateNestedOneWithoutUserInput
    cryptoWallets?: CryptoWalletUncheckedCreateNestedManyWithoutUserInput
    physicalCard?: PhysicalCardUncheckedCreateNestedOneWithoutUserInput
    ownedCards?: CardUncheckedCreateNestedManyWithoutOwnerInput
    tradingHistory?: TransactionUncheckedCreateNestedManyWithoutUserInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderInput
    listings?: MarketplaceListingUncheckedCreateNestedManyWithoutSellerInput
    appOrders?: AppOrderUncheckedCreateNestedManyWithoutUserInput
    orderRevisions?: OrderRevisionUncheckedCreateNestedManyWithoutUserInput
    orderCommunications?: OrderCommunicationUncheckedCreateNestedManyWithoutUserInput
    bettingPayouts?: BettingPayoutUncheckedCreateNestedManyWithoutUserInput
    ownedAuctions?: CardAuctionUncheckedCreateNestedManyWithoutOwnerInput
    wonAuctions?: CardAuctionUncheckedCreateNestedManyWithoutWinnerInput
    placedAuctionBids?: AuctionBidUncheckedCreateNestedManyWithoutBidderInput
    watchedAuctions?: AuctionWatcherUncheckedCreateNestedManyWithoutUserInput
    initiatedMABattles?: MABattleUncheckedCreateNestedManyWithoutInitiatorInput
    targetedMABattles?: MABattleUncheckedCreateNestedManyWithoutTargetInput
    battleProposals?: BattleProposalUncheckedCreateNestedManyWithoutProposerInput
    battleVotes?: BattleVotingUncheckedCreateNestedManyWithoutVoterInput
    stakingPositions?: StakingPositionUncheckedCreateNestedManyWithoutUserInput
    stakingRewards?: StakingRewardUncheckedCreateNestedManyWithoutUserInput
    governanceProposals?: GovernanceProposalUncheckedCreateNestedManyWithoutProposerInput
    governanceVotes?: GovernanceVoteUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    socialFeeds?: SocialFeedUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutBettingPositionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBettingPositionsInput, UserUncheckedCreateWithoutBettingPositionsInput>
  }

  export type BettingMarketUpsertWithoutPositionsInput = {
    update: XOR<BettingMarketUpdateWithoutPositionsInput, BettingMarketUncheckedUpdateWithoutPositionsInput>
    create: XOR<BettingMarketCreateWithoutPositionsInput, BettingMarketUncheckedCreateWithoutPositionsInput>
    where?: BettingMarketWhereInput
  }

  export type BettingMarketUpdateToOneWithWhereWithoutPositionsInput = {
    where?: BettingMarketWhereInput
    data: XOR<BettingMarketUpdateWithoutPositionsInput, BettingMarketUncheckedUpdateWithoutPositionsInput>
  }

  export type BettingMarketUpdateWithoutPositionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    metricType?: EnumMarketMetricTypeFieldUpdateOperationsInput | $Enums.MarketMetricType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    currentValue?: FloatFieldUpdateOperationsInput | number
    predictionTarget?: FloatFieldUpdateOperationsInput | number
    targetDirection?: EnumPredictionDirectionFieldUpdateOperationsInput | $Enums.PredictionDirection
    odds?: FloatFieldUpdateOperationsInput | number
    totalPot?: FloatFieldUpdateOperationsInput | number
    minimumBet?: FloatFieldUpdateOperationsInput | number
    maximumBet?: NullableFloatFieldUpdateOperationsInput | number | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    settlementDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMarketStatusFieldUpdateOperationsInput | $Enums.MarketStatus
    settled?: BoolFieldUpdateOperationsInput | boolean
    settledValue?: NullableFloatFieldUpdateOperationsInput | number | null
    winningDirection?: NullableEnumPredictionDirectionFieldUpdateOperationsInput | $Enums.PredictionDirection | null
    marketMakerFee?: FloatFieldUpdateOperationsInput | number
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    card?: CardUpdateOneRequiredWithoutBettingMarketsNestedInput
    payouts?: BettingPayoutUpdateManyWithoutMarketNestedInput
    metrics?: MarketMetricsUpdateManyWithoutMarketNestedInput
  }

  export type BettingMarketUncheckedUpdateWithoutPositionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardId?: StringFieldUpdateOperationsInput | string
    metricType?: EnumMarketMetricTypeFieldUpdateOperationsInput | $Enums.MarketMetricType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    currentValue?: FloatFieldUpdateOperationsInput | number
    predictionTarget?: FloatFieldUpdateOperationsInput | number
    targetDirection?: EnumPredictionDirectionFieldUpdateOperationsInput | $Enums.PredictionDirection
    odds?: FloatFieldUpdateOperationsInput | number
    totalPot?: FloatFieldUpdateOperationsInput | number
    minimumBet?: FloatFieldUpdateOperationsInput | number
    maximumBet?: NullableFloatFieldUpdateOperationsInput | number | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    settlementDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMarketStatusFieldUpdateOperationsInput | $Enums.MarketStatus
    settled?: BoolFieldUpdateOperationsInput | boolean
    settledValue?: NullableFloatFieldUpdateOperationsInput | number | null
    winningDirection?: NullableEnumPredictionDirectionFieldUpdateOperationsInput | $Enums.PredictionDirection | null
    marketMakerFee?: FloatFieldUpdateOperationsInput | number
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payouts?: BettingPayoutUncheckedUpdateManyWithoutMarketNestedInput
    metrics?: MarketMetricsUncheckedUpdateManyWithoutMarketNestedInput
  }

  export type UserUpsertWithoutBettingPositionsInput = {
    update: XOR<UserUpdateWithoutBettingPositionsInput, UserUncheckedUpdateWithoutBettingPositionsInput>
    create: XOR<UserCreateWithoutBettingPositionsInput, UserUncheckedCreateWithoutBettingPositionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBettingPositionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBettingPositionsInput, UserUncheckedUpdateWithoutBettingPositionsInput>
  }

  export type UserUpdateWithoutBettingPositionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eceBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: UserSubscriptionUpdateOneWithoutUserNestedInput
    cryptoWallets?: CryptoWalletUpdateManyWithoutUserNestedInput
    physicalCard?: PhysicalCardUpdateOneWithoutUserNestedInput
    ownedCards?: CardUpdateManyWithoutOwnerNestedInput
    tradingHistory?: TransactionUpdateManyWithoutUserNestedInput
    bids?: BidUpdateManyWithoutBidderNestedInput
    listings?: MarketplaceListingUpdateManyWithoutSellerNestedInput
    appOrders?: AppOrderUpdateManyWithoutUserNestedInput
    orderRevisions?: OrderRevisionUpdateManyWithoutUserNestedInput
    orderCommunications?: OrderCommunicationUpdateManyWithoutUserNestedInput
    bettingPayouts?: BettingPayoutUpdateManyWithoutUserNestedInput
    ownedAuctions?: CardAuctionUpdateManyWithoutOwnerNestedInput
    wonAuctions?: CardAuctionUpdateManyWithoutWinnerNestedInput
    placedAuctionBids?: AuctionBidUpdateManyWithoutBidderNestedInput
    watchedAuctions?: AuctionWatcherUpdateManyWithoutUserNestedInput
    initiatedMABattles?: MABattleUpdateManyWithoutInitiatorNestedInput
    targetedMABattles?: MABattleUpdateManyWithoutTargetNestedInput
    battleProposals?: BattleProposalUpdateManyWithoutProposerNestedInput
    battleVotes?: BattleVotingUpdateManyWithoutVoterNestedInput
    stakingPositions?: StakingPositionUpdateManyWithoutUserNestedInput
    stakingRewards?: StakingRewardUpdateManyWithoutUserNestedInput
    governanceProposals?: GovernanceProposalUpdateManyWithoutProposerNestedInput
    governanceVotes?: GovernanceVoteUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    socialFeeds?: SocialFeedUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutBettingPositionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eceBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: UserSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    cryptoWallets?: CryptoWalletUncheckedUpdateManyWithoutUserNestedInput
    physicalCard?: PhysicalCardUncheckedUpdateOneWithoutUserNestedInput
    ownedCards?: CardUncheckedUpdateManyWithoutOwnerNestedInput
    tradingHistory?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderNestedInput
    listings?: MarketplaceListingUncheckedUpdateManyWithoutSellerNestedInput
    appOrders?: AppOrderUncheckedUpdateManyWithoutUserNestedInput
    orderRevisions?: OrderRevisionUncheckedUpdateManyWithoutUserNestedInput
    orderCommunications?: OrderCommunicationUncheckedUpdateManyWithoutUserNestedInput
    bettingPayouts?: BettingPayoutUncheckedUpdateManyWithoutUserNestedInput
    ownedAuctions?: CardAuctionUncheckedUpdateManyWithoutOwnerNestedInput
    wonAuctions?: CardAuctionUncheckedUpdateManyWithoutWinnerNestedInput
    placedAuctionBids?: AuctionBidUncheckedUpdateManyWithoutBidderNestedInput
    watchedAuctions?: AuctionWatcherUncheckedUpdateManyWithoutUserNestedInput
    initiatedMABattles?: MABattleUncheckedUpdateManyWithoutInitiatorNestedInput
    targetedMABattles?: MABattleUncheckedUpdateManyWithoutTargetNestedInput
    battleProposals?: BattleProposalUncheckedUpdateManyWithoutProposerNestedInput
    battleVotes?: BattleVotingUncheckedUpdateManyWithoutVoterNestedInput
    stakingPositions?: StakingPositionUncheckedUpdateManyWithoutUserNestedInput
    stakingRewards?: StakingRewardUncheckedUpdateManyWithoutUserNestedInput
    governanceProposals?: GovernanceProposalUncheckedUpdateManyWithoutProposerNestedInput
    governanceVotes?: GovernanceVoteUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    socialFeeds?: SocialFeedUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type CardCreateWithoutMarketMetricsInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.CardCategory
    rarity: $Enums.CardRarity
    company?: string | null
    currentPrice: number
    historicalPrices?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    stats?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedCardsInput
    listing?: MarketplaceListingCreateNestedOneWithoutCardInput
    bids?: BidCreateNestedManyWithoutCardInput
    transactions?: TransactionCreateNestedManyWithoutCardInput
    bettingMarkets?: BettingMarketCreateNestedManyWithoutCardInput
    auction?: CardAuctionCreateNestedOneWithoutCardInput
    auctionHistory?: AuctionHistoryCreateNestedManyWithoutCardInput
    initiatedBattles?: MABattleCreateNestedManyWithoutInitiatorCardInput
    targetedBattles?: MABattleCreateNestedManyWithoutTargetCardInput
  }

  export type CardUncheckedCreateWithoutMarketMetricsInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.CardCategory
    rarity: $Enums.CardRarity
    company?: string | null
    currentPrice: number
    historicalPrices?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    stats?: NullableJsonNullValueInput | InputJsonValue
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    listing?: MarketplaceListingUncheckedCreateNestedOneWithoutCardInput
    bids?: BidUncheckedCreateNestedManyWithoutCardInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCardInput
    bettingMarkets?: BettingMarketUncheckedCreateNestedManyWithoutCardInput
    auction?: CardAuctionUncheckedCreateNestedOneWithoutCardInput
    auctionHistory?: AuctionHistoryUncheckedCreateNestedManyWithoutCardInput
    initiatedBattles?: MABattleUncheckedCreateNestedManyWithoutInitiatorCardInput
    targetedBattles?: MABattleUncheckedCreateNestedManyWithoutTargetCardInput
  }

  export type CardCreateOrConnectWithoutMarketMetricsInput = {
    where: CardWhereUniqueInput
    create: XOR<CardCreateWithoutMarketMetricsInput, CardUncheckedCreateWithoutMarketMetricsInput>
  }

  export type BettingMarketCreateWithoutMetricsInput = {
    id?: string
    metricType: $Enums.MarketMetricType
    title: string
    description: string
    currentValue: number
    predictionTarget: number
    targetDirection: $Enums.PredictionDirection
    odds?: number
    totalPot?: number
    minimumBet?: number
    maximumBet?: number | null
    startTime?: Date | string
    expiryDate: Date | string
    settlementDate?: Date | string | null
    status?: $Enums.MarketStatus
    settled?: boolean
    settledValue?: number | null
    winningDirection?: $Enums.PredictionDirection | null
    marketMakerFee?: number
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    card: CardCreateNestedOneWithoutBettingMarketsInput
    positions?: BettingPositionCreateNestedManyWithoutMarketInput
    payouts?: BettingPayoutCreateNestedManyWithoutMarketInput
  }

  export type BettingMarketUncheckedCreateWithoutMetricsInput = {
    id?: string
    cardId: string
    metricType: $Enums.MarketMetricType
    title: string
    description: string
    currentValue: number
    predictionTarget: number
    targetDirection: $Enums.PredictionDirection
    odds?: number
    totalPot?: number
    minimumBet?: number
    maximumBet?: number | null
    startTime?: Date | string
    expiryDate: Date | string
    settlementDate?: Date | string | null
    status?: $Enums.MarketStatus
    settled?: boolean
    settledValue?: number | null
    winningDirection?: $Enums.PredictionDirection | null
    marketMakerFee?: number
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    positions?: BettingPositionUncheckedCreateNestedManyWithoutMarketInput
    payouts?: BettingPayoutUncheckedCreateNestedManyWithoutMarketInput
  }

  export type BettingMarketCreateOrConnectWithoutMetricsInput = {
    where: BettingMarketWhereUniqueInput
    create: XOR<BettingMarketCreateWithoutMetricsInput, BettingMarketUncheckedCreateWithoutMetricsInput>
  }

  export type CardUpsertWithoutMarketMetricsInput = {
    update: XOR<CardUpdateWithoutMarketMetricsInput, CardUncheckedUpdateWithoutMarketMetricsInput>
    create: XOR<CardCreateWithoutMarketMetricsInput, CardUncheckedCreateWithoutMarketMetricsInput>
    where?: CardWhereInput
  }

  export type CardUpdateToOneWithWhereWithoutMarketMetricsInput = {
    where?: CardWhereInput
    data: XOR<CardUpdateWithoutMarketMetricsInput, CardUncheckedUpdateWithoutMarketMetricsInput>
  }

  export type CardUpdateWithoutMarketMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCardCategoryFieldUpdateOperationsInput | $Enums.CardCategory
    rarity?: EnumCardRarityFieldUpdateOperationsInput | $Enums.CardRarity
    company?: NullableStringFieldUpdateOperationsInput | string | null
    currentPrice?: FloatFieldUpdateOperationsInput | number
    historicalPrices?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    stats?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedCardsNestedInput
    listing?: MarketplaceListingUpdateOneWithoutCardNestedInput
    bids?: BidUpdateManyWithoutCardNestedInput
    transactions?: TransactionUpdateManyWithoutCardNestedInput
    bettingMarkets?: BettingMarketUpdateManyWithoutCardNestedInput
    auction?: CardAuctionUpdateOneWithoutCardNestedInput
    auctionHistory?: AuctionHistoryUpdateManyWithoutCardNestedInput
    initiatedBattles?: MABattleUpdateManyWithoutInitiatorCardNestedInput
    targetedBattles?: MABattleUpdateManyWithoutTargetCardNestedInput
  }

  export type CardUncheckedUpdateWithoutMarketMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCardCategoryFieldUpdateOperationsInput | $Enums.CardCategory
    rarity?: EnumCardRarityFieldUpdateOperationsInput | $Enums.CardRarity
    company?: NullableStringFieldUpdateOperationsInput | string | null
    currentPrice?: FloatFieldUpdateOperationsInput | number
    historicalPrices?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    stats?: NullableJsonNullValueInput | InputJsonValue
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listing?: MarketplaceListingUncheckedUpdateOneWithoutCardNestedInput
    bids?: BidUncheckedUpdateManyWithoutCardNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCardNestedInput
    bettingMarkets?: BettingMarketUncheckedUpdateManyWithoutCardNestedInput
    auction?: CardAuctionUncheckedUpdateOneWithoutCardNestedInput
    auctionHistory?: AuctionHistoryUncheckedUpdateManyWithoutCardNestedInput
    initiatedBattles?: MABattleUncheckedUpdateManyWithoutInitiatorCardNestedInput
    targetedBattles?: MABattleUncheckedUpdateManyWithoutTargetCardNestedInput
  }

  export type BettingMarketUpsertWithoutMetricsInput = {
    update: XOR<BettingMarketUpdateWithoutMetricsInput, BettingMarketUncheckedUpdateWithoutMetricsInput>
    create: XOR<BettingMarketCreateWithoutMetricsInput, BettingMarketUncheckedCreateWithoutMetricsInput>
    where?: BettingMarketWhereInput
  }

  export type BettingMarketUpdateToOneWithWhereWithoutMetricsInput = {
    where?: BettingMarketWhereInput
    data: XOR<BettingMarketUpdateWithoutMetricsInput, BettingMarketUncheckedUpdateWithoutMetricsInput>
  }

  export type BettingMarketUpdateWithoutMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    metricType?: EnumMarketMetricTypeFieldUpdateOperationsInput | $Enums.MarketMetricType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    currentValue?: FloatFieldUpdateOperationsInput | number
    predictionTarget?: FloatFieldUpdateOperationsInput | number
    targetDirection?: EnumPredictionDirectionFieldUpdateOperationsInput | $Enums.PredictionDirection
    odds?: FloatFieldUpdateOperationsInput | number
    totalPot?: FloatFieldUpdateOperationsInput | number
    minimumBet?: FloatFieldUpdateOperationsInput | number
    maximumBet?: NullableFloatFieldUpdateOperationsInput | number | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    settlementDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMarketStatusFieldUpdateOperationsInput | $Enums.MarketStatus
    settled?: BoolFieldUpdateOperationsInput | boolean
    settledValue?: NullableFloatFieldUpdateOperationsInput | number | null
    winningDirection?: NullableEnumPredictionDirectionFieldUpdateOperationsInput | $Enums.PredictionDirection | null
    marketMakerFee?: FloatFieldUpdateOperationsInput | number
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    card?: CardUpdateOneRequiredWithoutBettingMarketsNestedInput
    positions?: BettingPositionUpdateManyWithoutMarketNestedInput
    payouts?: BettingPayoutUpdateManyWithoutMarketNestedInput
  }

  export type BettingMarketUncheckedUpdateWithoutMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardId?: StringFieldUpdateOperationsInput | string
    metricType?: EnumMarketMetricTypeFieldUpdateOperationsInput | $Enums.MarketMetricType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    currentValue?: FloatFieldUpdateOperationsInput | number
    predictionTarget?: FloatFieldUpdateOperationsInput | number
    targetDirection?: EnumPredictionDirectionFieldUpdateOperationsInput | $Enums.PredictionDirection
    odds?: FloatFieldUpdateOperationsInput | number
    totalPot?: FloatFieldUpdateOperationsInput | number
    minimumBet?: FloatFieldUpdateOperationsInput | number
    maximumBet?: NullableFloatFieldUpdateOperationsInput | number | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    settlementDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMarketStatusFieldUpdateOperationsInput | $Enums.MarketStatus
    settled?: BoolFieldUpdateOperationsInput | boolean
    settledValue?: NullableFloatFieldUpdateOperationsInput | number | null
    winningDirection?: NullableEnumPredictionDirectionFieldUpdateOperationsInput | $Enums.PredictionDirection | null
    marketMakerFee?: FloatFieldUpdateOperationsInput | number
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    positions?: BettingPositionUncheckedUpdateManyWithoutMarketNestedInput
    payouts?: BettingPayoutUncheckedUpdateManyWithoutMarketNestedInput
  }

  export type BettingMarketCreateWithoutPayoutsInput = {
    id?: string
    metricType: $Enums.MarketMetricType
    title: string
    description: string
    currentValue: number
    predictionTarget: number
    targetDirection: $Enums.PredictionDirection
    odds?: number
    totalPot?: number
    minimumBet?: number
    maximumBet?: number | null
    startTime?: Date | string
    expiryDate: Date | string
    settlementDate?: Date | string | null
    status?: $Enums.MarketStatus
    settled?: boolean
    settledValue?: number | null
    winningDirection?: $Enums.PredictionDirection | null
    marketMakerFee?: number
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    card: CardCreateNestedOneWithoutBettingMarketsInput
    positions?: BettingPositionCreateNestedManyWithoutMarketInput
    metrics?: MarketMetricsCreateNestedManyWithoutMarketInput
  }

  export type BettingMarketUncheckedCreateWithoutPayoutsInput = {
    id?: string
    cardId: string
    metricType: $Enums.MarketMetricType
    title: string
    description: string
    currentValue: number
    predictionTarget: number
    targetDirection: $Enums.PredictionDirection
    odds?: number
    totalPot?: number
    minimumBet?: number
    maximumBet?: number | null
    startTime?: Date | string
    expiryDate: Date | string
    settlementDate?: Date | string | null
    status?: $Enums.MarketStatus
    settled?: boolean
    settledValue?: number | null
    winningDirection?: $Enums.PredictionDirection | null
    marketMakerFee?: number
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    positions?: BettingPositionUncheckedCreateNestedManyWithoutMarketInput
    metrics?: MarketMetricsUncheckedCreateNestedManyWithoutMarketInput
  }

  export type BettingMarketCreateOrConnectWithoutPayoutsInput = {
    where: BettingMarketWhereUniqueInput
    create: XOR<BettingMarketCreateWithoutPayoutsInput, BettingMarketUncheckedCreateWithoutPayoutsInput>
  }

  export type UserCreateWithoutBettingPayoutsInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    passwordHash?: string | null
    emailVerified?: Date | string | null
    eceBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string
    subscription?: UserSubscriptionCreateNestedOneWithoutUserInput
    cryptoWallets?: CryptoWalletCreateNestedManyWithoutUserInput
    physicalCard?: PhysicalCardCreateNestedOneWithoutUserInput
    ownedCards?: CardCreateNestedManyWithoutOwnerInput
    tradingHistory?: TransactionCreateNestedManyWithoutUserInput
    bids?: BidCreateNestedManyWithoutBidderInput
    listings?: MarketplaceListingCreateNestedManyWithoutSellerInput
    appOrders?: AppOrderCreateNestedManyWithoutUserInput
    orderRevisions?: OrderRevisionCreateNestedManyWithoutUserInput
    orderCommunications?: OrderCommunicationCreateNestedManyWithoutUserInput
    bettingPositions?: BettingPositionCreateNestedManyWithoutUserInput
    ownedAuctions?: CardAuctionCreateNestedManyWithoutOwnerInput
    wonAuctions?: CardAuctionCreateNestedManyWithoutWinnerInput
    placedAuctionBids?: AuctionBidCreateNestedManyWithoutBidderInput
    watchedAuctions?: AuctionWatcherCreateNestedManyWithoutUserInput
    initiatedMABattles?: MABattleCreateNestedManyWithoutInitiatorInput
    targetedMABattles?: MABattleCreateNestedManyWithoutTargetInput
    battleProposals?: BattleProposalCreateNestedManyWithoutProposerInput
    battleVotes?: BattleVotingCreateNestedManyWithoutVoterInput
    stakingPositions?: StakingPositionCreateNestedManyWithoutUserInput
    stakingRewards?: StakingRewardCreateNestedManyWithoutUserInput
    governanceProposals?: GovernanceProposalCreateNestedManyWithoutProposerInput
    governanceVotes?: GovernanceVoteCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    socialFeeds?: SocialFeedCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutBettingPayoutsInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    passwordHash?: string | null
    emailVerified?: Date | string | null
    eceBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string
    subscription?: UserSubscriptionUncheckedCreateNestedOneWithoutUserInput
    cryptoWallets?: CryptoWalletUncheckedCreateNestedManyWithoutUserInput
    physicalCard?: PhysicalCardUncheckedCreateNestedOneWithoutUserInput
    ownedCards?: CardUncheckedCreateNestedManyWithoutOwnerInput
    tradingHistory?: TransactionUncheckedCreateNestedManyWithoutUserInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderInput
    listings?: MarketplaceListingUncheckedCreateNestedManyWithoutSellerInput
    appOrders?: AppOrderUncheckedCreateNestedManyWithoutUserInput
    orderRevisions?: OrderRevisionUncheckedCreateNestedManyWithoutUserInput
    orderCommunications?: OrderCommunicationUncheckedCreateNestedManyWithoutUserInput
    bettingPositions?: BettingPositionUncheckedCreateNestedManyWithoutUserInput
    ownedAuctions?: CardAuctionUncheckedCreateNestedManyWithoutOwnerInput
    wonAuctions?: CardAuctionUncheckedCreateNestedManyWithoutWinnerInput
    placedAuctionBids?: AuctionBidUncheckedCreateNestedManyWithoutBidderInput
    watchedAuctions?: AuctionWatcherUncheckedCreateNestedManyWithoutUserInput
    initiatedMABattles?: MABattleUncheckedCreateNestedManyWithoutInitiatorInput
    targetedMABattles?: MABattleUncheckedCreateNestedManyWithoutTargetInput
    battleProposals?: BattleProposalUncheckedCreateNestedManyWithoutProposerInput
    battleVotes?: BattleVotingUncheckedCreateNestedManyWithoutVoterInput
    stakingPositions?: StakingPositionUncheckedCreateNestedManyWithoutUserInput
    stakingRewards?: StakingRewardUncheckedCreateNestedManyWithoutUserInput
    governanceProposals?: GovernanceProposalUncheckedCreateNestedManyWithoutProposerInput
    governanceVotes?: GovernanceVoteUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    socialFeeds?: SocialFeedUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutBettingPayoutsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBettingPayoutsInput, UserUncheckedCreateWithoutBettingPayoutsInput>
  }

  export type BettingMarketUpsertWithoutPayoutsInput = {
    update: XOR<BettingMarketUpdateWithoutPayoutsInput, BettingMarketUncheckedUpdateWithoutPayoutsInput>
    create: XOR<BettingMarketCreateWithoutPayoutsInput, BettingMarketUncheckedCreateWithoutPayoutsInput>
    where?: BettingMarketWhereInput
  }

  export type BettingMarketUpdateToOneWithWhereWithoutPayoutsInput = {
    where?: BettingMarketWhereInput
    data: XOR<BettingMarketUpdateWithoutPayoutsInput, BettingMarketUncheckedUpdateWithoutPayoutsInput>
  }

  export type BettingMarketUpdateWithoutPayoutsInput = {
    id?: StringFieldUpdateOperationsInput | string
    metricType?: EnumMarketMetricTypeFieldUpdateOperationsInput | $Enums.MarketMetricType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    currentValue?: FloatFieldUpdateOperationsInput | number
    predictionTarget?: FloatFieldUpdateOperationsInput | number
    targetDirection?: EnumPredictionDirectionFieldUpdateOperationsInput | $Enums.PredictionDirection
    odds?: FloatFieldUpdateOperationsInput | number
    totalPot?: FloatFieldUpdateOperationsInput | number
    minimumBet?: FloatFieldUpdateOperationsInput | number
    maximumBet?: NullableFloatFieldUpdateOperationsInput | number | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    settlementDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMarketStatusFieldUpdateOperationsInput | $Enums.MarketStatus
    settled?: BoolFieldUpdateOperationsInput | boolean
    settledValue?: NullableFloatFieldUpdateOperationsInput | number | null
    winningDirection?: NullableEnumPredictionDirectionFieldUpdateOperationsInput | $Enums.PredictionDirection | null
    marketMakerFee?: FloatFieldUpdateOperationsInput | number
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    card?: CardUpdateOneRequiredWithoutBettingMarketsNestedInput
    positions?: BettingPositionUpdateManyWithoutMarketNestedInput
    metrics?: MarketMetricsUpdateManyWithoutMarketNestedInput
  }

  export type BettingMarketUncheckedUpdateWithoutPayoutsInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardId?: StringFieldUpdateOperationsInput | string
    metricType?: EnumMarketMetricTypeFieldUpdateOperationsInput | $Enums.MarketMetricType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    currentValue?: FloatFieldUpdateOperationsInput | number
    predictionTarget?: FloatFieldUpdateOperationsInput | number
    targetDirection?: EnumPredictionDirectionFieldUpdateOperationsInput | $Enums.PredictionDirection
    odds?: FloatFieldUpdateOperationsInput | number
    totalPot?: FloatFieldUpdateOperationsInput | number
    minimumBet?: FloatFieldUpdateOperationsInput | number
    maximumBet?: NullableFloatFieldUpdateOperationsInput | number | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    settlementDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMarketStatusFieldUpdateOperationsInput | $Enums.MarketStatus
    settled?: BoolFieldUpdateOperationsInput | boolean
    settledValue?: NullableFloatFieldUpdateOperationsInput | number | null
    winningDirection?: NullableEnumPredictionDirectionFieldUpdateOperationsInput | $Enums.PredictionDirection | null
    marketMakerFee?: FloatFieldUpdateOperationsInput | number
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    positions?: BettingPositionUncheckedUpdateManyWithoutMarketNestedInput
    metrics?: MarketMetricsUncheckedUpdateManyWithoutMarketNestedInput
  }

  export type UserUpsertWithoutBettingPayoutsInput = {
    update: XOR<UserUpdateWithoutBettingPayoutsInput, UserUncheckedUpdateWithoutBettingPayoutsInput>
    create: XOR<UserCreateWithoutBettingPayoutsInput, UserUncheckedCreateWithoutBettingPayoutsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBettingPayoutsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBettingPayoutsInput, UserUncheckedUpdateWithoutBettingPayoutsInput>
  }

  export type UserUpdateWithoutBettingPayoutsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eceBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: UserSubscriptionUpdateOneWithoutUserNestedInput
    cryptoWallets?: CryptoWalletUpdateManyWithoutUserNestedInput
    physicalCard?: PhysicalCardUpdateOneWithoutUserNestedInput
    ownedCards?: CardUpdateManyWithoutOwnerNestedInput
    tradingHistory?: TransactionUpdateManyWithoutUserNestedInput
    bids?: BidUpdateManyWithoutBidderNestedInput
    listings?: MarketplaceListingUpdateManyWithoutSellerNestedInput
    appOrders?: AppOrderUpdateManyWithoutUserNestedInput
    orderRevisions?: OrderRevisionUpdateManyWithoutUserNestedInput
    orderCommunications?: OrderCommunicationUpdateManyWithoutUserNestedInput
    bettingPositions?: BettingPositionUpdateManyWithoutUserNestedInput
    ownedAuctions?: CardAuctionUpdateManyWithoutOwnerNestedInput
    wonAuctions?: CardAuctionUpdateManyWithoutWinnerNestedInput
    placedAuctionBids?: AuctionBidUpdateManyWithoutBidderNestedInput
    watchedAuctions?: AuctionWatcherUpdateManyWithoutUserNestedInput
    initiatedMABattles?: MABattleUpdateManyWithoutInitiatorNestedInput
    targetedMABattles?: MABattleUpdateManyWithoutTargetNestedInput
    battleProposals?: BattleProposalUpdateManyWithoutProposerNestedInput
    battleVotes?: BattleVotingUpdateManyWithoutVoterNestedInput
    stakingPositions?: StakingPositionUpdateManyWithoutUserNestedInput
    stakingRewards?: StakingRewardUpdateManyWithoutUserNestedInput
    governanceProposals?: GovernanceProposalUpdateManyWithoutProposerNestedInput
    governanceVotes?: GovernanceVoteUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    socialFeeds?: SocialFeedUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutBettingPayoutsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eceBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: UserSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    cryptoWallets?: CryptoWalletUncheckedUpdateManyWithoutUserNestedInput
    physicalCard?: PhysicalCardUncheckedUpdateOneWithoutUserNestedInput
    ownedCards?: CardUncheckedUpdateManyWithoutOwnerNestedInput
    tradingHistory?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderNestedInput
    listings?: MarketplaceListingUncheckedUpdateManyWithoutSellerNestedInput
    appOrders?: AppOrderUncheckedUpdateManyWithoutUserNestedInput
    orderRevisions?: OrderRevisionUncheckedUpdateManyWithoutUserNestedInput
    orderCommunications?: OrderCommunicationUncheckedUpdateManyWithoutUserNestedInput
    bettingPositions?: BettingPositionUncheckedUpdateManyWithoutUserNestedInput
    ownedAuctions?: CardAuctionUncheckedUpdateManyWithoutOwnerNestedInput
    wonAuctions?: CardAuctionUncheckedUpdateManyWithoutWinnerNestedInput
    placedAuctionBids?: AuctionBidUncheckedUpdateManyWithoutBidderNestedInput
    watchedAuctions?: AuctionWatcherUncheckedUpdateManyWithoutUserNestedInput
    initiatedMABattles?: MABattleUncheckedUpdateManyWithoutInitiatorNestedInput
    targetedMABattles?: MABattleUncheckedUpdateManyWithoutTargetNestedInput
    battleProposals?: BattleProposalUncheckedUpdateManyWithoutProposerNestedInput
    battleVotes?: BattleVotingUncheckedUpdateManyWithoutVoterNestedInput
    stakingPositions?: StakingPositionUncheckedUpdateManyWithoutUserNestedInput
    stakingRewards?: StakingRewardUncheckedUpdateManyWithoutUserNestedInput
    governanceProposals?: GovernanceProposalUncheckedUpdateManyWithoutProposerNestedInput
    governanceVotes?: GovernanceVoteUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    socialFeeds?: SocialFeedUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type CardCreateWithoutAuctionInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.CardCategory
    rarity: $Enums.CardRarity
    company?: string | null
    currentPrice: number
    historicalPrices?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    stats?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedCardsInput
    listing?: MarketplaceListingCreateNestedOneWithoutCardInput
    bids?: BidCreateNestedManyWithoutCardInput
    transactions?: TransactionCreateNestedManyWithoutCardInput
    bettingMarkets?: BettingMarketCreateNestedManyWithoutCardInput
    marketMetrics?: MarketMetricsCreateNestedManyWithoutCardInput
    auctionHistory?: AuctionHistoryCreateNestedManyWithoutCardInput
    initiatedBattles?: MABattleCreateNestedManyWithoutInitiatorCardInput
    targetedBattles?: MABattleCreateNestedManyWithoutTargetCardInput
  }

  export type CardUncheckedCreateWithoutAuctionInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.CardCategory
    rarity: $Enums.CardRarity
    company?: string | null
    currentPrice: number
    historicalPrices?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    stats?: NullableJsonNullValueInput | InputJsonValue
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    listing?: MarketplaceListingUncheckedCreateNestedOneWithoutCardInput
    bids?: BidUncheckedCreateNestedManyWithoutCardInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCardInput
    bettingMarkets?: BettingMarketUncheckedCreateNestedManyWithoutCardInput
    marketMetrics?: MarketMetricsUncheckedCreateNestedManyWithoutCardInput
    auctionHistory?: AuctionHistoryUncheckedCreateNestedManyWithoutCardInput
    initiatedBattles?: MABattleUncheckedCreateNestedManyWithoutInitiatorCardInput
    targetedBattles?: MABattleUncheckedCreateNestedManyWithoutTargetCardInput
  }

  export type CardCreateOrConnectWithoutAuctionInput = {
    where: CardWhereUniqueInput
    create: XOR<CardCreateWithoutAuctionInput, CardUncheckedCreateWithoutAuctionInput>
  }

  export type UserCreateWithoutOwnedAuctionsInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    passwordHash?: string | null
    emailVerified?: Date | string | null
    eceBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string
    subscription?: UserSubscriptionCreateNestedOneWithoutUserInput
    cryptoWallets?: CryptoWalletCreateNestedManyWithoutUserInput
    physicalCard?: PhysicalCardCreateNestedOneWithoutUserInput
    ownedCards?: CardCreateNestedManyWithoutOwnerInput
    tradingHistory?: TransactionCreateNestedManyWithoutUserInput
    bids?: BidCreateNestedManyWithoutBidderInput
    listings?: MarketplaceListingCreateNestedManyWithoutSellerInput
    appOrders?: AppOrderCreateNestedManyWithoutUserInput
    orderRevisions?: OrderRevisionCreateNestedManyWithoutUserInput
    orderCommunications?: OrderCommunicationCreateNestedManyWithoutUserInput
    bettingPositions?: BettingPositionCreateNestedManyWithoutUserInput
    bettingPayouts?: BettingPayoutCreateNestedManyWithoutUserInput
    wonAuctions?: CardAuctionCreateNestedManyWithoutWinnerInput
    placedAuctionBids?: AuctionBidCreateNestedManyWithoutBidderInput
    watchedAuctions?: AuctionWatcherCreateNestedManyWithoutUserInput
    initiatedMABattles?: MABattleCreateNestedManyWithoutInitiatorInput
    targetedMABattles?: MABattleCreateNestedManyWithoutTargetInput
    battleProposals?: BattleProposalCreateNestedManyWithoutProposerInput
    battleVotes?: BattleVotingCreateNestedManyWithoutVoterInput
    stakingPositions?: StakingPositionCreateNestedManyWithoutUserInput
    stakingRewards?: StakingRewardCreateNestedManyWithoutUserInput
    governanceProposals?: GovernanceProposalCreateNestedManyWithoutProposerInput
    governanceVotes?: GovernanceVoteCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    socialFeeds?: SocialFeedCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutOwnedAuctionsInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    passwordHash?: string | null
    emailVerified?: Date | string | null
    eceBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string
    subscription?: UserSubscriptionUncheckedCreateNestedOneWithoutUserInput
    cryptoWallets?: CryptoWalletUncheckedCreateNestedManyWithoutUserInput
    physicalCard?: PhysicalCardUncheckedCreateNestedOneWithoutUserInput
    ownedCards?: CardUncheckedCreateNestedManyWithoutOwnerInput
    tradingHistory?: TransactionUncheckedCreateNestedManyWithoutUserInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderInput
    listings?: MarketplaceListingUncheckedCreateNestedManyWithoutSellerInput
    appOrders?: AppOrderUncheckedCreateNestedManyWithoutUserInput
    orderRevisions?: OrderRevisionUncheckedCreateNestedManyWithoutUserInput
    orderCommunications?: OrderCommunicationUncheckedCreateNestedManyWithoutUserInput
    bettingPositions?: BettingPositionUncheckedCreateNestedManyWithoutUserInput
    bettingPayouts?: BettingPayoutUncheckedCreateNestedManyWithoutUserInput
    wonAuctions?: CardAuctionUncheckedCreateNestedManyWithoutWinnerInput
    placedAuctionBids?: AuctionBidUncheckedCreateNestedManyWithoutBidderInput
    watchedAuctions?: AuctionWatcherUncheckedCreateNestedManyWithoutUserInput
    initiatedMABattles?: MABattleUncheckedCreateNestedManyWithoutInitiatorInput
    targetedMABattles?: MABattleUncheckedCreateNestedManyWithoutTargetInput
    battleProposals?: BattleProposalUncheckedCreateNestedManyWithoutProposerInput
    battleVotes?: BattleVotingUncheckedCreateNestedManyWithoutVoterInput
    stakingPositions?: StakingPositionUncheckedCreateNestedManyWithoutUserInput
    stakingRewards?: StakingRewardUncheckedCreateNestedManyWithoutUserInput
    governanceProposals?: GovernanceProposalUncheckedCreateNestedManyWithoutProposerInput
    governanceVotes?: GovernanceVoteUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    socialFeeds?: SocialFeedUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutOwnedAuctionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOwnedAuctionsInput, UserUncheckedCreateWithoutOwnedAuctionsInput>
  }

  export type AuctionConditionsCreateWithoutAuctionInput = {
    id?: string
    proMembersOnly?: boolean
    minimumRating?: number | null
    geographicRestrictions?: AuctionConditionsCreategeographicRestrictionsInput | string[]
    minimumNetWorth?: number | null
    verificationRequired?: boolean
    minimumPortfolioValue?: number | null
    minimumCardsOwned?: number | null
    industryRestrictions?: AuctionConditionsCreateindustryRestrictionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuctionConditionsUncheckedCreateWithoutAuctionInput = {
    id?: string
    proMembersOnly?: boolean
    minimumRating?: number | null
    geographicRestrictions?: AuctionConditionsCreategeographicRestrictionsInput | string[]
    minimumNetWorth?: number | null
    verificationRequired?: boolean
    minimumPortfolioValue?: number | null
    minimumCardsOwned?: number | null
    industryRestrictions?: AuctionConditionsCreateindustryRestrictionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuctionConditionsCreateOrConnectWithoutAuctionInput = {
    where: AuctionConditionsWhereUniqueInput
    create: XOR<AuctionConditionsCreateWithoutAuctionInput, AuctionConditionsUncheckedCreateWithoutAuctionInput>
  }

  export type UserCreateWithoutWonAuctionsInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    passwordHash?: string | null
    emailVerified?: Date | string | null
    eceBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string
    subscription?: UserSubscriptionCreateNestedOneWithoutUserInput
    cryptoWallets?: CryptoWalletCreateNestedManyWithoutUserInput
    physicalCard?: PhysicalCardCreateNestedOneWithoutUserInput
    ownedCards?: CardCreateNestedManyWithoutOwnerInput
    tradingHistory?: TransactionCreateNestedManyWithoutUserInput
    bids?: BidCreateNestedManyWithoutBidderInput
    listings?: MarketplaceListingCreateNestedManyWithoutSellerInput
    appOrders?: AppOrderCreateNestedManyWithoutUserInput
    orderRevisions?: OrderRevisionCreateNestedManyWithoutUserInput
    orderCommunications?: OrderCommunicationCreateNestedManyWithoutUserInput
    bettingPositions?: BettingPositionCreateNestedManyWithoutUserInput
    bettingPayouts?: BettingPayoutCreateNestedManyWithoutUserInput
    ownedAuctions?: CardAuctionCreateNestedManyWithoutOwnerInput
    placedAuctionBids?: AuctionBidCreateNestedManyWithoutBidderInput
    watchedAuctions?: AuctionWatcherCreateNestedManyWithoutUserInput
    initiatedMABattles?: MABattleCreateNestedManyWithoutInitiatorInput
    targetedMABattles?: MABattleCreateNestedManyWithoutTargetInput
    battleProposals?: BattleProposalCreateNestedManyWithoutProposerInput
    battleVotes?: BattleVotingCreateNestedManyWithoutVoterInput
    stakingPositions?: StakingPositionCreateNestedManyWithoutUserInput
    stakingRewards?: StakingRewardCreateNestedManyWithoutUserInput
    governanceProposals?: GovernanceProposalCreateNestedManyWithoutProposerInput
    governanceVotes?: GovernanceVoteCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    socialFeeds?: SocialFeedCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutWonAuctionsInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    passwordHash?: string | null
    emailVerified?: Date | string | null
    eceBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string
    subscription?: UserSubscriptionUncheckedCreateNestedOneWithoutUserInput
    cryptoWallets?: CryptoWalletUncheckedCreateNestedManyWithoutUserInput
    physicalCard?: PhysicalCardUncheckedCreateNestedOneWithoutUserInput
    ownedCards?: CardUncheckedCreateNestedManyWithoutOwnerInput
    tradingHistory?: TransactionUncheckedCreateNestedManyWithoutUserInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderInput
    listings?: MarketplaceListingUncheckedCreateNestedManyWithoutSellerInput
    appOrders?: AppOrderUncheckedCreateNestedManyWithoutUserInput
    orderRevisions?: OrderRevisionUncheckedCreateNestedManyWithoutUserInput
    orderCommunications?: OrderCommunicationUncheckedCreateNestedManyWithoutUserInput
    bettingPositions?: BettingPositionUncheckedCreateNestedManyWithoutUserInput
    bettingPayouts?: BettingPayoutUncheckedCreateNestedManyWithoutUserInput
    ownedAuctions?: CardAuctionUncheckedCreateNestedManyWithoutOwnerInput
    placedAuctionBids?: AuctionBidUncheckedCreateNestedManyWithoutBidderInput
    watchedAuctions?: AuctionWatcherUncheckedCreateNestedManyWithoutUserInput
    initiatedMABattles?: MABattleUncheckedCreateNestedManyWithoutInitiatorInput
    targetedMABattles?: MABattleUncheckedCreateNestedManyWithoutTargetInput
    battleProposals?: BattleProposalUncheckedCreateNestedManyWithoutProposerInput
    battleVotes?: BattleVotingUncheckedCreateNestedManyWithoutVoterInput
    stakingPositions?: StakingPositionUncheckedCreateNestedManyWithoutUserInput
    stakingRewards?: StakingRewardUncheckedCreateNestedManyWithoutUserInput
    governanceProposals?: GovernanceProposalUncheckedCreateNestedManyWithoutProposerInput
    governanceVotes?: GovernanceVoteUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    socialFeeds?: SocialFeedUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutWonAuctionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWonAuctionsInput, UserUncheckedCreateWithoutWonAuctionsInput>
  }

  export type AuctionBidCreateWithoutAuctionInput = {
    id?: string
    bidAmount: number
    maxAutoBid?: number | null
    bidType?: $Enums.BidType
    status?: $Enums.AuctionBidStatus
    isWinning?: boolean
    outbidNotified?: boolean
    userAgent?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bidder: UserCreateNestedOneWithoutPlacedAuctionBidsInput
  }

  export type AuctionBidUncheckedCreateWithoutAuctionInput = {
    id?: string
    bidderId: string
    bidAmount: number
    maxAutoBid?: number | null
    bidType?: $Enums.BidType
    status?: $Enums.AuctionBidStatus
    isWinning?: boolean
    outbidNotified?: boolean
    userAgent?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuctionBidCreateOrConnectWithoutAuctionInput = {
    where: AuctionBidWhereUniqueInput
    create: XOR<AuctionBidCreateWithoutAuctionInput, AuctionBidUncheckedCreateWithoutAuctionInput>
  }

  export type AuctionBidCreateManyAuctionInputEnvelope = {
    data: AuctionBidCreateManyAuctionInput | AuctionBidCreateManyAuctionInput[]
    skipDuplicates?: boolean
  }

  export type AuctionWatcherCreateWithoutAuctionInput = {
    id?: string
    bidNotifications?: boolean
    endingNotifications?: boolean
    priceAlerts?: boolean
    alertThreshold?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutWatchedAuctionsInput
  }

  export type AuctionWatcherUncheckedCreateWithoutAuctionInput = {
    id?: string
    userId: string
    bidNotifications?: boolean
    endingNotifications?: boolean
    priceAlerts?: boolean
    alertThreshold?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuctionWatcherCreateOrConnectWithoutAuctionInput = {
    where: AuctionWatcherWhereUniqueInput
    create: XOR<AuctionWatcherCreateWithoutAuctionInput, AuctionWatcherUncheckedCreateWithoutAuctionInput>
  }

  export type AuctionWatcherCreateManyAuctionInputEnvelope = {
    data: AuctionWatcherCreateManyAuctionInput | AuctionWatcherCreateManyAuctionInput[]
    skipDuplicates?: boolean
  }

  export type AuctionHistoryCreateWithoutAuctionInput = {
    id?: string
    salePrice: number
    sellerId: string
    buyerId: string
    saleType: $Enums.SaleType
    marketTrends?: NullableJsonNullValueInput | InputJsonValue
    priceHistory?: NullableJsonNullValueInput | InputJsonValue
    daysSinceListing?: number | null
    numberOfBids?: number | null
    highestBid?: number | null
    saleDate?: Date | string
    createdAt?: Date | string
    card: CardCreateNestedOneWithoutAuctionHistoryInput
  }

  export type AuctionHistoryUncheckedCreateWithoutAuctionInput = {
    id?: string
    cardId: string
    salePrice: number
    sellerId: string
    buyerId: string
    saleType: $Enums.SaleType
    marketTrends?: NullableJsonNullValueInput | InputJsonValue
    priceHistory?: NullableJsonNullValueInput | InputJsonValue
    daysSinceListing?: number | null
    numberOfBids?: number | null
    highestBid?: number | null
    saleDate?: Date | string
    createdAt?: Date | string
  }

  export type AuctionHistoryCreateOrConnectWithoutAuctionInput = {
    where: AuctionHistoryWhereUniqueInput
    create: XOR<AuctionHistoryCreateWithoutAuctionInput, AuctionHistoryUncheckedCreateWithoutAuctionInput>
  }

  export type AuctionHistoryCreateManyAuctionInputEnvelope = {
    data: AuctionHistoryCreateManyAuctionInput | AuctionHistoryCreateManyAuctionInput[]
    skipDuplicates?: boolean
  }

  export type CardUpsertWithoutAuctionInput = {
    update: XOR<CardUpdateWithoutAuctionInput, CardUncheckedUpdateWithoutAuctionInput>
    create: XOR<CardCreateWithoutAuctionInput, CardUncheckedCreateWithoutAuctionInput>
    where?: CardWhereInput
  }

  export type CardUpdateToOneWithWhereWithoutAuctionInput = {
    where?: CardWhereInput
    data: XOR<CardUpdateWithoutAuctionInput, CardUncheckedUpdateWithoutAuctionInput>
  }

  export type CardUpdateWithoutAuctionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCardCategoryFieldUpdateOperationsInput | $Enums.CardCategory
    rarity?: EnumCardRarityFieldUpdateOperationsInput | $Enums.CardRarity
    company?: NullableStringFieldUpdateOperationsInput | string | null
    currentPrice?: FloatFieldUpdateOperationsInput | number
    historicalPrices?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    stats?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedCardsNestedInput
    listing?: MarketplaceListingUpdateOneWithoutCardNestedInput
    bids?: BidUpdateManyWithoutCardNestedInput
    transactions?: TransactionUpdateManyWithoutCardNestedInput
    bettingMarkets?: BettingMarketUpdateManyWithoutCardNestedInput
    marketMetrics?: MarketMetricsUpdateManyWithoutCardNestedInput
    auctionHistory?: AuctionHistoryUpdateManyWithoutCardNestedInput
    initiatedBattles?: MABattleUpdateManyWithoutInitiatorCardNestedInput
    targetedBattles?: MABattleUpdateManyWithoutTargetCardNestedInput
  }

  export type CardUncheckedUpdateWithoutAuctionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCardCategoryFieldUpdateOperationsInput | $Enums.CardCategory
    rarity?: EnumCardRarityFieldUpdateOperationsInput | $Enums.CardRarity
    company?: NullableStringFieldUpdateOperationsInput | string | null
    currentPrice?: FloatFieldUpdateOperationsInput | number
    historicalPrices?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    stats?: NullableJsonNullValueInput | InputJsonValue
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listing?: MarketplaceListingUncheckedUpdateOneWithoutCardNestedInput
    bids?: BidUncheckedUpdateManyWithoutCardNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCardNestedInput
    bettingMarkets?: BettingMarketUncheckedUpdateManyWithoutCardNestedInput
    marketMetrics?: MarketMetricsUncheckedUpdateManyWithoutCardNestedInput
    auctionHistory?: AuctionHistoryUncheckedUpdateManyWithoutCardNestedInput
    initiatedBattles?: MABattleUncheckedUpdateManyWithoutInitiatorCardNestedInput
    targetedBattles?: MABattleUncheckedUpdateManyWithoutTargetCardNestedInput
  }

  export type UserUpsertWithoutOwnedAuctionsInput = {
    update: XOR<UserUpdateWithoutOwnedAuctionsInput, UserUncheckedUpdateWithoutOwnedAuctionsInput>
    create: XOR<UserCreateWithoutOwnedAuctionsInput, UserUncheckedCreateWithoutOwnedAuctionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOwnedAuctionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOwnedAuctionsInput, UserUncheckedUpdateWithoutOwnedAuctionsInput>
  }

  export type UserUpdateWithoutOwnedAuctionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eceBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: UserSubscriptionUpdateOneWithoutUserNestedInput
    cryptoWallets?: CryptoWalletUpdateManyWithoutUserNestedInput
    physicalCard?: PhysicalCardUpdateOneWithoutUserNestedInput
    ownedCards?: CardUpdateManyWithoutOwnerNestedInput
    tradingHistory?: TransactionUpdateManyWithoutUserNestedInput
    bids?: BidUpdateManyWithoutBidderNestedInput
    listings?: MarketplaceListingUpdateManyWithoutSellerNestedInput
    appOrders?: AppOrderUpdateManyWithoutUserNestedInput
    orderRevisions?: OrderRevisionUpdateManyWithoutUserNestedInput
    orderCommunications?: OrderCommunicationUpdateManyWithoutUserNestedInput
    bettingPositions?: BettingPositionUpdateManyWithoutUserNestedInput
    bettingPayouts?: BettingPayoutUpdateManyWithoutUserNestedInput
    wonAuctions?: CardAuctionUpdateManyWithoutWinnerNestedInput
    placedAuctionBids?: AuctionBidUpdateManyWithoutBidderNestedInput
    watchedAuctions?: AuctionWatcherUpdateManyWithoutUserNestedInput
    initiatedMABattles?: MABattleUpdateManyWithoutInitiatorNestedInput
    targetedMABattles?: MABattleUpdateManyWithoutTargetNestedInput
    battleProposals?: BattleProposalUpdateManyWithoutProposerNestedInput
    battleVotes?: BattleVotingUpdateManyWithoutVoterNestedInput
    stakingPositions?: StakingPositionUpdateManyWithoutUserNestedInput
    stakingRewards?: StakingRewardUpdateManyWithoutUserNestedInput
    governanceProposals?: GovernanceProposalUpdateManyWithoutProposerNestedInput
    governanceVotes?: GovernanceVoteUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    socialFeeds?: SocialFeedUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutOwnedAuctionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eceBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: UserSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    cryptoWallets?: CryptoWalletUncheckedUpdateManyWithoutUserNestedInput
    physicalCard?: PhysicalCardUncheckedUpdateOneWithoutUserNestedInput
    ownedCards?: CardUncheckedUpdateManyWithoutOwnerNestedInput
    tradingHistory?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderNestedInput
    listings?: MarketplaceListingUncheckedUpdateManyWithoutSellerNestedInput
    appOrders?: AppOrderUncheckedUpdateManyWithoutUserNestedInput
    orderRevisions?: OrderRevisionUncheckedUpdateManyWithoutUserNestedInput
    orderCommunications?: OrderCommunicationUncheckedUpdateManyWithoutUserNestedInput
    bettingPositions?: BettingPositionUncheckedUpdateManyWithoutUserNestedInput
    bettingPayouts?: BettingPayoutUncheckedUpdateManyWithoutUserNestedInput
    wonAuctions?: CardAuctionUncheckedUpdateManyWithoutWinnerNestedInput
    placedAuctionBids?: AuctionBidUncheckedUpdateManyWithoutBidderNestedInput
    watchedAuctions?: AuctionWatcherUncheckedUpdateManyWithoutUserNestedInput
    initiatedMABattles?: MABattleUncheckedUpdateManyWithoutInitiatorNestedInput
    targetedMABattles?: MABattleUncheckedUpdateManyWithoutTargetNestedInput
    battleProposals?: BattleProposalUncheckedUpdateManyWithoutProposerNestedInput
    battleVotes?: BattleVotingUncheckedUpdateManyWithoutVoterNestedInput
    stakingPositions?: StakingPositionUncheckedUpdateManyWithoutUserNestedInput
    stakingRewards?: StakingRewardUncheckedUpdateManyWithoutUserNestedInput
    governanceProposals?: GovernanceProposalUncheckedUpdateManyWithoutProposerNestedInput
    governanceVotes?: GovernanceVoteUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    socialFeeds?: SocialFeedUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type AuctionConditionsUpsertWithoutAuctionInput = {
    update: XOR<AuctionConditionsUpdateWithoutAuctionInput, AuctionConditionsUncheckedUpdateWithoutAuctionInput>
    create: XOR<AuctionConditionsCreateWithoutAuctionInput, AuctionConditionsUncheckedCreateWithoutAuctionInput>
    where?: AuctionConditionsWhereInput
  }

  export type AuctionConditionsUpdateToOneWithWhereWithoutAuctionInput = {
    where?: AuctionConditionsWhereInput
    data: XOR<AuctionConditionsUpdateWithoutAuctionInput, AuctionConditionsUncheckedUpdateWithoutAuctionInput>
  }

  export type AuctionConditionsUpdateWithoutAuctionInput = {
    id?: StringFieldUpdateOperationsInput | string
    proMembersOnly?: BoolFieldUpdateOperationsInput | boolean
    minimumRating?: NullableFloatFieldUpdateOperationsInput | number | null
    geographicRestrictions?: AuctionConditionsUpdategeographicRestrictionsInput | string[]
    minimumNetWorth?: NullableFloatFieldUpdateOperationsInput | number | null
    verificationRequired?: BoolFieldUpdateOperationsInput | boolean
    minimumPortfolioValue?: NullableFloatFieldUpdateOperationsInput | number | null
    minimumCardsOwned?: NullableIntFieldUpdateOperationsInput | number | null
    industryRestrictions?: AuctionConditionsUpdateindustryRestrictionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuctionConditionsUncheckedUpdateWithoutAuctionInput = {
    id?: StringFieldUpdateOperationsInput | string
    proMembersOnly?: BoolFieldUpdateOperationsInput | boolean
    minimumRating?: NullableFloatFieldUpdateOperationsInput | number | null
    geographicRestrictions?: AuctionConditionsUpdategeographicRestrictionsInput | string[]
    minimumNetWorth?: NullableFloatFieldUpdateOperationsInput | number | null
    verificationRequired?: BoolFieldUpdateOperationsInput | boolean
    minimumPortfolioValue?: NullableFloatFieldUpdateOperationsInput | number | null
    minimumCardsOwned?: NullableIntFieldUpdateOperationsInput | number | null
    industryRestrictions?: AuctionConditionsUpdateindustryRestrictionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutWonAuctionsInput = {
    update: XOR<UserUpdateWithoutWonAuctionsInput, UserUncheckedUpdateWithoutWonAuctionsInput>
    create: XOR<UserCreateWithoutWonAuctionsInput, UserUncheckedCreateWithoutWonAuctionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWonAuctionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWonAuctionsInput, UserUncheckedUpdateWithoutWonAuctionsInput>
  }

  export type UserUpdateWithoutWonAuctionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eceBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: UserSubscriptionUpdateOneWithoutUserNestedInput
    cryptoWallets?: CryptoWalletUpdateManyWithoutUserNestedInput
    physicalCard?: PhysicalCardUpdateOneWithoutUserNestedInput
    ownedCards?: CardUpdateManyWithoutOwnerNestedInput
    tradingHistory?: TransactionUpdateManyWithoutUserNestedInput
    bids?: BidUpdateManyWithoutBidderNestedInput
    listings?: MarketplaceListingUpdateManyWithoutSellerNestedInput
    appOrders?: AppOrderUpdateManyWithoutUserNestedInput
    orderRevisions?: OrderRevisionUpdateManyWithoutUserNestedInput
    orderCommunications?: OrderCommunicationUpdateManyWithoutUserNestedInput
    bettingPositions?: BettingPositionUpdateManyWithoutUserNestedInput
    bettingPayouts?: BettingPayoutUpdateManyWithoutUserNestedInput
    ownedAuctions?: CardAuctionUpdateManyWithoutOwnerNestedInput
    placedAuctionBids?: AuctionBidUpdateManyWithoutBidderNestedInput
    watchedAuctions?: AuctionWatcherUpdateManyWithoutUserNestedInput
    initiatedMABattles?: MABattleUpdateManyWithoutInitiatorNestedInput
    targetedMABattles?: MABattleUpdateManyWithoutTargetNestedInput
    battleProposals?: BattleProposalUpdateManyWithoutProposerNestedInput
    battleVotes?: BattleVotingUpdateManyWithoutVoterNestedInput
    stakingPositions?: StakingPositionUpdateManyWithoutUserNestedInput
    stakingRewards?: StakingRewardUpdateManyWithoutUserNestedInput
    governanceProposals?: GovernanceProposalUpdateManyWithoutProposerNestedInput
    governanceVotes?: GovernanceVoteUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    socialFeeds?: SocialFeedUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutWonAuctionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eceBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: UserSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    cryptoWallets?: CryptoWalletUncheckedUpdateManyWithoutUserNestedInput
    physicalCard?: PhysicalCardUncheckedUpdateOneWithoutUserNestedInput
    ownedCards?: CardUncheckedUpdateManyWithoutOwnerNestedInput
    tradingHistory?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderNestedInput
    listings?: MarketplaceListingUncheckedUpdateManyWithoutSellerNestedInput
    appOrders?: AppOrderUncheckedUpdateManyWithoutUserNestedInput
    orderRevisions?: OrderRevisionUncheckedUpdateManyWithoutUserNestedInput
    orderCommunications?: OrderCommunicationUncheckedUpdateManyWithoutUserNestedInput
    bettingPositions?: BettingPositionUncheckedUpdateManyWithoutUserNestedInput
    bettingPayouts?: BettingPayoutUncheckedUpdateManyWithoutUserNestedInput
    ownedAuctions?: CardAuctionUncheckedUpdateManyWithoutOwnerNestedInput
    placedAuctionBids?: AuctionBidUncheckedUpdateManyWithoutBidderNestedInput
    watchedAuctions?: AuctionWatcherUncheckedUpdateManyWithoutUserNestedInput
    initiatedMABattles?: MABattleUncheckedUpdateManyWithoutInitiatorNestedInput
    targetedMABattles?: MABattleUncheckedUpdateManyWithoutTargetNestedInput
    battleProposals?: BattleProposalUncheckedUpdateManyWithoutProposerNestedInput
    battleVotes?: BattleVotingUncheckedUpdateManyWithoutVoterNestedInput
    stakingPositions?: StakingPositionUncheckedUpdateManyWithoutUserNestedInput
    stakingRewards?: StakingRewardUncheckedUpdateManyWithoutUserNestedInput
    governanceProposals?: GovernanceProposalUncheckedUpdateManyWithoutProposerNestedInput
    governanceVotes?: GovernanceVoteUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    socialFeeds?: SocialFeedUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type AuctionBidUpsertWithWhereUniqueWithoutAuctionInput = {
    where: AuctionBidWhereUniqueInput
    update: XOR<AuctionBidUpdateWithoutAuctionInput, AuctionBidUncheckedUpdateWithoutAuctionInput>
    create: XOR<AuctionBidCreateWithoutAuctionInput, AuctionBidUncheckedCreateWithoutAuctionInput>
  }

  export type AuctionBidUpdateWithWhereUniqueWithoutAuctionInput = {
    where: AuctionBidWhereUniqueInput
    data: XOR<AuctionBidUpdateWithoutAuctionInput, AuctionBidUncheckedUpdateWithoutAuctionInput>
  }

  export type AuctionBidUpdateManyWithWhereWithoutAuctionInput = {
    where: AuctionBidScalarWhereInput
    data: XOR<AuctionBidUpdateManyMutationInput, AuctionBidUncheckedUpdateManyWithoutAuctionInput>
  }

  export type AuctionWatcherUpsertWithWhereUniqueWithoutAuctionInput = {
    where: AuctionWatcherWhereUniqueInput
    update: XOR<AuctionWatcherUpdateWithoutAuctionInput, AuctionWatcherUncheckedUpdateWithoutAuctionInput>
    create: XOR<AuctionWatcherCreateWithoutAuctionInput, AuctionWatcherUncheckedCreateWithoutAuctionInput>
  }

  export type AuctionWatcherUpdateWithWhereUniqueWithoutAuctionInput = {
    where: AuctionWatcherWhereUniqueInput
    data: XOR<AuctionWatcherUpdateWithoutAuctionInput, AuctionWatcherUncheckedUpdateWithoutAuctionInput>
  }

  export type AuctionWatcherUpdateManyWithWhereWithoutAuctionInput = {
    where: AuctionWatcherScalarWhereInput
    data: XOR<AuctionWatcherUpdateManyMutationInput, AuctionWatcherUncheckedUpdateManyWithoutAuctionInput>
  }

  export type AuctionHistoryUpsertWithWhereUniqueWithoutAuctionInput = {
    where: AuctionHistoryWhereUniqueInput
    update: XOR<AuctionHistoryUpdateWithoutAuctionInput, AuctionHistoryUncheckedUpdateWithoutAuctionInput>
    create: XOR<AuctionHistoryCreateWithoutAuctionInput, AuctionHistoryUncheckedCreateWithoutAuctionInput>
  }

  export type AuctionHistoryUpdateWithWhereUniqueWithoutAuctionInput = {
    where: AuctionHistoryWhereUniqueInput
    data: XOR<AuctionHistoryUpdateWithoutAuctionInput, AuctionHistoryUncheckedUpdateWithoutAuctionInput>
  }

  export type AuctionHistoryUpdateManyWithWhereWithoutAuctionInput = {
    where: AuctionHistoryScalarWhereInput
    data: XOR<AuctionHistoryUpdateManyMutationInput, AuctionHistoryUncheckedUpdateManyWithoutAuctionInput>
  }

  export type CardAuctionCreateWithoutConditionsInput = {
    id?: string
    title: string
    description?: string | null
    startPrice: number
    reservePrice?: number | null
    currentBid?: number | null
    bidIncrement?: number
    startTime?: Date | string
    endTime: Date | string
    autoExtend?: boolean
    status?: $Enums.AuctionStatus
    finalized?: boolean
    viewCount?: number
    watcherCount?: number
    bidCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    card: CardCreateNestedOneWithoutAuctionInput
    owner: UserCreateNestedOneWithoutOwnedAuctionsInput
    winner?: UserCreateNestedOneWithoutWonAuctionsInput
    bids?: AuctionBidCreateNestedManyWithoutAuctionInput
    watchers?: AuctionWatcherCreateNestedManyWithoutAuctionInput
    history?: AuctionHistoryCreateNestedManyWithoutAuctionInput
  }

  export type CardAuctionUncheckedCreateWithoutConditionsInput = {
    id?: string
    cardId: string
    ownerId: string
    title: string
    description?: string | null
    startPrice: number
    reservePrice?: number | null
    currentBid?: number | null
    bidIncrement?: number
    startTime?: Date | string
    endTime: Date | string
    autoExtend?: boolean
    status?: $Enums.AuctionStatus
    finalized?: boolean
    winnerId?: string | null
    viewCount?: number
    watcherCount?: number
    bidCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bids?: AuctionBidUncheckedCreateNestedManyWithoutAuctionInput
    watchers?: AuctionWatcherUncheckedCreateNestedManyWithoutAuctionInput
    history?: AuctionHistoryUncheckedCreateNestedManyWithoutAuctionInput
  }

  export type CardAuctionCreateOrConnectWithoutConditionsInput = {
    where: CardAuctionWhereUniqueInput
    create: XOR<CardAuctionCreateWithoutConditionsInput, CardAuctionUncheckedCreateWithoutConditionsInput>
  }

  export type CardAuctionUpsertWithoutConditionsInput = {
    update: XOR<CardAuctionUpdateWithoutConditionsInput, CardAuctionUncheckedUpdateWithoutConditionsInput>
    create: XOR<CardAuctionCreateWithoutConditionsInput, CardAuctionUncheckedCreateWithoutConditionsInput>
    where?: CardAuctionWhereInput
  }

  export type CardAuctionUpdateToOneWithWhereWithoutConditionsInput = {
    where?: CardAuctionWhereInput
    data: XOR<CardAuctionUpdateWithoutConditionsInput, CardAuctionUncheckedUpdateWithoutConditionsInput>
  }

  export type CardAuctionUpdateWithoutConditionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startPrice?: FloatFieldUpdateOperationsInput | number
    reservePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currentBid?: NullableFloatFieldUpdateOperationsInput | number | null
    bidIncrement?: FloatFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    autoExtend?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAuctionStatusFieldUpdateOperationsInput | $Enums.AuctionStatus
    finalized?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    watcherCount?: IntFieldUpdateOperationsInput | number
    bidCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    card?: CardUpdateOneRequiredWithoutAuctionNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedAuctionsNestedInput
    winner?: UserUpdateOneWithoutWonAuctionsNestedInput
    bids?: AuctionBidUpdateManyWithoutAuctionNestedInput
    watchers?: AuctionWatcherUpdateManyWithoutAuctionNestedInput
    history?: AuctionHistoryUpdateManyWithoutAuctionNestedInput
  }

  export type CardAuctionUncheckedUpdateWithoutConditionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startPrice?: FloatFieldUpdateOperationsInput | number
    reservePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currentBid?: NullableFloatFieldUpdateOperationsInput | number | null
    bidIncrement?: FloatFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    autoExtend?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAuctionStatusFieldUpdateOperationsInput | $Enums.AuctionStatus
    finalized?: BoolFieldUpdateOperationsInput | boolean
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    watcherCount?: IntFieldUpdateOperationsInput | number
    bidCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bids?: AuctionBidUncheckedUpdateManyWithoutAuctionNestedInput
    watchers?: AuctionWatcherUncheckedUpdateManyWithoutAuctionNestedInput
    history?: AuctionHistoryUncheckedUpdateManyWithoutAuctionNestedInput
  }

  export type CardAuctionCreateWithoutBidsInput = {
    id?: string
    title: string
    description?: string | null
    startPrice: number
    reservePrice?: number | null
    currentBid?: number | null
    bidIncrement?: number
    startTime?: Date | string
    endTime: Date | string
    autoExtend?: boolean
    status?: $Enums.AuctionStatus
    finalized?: boolean
    viewCount?: number
    watcherCount?: number
    bidCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    card: CardCreateNestedOneWithoutAuctionInput
    owner: UserCreateNestedOneWithoutOwnedAuctionsInput
    conditions?: AuctionConditionsCreateNestedOneWithoutAuctionInput
    winner?: UserCreateNestedOneWithoutWonAuctionsInput
    watchers?: AuctionWatcherCreateNestedManyWithoutAuctionInput
    history?: AuctionHistoryCreateNestedManyWithoutAuctionInput
  }

  export type CardAuctionUncheckedCreateWithoutBidsInput = {
    id?: string
    cardId: string
    ownerId: string
    title: string
    description?: string | null
    startPrice: number
    reservePrice?: number | null
    currentBid?: number | null
    bidIncrement?: number
    startTime?: Date | string
    endTime: Date | string
    autoExtend?: boolean
    status?: $Enums.AuctionStatus
    finalized?: boolean
    winnerId?: string | null
    viewCount?: number
    watcherCount?: number
    bidCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    conditions?: AuctionConditionsUncheckedCreateNestedOneWithoutAuctionInput
    watchers?: AuctionWatcherUncheckedCreateNestedManyWithoutAuctionInput
    history?: AuctionHistoryUncheckedCreateNestedManyWithoutAuctionInput
  }

  export type CardAuctionCreateOrConnectWithoutBidsInput = {
    where: CardAuctionWhereUniqueInput
    create: XOR<CardAuctionCreateWithoutBidsInput, CardAuctionUncheckedCreateWithoutBidsInput>
  }

  export type UserCreateWithoutPlacedAuctionBidsInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    passwordHash?: string | null
    emailVerified?: Date | string | null
    eceBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string
    subscription?: UserSubscriptionCreateNestedOneWithoutUserInput
    cryptoWallets?: CryptoWalletCreateNestedManyWithoutUserInput
    physicalCard?: PhysicalCardCreateNestedOneWithoutUserInput
    ownedCards?: CardCreateNestedManyWithoutOwnerInput
    tradingHistory?: TransactionCreateNestedManyWithoutUserInput
    bids?: BidCreateNestedManyWithoutBidderInput
    listings?: MarketplaceListingCreateNestedManyWithoutSellerInput
    appOrders?: AppOrderCreateNestedManyWithoutUserInput
    orderRevisions?: OrderRevisionCreateNestedManyWithoutUserInput
    orderCommunications?: OrderCommunicationCreateNestedManyWithoutUserInput
    bettingPositions?: BettingPositionCreateNestedManyWithoutUserInput
    bettingPayouts?: BettingPayoutCreateNestedManyWithoutUserInput
    ownedAuctions?: CardAuctionCreateNestedManyWithoutOwnerInput
    wonAuctions?: CardAuctionCreateNestedManyWithoutWinnerInput
    watchedAuctions?: AuctionWatcherCreateNestedManyWithoutUserInput
    initiatedMABattles?: MABattleCreateNestedManyWithoutInitiatorInput
    targetedMABattles?: MABattleCreateNestedManyWithoutTargetInput
    battleProposals?: BattleProposalCreateNestedManyWithoutProposerInput
    battleVotes?: BattleVotingCreateNestedManyWithoutVoterInput
    stakingPositions?: StakingPositionCreateNestedManyWithoutUserInput
    stakingRewards?: StakingRewardCreateNestedManyWithoutUserInput
    governanceProposals?: GovernanceProposalCreateNestedManyWithoutProposerInput
    governanceVotes?: GovernanceVoteCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    socialFeeds?: SocialFeedCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutPlacedAuctionBidsInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    passwordHash?: string | null
    emailVerified?: Date | string | null
    eceBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string
    subscription?: UserSubscriptionUncheckedCreateNestedOneWithoutUserInput
    cryptoWallets?: CryptoWalletUncheckedCreateNestedManyWithoutUserInput
    physicalCard?: PhysicalCardUncheckedCreateNestedOneWithoutUserInput
    ownedCards?: CardUncheckedCreateNestedManyWithoutOwnerInput
    tradingHistory?: TransactionUncheckedCreateNestedManyWithoutUserInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderInput
    listings?: MarketplaceListingUncheckedCreateNestedManyWithoutSellerInput
    appOrders?: AppOrderUncheckedCreateNestedManyWithoutUserInput
    orderRevisions?: OrderRevisionUncheckedCreateNestedManyWithoutUserInput
    orderCommunications?: OrderCommunicationUncheckedCreateNestedManyWithoutUserInput
    bettingPositions?: BettingPositionUncheckedCreateNestedManyWithoutUserInput
    bettingPayouts?: BettingPayoutUncheckedCreateNestedManyWithoutUserInput
    ownedAuctions?: CardAuctionUncheckedCreateNestedManyWithoutOwnerInput
    wonAuctions?: CardAuctionUncheckedCreateNestedManyWithoutWinnerInput
    watchedAuctions?: AuctionWatcherUncheckedCreateNestedManyWithoutUserInput
    initiatedMABattles?: MABattleUncheckedCreateNestedManyWithoutInitiatorInput
    targetedMABattles?: MABattleUncheckedCreateNestedManyWithoutTargetInput
    battleProposals?: BattleProposalUncheckedCreateNestedManyWithoutProposerInput
    battleVotes?: BattleVotingUncheckedCreateNestedManyWithoutVoterInput
    stakingPositions?: StakingPositionUncheckedCreateNestedManyWithoutUserInput
    stakingRewards?: StakingRewardUncheckedCreateNestedManyWithoutUserInput
    governanceProposals?: GovernanceProposalUncheckedCreateNestedManyWithoutProposerInput
    governanceVotes?: GovernanceVoteUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    socialFeeds?: SocialFeedUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutPlacedAuctionBidsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPlacedAuctionBidsInput, UserUncheckedCreateWithoutPlacedAuctionBidsInput>
  }

  export type CardAuctionUpsertWithoutBidsInput = {
    update: XOR<CardAuctionUpdateWithoutBidsInput, CardAuctionUncheckedUpdateWithoutBidsInput>
    create: XOR<CardAuctionCreateWithoutBidsInput, CardAuctionUncheckedCreateWithoutBidsInput>
    where?: CardAuctionWhereInput
  }

  export type CardAuctionUpdateToOneWithWhereWithoutBidsInput = {
    where?: CardAuctionWhereInput
    data: XOR<CardAuctionUpdateWithoutBidsInput, CardAuctionUncheckedUpdateWithoutBidsInput>
  }

  export type CardAuctionUpdateWithoutBidsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startPrice?: FloatFieldUpdateOperationsInput | number
    reservePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currentBid?: NullableFloatFieldUpdateOperationsInput | number | null
    bidIncrement?: FloatFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    autoExtend?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAuctionStatusFieldUpdateOperationsInput | $Enums.AuctionStatus
    finalized?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    watcherCount?: IntFieldUpdateOperationsInput | number
    bidCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    card?: CardUpdateOneRequiredWithoutAuctionNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedAuctionsNestedInput
    conditions?: AuctionConditionsUpdateOneWithoutAuctionNestedInput
    winner?: UserUpdateOneWithoutWonAuctionsNestedInput
    watchers?: AuctionWatcherUpdateManyWithoutAuctionNestedInput
    history?: AuctionHistoryUpdateManyWithoutAuctionNestedInput
  }

  export type CardAuctionUncheckedUpdateWithoutBidsInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startPrice?: FloatFieldUpdateOperationsInput | number
    reservePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currentBid?: NullableFloatFieldUpdateOperationsInput | number | null
    bidIncrement?: FloatFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    autoExtend?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAuctionStatusFieldUpdateOperationsInput | $Enums.AuctionStatus
    finalized?: BoolFieldUpdateOperationsInput | boolean
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    watcherCount?: IntFieldUpdateOperationsInput | number
    bidCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conditions?: AuctionConditionsUncheckedUpdateOneWithoutAuctionNestedInput
    watchers?: AuctionWatcherUncheckedUpdateManyWithoutAuctionNestedInput
    history?: AuctionHistoryUncheckedUpdateManyWithoutAuctionNestedInput
  }

  export type UserUpsertWithoutPlacedAuctionBidsInput = {
    update: XOR<UserUpdateWithoutPlacedAuctionBidsInput, UserUncheckedUpdateWithoutPlacedAuctionBidsInput>
    create: XOR<UserCreateWithoutPlacedAuctionBidsInput, UserUncheckedCreateWithoutPlacedAuctionBidsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPlacedAuctionBidsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPlacedAuctionBidsInput, UserUncheckedUpdateWithoutPlacedAuctionBidsInput>
  }

  export type UserUpdateWithoutPlacedAuctionBidsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eceBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: UserSubscriptionUpdateOneWithoutUserNestedInput
    cryptoWallets?: CryptoWalletUpdateManyWithoutUserNestedInput
    physicalCard?: PhysicalCardUpdateOneWithoutUserNestedInput
    ownedCards?: CardUpdateManyWithoutOwnerNestedInput
    tradingHistory?: TransactionUpdateManyWithoutUserNestedInput
    bids?: BidUpdateManyWithoutBidderNestedInput
    listings?: MarketplaceListingUpdateManyWithoutSellerNestedInput
    appOrders?: AppOrderUpdateManyWithoutUserNestedInput
    orderRevisions?: OrderRevisionUpdateManyWithoutUserNestedInput
    orderCommunications?: OrderCommunicationUpdateManyWithoutUserNestedInput
    bettingPositions?: BettingPositionUpdateManyWithoutUserNestedInput
    bettingPayouts?: BettingPayoutUpdateManyWithoutUserNestedInput
    ownedAuctions?: CardAuctionUpdateManyWithoutOwnerNestedInput
    wonAuctions?: CardAuctionUpdateManyWithoutWinnerNestedInput
    watchedAuctions?: AuctionWatcherUpdateManyWithoutUserNestedInput
    initiatedMABattles?: MABattleUpdateManyWithoutInitiatorNestedInput
    targetedMABattles?: MABattleUpdateManyWithoutTargetNestedInput
    battleProposals?: BattleProposalUpdateManyWithoutProposerNestedInput
    battleVotes?: BattleVotingUpdateManyWithoutVoterNestedInput
    stakingPositions?: StakingPositionUpdateManyWithoutUserNestedInput
    stakingRewards?: StakingRewardUpdateManyWithoutUserNestedInput
    governanceProposals?: GovernanceProposalUpdateManyWithoutProposerNestedInput
    governanceVotes?: GovernanceVoteUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    socialFeeds?: SocialFeedUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutPlacedAuctionBidsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eceBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: UserSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    cryptoWallets?: CryptoWalletUncheckedUpdateManyWithoutUserNestedInput
    physicalCard?: PhysicalCardUncheckedUpdateOneWithoutUserNestedInput
    ownedCards?: CardUncheckedUpdateManyWithoutOwnerNestedInput
    tradingHistory?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderNestedInput
    listings?: MarketplaceListingUncheckedUpdateManyWithoutSellerNestedInput
    appOrders?: AppOrderUncheckedUpdateManyWithoutUserNestedInput
    orderRevisions?: OrderRevisionUncheckedUpdateManyWithoutUserNestedInput
    orderCommunications?: OrderCommunicationUncheckedUpdateManyWithoutUserNestedInput
    bettingPositions?: BettingPositionUncheckedUpdateManyWithoutUserNestedInput
    bettingPayouts?: BettingPayoutUncheckedUpdateManyWithoutUserNestedInput
    ownedAuctions?: CardAuctionUncheckedUpdateManyWithoutOwnerNestedInput
    wonAuctions?: CardAuctionUncheckedUpdateManyWithoutWinnerNestedInput
    watchedAuctions?: AuctionWatcherUncheckedUpdateManyWithoutUserNestedInput
    initiatedMABattles?: MABattleUncheckedUpdateManyWithoutInitiatorNestedInput
    targetedMABattles?: MABattleUncheckedUpdateManyWithoutTargetNestedInput
    battleProposals?: BattleProposalUncheckedUpdateManyWithoutProposerNestedInput
    battleVotes?: BattleVotingUncheckedUpdateManyWithoutVoterNestedInput
    stakingPositions?: StakingPositionUncheckedUpdateManyWithoutUserNestedInput
    stakingRewards?: StakingRewardUncheckedUpdateManyWithoutUserNestedInput
    governanceProposals?: GovernanceProposalUncheckedUpdateManyWithoutProposerNestedInput
    governanceVotes?: GovernanceVoteUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    socialFeeds?: SocialFeedUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type CardAuctionCreateWithoutWatchersInput = {
    id?: string
    title: string
    description?: string | null
    startPrice: number
    reservePrice?: number | null
    currentBid?: number | null
    bidIncrement?: number
    startTime?: Date | string
    endTime: Date | string
    autoExtend?: boolean
    status?: $Enums.AuctionStatus
    finalized?: boolean
    viewCount?: number
    watcherCount?: number
    bidCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    card: CardCreateNestedOneWithoutAuctionInput
    owner: UserCreateNestedOneWithoutOwnedAuctionsInput
    conditions?: AuctionConditionsCreateNestedOneWithoutAuctionInput
    winner?: UserCreateNestedOneWithoutWonAuctionsInput
    bids?: AuctionBidCreateNestedManyWithoutAuctionInput
    history?: AuctionHistoryCreateNestedManyWithoutAuctionInput
  }

  export type CardAuctionUncheckedCreateWithoutWatchersInput = {
    id?: string
    cardId: string
    ownerId: string
    title: string
    description?: string | null
    startPrice: number
    reservePrice?: number | null
    currentBid?: number | null
    bidIncrement?: number
    startTime?: Date | string
    endTime: Date | string
    autoExtend?: boolean
    status?: $Enums.AuctionStatus
    finalized?: boolean
    winnerId?: string | null
    viewCount?: number
    watcherCount?: number
    bidCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    conditions?: AuctionConditionsUncheckedCreateNestedOneWithoutAuctionInput
    bids?: AuctionBidUncheckedCreateNestedManyWithoutAuctionInput
    history?: AuctionHistoryUncheckedCreateNestedManyWithoutAuctionInput
  }

  export type CardAuctionCreateOrConnectWithoutWatchersInput = {
    where: CardAuctionWhereUniqueInput
    create: XOR<CardAuctionCreateWithoutWatchersInput, CardAuctionUncheckedCreateWithoutWatchersInput>
  }

  export type UserCreateWithoutWatchedAuctionsInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    passwordHash?: string | null
    emailVerified?: Date | string | null
    eceBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string
    subscription?: UserSubscriptionCreateNestedOneWithoutUserInput
    cryptoWallets?: CryptoWalletCreateNestedManyWithoutUserInput
    physicalCard?: PhysicalCardCreateNestedOneWithoutUserInput
    ownedCards?: CardCreateNestedManyWithoutOwnerInput
    tradingHistory?: TransactionCreateNestedManyWithoutUserInput
    bids?: BidCreateNestedManyWithoutBidderInput
    listings?: MarketplaceListingCreateNestedManyWithoutSellerInput
    appOrders?: AppOrderCreateNestedManyWithoutUserInput
    orderRevisions?: OrderRevisionCreateNestedManyWithoutUserInput
    orderCommunications?: OrderCommunicationCreateNestedManyWithoutUserInput
    bettingPositions?: BettingPositionCreateNestedManyWithoutUserInput
    bettingPayouts?: BettingPayoutCreateNestedManyWithoutUserInput
    ownedAuctions?: CardAuctionCreateNestedManyWithoutOwnerInput
    wonAuctions?: CardAuctionCreateNestedManyWithoutWinnerInput
    placedAuctionBids?: AuctionBidCreateNestedManyWithoutBidderInput
    initiatedMABattles?: MABattleCreateNestedManyWithoutInitiatorInput
    targetedMABattles?: MABattleCreateNestedManyWithoutTargetInput
    battleProposals?: BattleProposalCreateNestedManyWithoutProposerInput
    battleVotes?: BattleVotingCreateNestedManyWithoutVoterInput
    stakingPositions?: StakingPositionCreateNestedManyWithoutUserInput
    stakingRewards?: StakingRewardCreateNestedManyWithoutUserInput
    governanceProposals?: GovernanceProposalCreateNestedManyWithoutProposerInput
    governanceVotes?: GovernanceVoteCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    socialFeeds?: SocialFeedCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutWatchedAuctionsInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    passwordHash?: string | null
    emailVerified?: Date | string | null
    eceBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string
    subscription?: UserSubscriptionUncheckedCreateNestedOneWithoutUserInput
    cryptoWallets?: CryptoWalletUncheckedCreateNestedManyWithoutUserInput
    physicalCard?: PhysicalCardUncheckedCreateNestedOneWithoutUserInput
    ownedCards?: CardUncheckedCreateNestedManyWithoutOwnerInput
    tradingHistory?: TransactionUncheckedCreateNestedManyWithoutUserInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderInput
    listings?: MarketplaceListingUncheckedCreateNestedManyWithoutSellerInput
    appOrders?: AppOrderUncheckedCreateNestedManyWithoutUserInput
    orderRevisions?: OrderRevisionUncheckedCreateNestedManyWithoutUserInput
    orderCommunications?: OrderCommunicationUncheckedCreateNestedManyWithoutUserInput
    bettingPositions?: BettingPositionUncheckedCreateNestedManyWithoutUserInput
    bettingPayouts?: BettingPayoutUncheckedCreateNestedManyWithoutUserInput
    ownedAuctions?: CardAuctionUncheckedCreateNestedManyWithoutOwnerInput
    wonAuctions?: CardAuctionUncheckedCreateNestedManyWithoutWinnerInput
    placedAuctionBids?: AuctionBidUncheckedCreateNestedManyWithoutBidderInput
    initiatedMABattles?: MABattleUncheckedCreateNestedManyWithoutInitiatorInput
    targetedMABattles?: MABattleUncheckedCreateNestedManyWithoutTargetInput
    battleProposals?: BattleProposalUncheckedCreateNestedManyWithoutProposerInput
    battleVotes?: BattleVotingUncheckedCreateNestedManyWithoutVoterInput
    stakingPositions?: StakingPositionUncheckedCreateNestedManyWithoutUserInput
    stakingRewards?: StakingRewardUncheckedCreateNestedManyWithoutUserInput
    governanceProposals?: GovernanceProposalUncheckedCreateNestedManyWithoutProposerInput
    governanceVotes?: GovernanceVoteUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    socialFeeds?: SocialFeedUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutWatchedAuctionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWatchedAuctionsInput, UserUncheckedCreateWithoutWatchedAuctionsInput>
  }

  export type CardAuctionUpsertWithoutWatchersInput = {
    update: XOR<CardAuctionUpdateWithoutWatchersInput, CardAuctionUncheckedUpdateWithoutWatchersInput>
    create: XOR<CardAuctionCreateWithoutWatchersInput, CardAuctionUncheckedCreateWithoutWatchersInput>
    where?: CardAuctionWhereInput
  }

  export type CardAuctionUpdateToOneWithWhereWithoutWatchersInput = {
    where?: CardAuctionWhereInput
    data: XOR<CardAuctionUpdateWithoutWatchersInput, CardAuctionUncheckedUpdateWithoutWatchersInput>
  }

  export type CardAuctionUpdateWithoutWatchersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startPrice?: FloatFieldUpdateOperationsInput | number
    reservePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currentBid?: NullableFloatFieldUpdateOperationsInput | number | null
    bidIncrement?: FloatFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    autoExtend?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAuctionStatusFieldUpdateOperationsInput | $Enums.AuctionStatus
    finalized?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    watcherCount?: IntFieldUpdateOperationsInput | number
    bidCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    card?: CardUpdateOneRequiredWithoutAuctionNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedAuctionsNestedInput
    conditions?: AuctionConditionsUpdateOneWithoutAuctionNestedInput
    winner?: UserUpdateOneWithoutWonAuctionsNestedInput
    bids?: AuctionBidUpdateManyWithoutAuctionNestedInput
    history?: AuctionHistoryUpdateManyWithoutAuctionNestedInput
  }

  export type CardAuctionUncheckedUpdateWithoutWatchersInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startPrice?: FloatFieldUpdateOperationsInput | number
    reservePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currentBid?: NullableFloatFieldUpdateOperationsInput | number | null
    bidIncrement?: FloatFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    autoExtend?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAuctionStatusFieldUpdateOperationsInput | $Enums.AuctionStatus
    finalized?: BoolFieldUpdateOperationsInput | boolean
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    watcherCount?: IntFieldUpdateOperationsInput | number
    bidCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conditions?: AuctionConditionsUncheckedUpdateOneWithoutAuctionNestedInput
    bids?: AuctionBidUncheckedUpdateManyWithoutAuctionNestedInput
    history?: AuctionHistoryUncheckedUpdateManyWithoutAuctionNestedInput
  }

  export type UserUpsertWithoutWatchedAuctionsInput = {
    update: XOR<UserUpdateWithoutWatchedAuctionsInput, UserUncheckedUpdateWithoutWatchedAuctionsInput>
    create: XOR<UserCreateWithoutWatchedAuctionsInput, UserUncheckedCreateWithoutWatchedAuctionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWatchedAuctionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWatchedAuctionsInput, UserUncheckedUpdateWithoutWatchedAuctionsInput>
  }

  export type UserUpdateWithoutWatchedAuctionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eceBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: UserSubscriptionUpdateOneWithoutUserNestedInput
    cryptoWallets?: CryptoWalletUpdateManyWithoutUserNestedInput
    physicalCard?: PhysicalCardUpdateOneWithoutUserNestedInput
    ownedCards?: CardUpdateManyWithoutOwnerNestedInput
    tradingHistory?: TransactionUpdateManyWithoutUserNestedInput
    bids?: BidUpdateManyWithoutBidderNestedInput
    listings?: MarketplaceListingUpdateManyWithoutSellerNestedInput
    appOrders?: AppOrderUpdateManyWithoutUserNestedInput
    orderRevisions?: OrderRevisionUpdateManyWithoutUserNestedInput
    orderCommunications?: OrderCommunicationUpdateManyWithoutUserNestedInput
    bettingPositions?: BettingPositionUpdateManyWithoutUserNestedInput
    bettingPayouts?: BettingPayoutUpdateManyWithoutUserNestedInput
    ownedAuctions?: CardAuctionUpdateManyWithoutOwnerNestedInput
    wonAuctions?: CardAuctionUpdateManyWithoutWinnerNestedInput
    placedAuctionBids?: AuctionBidUpdateManyWithoutBidderNestedInput
    initiatedMABattles?: MABattleUpdateManyWithoutInitiatorNestedInput
    targetedMABattles?: MABattleUpdateManyWithoutTargetNestedInput
    battleProposals?: BattleProposalUpdateManyWithoutProposerNestedInput
    battleVotes?: BattleVotingUpdateManyWithoutVoterNestedInput
    stakingPositions?: StakingPositionUpdateManyWithoutUserNestedInput
    stakingRewards?: StakingRewardUpdateManyWithoutUserNestedInput
    governanceProposals?: GovernanceProposalUpdateManyWithoutProposerNestedInput
    governanceVotes?: GovernanceVoteUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    socialFeeds?: SocialFeedUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutWatchedAuctionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eceBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: UserSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    cryptoWallets?: CryptoWalletUncheckedUpdateManyWithoutUserNestedInput
    physicalCard?: PhysicalCardUncheckedUpdateOneWithoutUserNestedInput
    ownedCards?: CardUncheckedUpdateManyWithoutOwnerNestedInput
    tradingHistory?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderNestedInput
    listings?: MarketplaceListingUncheckedUpdateManyWithoutSellerNestedInput
    appOrders?: AppOrderUncheckedUpdateManyWithoutUserNestedInput
    orderRevisions?: OrderRevisionUncheckedUpdateManyWithoutUserNestedInput
    orderCommunications?: OrderCommunicationUncheckedUpdateManyWithoutUserNestedInput
    bettingPositions?: BettingPositionUncheckedUpdateManyWithoutUserNestedInput
    bettingPayouts?: BettingPayoutUncheckedUpdateManyWithoutUserNestedInput
    ownedAuctions?: CardAuctionUncheckedUpdateManyWithoutOwnerNestedInput
    wonAuctions?: CardAuctionUncheckedUpdateManyWithoutWinnerNestedInput
    placedAuctionBids?: AuctionBidUncheckedUpdateManyWithoutBidderNestedInput
    initiatedMABattles?: MABattleUncheckedUpdateManyWithoutInitiatorNestedInput
    targetedMABattles?: MABattleUncheckedUpdateManyWithoutTargetNestedInput
    battleProposals?: BattleProposalUncheckedUpdateManyWithoutProposerNestedInput
    battleVotes?: BattleVotingUncheckedUpdateManyWithoutVoterNestedInput
    stakingPositions?: StakingPositionUncheckedUpdateManyWithoutUserNestedInput
    stakingRewards?: StakingRewardUncheckedUpdateManyWithoutUserNestedInput
    governanceProposals?: GovernanceProposalUncheckedUpdateManyWithoutProposerNestedInput
    governanceVotes?: GovernanceVoteUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    socialFeeds?: SocialFeedUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type CardCreateWithoutAuctionHistoryInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.CardCategory
    rarity: $Enums.CardRarity
    company?: string | null
    currentPrice: number
    historicalPrices?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    stats?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedCardsInput
    listing?: MarketplaceListingCreateNestedOneWithoutCardInput
    bids?: BidCreateNestedManyWithoutCardInput
    transactions?: TransactionCreateNestedManyWithoutCardInput
    bettingMarkets?: BettingMarketCreateNestedManyWithoutCardInput
    marketMetrics?: MarketMetricsCreateNestedManyWithoutCardInput
    auction?: CardAuctionCreateNestedOneWithoutCardInput
    initiatedBattles?: MABattleCreateNestedManyWithoutInitiatorCardInput
    targetedBattles?: MABattleCreateNestedManyWithoutTargetCardInput
  }

  export type CardUncheckedCreateWithoutAuctionHistoryInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.CardCategory
    rarity: $Enums.CardRarity
    company?: string | null
    currentPrice: number
    historicalPrices?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    stats?: NullableJsonNullValueInput | InputJsonValue
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    listing?: MarketplaceListingUncheckedCreateNestedOneWithoutCardInput
    bids?: BidUncheckedCreateNestedManyWithoutCardInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCardInput
    bettingMarkets?: BettingMarketUncheckedCreateNestedManyWithoutCardInput
    marketMetrics?: MarketMetricsUncheckedCreateNestedManyWithoutCardInput
    auction?: CardAuctionUncheckedCreateNestedOneWithoutCardInput
    initiatedBattles?: MABattleUncheckedCreateNestedManyWithoutInitiatorCardInput
    targetedBattles?: MABattleUncheckedCreateNestedManyWithoutTargetCardInput
  }

  export type CardCreateOrConnectWithoutAuctionHistoryInput = {
    where: CardWhereUniqueInput
    create: XOR<CardCreateWithoutAuctionHistoryInput, CardUncheckedCreateWithoutAuctionHistoryInput>
  }

  export type CardAuctionCreateWithoutHistoryInput = {
    id?: string
    title: string
    description?: string | null
    startPrice: number
    reservePrice?: number | null
    currentBid?: number | null
    bidIncrement?: number
    startTime?: Date | string
    endTime: Date | string
    autoExtend?: boolean
    status?: $Enums.AuctionStatus
    finalized?: boolean
    viewCount?: number
    watcherCount?: number
    bidCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    card: CardCreateNestedOneWithoutAuctionInput
    owner: UserCreateNestedOneWithoutOwnedAuctionsInput
    conditions?: AuctionConditionsCreateNestedOneWithoutAuctionInput
    winner?: UserCreateNestedOneWithoutWonAuctionsInput
    bids?: AuctionBidCreateNestedManyWithoutAuctionInput
    watchers?: AuctionWatcherCreateNestedManyWithoutAuctionInput
  }

  export type CardAuctionUncheckedCreateWithoutHistoryInput = {
    id?: string
    cardId: string
    ownerId: string
    title: string
    description?: string | null
    startPrice: number
    reservePrice?: number | null
    currentBid?: number | null
    bidIncrement?: number
    startTime?: Date | string
    endTime: Date | string
    autoExtend?: boolean
    status?: $Enums.AuctionStatus
    finalized?: boolean
    winnerId?: string | null
    viewCount?: number
    watcherCount?: number
    bidCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    conditions?: AuctionConditionsUncheckedCreateNestedOneWithoutAuctionInput
    bids?: AuctionBidUncheckedCreateNestedManyWithoutAuctionInput
    watchers?: AuctionWatcherUncheckedCreateNestedManyWithoutAuctionInput
  }

  export type CardAuctionCreateOrConnectWithoutHistoryInput = {
    where: CardAuctionWhereUniqueInput
    create: XOR<CardAuctionCreateWithoutHistoryInput, CardAuctionUncheckedCreateWithoutHistoryInput>
  }

  export type CardUpsertWithoutAuctionHistoryInput = {
    update: XOR<CardUpdateWithoutAuctionHistoryInput, CardUncheckedUpdateWithoutAuctionHistoryInput>
    create: XOR<CardCreateWithoutAuctionHistoryInput, CardUncheckedCreateWithoutAuctionHistoryInput>
    where?: CardWhereInput
  }

  export type CardUpdateToOneWithWhereWithoutAuctionHistoryInput = {
    where?: CardWhereInput
    data: XOR<CardUpdateWithoutAuctionHistoryInput, CardUncheckedUpdateWithoutAuctionHistoryInput>
  }

  export type CardUpdateWithoutAuctionHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCardCategoryFieldUpdateOperationsInput | $Enums.CardCategory
    rarity?: EnumCardRarityFieldUpdateOperationsInput | $Enums.CardRarity
    company?: NullableStringFieldUpdateOperationsInput | string | null
    currentPrice?: FloatFieldUpdateOperationsInput | number
    historicalPrices?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    stats?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedCardsNestedInput
    listing?: MarketplaceListingUpdateOneWithoutCardNestedInput
    bids?: BidUpdateManyWithoutCardNestedInput
    transactions?: TransactionUpdateManyWithoutCardNestedInput
    bettingMarkets?: BettingMarketUpdateManyWithoutCardNestedInput
    marketMetrics?: MarketMetricsUpdateManyWithoutCardNestedInput
    auction?: CardAuctionUpdateOneWithoutCardNestedInput
    initiatedBattles?: MABattleUpdateManyWithoutInitiatorCardNestedInput
    targetedBattles?: MABattleUpdateManyWithoutTargetCardNestedInput
  }

  export type CardUncheckedUpdateWithoutAuctionHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCardCategoryFieldUpdateOperationsInput | $Enums.CardCategory
    rarity?: EnumCardRarityFieldUpdateOperationsInput | $Enums.CardRarity
    company?: NullableStringFieldUpdateOperationsInput | string | null
    currentPrice?: FloatFieldUpdateOperationsInput | number
    historicalPrices?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    stats?: NullableJsonNullValueInput | InputJsonValue
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listing?: MarketplaceListingUncheckedUpdateOneWithoutCardNestedInput
    bids?: BidUncheckedUpdateManyWithoutCardNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCardNestedInput
    bettingMarkets?: BettingMarketUncheckedUpdateManyWithoutCardNestedInput
    marketMetrics?: MarketMetricsUncheckedUpdateManyWithoutCardNestedInput
    auction?: CardAuctionUncheckedUpdateOneWithoutCardNestedInput
    initiatedBattles?: MABattleUncheckedUpdateManyWithoutInitiatorCardNestedInput
    targetedBattles?: MABattleUncheckedUpdateManyWithoutTargetCardNestedInput
  }

  export type CardAuctionUpsertWithoutHistoryInput = {
    update: XOR<CardAuctionUpdateWithoutHistoryInput, CardAuctionUncheckedUpdateWithoutHistoryInput>
    create: XOR<CardAuctionCreateWithoutHistoryInput, CardAuctionUncheckedCreateWithoutHistoryInput>
    where?: CardAuctionWhereInput
  }

  export type CardAuctionUpdateToOneWithWhereWithoutHistoryInput = {
    where?: CardAuctionWhereInput
    data: XOR<CardAuctionUpdateWithoutHistoryInput, CardAuctionUncheckedUpdateWithoutHistoryInput>
  }

  export type CardAuctionUpdateWithoutHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startPrice?: FloatFieldUpdateOperationsInput | number
    reservePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currentBid?: NullableFloatFieldUpdateOperationsInput | number | null
    bidIncrement?: FloatFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    autoExtend?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAuctionStatusFieldUpdateOperationsInput | $Enums.AuctionStatus
    finalized?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    watcherCount?: IntFieldUpdateOperationsInput | number
    bidCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    card?: CardUpdateOneRequiredWithoutAuctionNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedAuctionsNestedInput
    conditions?: AuctionConditionsUpdateOneWithoutAuctionNestedInput
    winner?: UserUpdateOneWithoutWonAuctionsNestedInput
    bids?: AuctionBidUpdateManyWithoutAuctionNestedInput
    watchers?: AuctionWatcherUpdateManyWithoutAuctionNestedInput
  }

  export type CardAuctionUncheckedUpdateWithoutHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startPrice?: FloatFieldUpdateOperationsInput | number
    reservePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currentBid?: NullableFloatFieldUpdateOperationsInput | number | null
    bidIncrement?: FloatFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    autoExtend?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAuctionStatusFieldUpdateOperationsInput | $Enums.AuctionStatus
    finalized?: BoolFieldUpdateOperationsInput | boolean
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    watcherCount?: IntFieldUpdateOperationsInput | number
    bidCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conditions?: AuctionConditionsUncheckedUpdateOneWithoutAuctionNestedInput
    bids?: AuctionBidUncheckedUpdateManyWithoutAuctionNestedInput
    watchers?: AuctionWatcherUncheckedUpdateManyWithoutAuctionNestedInput
  }

  export type CardCreateWithoutInitiatedBattlesInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.CardCategory
    rarity: $Enums.CardRarity
    company?: string | null
    currentPrice: number
    historicalPrices?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    stats?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedCardsInput
    listing?: MarketplaceListingCreateNestedOneWithoutCardInput
    bids?: BidCreateNestedManyWithoutCardInput
    transactions?: TransactionCreateNestedManyWithoutCardInput
    bettingMarkets?: BettingMarketCreateNestedManyWithoutCardInput
    marketMetrics?: MarketMetricsCreateNestedManyWithoutCardInput
    auction?: CardAuctionCreateNestedOneWithoutCardInput
    auctionHistory?: AuctionHistoryCreateNestedManyWithoutCardInput
    targetedBattles?: MABattleCreateNestedManyWithoutTargetCardInput
  }

  export type CardUncheckedCreateWithoutInitiatedBattlesInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.CardCategory
    rarity: $Enums.CardRarity
    company?: string | null
    currentPrice: number
    historicalPrices?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    stats?: NullableJsonNullValueInput | InputJsonValue
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    listing?: MarketplaceListingUncheckedCreateNestedOneWithoutCardInput
    bids?: BidUncheckedCreateNestedManyWithoutCardInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCardInput
    bettingMarkets?: BettingMarketUncheckedCreateNestedManyWithoutCardInput
    marketMetrics?: MarketMetricsUncheckedCreateNestedManyWithoutCardInput
    auction?: CardAuctionUncheckedCreateNestedOneWithoutCardInput
    auctionHistory?: AuctionHistoryUncheckedCreateNestedManyWithoutCardInput
    targetedBattles?: MABattleUncheckedCreateNestedManyWithoutTargetCardInput
  }

  export type CardCreateOrConnectWithoutInitiatedBattlesInput = {
    where: CardWhereUniqueInput
    create: XOR<CardCreateWithoutInitiatedBattlesInput, CardUncheckedCreateWithoutInitiatedBattlesInput>
  }

  export type CardCreateWithoutTargetedBattlesInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.CardCategory
    rarity: $Enums.CardRarity
    company?: string | null
    currentPrice: number
    historicalPrices?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    stats?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedCardsInput
    listing?: MarketplaceListingCreateNestedOneWithoutCardInput
    bids?: BidCreateNestedManyWithoutCardInput
    transactions?: TransactionCreateNestedManyWithoutCardInput
    bettingMarkets?: BettingMarketCreateNestedManyWithoutCardInput
    marketMetrics?: MarketMetricsCreateNestedManyWithoutCardInput
    auction?: CardAuctionCreateNestedOneWithoutCardInput
    auctionHistory?: AuctionHistoryCreateNestedManyWithoutCardInput
    initiatedBattles?: MABattleCreateNestedManyWithoutInitiatorCardInput
  }

  export type CardUncheckedCreateWithoutTargetedBattlesInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.CardCategory
    rarity: $Enums.CardRarity
    company?: string | null
    currentPrice: number
    historicalPrices?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    stats?: NullableJsonNullValueInput | InputJsonValue
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    listing?: MarketplaceListingUncheckedCreateNestedOneWithoutCardInput
    bids?: BidUncheckedCreateNestedManyWithoutCardInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCardInput
    bettingMarkets?: BettingMarketUncheckedCreateNestedManyWithoutCardInput
    marketMetrics?: MarketMetricsUncheckedCreateNestedManyWithoutCardInput
    auction?: CardAuctionUncheckedCreateNestedOneWithoutCardInput
    auctionHistory?: AuctionHistoryUncheckedCreateNestedManyWithoutCardInput
    initiatedBattles?: MABattleUncheckedCreateNestedManyWithoutInitiatorCardInput
  }

  export type CardCreateOrConnectWithoutTargetedBattlesInput = {
    where: CardWhereUniqueInput
    create: XOR<CardCreateWithoutTargetedBattlesInput, CardUncheckedCreateWithoutTargetedBattlesInput>
  }

  export type UserCreateWithoutInitiatedMABattlesInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    passwordHash?: string | null
    emailVerified?: Date | string | null
    eceBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string
    subscription?: UserSubscriptionCreateNestedOneWithoutUserInput
    cryptoWallets?: CryptoWalletCreateNestedManyWithoutUserInput
    physicalCard?: PhysicalCardCreateNestedOneWithoutUserInput
    ownedCards?: CardCreateNestedManyWithoutOwnerInput
    tradingHistory?: TransactionCreateNestedManyWithoutUserInput
    bids?: BidCreateNestedManyWithoutBidderInput
    listings?: MarketplaceListingCreateNestedManyWithoutSellerInput
    appOrders?: AppOrderCreateNestedManyWithoutUserInput
    orderRevisions?: OrderRevisionCreateNestedManyWithoutUserInput
    orderCommunications?: OrderCommunicationCreateNestedManyWithoutUserInput
    bettingPositions?: BettingPositionCreateNestedManyWithoutUserInput
    bettingPayouts?: BettingPayoutCreateNestedManyWithoutUserInput
    ownedAuctions?: CardAuctionCreateNestedManyWithoutOwnerInput
    wonAuctions?: CardAuctionCreateNestedManyWithoutWinnerInput
    placedAuctionBids?: AuctionBidCreateNestedManyWithoutBidderInput
    watchedAuctions?: AuctionWatcherCreateNestedManyWithoutUserInput
    targetedMABattles?: MABattleCreateNestedManyWithoutTargetInput
    battleProposals?: BattleProposalCreateNestedManyWithoutProposerInput
    battleVotes?: BattleVotingCreateNestedManyWithoutVoterInput
    stakingPositions?: StakingPositionCreateNestedManyWithoutUserInput
    stakingRewards?: StakingRewardCreateNestedManyWithoutUserInput
    governanceProposals?: GovernanceProposalCreateNestedManyWithoutProposerInput
    governanceVotes?: GovernanceVoteCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    socialFeeds?: SocialFeedCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutInitiatedMABattlesInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    passwordHash?: string | null
    emailVerified?: Date | string | null
    eceBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string
    subscription?: UserSubscriptionUncheckedCreateNestedOneWithoutUserInput
    cryptoWallets?: CryptoWalletUncheckedCreateNestedManyWithoutUserInput
    physicalCard?: PhysicalCardUncheckedCreateNestedOneWithoutUserInput
    ownedCards?: CardUncheckedCreateNestedManyWithoutOwnerInput
    tradingHistory?: TransactionUncheckedCreateNestedManyWithoutUserInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderInput
    listings?: MarketplaceListingUncheckedCreateNestedManyWithoutSellerInput
    appOrders?: AppOrderUncheckedCreateNestedManyWithoutUserInput
    orderRevisions?: OrderRevisionUncheckedCreateNestedManyWithoutUserInput
    orderCommunications?: OrderCommunicationUncheckedCreateNestedManyWithoutUserInput
    bettingPositions?: BettingPositionUncheckedCreateNestedManyWithoutUserInput
    bettingPayouts?: BettingPayoutUncheckedCreateNestedManyWithoutUserInput
    ownedAuctions?: CardAuctionUncheckedCreateNestedManyWithoutOwnerInput
    wonAuctions?: CardAuctionUncheckedCreateNestedManyWithoutWinnerInput
    placedAuctionBids?: AuctionBidUncheckedCreateNestedManyWithoutBidderInput
    watchedAuctions?: AuctionWatcherUncheckedCreateNestedManyWithoutUserInput
    targetedMABattles?: MABattleUncheckedCreateNestedManyWithoutTargetInput
    battleProposals?: BattleProposalUncheckedCreateNestedManyWithoutProposerInput
    battleVotes?: BattleVotingUncheckedCreateNestedManyWithoutVoterInput
    stakingPositions?: StakingPositionUncheckedCreateNestedManyWithoutUserInput
    stakingRewards?: StakingRewardUncheckedCreateNestedManyWithoutUserInput
    governanceProposals?: GovernanceProposalUncheckedCreateNestedManyWithoutProposerInput
    governanceVotes?: GovernanceVoteUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    socialFeeds?: SocialFeedUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutInitiatedMABattlesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInitiatedMABattlesInput, UserUncheckedCreateWithoutInitiatedMABattlesInput>
  }

  export type UserCreateWithoutTargetedMABattlesInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    passwordHash?: string | null
    emailVerified?: Date | string | null
    eceBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string
    subscription?: UserSubscriptionCreateNestedOneWithoutUserInput
    cryptoWallets?: CryptoWalletCreateNestedManyWithoutUserInput
    physicalCard?: PhysicalCardCreateNestedOneWithoutUserInput
    ownedCards?: CardCreateNestedManyWithoutOwnerInput
    tradingHistory?: TransactionCreateNestedManyWithoutUserInput
    bids?: BidCreateNestedManyWithoutBidderInput
    listings?: MarketplaceListingCreateNestedManyWithoutSellerInput
    appOrders?: AppOrderCreateNestedManyWithoutUserInput
    orderRevisions?: OrderRevisionCreateNestedManyWithoutUserInput
    orderCommunications?: OrderCommunicationCreateNestedManyWithoutUserInput
    bettingPositions?: BettingPositionCreateNestedManyWithoutUserInput
    bettingPayouts?: BettingPayoutCreateNestedManyWithoutUserInput
    ownedAuctions?: CardAuctionCreateNestedManyWithoutOwnerInput
    wonAuctions?: CardAuctionCreateNestedManyWithoutWinnerInput
    placedAuctionBids?: AuctionBidCreateNestedManyWithoutBidderInput
    watchedAuctions?: AuctionWatcherCreateNestedManyWithoutUserInput
    initiatedMABattles?: MABattleCreateNestedManyWithoutInitiatorInput
    battleProposals?: BattleProposalCreateNestedManyWithoutProposerInput
    battleVotes?: BattleVotingCreateNestedManyWithoutVoterInput
    stakingPositions?: StakingPositionCreateNestedManyWithoutUserInput
    stakingRewards?: StakingRewardCreateNestedManyWithoutUserInput
    governanceProposals?: GovernanceProposalCreateNestedManyWithoutProposerInput
    governanceVotes?: GovernanceVoteCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    socialFeeds?: SocialFeedCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutTargetedMABattlesInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    passwordHash?: string | null
    emailVerified?: Date | string | null
    eceBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string
    subscription?: UserSubscriptionUncheckedCreateNestedOneWithoutUserInput
    cryptoWallets?: CryptoWalletUncheckedCreateNestedManyWithoutUserInput
    physicalCard?: PhysicalCardUncheckedCreateNestedOneWithoutUserInput
    ownedCards?: CardUncheckedCreateNestedManyWithoutOwnerInput
    tradingHistory?: TransactionUncheckedCreateNestedManyWithoutUserInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderInput
    listings?: MarketplaceListingUncheckedCreateNestedManyWithoutSellerInput
    appOrders?: AppOrderUncheckedCreateNestedManyWithoutUserInput
    orderRevisions?: OrderRevisionUncheckedCreateNestedManyWithoutUserInput
    orderCommunications?: OrderCommunicationUncheckedCreateNestedManyWithoutUserInput
    bettingPositions?: BettingPositionUncheckedCreateNestedManyWithoutUserInput
    bettingPayouts?: BettingPayoutUncheckedCreateNestedManyWithoutUserInput
    ownedAuctions?: CardAuctionUncheckedCreateNestedManyWithoutOwnerInput
    wonAuctions?: CardAuctionUncheckedCreateNestedManyWithoutWinnerInput
    placedAuctionBids?: AuctionBidUncheckedCreateNestedManyWithoutBidderInput
    watchedAuctions?: AuctionWatcherUncheckedCreateNestedManyWithoutUserInput
    initiatedMABattles?: MABattleUncheckedCreateNestedManyWithoutInitiatorInput
    battleProposals?: BattleProposalUncheckedCreateNestedManyWithoutProposerInput
    battleVotes?: BattleVotingUncheckedCreateNestedManyWithoutVoterInput
    stakingPositions?: StakingPositionUncheckedCreateNestedManyWithoutUserInput
    stakingRewards?: StakingRewardUncheckedCreateNestedManyWithoutUserInput
    governanceProposals?: GovernanceProposalUncheckedCreateNestedManyWithoutProposerInput
    governanceVotes?: GovernanceVoteUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    socialFeeds?: SocialFeedUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutTargetedMABattlesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTargetedMABattlesInput, UserUncheckedCreateWithoutTargetedMABattlesInput>
  }

  export type BattleOutcomeCreateWithoutWinningBattleInput = {
    id?: string
    winner: $Enums.BattleWinner
    winningProposalId?: string | null
    finalTerms: JsonNullValueInput | InputJsonValue
    finalValuation: number
    implementation: JsonNullValueInput | InputJsonValue
    stakeholdersPayouts: JsonNullValueInput | InputJsonValue
    tokenRewards: JsonNullValueInput | InputJsonValue
    completionDate?: Date | string | null
    realWorldImpact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    battle: MABattleCreateNestedOneWithoutOutcomesInput
  }

  export type BattleOutcomeUncheckedCreateWithoutWinningBattleInput = {
    id?: string
    battleId: string
    winner: $Enums.BattleWinner
    winningProposalId?: string | null
    finalTerms: JsonNullValueInput | InputJsonValue
    finalValuation: number
    implementation: JsonNullValueInput | InputJsonValue
    stakeholdersPayouts: JsonNullValueInput | InputJsonValue
    tokenRewards: JsonNullValueInput | InputJsonValue
    completionDate?: Date | string | null
    realWorldImpact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BattleOutcomeCreateOrConnectWithoutWinningBattleInput = {
    where: BattleOutcomeWhereUniqueInput
    create: XOR<BattleOutcomeCreateWithoutWinningBattleInput, BattleOutcomeUncheckedCreateWithoutWinningBattleInput>
  }

  export type BattleProposalCreateWithoutBattleInput = {
    id?: string
    proposalType: $Enums.ProposalType
    title: string
    description: string
    terms: JsonNullValueInput | InputJsonValue
    valuation: number
    paymentStructure: JsonNullValueInput | InputJsonValue
    timeline: JsonNullValueInput | InputJsonValue
    synergies: JsonNullValueInput | InputJsonValue
    conditions: JsonNullValueInput | InputJsonValue
    contingencies: JsonNullValueInput | InputJsonValue
    status?: $Enums.ProposalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    proposer: UserCreateNestedOneWithoutBattleProposalsInput
    votes?: BattleVotingCreateNestedManyWithoutProposalInput
  }

  export type BattleProposalUncheckedCreateWithoutBattleInput = {
    id?: string
    proposerId: string
    proposalType: $Enums.ProposalType
    title: string
    description: string
    terms: JsonNullValueInput | InputJsonValue
    valuation: number
    paymentStructure: JsonNullValueInput | InputJsonValue
    timeline: JsonNullValueInput | InputJsonValue
    synergies: JsonNullValueInput | InputJsonValue
    conditions: JsonNullValueInput | InputJsonValue
    contingencies: JsonNullValueInput | InputJsonValue
    status?: $Enums.ProposalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: BattleVotingUncheckedCreateNestedManyWithoutProposalInput
  }

  export type BattleProposalCreateOrConnectWithoutBattleInput = {
    where: BattleProposalWhereUniqueInput
    create: XOR<BattleProposalCreateWithoutBattleInput, BattleProposalUncheckedCreateWithoutBattleInput>
  }

  export type BattleProposalCreateManyBattleInputEnvelope = {
    data: BattleProposalCreateManyBattleInput | BattleProposalCreateManyBattleInput[]
    skipDuplicates?: boolean
  }

  export type BattleVotingCreateWithoutBattleInput = {
    id?: string
    vote: $Enums.VoteDirection
    voteWeight: number
    reasoning?: string | null
    confidence?: number | null
    eceStaked?: number | null
    expertRating?: number | null
    portfolioValue?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    proposal?: BattleProposalCreateNestedOneWithoutVotesInput
    voter: UserCreateNestedOneWithoutBattleVotesInput
  }

  export type BattleVotingUncheckedCreateWithoutBattleInput = {
    id?: string
    proposalId?: string | null
    voterId: string
    vote: $Enums.VoteDirection
    voteWeight: number
    reasoning?: string | null
    confidence?: number | null
    eceStaked?: number | null
    expertRating?: number | null
    portfolioValue?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BattleVotingCreateOrConnectWithoutBattleInput = {
    where: BattleVotingWhereUniqueInput
    create: XOR<BattleVotingCreateWithoutBattleInput, BattleVotingUncheckedCreateWithoutBattleInput>
  }

  export type BattleVotingCreateManyBattleInputEnvelope = {
    data: BattleVotingCreateManyBattleInput | BattleVotingCreateManyBattleInput[]
    skipDuplicates?: boolean
  }

  export type BattleOutcomeCreateWithoutBattleInput = {
    id?: string
    winner: $Enums.BattleWinner
    winningProposalId?: string | null
    finalTerms: JsonNullValueInput | InputJsonValue
    finalValuation: number
    implementation: JsonNullValueInput | InputJsonValue
    stakeholdersPayouts: JsonNullValueInput | InputJsonValue
    tokenRewards: JsonNullValueInput | InputJsonValue
    completionDate?: Date | string | null
    realWorldImpact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    winningBattle?: MABattleCreateNestedOneWithoutWinnerInput
  }

  export type BattleOutcomeUncheckedCreateWithoutBattleInput = {
    id?: string
    winningBattleId?: string | null
    winner: $Enums.BattleWinner
    winningProposalId?: string | null
    finalTerms: JsonNullValueInput | InputJsonValue
    finalValuation: number
    implementation: JsonNullValueInput | InputJsonValue
    stakeholdersPayouts: JsonNullValueInput | InputJsonValue
    tokenRewards: JsonNullValueInput | InputJsonValue
    completionDate?: Date | string | null
    realWorldImpact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BattleOutcomeCreateOrConnectWithoutBattleInput = {
    where: BattleOutcomeWhereUniqueInput
    create: XOR<BattleOutcomeCreateWithoutBattleInput, BattleOutcomeUncheckedCreateWithoutBattleInput>
  }

  export type BattleOutcomeCreateManyBattleInputEnvelope = {
    data: BattleOutcomeCreateManyBattleInput | BattleOutcomeCreateManyBattleInput[]
    skipDuplicates?: boolean
  }

  export type CardUpsertWithoutInitiatedBattlesInput = {
    update: XOR<CardUpdateWithoutInitiatedBattlesInput, CardUncheckedUpdateWithoutInitiatedBattlesInput>
    create: XOR<CardCreateWithoutInitiatedBattlesInput, CardUncheckedCreateWithoutInitiatedBattlesInput>
    where?: CardWhereInput
  }

  export type CardUpdateToOneWithWhereWithoutInitiatedBattlesInput = {
    where?: CardWhereInput
    data: XOR<CardUpdateWithoutInitiatedBattlesInput, CardUncheckedUpdateWithoutInitiatedBattlesInput>
  }

  export type CardUpdateWithoutInitiatedBattlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCardCategoryFieldUpdateOperationsInput | $Enums.CardCategory
    rarity?: EnumCardRarityFieldUpdateOperationsInput | $Enums.CardRarity
    company?: NullableStringFieldUpdateOperationsInput | string | null
    currentPrice?: FloatFieldUpdateOperationsInput | number
    historicalPrices?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    stats?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedCardsNestedInput
    listing?: MarketplaceListingUpdateOneWithoutCardNestedInput
    bids?: BidUpdateManyWithoutCardNestedInput
    transactions?: TransactionUpdateManyWithoutCardNestedInput
    bettingMarkets?: BettingMarketUpdateManyWithoutCardNestedInput
    marketMetrics?: MarketMetricsUpdateManyWithoutCardNestedInput
    auction?: CardAuctionUpdateOneWithoutCardNestedInput
    auctionHistory?: AuctionHistoryUpdateManyWithoutCardNestedInput
    targetedBattles?: MABattleUpdateManyWithoutTargetCardNestedInput
  }

  export type CardUncheckedUpdateWithoutInitiatedBattlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCardCategoryFieldUpdateOperationsInput | $Enums.CardCategory
    rarity?: EnumCardRarityFieldUpdateOperationsInput | $Enums.CardRarity
    company?: NullableStringFieldUpdateOperationsInput | string | null
    currentPrice?: FloatFieldUpdateOperationsInput | number
    historicalPrices?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    stats?: NullableJsonNullValueInput | InputJsonValue
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listing?: MarketplaceListingUncheckedUpdateOneWithoutCardNestedInput
    bids?: BidUncheckedUpdateManyWithoutCardNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCardNestedInput
    bettingMarkets?: BettingMarketUncheckedUpdateManyWithoutCardNestedInput
    marketMetrics?: MarketMetricsUncheckedUpdateManyWithoutCardNestedInput
    auction?: CardAuctionUncheckedUpdateOneWithoutCardNestedInput
    auctionHistory?: AuctionHistoryUncheckedUpdateManyWithoutCardNestedInput
    targetedBattles?: MABattleUncheckedUpdateManyWithoutTargetCardNestedInput
  }

  export type CardUpsertWithoutTargetedBattlesInput = {
    update: XOR<CardUpdateWithoutTargetedBattlesInput, CardUncheckedUpdateWithoutTargetedBattlesInput>
    create: XOR<CardCreateWithoutTargetedBattlesInput, CardUncheckedCreateWithoutTargetedBattlesInput>
    where?: CardWhereInput
  }

  export type CardUpdateToOneWithWhereWithoutTargetedBattlesInput = {
    where?: CardWhereInput
    data: XOR<CardUpdateWithoutTargetedBattlesInput, CardUncheckedUpdateWithoutTargetedBattlesInput>
  }

  export type CardUpdateWithoutTargetedBattlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCardCategoryFieldUpdateOperationsInput | $Enums.CardCategory
    rarity?: EnumCardRarityFieldUpdateOperationsInput | $Enums.CardRarity
    company?: NullableStringFieldUpdateOperationsInput | string | null
    currentPrice?: FloatFieldUpdateOperationsInput | number
    historicalPrices?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    stats?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedCardsNestedInput
    listing?: MarketplaceListingUpdateOneWithoutCardNestedInput
    bids?: BidUpdateManyWithoutCardNestedInput
    transactions?: TransactionUpdateManyWithoutCardNestedInput
    bettingMarkets?: BettingMarketUpdateManyWithoutCardNestedInput
    marketMetrics?: MarketMetricsUpdateManyWithoutCardNestedInput
    auction?: CardAuctionUpdateOneWithoutCardNestedInput
    auctionHistory?: AuctionHistoryUpdateManyWithoutCardNestedInput
    initiatedBattles?: MABattleUpdateManyWithoutInitiatorCardNestedInput
  }

  export type CardUncheckedUpdateWithoutTargetedBattlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCardCategoryFieldUpdateOperationsInput | $Enums.CardCategory
    rarity?: EnumCardRarityFieldUpdateOperationsInput | $Enums.CardRarity
    company?: NullableStringFieldUpdateOperationsInput | string | null
    currentPrice?: FloatFieldUpdateOperationsInput | number
    historicalPrices?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    stats?: NullableJsonNullValueInput | InputJsonValue
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listing?: MarketplaceListingUncheckedUpdateOneWithoutCardNestedInput
    bids?: BidUncheckedUpdateManyWithoutCardNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCardNestedInput
    bettingMarkets?: BettingMarketUncheckedUpdateManyWithoutCardNestedInput
    marketMetrics?: MarketMetricsUncheckedUpdateManyWithoutCardNestedInput
    auction?: CardAuctionUncheckedUpdateOneWithoutCardNestedInput
    auctionHistory?: AuctionHistoryUncheckedUpdateManyWithoutCardNestedInput
    initiatedBattles?: MABattleUncheckedUpdateManyWithoutInitiatorCardNestedInput
  }

  export type UserUpsertWithoutInitiatedMABattlesInput = {
    update: XOR<UserUpdateWithoutInitiatedMABattlesInput, UserUncheckedUpdateWithoutInitiatedMABattlesInput>
    create: XOR<UserCreateWithoutInitiatedMABattlesInput, UserUncheckedCreateWithoutInitiatedMABattlesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInitiatedMABattlesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInitiatedMABattlesInput, UserUncheckedUpdateWithoutInitiatedMABattlesInput>
  }

  export type UserUpdateWithoutInitiatedMABattlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eceBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: UserSubscriptionUpdateOneWithoutUserNestedInput
    cryptoWallets?: CryptoWalletUpdateManyWithoutUserNestedInput
    physicalCard?: PhysicalCardUpdateOneWithoutUserNestedInput
    ownedCards?: CardUpdateManyWithoutOwnerNestedInput
    tradingHistory?: TransactionUpdateManyWithoutUserNestedInput
    bids?: BidUpdateManyWithoutBidderNestedInput
    listings?: MarketplaceListingUpdateManyWithoutSellerNestedInput
    appOrders?: AppOrderUpdateManyWithoutUserNestedInput
    orderRevisions?: OrderRevisionUpdateManyWithoutUserNestedInput
    orderCommunications?: OrderCommunicationUpdateManyWithoutUserNestedInput
    bettingPositions?: BettingPositionUpdateManyWithoutUserNestedInput
    bettingPayouts?: BettingPayoutUpdateManyWithoutUserNestedInput
    ownedAuctions?: CardAuctionUpdateManyWithoutOwnerNestedInput
    wonAuctions?: CardAuctionUpdateManyWithoutWinnerNestedInput
    placedAuctionBids?: AuctionBidUpdateManyWithoutBidderNestedInput
    watchedAuctions?: AuctionWatcherUpdateManyWithoutUserNestedInput
    targetedMABattles?: MABattleUpdateManyWithoutTargetNestedInput
    battleProposals?: BattleProposalUpdateManyWithoutProposerNestedInput
    battleVotes?: BattleVotingUpdateManyWithoutVoterNestedInput
    stakingPositions?: StakingPositionUpdateManyWithoutUserNestedInput
    stakingRewards?: StakingRewardUpdateManyWithoutUserNestedInput
    governanceProposals?: GovernanceProposalUpdateManyWithoutProposerNestedInput
    governanceVotes?: GovernanceVoteUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    socialFeeds?: SocialFeedUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutInitiatedMABattlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eceBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: UserSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    cryptoWallets?: CryptoWalletUncheckedUpdateManyWithoutUserNestedInput
    physicalCard?: PhysicalCardUncheckedUpdateOneWithoutUserNestedInput
    ownedCards?: CardUncheckedUpdateManyWithoutOwnerNestedInput
    tradingHistory?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderNestedInput
    listings?: MarketplaceListingUncheckedUpdateManyWithoutSellerNestedInput
    appOrders?: AppOrderUncheckedUpdateManyWithoutUserNestedInput
    orderRevisions?: OrderRevisionUncheckedUpdateManyWithoutUserNestedInput
    orderCommunications?: OrderCommunicationUncheckedUpdateManyWithoutUserNestedInput
    bettingPositions?: BettingPositionUncheckedUpdateManyWithoutUserNestedInput
    bettingPayouts?: BettingPayoutUncheckedUpdateManyWithoutUserNestedInput
    ownedAuctions?: CardAuctionUncheckedUpdateManyWithoutOwnerNestedInput
    wonAuctions?: CardAuctionUncheckedUpdateManyWithoutWinnerNestedInput
    placedAuctionBids?: AuctionBidUncheckedUpdateManyWithoutBidderNestedInput
    watchedAuctions?: AuctionWatcherUncheckedUpdateManyWithoutUserNestedInput
    targetedMABattles?: MABattleUncheckedUpdateManyWithoutTargetNestedInput
    battleProposals?: BattleProposalUncheckedUpdateManyWithoutProposerNestedInput
    battleVotes?: BattleVotingUncheckedUpdateManyWithoutVoterNestedInput
    stakingPositions?: StakingPositionUncheckedUpdateManyWithoutUserNestedInput
    stakingRewards?: StakingRewardUncheckedUpdateManyWithoutUserNestedInput
    governanceProposals?: GovernanceProposalUncheckedUpdateManyWithoutProposerNestedInput
    governanceVotes?: GovernanceVoteUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    socialFeeds?: SocialFeedUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type UserUpsertWithoutTargetedMABattlesInput = {
    update: XOR<UserUpdateWithoutTargetedMABattlesInput, UserUncheckedUpdateWithoutTargetedMABattlesInput>
    create: XOR<UserCreateWithoutTargetedMABattlesInput, UserUncheckedCreateWithoutTargetedMABattlesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTargetedMABattlesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTargetedMABattlesInput, UserUncheckedUpdateWithoutTargetedMABattlesInput>
  }

  export type UserUpdateWithoutTargetedMABattlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eceBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: UserSubscriptionUpdateOneWithoutUserNestedInput
    cryptoWallets?: CryptoWalletUpdateManyWithoutUserNestedInput
    physicalCard?: PhysicalCardUpdateOneWithoutUserNestedInput
    ownedCards?: CardUpdateManyWithoutOwnerNestedInput
    tradingHistory?: TransactionUpdateManyWithoutUserNestedInput
    bids?: BidUpdateManyWithoutBidderNestedInput
    listings?: MarketplaceListingUpdateManyWithoutSellerNestedInput
    appOrders?: AppOrderUpdateManyWithoutUserNestedInput
    orderRevisions?: OrderRevisionUpdateManyWithoutUserNestedInput
    orderCommunications?: OrderCommunicationUpdateManyWithoutUserNestedInput
    bettingPositions?: BettingPositionUpdateManyWithoutUserNestedInput
    bettingPayouts?: BettingPayoutUpdateManyWithoutUserNestedInput
    ownedAuctions?: CardAuctionUpdateManyWithoutOwnerNestedInput
    wonAuctions?: CardAuctionUpdateManyWithoutWinnerNestedInput
    placedAuctionBids?: AuctionBidUpdateManyWithoutBidderNestedInput
    watchedAuctions?: AuctionWatcherUpdateManyWithoutUserNestedInput
    initiatedMABattles?: MABattleUpdateManyWithoutInitiatorNestedInput
    battleProposals?: BattleProposalUpdateManyWithoutProposerNestedInput
    battleVotes?: BattleVotingUpdateManyWithoutVoterNestedInput
    stakingPositions?: StakingPositionUpdateManyWithoutUserNestedInput
    stakingRewards?: StakingRewardUpdateManyWithoutUserNestedInput
    governanceProposals?: GovernanceProposalUpdateManyWithoutProposerNestedInput
    governanceVotes?: GovernanceVoteUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    socialFeeds?: SocialFeedUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutTargetedMABattlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eceBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: UserSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    cryptoWallets?: CryptoWalletUncheckedUpdateManyWithoutUserNestedInput
    physicalCard?: PhysicalCardUncheckedUpdateOneWithoutUserNestedInput
    ownedCards?: CardUncheckedUpdateManyWithoutOwnerNestedInput
    tradingHistory?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderNestedInput
    listings?: MarketplaceListingUncheckedUpdateManyWithoutSellerNestedInput
    appOrders?: AppOrderUncheckedUpdateManyWithoutUserNestedInput
    orderRevisions?: OrderRevisionUncheckedUpdateManyWithoutUserNestedInput
    orderCommunications?: OrderCommunicationUncheckedUpdateManyWithoutUserNestedInput
    bettingPositions?: BettingPositionUncheckedUpdateManyWithoutUserNestedInput
    bettingPayouts?: BettingPayoutUncheckedUpdateManyWithoutUserNestedInput
    ownedAuctions?: CardAuctionUncheckedUpdateManyWithoutOwnerNestedInput
    wonAuctions?: CardAuctionUncheckedUpdateManyWithoutWinnerNestedInput
    placedAuctionBids?: AuctionBidUncheckedUpdateManyWithoutBidderNestedInput
    watchedAuctions?: AuctionWatcherUncheckedUpdateManyWithoutUserNestedInput
    initiatedMABattles?: MABattleUncheckedUpdateManyWithoutInitiatorNestedInput
    battleProposals?: BattleProposalUncheckedUpdateManyWithoutProposerNestedInput
    battleVotes?: BattleVotingUncheckedUpdateManyWithoutVoterNestedInput
    stakingPositions?: StakingPositionUncheckedUpdateManyWithoutUserNestedInput
    stakingRewards?: StakingRewardUncheckedUpdateManyWithoutUserNestedInput
    governanceProposals?: GovernanceProposalUncheckedUpdateManyWithoutProposerNestedInput
    governanceVotes?: GovernanceVoteUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    socialFeeds?: SocialFeedUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type BattleOutcomeUpsertWithoutWinningBattleInput = {
    update: XOR<BattleOutcomeUpdateWithoutWinningBattleInput, BattleOutcomeUncheckedUpdateWithoutWinningBattleInput>
    create: XOR<BattleOutcomeCreateWithoutWinningBattleInput, BattleOutcomeUncheckedCreateWithoutWinningBattleInput>
    where?: BattleOutcomeWhereInput
  }

  export type BattleOutcomeUpdateToOneWithWhereWithoutWinningBattleInput = {
    where?: BattleOutcomeWhereInput
    data: XOR<BattleOutcomeUpdateWithoutWinningBattleInput, BattleOutcomeUncheckedUpdateWithoutWinningBattleInput>
  }

  export type BattleOutcomeUpdateWithoutWinningBattleInput = {
    id?: StringFieldUpdateOperationsInput | string
    winner?: EnumBattleWinnerFieldUpdateOperationsInput | $Enums.BattleWinner
    winningProposalId?: NullableStringFieldUpdateOperationsInput | string | null
    finalTerms?: JsonNullValueInput | InputJsonValue
    finalValuation?: FloatFieldUpdateOperationsInput | number
    implementation?: JsonNullValueInput | InputJsonValue
    stakeholdersPayouts?: JsonNullValueInput | InputJsonValue
    tokenRewards?: JsonNullValueInput | InputJsonValue
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    realWorldImpact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    battle?: MABattleUpdateOneRequiredWithoutOutcomesNestedInput
  }

  export type BattleOutcomeUncheckedUpdateWithoutWinningBattleInput = {
    id?: StringFieldUpdateOperationsInput | string
    battleId?: StringFieldUpdateOperationsInput | string
    winner?: EnumBattleWinnerFieldUpdateOperationsInput | $Enums.BattleWinner
    winningProposalId?: NullableStringFieldUpdateOperationsInput | string | null
    finalTerms?: JsonNullValueInput | InputJsonValue
    finalValuation?: FloatFieldUpdateOperationsInput | number
    implementation?: JsonNullValueInput | InputJsonValue
    stakeholdersPayouts?: JsonNullValueInput | InputJsonValue
    tokenRewards?: JsonNullValueInput | InputJsonValue
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    realWorldImpact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BattleProposalUpsertWithWhereUniqueWithoutBattleInput = {
    where: BattleProposalWhereUniqueInput
    update: XOR<BattleProposalUpdateWithoutBattleInput, BattleProposalUncheckedUpdateWithoutBattleInput>
    create: XOR<BattleProposalCreateWithoutBattleInput, BattleProposalUncheckedCreateWithoutBattleInput>
  }

  export type BattleProposalUpdateWithWhereUniqueWithoutBattleInput = {
    where: BattleProposalWhereUniqueInput
    data: XOR<BattleProposalUpdateWithoutBattleInput, BattleProposalUncheckedUpdateWithoutBattleInput>
  }

  export type BattleProposalUpdateManyWithWhereWithoutBattleInput = {
    where: BattleProposalScalarWhereInput
    data: XOR<BattleProposalUpdateManyMutationInput, BattleProposalUncheckedUpdateManyWithoutBattleInput>
  }

  export type BattleVotingUpsertWithWhereUniqueWithoutBattleInput = {
    where: BattleVotingWhereUniqueInput
    update: XOR<BattleVotingUpdateWithoutBattleInput, BattleVotingUncheckedUpdateWithoutBattleInput>
    create: XOR<BattleVotingCreateWithoutBattleInput, BattleVotingUncheckedCreateWithoutBattleInput>
  }

  export type BattleVotingUpdateWithWhereUniqueWithoutBattleInput = {
    where: BattleVotingWhereUniqueInput
    data: XOR<BattleVotingUpdateWithoutBattleInput, BattleVotingUncheckedUpdateWithoutBattleInput>
  }

  export type BattleVotingUpdateManyWithWhereWithoutBattleInput = {
    where: BattleVotingScalarWhereInput
    data: XOR<BattleVotingUpdateManyMutationInput, BattleVotingUncheckedUpdateManyWithoutBattleInput>
  }

  export type BattleOutcomeUpsertWithWhereUniqueWithoutBattleInput = {
    where: BattleOutcomeWhereUniqueInput
    update: XOR<BattleOutcomeUpdateWithoutBattleInput, BattleOutcomeUncheckedUpdateWithoutBattleInput>
    create: XOR<BattleOutcomeCreateWithoutBattleInput, BattleOutcomeUncheckedCreateWithoutBattleInput>
  }

  export type BattleOutcomeUpdateWithWhereUniqueWithoutBattleInput = {
    where: BattleOutcomeWhereUniqueInput
    data: XOR<BattleOutcomeUpdateWithoutBattleInput, BattleOutcomeUncheckedUpdateWithoutBattleInput>
  }

  export type BattleOutcomeUpdateManyWithWhereWithoutBattleInput = {
    where: BattleOutcomeScalarWhereInput
    data: XOR<BattleOutcomeUpdateManyMutationInput, BattleOutcomeUncheckedUpdateManyWithoutBattleInput>
  }

  export type BattleOutcomeScalarWhereInput = {
    AND?: BattleOutcomeScalarWhereInput | BattleOutcomeScalarWhereInput[]
    OR?: BattleOutcomeScalarWhereInput[]
    NOT?: BattleOutcomeScalarWhereInput | BattleOutcomeScalarWhereInput[]
    id?: StringFilter<"BattleOutcome"> | string
    battleId?: StringFilter<"BattleOutcome"> | string
    winningBattleId?: StringNullableFilter<"BattleOutcome"> | string | null
    winner?: EnumBattleWinnerFilter<"BattleOutcome"> | $Enums.BattleWinner
    winningProposalId?: StringNullableFilter<"BattleOutcome"> | string | null
    finalTerms?: JsonFilter<"BattleOutcome">
    finalValuation?: FloatFilter<"BattleOutcome"> | number
    implementation?: JsonFilter<"BattleOutcome">
    stakeholdersPayouts?: JsonFilter<"BattleOutcome">
    tokenRewards?: JsonFilter<"BattleOutcome">
    completionDate?: DateTimeNullableFilter<"BattleOutcome"> | Date | string | null
    realWorldImpact?: StringNullableFilter<"BattleOutcome"> | string | null
    createdAt?: DateTimeFilter<"BattleOutcome"> | Date | string
    updatedAt?: DateTimeFilter<"BattleOutcome"> | Date | string
  }

  export type MABattleCreateWithoutProposalsInput = {
    id?: string
    battleType: $Enums.BattleType
    title: string
    description: string
    stakes: number
    timeline: Date | string
    votingPeriod: Date | string
    status?: $Enums.BattleStatus
    resolved?: boolean
    viewCount?: number
    participantCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    initiatorCard: CardCreateNestedOneWithoutInitiatedBattlesInput
    targetCard: CardCreateNestedOneWithoutTargetedBattlesInput
    initiator: UserCreateNestedOneWithoutInitiatedMABattlesInput
    target?: UserCreateNestedOneWithoutTargetedMABattlesInput
    winner?: BattleOutcomeCreateNestedOneWithoutWinningBattleInput
    votes?: BattleVotingCreateNestedManyWithoutBattleInput
    outcomes?: BattleOutcomeCreateNestedManyWithoutBattleInput
  }

  export type MABattleUncheckedCreateWithoutProposalsInput = {
    id?: string
    initiatorCardId: string
    targetCardId: string
    initiatorUserId: string
    targetUserId?: string | null
    battleType: $Enums.BattleType
    title: string
    description: string
    stakes: number
    timeline: Date | string
    votingPeriod: Date | string
    status?: $Enums.BattleStatus
    resolved?: boolean
    viewCount?: number
    participantCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    winner?: BattleOutcomeUncheckedCreateNestedOneWithoutWinningBattleInput
    votes?: BattleVotingUncheckedCreateNestedManyWithoutBattleInput
    outcomes?: BattleOutcomeUncheckedCreateNestedManyWithoutBattleInput
  }

  export type MABattleCreateOrConnectWithoutProposalsInput = {
    where: MABattleWhereUniqueInput
    create: XOR<MABattleCreateWithoutProposalsInput, MABattleUncheckedCreateWithoutProposalsInput>
  }

  export type UserCreateWithoutBattleProposalsInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    passwordHash?: string | null
    emailVerified?: Date | string | null
    eceBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string
    subscription?: UserSubscriptionCreateNestedOneWithoutUserInput
    cryptoWallets?: CryptoWalletCreateNestedManyWithoutUserInput
    physicalCard?: PhysicalCardCreateNestedOneWithoutUserInput
    ownedCards?: CardCreateNestedManyWithoutOwnerInput
    tradingHistory?: TransactionCreateNestedManyWithoutUserInput
    bids?: BidCreateNestedManyWithoutBidderInput
    listings?: MarketplaceListingCreateNestedManyWithoutSellerInput
    appOrders?: AppOrderCreateNestedManyWithoutUserInput
    orderRevisions?: OrderRevisionCreateNestedManyWithoutUserInput
    orderCommunications?: OrderCommunicationCreateNestedManyWithoutUserInput
    bettingPositions?: BettingPositionCreateNestedManyWithoutUserInput
    bettingPayouts?: BettingPayoutCreateNestedManyWithoutUserInput
    ownedAuctions?: CardAuctionCreateNestedManyWithoutOwnerInput
    wonAuctions?: CardAuctionCreateNestedManyWithoutWinnerInput
    placedAuctionBids?: AuctionBidCreateNestedManyWithoutBidderInput
    watchedAuctions?: AuctionWatcherCreateNestedManyWithoutUserInput
    initiatedMABattles?: MABattleCreateNestedManyWithoutInitiatorInput
    targetedMABattles?: MABattleCreateNestedManyWithoutTargetInput
    battleVotes?: BattleVotingCreateNestedManyWithoutVoterInput
    stakingPositions?: StakingPositionCreateNestedManyWithoutUserInput
    stakingRewards?: StakingRewardCreateNestedManyWithoutUserInput
    governanceProposals?: GovernanceProposalCreateNestedManyWithoutProposerInput
    governanceVotes?: GovernanceVoteCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    socialFeeds?: SocialFeedCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutBattleProposalsInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    passwordHash?: string | null
    emailVerified?: Date | string | null
    eceBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string
    subscription?: UserSubscriptionUncheckedCreateNestedOneWithoutUserInput
    cryptoWallets?: CryptoWalletUncheckedCreateNestedManyWithoutUserInput
    physicalCard?: PhysicalCardUncheckedCreateNestedOneWithoutUserInput
    ownedCards?: CardUncheckedCreateNestedManyWithoutOwnerInput
    tradingHistory?: TransactionUncheckedCreateNestedManyWithoutUserInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderInput
    listings?: MarketplaceListingUncheckedCreateNestedManyWithoutSellerInput
    appOrders?: AppOrderUncheckedCreateNestedManyWithoutUserInput
    orderRevisions?: OrderRevisionUncheckedCreateNestedManyWithoutUserInput
    orderCommunications?: OrderCommunicationUncheckedCreateNestedManyWithoutUserInput
    bettingPositions?: BettingPositionUncheckedCreateNestedManyWithoutUserInput
    bettingPayouts?: BettingPayoutUncheckedCreateNestedManyWithoutUserInput
    ownedAuctions?: CardAuctionUncheckedCreateNestedManyWithoutOwnerInput
    wonAuctions?: CardAuctionUncheckedCreateNestedManyWithoutWinnerInput
    placedAuctionBids?: AuctionBidUncheckedCreateNestedManyWithoutBidderInput
    watchedAuctions?: AuctionWatcherUncheckedCreateNestedManyWithoutUserInput
    initiatedMABattles?: MABattleUncheckedCreateNestedManyWithoutInitiatorInput
    targetedMABattles?: MABattleUncheckedCreateNestedManyWithoutTargetInput
    battleVotes?: BattleVotingUncheckedCreateNestedManyWithoutVoterInput
    stakingPositions?: StakingPositionUncheckedCreateNestedManyWithoutUserInput
    stakingRewards?: StakingRewardUncheckedCreateNestedManyWithoutUserInput
    governanceProposals?: GovernanceProposalUncheckedCreateNestedManyWithoutProposerInput
    governanceVotes?: GovernanceVoteUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    socialFeeds?: SocialFeedUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutBattleProposalsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBattleProposalsInput, UserUncheckedCreateWithoutBattleProposalsInput>
  }

  export type BattleVotingCreateWithoutProposalInput = {
    id?: string
    vote: $Enums.VoteDirection
    voteWeight: number
    reasoning?: string | null
    confidence?: number | null
    eceStaked?: number | null
    expertRating?: number | null
    portfolioValue?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    battle: MABattleCreateNestedOneWithoutVotesInput
    voter: UserCreateNestedOneWithoutBattleVotesInput
  }

  export type BattleVotingUncheckedCreateWithoutProposalInput = {
    id?: string
    battleId: string
    voterId: string
    vote: $Enums.VoteDirection
    voteWeight: number
    reasoning?: string | null
    confidence?: number | null
    eceStaked?: number | null
    expertRating?: number | null
    portfolioValue?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BattleVotingCreateOrConnectWithoutProposalInput = {
    where: BattleVotingWhereUniqueInput
    create: XOR<BattleVotingCreateWithoutProposalInput, BattleVotingUncheckedCreateWithoutProposalInput>
  }

  export type BattleVotingCreateManyProposalInputEnvelope = {
    data: BattleVotingCreateManyProposalInput | BattleVotingCreateManyProposalInput[]
    skipDuplicates?: boolean
  }

  export type MABattleUpsertWithoutProposalsInput = {
    update: XOR<MABattleUpdateWithoutProposalsInput, MABattleUncheckedUpdateWithoutProposalsInput>
    create: XOR<MABattleCreateWithoutProposalsInput, MABattleUncheckedCreateWithoutProposalsInput>
    where?: MABattleWhereInput
  }

  export type MABattleUpdateToOneWithWhereWithoutProposalsInput = {
    where?: MABattleWhereInput
    data: XOR<MABattleUpdateWithoutProposalsInput, MABattleUncheckedUpdateWithoutProposalsInput>
  }

  export type MABattleUpdateWithoutProposalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    battleType?: EnumBattleTypeFieldUpdateOperationsInput | $Enums.BattleType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    stakes?: FloatFieldUpdateOperationsInput | number
    timeline?: DateTimeFieldUpdateOperationsInput | Date | string
    votingPeriod?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBattleStatusFieldUpdateOperationsInput | $Enums.BattleStatus
    resolved?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    participantCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    initiatorCard?: CardUpdateOneRequiredWithoutInitiatedBattlesNestedInput
    targetCard?: CardUpdateOneRequiredWithoutTargetedBattlesNestedInput
    initiator?: UserUpdateOneRequiredWithoutInitiatedMABattlesNestedInput
    target?: UserUpdateOneWithoutTargetedMABattlesNestedInput
    winner?: BattleOutcomeUpdateOneWithoutWinningBattleNestedInput
    votes?: BattleVotingUpdateManyWithoutBattleNestedInput
    outcomes?: BattleOutcomeUpdateManyWithoutBattleNestedInput
  }

  export type MABattleUncheckedUpdateWithoutProposalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    initiatorCardId?: StringFieldUpdateOperationsInput | string
    targetCardId?: StringFieldUpdateOperationsInput | string
    initiatorUserId?: StringFieldUpdateOperationsInput | string
    targetUserId?: NullableStringFieldUpdateOperationsInput | string | null
    battleType?: EnumBattleTypeFieldUpdateOperationsInput | $Enums.BattleType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    stakes?: FloatFieldUpdateOperationsInput | number
    timeline?: DateTimeFieldUpdateOperationsInput | Date | string
    votingPeriod?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBattleStatusFieldUpdateOperationsInput | $Enums.BattleStatus
    resolved?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    participantCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    winner?: BattleOutcomeUncheckedUpdateOneWithoutWinningBattleNestedInput
    votes?: BattleVotingUncheckedUpdateManyWithoutBattleNestedInput
    outcomes?: BattleOutcomeUncheckedUpdateManyWithoutBattleNestedInput
  }

  export type UserUpsertWithoutBattleProposalsInput = {
    update: XOR<UserUpdateWithoutBattleProposalsInput, UserUncheckedUpdateWithoutBattleProposalsInput>
    create: XOR<UserCreateWithoutBattleProposalsInput, UserUncheckedCreateWithoutBattleProposalsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBattleProposalsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBattleProposalsInput, UserUncheckedUpdateWithoutBattleProposalsInput>
  }

  export type UserUpdateWithoutBattleProposalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eceBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: UserSubscriptionUpdateOneWithoutUserNestedInput
    cryptoWallets?: CryptoWalletUpdateManyWithoutUserNestedInput
    physicalCard?: PhysicalCardUpdateOneWithoutUserNestedInput
    ownedCards?: CardUpdateManyWithoutOwnerNestedInput
    tradingHistory?: TransactionUpdateManyWithoutUserNestedInput
    bids?: BidUpdateManyWithoutBidderNestedInput
    listings?: MarketplaceListingUpdateManyWithoutSellerNestedInput
    appOrders?: AppOrderUpdateManyWithoutUserNestedInput
    orderRevisions?: OrderRevisionUpdateManyWithoutUserNestedInput
    orderCommunications?: OrderCommunicationUpdateManyWithoutUserNestedInput
    bettingPositions?: BettingPositionUpdateManyWithoutUserNestedInput
    bettingPayouts?: BettingPayoutUpdateManyWithoutUserNestedInput
    ownedAuctions?: CardAuctionUpdateManyWithoutOwnerNestedInput
    wonAuctions?: CardAuctionUpdateManyWithoutWinnerNestedInput
    placedAuctionBids?: AuctionBidUpdateManyWithoutBidderNestedInput
    watchedAuctions?: AuctionWatcherUpdateManyWithoutUserNestedInput
    initiatedMABattles?: MABattleUpdateManyWithoutInitiatorNestedInput
    targetedMABattles?: MABattleUpdateManyWithoutTargetNestedInput
    battleVotes?: BattleVotingUpdateManyWithoutVoterNestedInput
    stakingPositions?: StakingPositionUpdateManyWithoutUserNestedInput
    stakingRewards?: StakingRewardUpdateManyWithoutUserNestedInput
    governanceProposals?: GovernanceProposalUpdateManyWithoutProposerNestedInput
    governanceVotes?: GovernanceVoteUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    socialFeeds?: SocialFeedUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutBattleProposalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eceBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: UserSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    cryptoWallets?: CryptoWalletUncheckedUpdateManyWithoutUserNestedInput
    physicalCard?: PhysicalCardUncheckedUpdateOneWithoutUserNestedInput
    ownedCards?: CardUncheckedUpdateManyWithoutOwnerNestedInput
    tradingHistory?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderNestedInput
    listings?: MarketplaceListingUncheckedUpdateManyWithoutSellerNestedInput
    appOrders?: AppOrderUncheckedUpdateManyWithoutUserNestedInput
    orderRevisions?: OrderRevisionUncheckedUpdateManyWithoutUserNestedInput
    orderCommunications?: OrderCommunicationUncheckedUpdateManyWithoutUserNestedInput
    bettingPositions?: BettingPositionUncheckedUpdateManyWithoutUserNestedInput
    bettingPayouts?: BettingPayoutUncheckedUpdateManyWithoutUserNestedInput
    ownedAuctions?: CardAuctionUncheckedUpdateManyWithoutOwnerNestedInput
    wonAuctions?: CardAuctionUncheckedUpdateManyWithoutWinnerNestedInput
    placedAuctionBids?: AuctionBidUncheckedUpdateManyWithoutBidderNestedInput
    watchedAuctions?: AuctionWatcherUncheckedUpdateManyWithoutUserNestedInput
    initiatedMABattles?: MABattleUncheckedUpdateManyWithoutInitiatorNestedInput
    targetedMABattles?: MABattleUncheckedUpdateManyWithoutTargetNestedInput
    battleVotes?: BattleVotingUncheckedUpdateManyWithoutVoterNestedInput
    stakingPositions?: StakingPositionUncheckedUpdateManyWithoutUserNestedInput
    stakingRewards?: StakingRewardUncheckedUpdateManyWithoutUserNestedInput
    governanceProposals?: GovernanceProposalUncheckedUpdateManyWithoutProposerNestedInput
    governanceVotes?: GovernanceVoteUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    socialFeeds?: SocialFeedUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type BattleVotingUpsertWithWhereUniqueWithoutProposalInput = {
    where: BattleVotingWhereUniqueInput
    update: XOR<BattleVotingUpdateWithoutProposalInput, BattleVotingUncheckedUpdateWithoutProposalInput>
    create: XOR<BattleVotingCreateWithoutProposalInput, BattleVotingUncheckedCreateWithoutProposalInput>
  }

  export type BattleVotingUpdateWithWhereUniqueWithoutProposalInput = {
    where: BattleVotingWhereUniqueInput
    data: XOR<BattleVotingUpdateWithoutProposalInput, BattleVotingUncheckedUpdateWithoutProposalInput>
  }

  export type BattleVotingUpdateManyWithWhereWithoutProposalInput = {
    where: BattleVotingScalarWhereInput
    data: XOR<BattleVotingUpdateManyMutationInput, BattleVotingUncheckedUpdateManyWithoutProposalInput>
  }

  export type MABattleCreateWithoutVotesInput = {
    id?: string
    battleType: $Enums.BattleType
    title: string
    description: string
    stakes: number
    timeline: Date | string
    votingPeriod: Date | string
    status?: $Enums.BattleStatus
    resolved?: boolean
    viewCount?: number
    participantCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    initiatorCard: CardCreateNestedOneWithoutInitiatedBattlesInput
    targetCard: CardCreateNestedOneWithoutTargetedBattlesInput
    initiator: UserCreateNestedOneWithoutInitiatedMABattlesInput
    target?: UserCreateNestedOneWithoutTargetedMABattlesInput
    winner?: BattleOutcomeCreateNestedOneWithoutWinningBattleInput
    proposals?: BattleProposalCreateNestedManyWithoutBattleInput
    outcomes?: BattleOutcomeCreateNestedManyWithoutBattleInput
  }

  export type MABattleUncheckedCreateWithoutVotesInput = {
    id?: string
    initiatorCardId: string
    targetCardId: string
    initiatorUserId: string
    targetUserId?: string | null
    battleType: $Enums.BattleType
    title: string
    description: string
    stakes: number
    timeline: Date | string
    votingPeriod: Date | string
    status?: $Enums.BattleStatus
    resolved?: boolean
    viewCount?: number
    participantCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    winner?: BattleOutcomeUncheckedCreateNestedOneWithoutWinningBattleInput
    proposals?: BattleProposalUncheckedCreateNestedManyWithoutBattleInput
    outcomes?: BattleOutcomeUncheckedCreateNestedManyWithoutBattleInput
  }

  export type MABattleCreateOrConnectWithoutVotesInput = {
    where: MABattleWhereUniqueInput
    create: XOR<MABattleCreateWithoutVotesInput, MABattleUncheckedCreateWithoutVotesInput>
  }

  export type BattleProposalCreateWithoutVotesInput = {
    id?: string
    proposalType: $Enums.ProposalType
    title: string
    description: string
    terms: JsonNullValueInput | InputJsonValue
    valuation: number
    paymentStructure: JsonNullValueInput | InputJsonValue
    timeline: JsonNullValueInput | InputJsonValue
    synergies: JsonNullValueInput | InputJsonValue
    conditions: JsonNullValueInput | InputJsonValue
    contingencies: JsonNullValueInput | InputJsonValue
    status?: $Enums.ProposalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    battle: MABattleCreateNestedOneWithoutProposalsInput
    proposer: UserCreateNestedOneWithoutBattleProposalsInput
  }

  export type BattleProposalUncheckedCreateWithoutVotesInput = {
    id?: string
    battleId: string
    proposerId: string
    proposalType: $Enums.ProposalType
    title: string
    description: string
    terms: JsonNullValueInput | InputJsonValue
    valuation: number
    paymentStructure: JsonNullValueInput | InputJsonValue
    timeline: JsonNullValueInput | InputJsonValue
    synergies: JsonNullValueInput | InputJsonValue
    conditions: JsonNullValueInput | InputJsonValue
    contingencies: JsonNullValueInput | InputJsonValue
    status?: $Enums.ProposalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BattleProposalCreateOrConnectWithoutVotesInput = {
    where: BattleProposalWhereUniqueInput
    create: XOR<BattleProposalCreateWithoutVotesInput, BattleProposalUncheckedCreateWithoutVotesInput>
  }

  export type UserCreateWithoutBattleVotesInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    passwordHash?: string | null
    emailVerified?: Date | string | null
    eceBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string
    subscription?: UserSubscriptionCreateNestedOneWithoutUserInput
    cryptoWallets?: CryptoWalletCreateNestedManyWithoutUserInput
    physicalCard?: PhysicalCardCreateNestedOneWithoutUserInput
    ownedCards?: CardCreateNestedManyWithoutOwnerInput
    tradingHistory?: TransactionCreateNestedManyWithoutUserInput
    bids?: BidCreateNestedManyWithoutBidderInput
    listings?: MarketplaceListingCreateNestedManyWithoutSellerInput
    appOrders?: AppOrderCreateNestedManyWithoutUserInput
    orderRevisions?: OrderRevisionCreateNestedManyWithoutUserInput
    orderCommunications?: OrderCommunicationCreateNestedManyWithoutUserInput
    bettingPositions?: BettingPositionCreateNestedManyWithoutUserInput
    bettingPayouts?: BettingPayoutCreateNestedManyWithoutUserInput
    ownedAuctions?: CardAuctionCreateNestedManyWithoutOwnerInput
    wonAuctions?: CardAuctionCreateNestedManyWithoutWinnerInput
    placedAuctionBids?: AuctionBidCreateNestedManyWithoutBidderInput
    watchedAuctions?: AuctionWatcherCreateNestedManyWithoutUserInput
    initiatedMABattles?: MABattleCreateNestedManyWithoutInitiatorInput
    targetedMABattles?: MABattleCreateNestedManyWithoutTargetInput
    battleProposals?: BattleProposalCreateNestedManyWithoutProposerInput
    stakingPositions?: StakingPositionCreateNestedManyWithoutUserInput
    stakingRewards?: StakingRewardCreateNestedManyWithoutUserInput
    governanceProposals?: GovernanceProposalCreateNestedManyWithoutProposerInput
    governanceVotes?: GovernanceVoteCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    socialFeeds?: SocialFeedCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutBattleVotesInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    passwordHash?: string | null
    emailVerified?: Date | string | null
    eceBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string
    subscription?: UserSubscriptionUncheckedCreateNestedOneWithoutUserInput
    cryptoWallets?: CryptoWalletUncheckedCreateNestedManyWithoutUserInput
    physicalCard?: PhysicalCardUncheckedCreateNestedOneWithoutUserInput
    ownedCards?: CardUncheckedCreateNestedManyWithoutOwnerInput
    tradingHistory?: TransactionUncheckedCreateNestedManyWithoutUserInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderInput
    listings?: MarketplaceListingUncheckedCreateNestedManyWithoutSellerInput
    appOrders?: AppOrderUncheckedCreateNestedManyWithoutUserInput
    orderRevisions?: OrderRevisionUncheckedCreateNestedManyWithoutUserInput
    orderCommunications?: OrderCommunicationUncheckedCreateNestedManyWithoutUserInput
    bettingPositions?: BettingPositionUncheckedCreateNestedManyWithoutUserInput
    bettingPayouts?: BettingPayoutUncheckedCreateNestedManyWithoutUserInput
    ownedAuctions?: CardAuctionUncheckedCreateNestedManyWithoutOwnerInput
    wonAuctions?: CardAuctionUncheckedCreateNestedManyWithoutWinnerInput
    placedAuctionBids?: AuctionBidUncheckedCreateNestedManyWithoutBidderInput
    watchedAuctions?: AuctionWatcherUncheckedCreateNestedManyWithoutUserInput
    initiatedMABattles?: MABattleUncheckedCreateNestedManyWithoutInitiatorInput
    targetedMABattles?: MABattleUncheckedCreateNestedManyWithoutTargetInput
    battleProposals?: BattleProposalUncheckedCreateNestedManyWithoutProposerInput
    stakingPositions?: StakingPositionUncheckedCreateNestedManyWithoutUserInput
    stakingRewards?: StakingRewardUncheckedCreateNestedManyWithoutUserInput
    governanceProposals?: GovernanceProposalUncheckedCreateNestedManyWithoutProposerInput
    governanceVotes?: GovernanceVoteUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    socialFeeds?: SocialFeedUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutBattleVotesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBattleVotesInput, UserUncheckedCreateWithoutBattleVotesInput>
  }

  export type MABattleUpsertWithoutVotesInput = {
    update: XOR<MABattleUpdateWithoutVotesInput, MABattleUncheckedUpdateWithoutVotesInput>
    create: XOR<MABattleCreateWithoutVotesInput, MABattleUncheckedCreateWithoutVotesInput>
    where?: MABattleWhereInput
  }

  export type MABattleUpdateToOneWithWhereWithoutVotesInput = {
    where?: MABattleWhereInput
    data: XOR<MABattleUpdateWithoutVotesInput, MABattleUncheckedUpdateWithoutVotesInput>
  }

  export type MABattleUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    battleType?: EnumBattleTypeFieldUpdateOperationsInput | $Enums.BattleType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    stakes?: FloatFieldUpdateOperationsInput | number
    timeline?: DateTimeFieldUpdateOperationsInput | Date | string
    votingPeriod?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBattleStatusFieldUpdateOperationsInput | $Enums.BattleStatus
    resolved?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    participantCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    initiatorCard?: CardUpdateOneRequiredWithoutInitiatedBattlesNestedInput
    targetCard?: CardUpdateOneRequiredWithoutTargetedBattlesNestedInput
    initiator?: UserUpdateOneRequiredWithoutInitiatedMABattlesNestedInput
    target?: UserUpdateOneWithoutTargetedMABattlesNestedInput
    winner?: BattleOutcomeUpdateOneWithoutWinningBattleNestedInput
    proposals?: BattleProposalUpdateManyWithoutBattleNestedInput
    outcomes?: BattleOutcomeUpdateManyWithoutBattleNestedInput
  }

  export type MABattleUncheckedUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    initiatorCardId?: StringFieldUpdateOperationsInput | string
    targetCardId?: StringFieldUpdateOperationsInput | string
    initiatorUserId?: StringFieldUpdateOperationsInput | string
    targetUserId?: NullableStringFieldUpdateOperationsInput | string | null
    battleType?: EnumBattleTypeFieldUpdateOperationsInput | $Enums.BattleType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    stakes?: FloatFieldUpdateOperationsInput | number
    timeline?: DateTimeFieldUpdateOperationsInput | Date | string
    votingPeriod?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBattleStatusFieldUpdateOperationsInput | $Enums.BattleStatus
    resolved?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    participantCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    winner?: BattleOutcomeUncheckedUpdateOneWithoutWinningBattleNestedInput
    proposals?: BattleProposalUncheckedUpdateManyWithoutBattleNestedInput
    outcomes?: BattleOutcomeUncheckedUpdateManyWithoutBattleNestedInput
  }

  export type BattleProposalUpsertWithoutVotesInput = {
    update: XOR<BattleProposalUpdateWithoutVotesInput, BattleProposalUncheckedUpdateWithoutVotesInput>
    create: XOR<BattleProposalCreateWithoutVotesInput, BattleProposalUncheckedCreateWithoutVotesInput>
    where?: BattleProposalWhereInput
  }

  export type BattleProposalUpdateToOneWithWhereWithoutVotesInput = {
    where?: BattleProposalWhereInput
    data: XOR<BattleProposalUpdateWithoutVotesInput, BattleProposalUncheckedUpdateWithoutVotesInput>
  }

  export type BattleProposalUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposalType?: EnumProposalTypeFieldUpdateOperationsInput | $Enums.ProposalType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    terms?: JsonNullValueInput | InputJsonValue
    valuation?: FloatFieldUpdateOperationsInput | number
    paymentStructure?: JsonNullValueInput | InputJsonValue
    timeline?: JsonNullValueInput | InputJsonValue
    synergies?: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    contingencies?: JsonNullValueInput | InputJsonValue
    status?: EnumProposalStatusFieldUpdateOperationsInput | $Enums.ProposalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    battle?: MABattleUpdateOneRequiredWithoutProposalsNestedInput
    proposer?: UserUpdateOneRequiredWithoutBattleProposalsNestedInput
  }

  export type BattleProposalUncheckedUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    battleId?: StringFieldUpdateOperationsInput | string
    proposerId?: StringFieldUpdateOperationsInput | string
    proposalType?: EnumProposalTypeFieldUpdateOperationsInput | $Enums.ProposalType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    terms?: JsonNullValueInput | InputJsonValue
    valuation?: FloatFieldUpdateOperationsInput | number
    paymentStructure?: JsonNullValueInput | InputJsonValue
    timeline?: JsonNullValueInput | InputJsonValue
    synergies?: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    contingencies?: JsonNullValueInput | InputJsonValue
    status?: EnumProposalStatusFieldUpdateOperationsInput | $Enums.ProposalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutBattleVotesInput = {
    update: XOR<UserUpdateWithoutBattleVotesInput, UserUncheckedUpdateWithoutBattleVotesInput>
    create: XOR<UserCreateWithoutBattleVotesInput, UserUncheckedCreateWithoutBattleVotesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBattleVotesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBattleVotesInput, UserUncheckedUpdateWithoutBattleVotesInput>
  }

  export type UserUpdateWithoutBattleVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eceBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: UserSubscriptionUpdateOneWithoutUserNestedInput
    cryptoWallets?: CryptoWalletUpdateManyWithoutUserNestedInput
    physicalCard?: PhysicalCardUpdateOneWithoutUserNestedInput
    ownedCards?: CardUpdateManyWithoutOwnerNestedInput
    tradingHistory?: TransactionUpdateManyWithoutUserNestedInput
    bids?: BidUpdateManyWithoutBidderNestedInput
    listings?: MarketplaceListingUpdateManyWithoutSellerNestedInput
    appOrders?: AppOrderUpdateManyWithoutUserNestedInput
    orderRevisions?: OrderRevisionUpdateManyWithoutUserNestedInput
    orderCommunications?: OrderCommunicationUpdateManyWithoutUserNestedInput
    bettingPositions?: BettingPositionUpdateManyWithoutUserNestedInput
    bettingPayouts?: BettingPayoutUpdateManyWithoutUserNestedInput
    ownedAuctions?: CardAuctionUpdateManyWithoutOwnerNestedInput
    wonAuctions?: CardAuctionUpdateManyWithoutWinnerNestedInput
    placedAuctionBids?: AuctionBidUpdateManyWithoutBidderNestedInput
    watchedAuctions?: AuctionWatcherUpdateManyWithoutUserNestedInput
    initiatedMABattles?: MABattleUpdateManyWithoutInitiatorNestedInput
    targetedMABattles?: MABattleUpdateManyWithoutTargetNestedInput
    battleProposals?: BattleProposalUpdateManyWithoutProposerNestedInput
    stakingPositions?: StakingPositionUpdateManyWithoutUserNestedInput
    stakingRewards?: StakingRewardUpdateManyWithoutUserNestedInput
    governanceProposals?: GovernanceProposalUpdateManyWithoutProposerNestedInput
    governanceVotes?: GovernanceVoteUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    socialFeeds?: SocialFeedUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutBattleVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eceBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: UserSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    cryptoWallets?: CryptoWalletUncheckedUpdateManyWithoutUserNestedInput
    physicalCard?: PhysicalCardUncheckedUpdateOneWithoutUserNestedInput
    ownedCards?: CardUncheckedUpdateManyWithoutOwnerNestedInput
    tradingHistory?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderNestedInput
    listings?: MarketplaceListingUncheckedUpdateManyWithoutSellerNestedInput
    appOrders?: AppOrderUncheckedUpdateManyWithoutUserNestedInput
    orderRevisions?: OrderRevisionUncheckedUpdateManyWithoutUserNestedInput
    orderCommunications?: OrderCommunicationUncheckedUpdateManyWithoutUserNestedInput
    bettingPositions?: BettingPositionUncheckedUpdateManyWithoutUserNestedInput
    bettingPayouts?: BettingPayoutUncheckedUpdateManyWithoutUserNestedInput
    ownedAuctions?: CardAuctionUncheckedUpdateManyWithoutOwnerNestedInput
    wonAuctions?: CardAuctionUncheckedUpdateManyWithoutWinnerNestedInput
    placedAuctionBids?: AuctionBidUncheckedUpdateManyWithoutBidderNestedInput
    watchedAuctions?: AuctionWatcherUncheckedUpdateManyWithoutUserNestedInput
    initiatedMABattles?: MABattleUncheckedUpdateManyWithoutInitiatorNestedInput
    targetedMABattles?: MABattleUncheckedUpdateManyWithoutTargetNestedInput
    battleProposals?: BattleProposalUncheckedUpdateManyWithoutProposerNestedInput
    stakingPositions?: StakingPositionUncheckedUpdateManyWithoutUserNestedInput
    stakingRewards?: StakingRewardUncheckedUpdateManyWithoutUserNestedInput
    governanceProposals?: GovernanceProposalUncheckedUpdateManyWithoutProposerNestedInput
    governanceVotes?: GovernanceVoteUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    socialFeeds?: SocialFeedUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type MABattleCreateWithoutOutcomesInput = {
    id?: string
    battleType: $Enums.BattleType
    title: string
    description: string
    stakes: number
    timeline: Date | string
    votingPeriod: Date | string
    status?: $Enums.BattleStatus
    resolved?: boolean
    viewCount?: number
    participantCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    initiatorCard: CardCreateNestedOneWithoutInitiatedBattlesInput
    targetCard: CardCreateNestedOneWithoutTargetedBattlesInput
    initiator: UserCreateNestedOneWithoutInitiatedMABattlesInput
    target?: UserCreateNestedOneWithoutTargetedMABattlesInput
    winner?: BattleOutcomeCreateNestedOneWithoutWinningBattleInput
    proposals?: BattleProposalCreateNestedManyWithoutBattleInput
    votes?: BattleVotingCreateNestedManyWithoutBattleInput
  }

  export type MABattleUncheckedCreateWithoutOutcomesInput = {
    id?: string
    initiatorCardId: string
    targetCardId: string
    initiatorUserId: string
    targetUserId?: string | null
    battleType: $Enums.BattleType
    title: string
    description: string
    stakes: number
    timeline: Date | string
    votingPeriod: Date | string
    status?: $Enums.BattleStatus
    resolved?: boolean
    viewCount?: number
    participantCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    winner?: BattleOutcomeUncheckedCreateNestedOneWithoutWinningBattleInput
    proposals?: BattleProposalUncheckedCreateNestedManyWithoutBattleInput
    votes?: BattleVotingUncheckedCreateNestedManyWithoutBattleInput
  }

  export type MABattleCreateOrConnectWithoutOutcomesInput = {
    where: MABattleWhereUniqueInput
    create: XOR<MABattleCreateWithoutOutcomesInput, MABattleUncheckedCreateWithoutOutcomesInput>
  }

  export type MABattleCreateWithoutWinnerInput = {
    id?: string
    battleType: $Enums.BattleType
    title: string
    description: string
    stakes: number
    timeline: Date | string
    votingPeriod: Date | string
    status?: $Enums.BattleStatus
    resolved?: boolean
    viewCount?: number
    participantCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    initiatorCard: CardCreateNestedOneWithoutInitiatedBattlesInput
    targetCard: CardCreateNestedOneWithoutTargetedBattlesInput
    initiator: UserCreateNestedOneWithoutInitiatedMABattlesInput
    target?: UserCreateNestedOneWithoutTargetedMABattlesInput
    proposals?: BattleProposalCreateNestedManyWithoutBattleInput
    votes?: BattleVotingCreateNestedManyWithoutBattleInput
    outcomes?: BattleOutcomeCreateNestedManyWithoutBattleInput
  }

  export type MABattleUncheckedCreateWithoutWinnerInput = {
    id?: string
    initiatorCardId: string
    targetCardId: string
    initiatorUserId: string
    targetUserId?: string | null
    battleType: $Enums.BattleType
    title: string
    description: string
    stakes: number
    timeline: Date | string
    votingPeriod: Date | string
    status?: $Enums.BattleStatus
    resolved?: boolean
    viewCount?: number
    participantCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    proposals?: BattleProposalUncheckedCreateNestedManyWithoutBattleInput
    votes?: BattleVotingUncheckedCreateNestedManyWithoutBattleInput
    outcomes?: BattleOutcomeUncheckedCreateNestedManyWithoutBattleInput
  }

  export type MABattleCreateOrConnectWithoutWinnerInput = {
    where: MABattleWhereUniqueInput
    create: XOR<MABattleCreateWithoutWinnerInput, MABattleUncheckedCreateWithoutWinnerInput>
  }

  export type MABattleUpsertWithoutOutcomesInput = {
    update: XOR<MABattleUpdateWithoutOutcomesInput, MABattleUncheckedUpdateWithoutOutcomesInput>
    create: XOR<MABattleCreateWithoutOutcomesInput, MABattleUncheckedCreateWithoutOutcomesInput>
    where?: MABattleWhereInput
  }

  export type MABattleUpdateToOneWithWhereWithoutOutcomesInput = {
    where?: MABattleWhereInput
    data: XOR<MABattleUpdateWithoutOutcomesInput, MABattleUncheckedUpdateWithoutOutcomesInput>
  }

  export type MABattleUpdateWithoutOutcomesInput = {
    id?: StringFieldUpdateOperationsInput | string
    battleType?: EnumBattleTypeFieldUpdateOperationsInput | $Enums.BattleType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    stakes?: FloatFieldUpdateOperationsInput | number
    timeline?: DateTimeFieldUpdateOperationsInput | Date | string
    votingPeriod?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBattleStatusFieldUpdateOperationsInput | $Enums.BattleStatus
    resolved?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    participantCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    initiatorCard?: CardUpdateOneRequiredWithoutInitiatedBattlesNestedInput
    targetCard?: CardUpdateOneRequiredWithoutTargetedBattlesNestedInput
    initiator?: UserUpdateOneRequiredWithoutInitiatedMABattlesNestedInput
    target?: UserUpdateOneWithoutTargetedMABattlesNestedInput
    winner?: BattleOutcomeUpdateOneWithoutWinningBattleNestedInput
    proposals?: BattleProposalUpdateManyWithoutBattleNestedInput
    votes?: BattleVotingUpdateManyWithoutBattleNestedInput
  }

  export type MABattleUncheckedUpdateWithoutOutcomesInput = {
    id?: StringFieldUpdateOperationsInput | string
    initiatorCardId?: StringFieldUpdateOperationsInput | string
    targetCardId?: StringFieldUpdateOperationsInput | string
    initiatorUserId?: StringFieldUpdateOperationsInput | string
    targetUserId?: NullableStringFieldUpdateOperationsInput | string | null
    battleType?: EnumBattleTypeFieldUpdateOperationsInput | $Enums.BattleType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    stakes?: FloatFieldUpdateOperationsInput | number
    timeline?: DateTimeFieldUpdateOperationsInput | Date | string
    votingPeriod?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBattleStatusFieldUpdateOperationsInput | $Enums.BattleStatus
    resolved?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    participantCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    winner?: BattleOutcomeUncheckedUpdateOneWithoutWinningBattleNestedInput
    proposals?: BattleProposalUncheckedUpdateManyWithoutBattleNestedInput
    votes?: BattleVotingUncheckedUpdateManyWithoutBattleNestedInput
  }

  export type MABattleUpsertWithoutWinnerInput = {
    update: XOR<MABattleUpdateWithoutWinnerInput, MABattleUncheckedUpdateWithoutWinnerInput>
    create: XOR<MABattleCreateWithoutWinnerInput, MABattleUncheckedCreateWithoutWinnerInput>
    where?: MABattleWhereInput
  }

  export type MABattleUpdateToOneWithWhereWithoutWinnerInput = {
    where?: MABattleWhereInput
    data: XOR<MABattleUpdateWithoutWinnerInput, MABattleUncheckedUpdateWithoutWinnerInput>
  }

  export type MABattleUpdateWithoutWinnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    battleType?: EnumBattleTypeFieldUpdateOperationsInput | $Enums.BattleType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    stakes?: FloatFieldUpdateOperationsInput | number
    timeline?: DateTimeFieldUpdateOperationsInput | Date | string
    votingPeriod?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBattleStatusFieldUpdateOperationsInput | $Enums.BattleStatus
    resolved?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    participantCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    initiatorCard?: CardUpdateOneRequiredWithoutInitiatedBattlesNestedInput
    targetCard?: CardUpdateOneRequiredWithoutTargetedBattlesNestedInput
    initiator?: UserUpdateOneRequiredWithoutInitiatedMABattlesNestedInput
    target?: UserUpdateOneWithoutTargetedMABattlesNestedInput
    proposals?: BattleProposalUpdateManyWithoutBattleNestedInput
    votes?: BattleVotingUpdateManyWithoutBattleNestedInput
    outcomes?: BattleOutcomeUpdateManyWithoutBattleNestedInput
  }

  export type MABattleUncheckedUpdateWithoutWinnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    initiatorCardId?: StringFieldUpdateOperationsInput | string
    targetCardId?: StringFieldUpdateOperationsInput | string
    initiatorUserId?: StringFieldUpdateOperationsInput | string
    targetUserId?: NullableStringFieldUpdateOperationsInput | string | null
    battleType?: EnumBattleTypeFieldUpdateOperationsInput | $Enums.BattleType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    stakes?: FloatFieldUpdateOperationsInput | number
    timeline?: DateTimeFieldUpdateOperationsInput | Date | string
    votingPeriod?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBattleStatusFieldUpdateOperationsInput | $Enums.BattleStatus
    resolved?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    participantCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proposals?: BattleProposalUncheckedUpdateManyWithoutBattleNestedInput
    votes?: BattleVotingUncheckedUpdateManyWithoutBattleNestedInput
    outcomes?: BattleOutcomeUncheckedUpdateManyWithoutBattleNestedInput
  }

  export type StakingPositionCreateWithoutPoolInput = {
    id?: string
    amount: number
    stakedAt?: Date | string
    unstakedAt?: Date | string | null
    lockupEndsAt?: Date | string | null
    isActive?: boolean
    user: UserCreateNestedOneWithoutStakingPositionsInput
    rewards?: StakingRewardCreateNestedManyWithoutPositionInput
  }

  export type StakingPositionUncheckedCreateWithoutPoolInput = {
    id?: string
    userId: string
    amount: number
    stakedAt?: Date | string
    unstakedAt?: Date | string | null
    lockupEndsAt?: Date | string | null
    isActive?: boolean
    rewards?: StakingRewardUncheckedCreateNestedManyWithoutPositionInput
  }

  export type StakingPositionCreateOrConnectWithoutPoolInput = {
    where: StakingPositionWhereUniqueInput
    create: XOR<StakingPositionCreateWithoutPoolInput, StakingPositionUncheckedCreateWithoutPoolInput>
  }

  export type StakingPositionCreateManyPoolInputEnvelope = {
    data: StakingPositionCreateManyPoolInput | StakingPositionCreateManyPoolInput[]
    skipDuplicates?: boolean
  }

  export type StakingRewardCreateWithoutPoolInput = {
    id?: string
    amount: number
    rewardType: $Enums.StakingRewardType
    claimedAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutStakingRewardsInput
    position: StakingPositionCreateNestedOneWithoutRewardsInput
  }

  export type StakingRewardUncheckedCreateWithoutPoolInput = {
    id?: string
    userId: string
    positionId: string
    amount: number
    rewardType: $Enums.StakingRewardType
    claimedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type StakingRewardCreateOrConnectWithoutPoolInput = {
    where: StakingRewardWhereUniqueInput
    create: XOR<StakingRewardCreateWithoutPoolInput, StakingRewardUncheckedCreateWithoutPoolInput>
  }

  export type StakingRewardCreateManyPoolInputEnvelope = {
    data: StakingRewardCreateManyPoolInput | StakingRewardCreateManyPoolInput[]
    skipDuplicates?: boolean
  }

  export type StakingPositionUpsertWithWhereUniqueWithoutPoolInput = {
    where: StakingPositionWhereUniqueInput
    update: XOR<StakingPositionUpdateWithoutPoolInput, StakingPositionUncheckedUpdateWithoutPoolInput>
    create: XOR<StakingPositionCreateWithoutPoolInput, StakingPositionUncheckedCreateWithoutPoolInput>
  }

  export type StakingPositionUpdateWithWhereUniqueWithoutPoolInput = {
    where: StakingPositionWhereUniqueInput
    data: XOR<StakingPositionUpdateWithoutPoolInput, StakingPositionUncheckedUpdateWithoutPoolInput>
  }

  export type StakingPositionUpdateManyWithWhereWithoutPoolInput = {
    where: StakingPositionScalarWhereInput
    data: XOR<StakingPositionUpdateManyMutationInput, StakingPositionUncheckedUpdateManyWithoutPoolInput>
  }

  export type StakingRewardUpsertWithWhereUniqueWithoutPoolInput = {
    where: StakingRewardWhereUniqueInput
    update: XOR<StakingRewardUpdateWithoutPoolInput, StakingRewardUncheckedUpdateWithoutPoolInput>
    create: XOR<StakingRewardCreateWithoutPoolInput, StakingRewardUncheckedCreateWithoutPoolInput>
  }

  export type StakingRewardUpdateWithWhereUniqueWithoutPoolInput = {
    where: StakingRewardWhereUniqueInput
    data: XOR<StakingRewardUpdateWithoutPoolInput, StakingRewardUncheckedUpdateWithoutPoolInput>
  }

  export type StakingRewardUpdateManyWithWhereWithoutPoolInput = {
    where: StakingRewardScalarWhereInput
    data: XOR<StakingRewardUpdateManyMutationInput, StakingRewardUncheckedUpdateManyWithoutPoolInput>
  }

  export type UserCreateWithoutStakingPositionsInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    passwordHash?: string | null
    emailVerified?: Date | string | null
    eceBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string
    subscription?: UserSubscriptionCreateNestedOneWithoutUserInput
    cryptoWallets?: CryptoWalletCreateNestedManyWithoutUserInput
    physicalCard?: PhysicalCardCreateNestedOneWithoutUserInput
    ownedCards?: CardCreateNestedManyWithoutOwnerInput
    tradingHistory?: TransactionCreateNestedManyWithoutUserInput
    bids?: BidCreateNestedManyWithoutBidderInput
    listings?: MarketplaceListingCreateNestedManyWithoutSellerInput
    appOrders?: AppOrderCreateNestedManyWithoutUserInput
    orderRevisions?: OrderRevisionCreateNestedManyWithoutUserInput
    orderCommunications?: OrderCommunicationCreateNestedManyWithoutUserInput
    bettingPositions?: BettingPositionCreateNestedManyWithoutUserInput
    bettingPayouts?: BettingPayoutCreateNestedManyWithoutUserInput
    ownedAuctions?: CardAuctionCreateNestedManyWithoutOwnerInput
    wonAuctions?: CardAuctionCreateNestedManyWithoutWinnerInput
    placedAuctionBids?: AuctionBidCreateNestedManyWithoutBidderInput
    watchedAuctions?: AuctionWatcherCreateNestedManyWithoutUserInput
    initiatedMABattles?: MABattleCreateNestedManyWithoutInitiatorInput
    targetedMABattles?: MABattleCreateNestedManyWithoutTargetInput
    battleProposals?: BattleProposalCreateNestedManyWithoutProposerInput
    battleVotes?: BattleVotingCreateNestedManyWithoutVoterInput
    stakingRewards?: StakingRewardCreateNestedManyWithoutUserInput
    governanceProposals?: GovernanceProposalCreateNestedManyWithoutProposerInput
    governanceVotes?: GovernanceVoteCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    socialFeeds?: SocialFeedCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutStakingPositionsInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    passwordHash?: string | null
    emailVerified?: Date | string | null
    eceBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string
    subscription?: UserSubscriptionUncheckedCreateNestedOneWithoutUserInput
    cryptoWallets?: CryptoWalletUncheckedCreateNestedManyWithoutUserInput
    physicalCard?: PhysicalCardUncheckedCreateNestedOneWithoutUserInput
    ownedCards?: CardUncheckedCreateNestedManyWithoutOwnerInput
    tradingHistory?: TransactionUncheckedCreateNestedManyWithoutUserInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderInput
    listings?: MarketplaceListingUncheckedCreateNestedManyWithoutSellerInput
    appOrders?: AppOrderUncheckedCreateNestedManyWithoutUserInput
    orderRevisions?: OrderRevisionUncheckedCreateNestedManyWithoutUserInput
    orderCommunications?: OrderCommunicationUncheckedCreateNestedManyWithoutUserInput
    bettingPositions?: BettingPositionUncheckedCreateNestedManyWithoutUserInput
    bettingPayouts?: BettingPayoutUncheckedCreateNestedManyWithoutUserInput
    ownedAuctions?: CardAuctionUncheckedCreateNestedManyWithoutOwnerInput
    wonAuctions?: CardAuctionUncheckedCreateNestedManyWithoutWinnerInput
    placedAuctionBids?: AuctionBidUncheckedCreateNestedManyWithoutBidderInput
    watchedAuctions?: AuctionWatcherUncheckedCreateNestedManyWithoutUserInput
    initiatedMABattles?: MABattleUncheckedCreateNestedManyWithoutInitiatorInput
    targetedMABattles?: MABattleUncheckedCreateNestedManyWithoutTargetInput
    battleProposals?: BattleProposalUncheckedCreateNestedManyWithoutProposerInput
    battleVotes?: BattleVotingUncheckedCreateNestedManyWithoutVoterInput
    stakingRewards?: StakingRewardUncheckedCreateNestedManyWithoutUserInput
    governanceProposals?: GovernanceProposalUncheckedCreateNestedManyWithoutProposerInput
    governanceVotes?: GovernanceVoteUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    socialFeeds?: SocialFeedUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutStakingPositionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStakingPositionsInput, UserUncheckedCreateWithoutStakingPositionsInput>
  }

  export type StakingPoolCreateWithoutStakesInput = {
    id?: string
    name: string
    description?: string | null
    poolType: $Enums.StakingPoolType
    totalStaked?: number
    totalRewards?: number
    apy?: number
    minStakeAmount?: number
    lockupPeriod?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    rewards?: StakingRewardCreateNestedManyWithoutPoolInput
  }

  export type StakingPoolUncheckedCreateWithoutStakesInput = {
    id?: string
    name: string
    description?: string | null
    poolType: $Enums.StakingPoolType
    totalStaked?: number
    totalRewards?: number
    apy?: number
    minStakeAmount?: number
    lockupPeriod?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    rewards?: StakingRewardUncheckedCreateNestedManyWithoutPoolInput
  }

  export type StakingPoolCreateOrConnectWithoutStakesInput = {
    where: StakingPoolWhereUniqueInput
    create: XOR<StakingPoolCreateWithoutStakesInput, StakingPoolUncheckedCreateWithoutStakesInput>
  }

  export type StakingRewardCreateWithoutPositionInput = {
    id?: string
    amount: number
    rewardType: $Enums.StakingRewardType
    claimedAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutStakingRewardsInput
    pool: StakingPoolCreateNestedOneWithoutRewardsInput
  }

  export type StakingRewardUncheckedCreateWithoutPositionInput = {
    id?: string
    userId: string
    poolId: string
    amount: number
    rewardType: $Enums.StakingRewardType
    claimedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type StakingRewardCreateOrConnectWithoutPositionInput = {
    where: StakingRewardWhereUniqueInput
    create: XOR<StakingRewardCreateWithoutPositionInput, StakingRewardUncheckedCreateWithoutPositionInput>
  }

  export type StakingRewardCreateManyPositionInputEnvelope = {
    data: StakingRewardCreateManyPositionInput | StakingRewardCreateManyPositionInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutStakingPositionsInput = {
    update: XOR<UserUpdateWithoutStakingPositionsInput, UserUncheckedUpdateWithoutStakingPositionsInput>
    create: XOR<UserCreateWithoutStakingPositionsInput, UserUncheckedCreateWithoutStakingPositionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStakingPositionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStakingPositionsInput, UserUncheckedUpdateWithoutStakingPositionsInput>
  }

  export type UserUpdateWithoutStakingPositionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eceBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: UserSubscriptionUpdateOneWithoutUserNestedInput
    cryptoWallets?: CryptoWalletUpdateManyWithoutUserNestedInput
    physicalCard?: PhysicalCardUpdateOneWithoutUserNestedInput
    ownedCards?: CardUpdateManyWithoutOwnerNestedInput
    tradingHistory?: TransactionUpdateManyWithoutUserNestedInput
    bids?: BidUpdateManyWithoutBidderNestedInput
    listings?: MarketplaceListingUpdateManyWithoutSellerNestedInput
    appOrders?: AppOrderUpdateManyWithoutUserNestedInput
    orderRevisions?: OrderRevisionUpdateManyWithoutUserNestedInput
    orderCommunications?: OrderCommunicationUpdateManyWithoutUserNestedInput
    bettingPositions?: BettingPositionUpdateManyWithoutUserNestedInput
    bettingPayouts?: BettingPayoutUpdateManyWithoutUserNestedInput
    ownedAuctions?: CardAuctionUpdateManyWithoutOwnerNestedInput
    wonAuctions?: CardAuctionUpdateManyWithoutWinnerNestedInput
    placedAuctionBids?: AuctionBidUpdateManyWithoutBidderNestedInput
    watchedAuctions?: AuctionWatcherUpdateManyWithoutUserNestedInput
    initiatedMABattles?: MABattleUpdateManyWithoutInitiatorNestedInput
    targetedMABattles?: MABattleUpdateManyWithoutTargetNestedInput
    battleProposals?: BattleProposalUpdateManyWithoutProposerNestedInput
    battleVotes?: BattleVotingUpdateManyWithoutVoterNestedInput
    stakingRewards?: StakingRewardUpdateManyWithoutUserNestedInput
    governanceProposals?: GovernanceProposalUpdateManyWithoutProposerNestedInput
    governanceVotes?: GovernanceVoteUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    socialFeeds?: SocialFeedUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutStakingPositionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eceBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: UserSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    cryptoWallets?: CryptoWalletUncheckedUpdateManyWithoutUserNestedInput
    physicalCard?: PhysicalCardUncheckedUpdateOneWithoutUserNestedInput
    ownedCards?: CardUncheckedUpdateManyWithoutOwnerNestedInput
    tradingHistory?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderNestedInput
    listings?: MarketplaceListingUncheckedUpdateManyWithoutSellerNestedInput
    appOrders?: AppOrderUncheckedUpdateManyWithoutUserNestedInput
    orderRevisions?: OrderRevisionUncheckedUpdateManyWithoutUserNestedInput
    orderCommunications?: OrderCommunicationUncheckedUpdateManyWithoutUserNestedInput
    bettingPositions?: BettingPositionUncheckedUpdateManyWithoutUserNestedInput
    bettingPayouts?: BettingPayoutUncheckedUpdateManyWithoutUserNestedInput
    ownedAuctions?: CardAuctionUncheckedUpdateManyWithoutOwnerNestedInput
    wonAuctions?: CardAuctionUncheckedUpdateManyWithoutWinnerNestedInput
    placedAuctionBids?: AuctionBidUncheckedUpdateManyWithoutBidderNestedInput
    watchedAuctions?: AuctionWatcherUncheckedUpdateManyWithoutUserNestedInput
    initiatedMABattles?: MABattleUncheckedUpdateManyWithoutInitiatorNestedInput
    targetedMABattles?: MABattleUncheckedUpdateManyWithoutTargetNestedInput
    battleProposals?: BattleProposalUncheckedUpdateManyWithoutProposerNestedInput
    battleVotes?: BattleVotingUncheckedUpdateManyWithoutVoterNestedInput
    stakingRewards?: StakingRewardUncheckedUpdateManyWithoutUserNestedInput
    governanceProposals?: GovernanceProposalUncheckedUpdateManyWithoutProposerNestedInput
    governanceVotes?: GovernanceVoteUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    socialFeeds?: SocialFeedUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type StakingPoolUpsertWithoutStakesInput = {
    update: XOR<StakingPoolUpdateWithoutStakesInput, StakingPoolUncheckedUpdateWithoutStakesInput>
    create: XOR<StakingPoolCreateWithoutStakesInput, StakingPoolUncheckedCreateWithoutStakesInput>
    where?: StakingPoolWhereInput
  }

  export type StakingPoolUpdateToOneWithWhereWithoutStakesInput = {
    where?: StakingPoolWhereInput
    data: XOR<StakingPoolUpdateWithoutStakesInput, StakingPoolUncheckedUpdateWithoutStakesInput>
  }

  export type StakingPoolUpdateWithoutStakesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    poolType?: EnumStakingPoolTypeFieldUpdateOperationsInput | $Enums.StakingPoolType
    totalStaked?: FloatFieldUpdateOperationsInput | number
    totalRewards?: FloatFieldUpdateOperationsInput | number
    apy?: FloatFieldUpdateOperationsInput | number
    minStakeAmount?: FloatFieldUpdateOperationsInput | number
    lockupPeriod?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rewards?: StakingRewardUpdateManyWithoutPoolNestedInput
  }

  export type StakingPoolUncheckedUpdateWithoutStakesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    poolType?: EnumStakingPoolTypeFieldUpdateOperationsInput | $Enums.StakingPoolType
    totalStaked?: FloatFieldUpdateOperationsInput | number
    totalRewards?: FloatFieldUpdateOperationsInput | number
    apy?: FloatFieldUpdateOperationsInput | number
    minStakeAmount?: FloatFieldUpdateOperationsInput | number
    lockupPeriod?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rewards?: StakingRewardUncheckedUpdateManyWithoutPoolNestedInput
  }

  export type StakingRewardUpsertWithWhereUniqueWithoutPositionInput = {
    where: StakingRewardWhereUniqueInput
    update: XOR<StakingRewardUpdateWithoutPositionInput, StakingRewardUncheckedUpdateWithoutPositionInput>
    create: XOR<StakingRewardCreateWithoutPositionInput, StakingRewardUncheckedCreateWithoutPositionInput>
  }

  export type StakingRewardUpdateWithWhereUniqueWithoutPositionInput = {
    where: StakingRewardWhereUniqueInput
    data: XOR<StakingRewardUpdateWithoutPositionInput, StakingRewardUncheckedUpdateWithoutPositionInput>
  }

  export type StakingRewardUpdateManyWithWhereWithoutPositionInput = {
    where: StakingRewardScalarWhereInput
    data: XOR<StakingRewardUpdateManyMutationInput, StakingRewardUncheckedUpdateManyWithoutPositionInput>
  }

  export type UserCreateWithoutStakingRewardsInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    passwordHash?: string | null
    emailVerified?: Date | string | null
    eceBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string
    subscription?: UserSubscriptionCreateNestedOneWithoutUserInput
    cryptoWallets?: CryptoWalletCreateNestedManyWithoutUserInput
    physicalCard?: PhysicalCardCreateNestedOneWithoutUserInput
    ownedCards?: CardCreateNestedManyWithoutOwnerInput
    tradingHistory?: TransactionCreateNestedManyWithoutUserInput
    bids?: BidCreateNestedManyWithoutBidderInput
    listings?: MarketplaceListingCreateNestedManyWithoutSellerInput
    appOrders?: AppOrderCreateNestedManyWithoutUserInput
    orderRevisions?: OrderRevisionCreateNestedManyWithoutUserInput
    orderCommunications?: OrderCommunicationCreateNestedManyWithoutUserInput
    bettingPositions?: BettingPositionCreateNestedManyWithoutUserInput
    bettingPayouts?: BettingPayoutCreateNestedManyWithoutUserInput
    ownedAuctions?: CardAuctionCreateNestedManyWithoutOwnerInput
    wonAuctions?: CardAuctionCreateNestedManyWithoutWinnerInput
    placedAuctionBids?: AuctionBidCreateNestedManyWithoutBidderInput
    watchedAuctions?: AuctionWatcherCreateNestedManyWithoutUserInput
    initiatedMABattles?: MABattleCreateNestedManyWithoutInitiatorInput
    targetedMABattles?: MABattleCreateNestedManyWithoutTargetInput
    battleProposals?: BattleProposalCreateNestedManyWithoutProposerInput
    battleVotes?: BattleVotingCreateNestedManyWithoutVoterInput
    stakingPositions?: StakingPositionCreateNestedManyWithoutUserInput
    governanceProposals?: GovernanceProposalCreateNestedManyWithoutProposerInput
    governanceVotes?: GovernanceVoteCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    socialFeeds?: SocialFeedCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutStakingRewardsInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    passwordHash?: string | null
    emailVerified?: Date | string | null
    eceBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string
    subscription?: UserSubscriptionUncheckedCreateNestedOneWithoutUserInput
    cryptoWallets?: CryptoWalletUncheckedCreateNestedManyWithoutUserInput
    physicalCard?: PhysicalCardUncheckedCreateNestedOneWithoutUserInput
    ownedCards?: CardUncheckedCreateNestedManyWithoutOwnerInput
    tradingHistory?: TransactionUncheckedCreateNestedManyWithoutUserInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderInput
    listings?: MarketplaceListingUncheckedCreateNestedManyWithoutSellerInput
    appOrders?: AppOrderUncheckedCreateNestedManyWithoutUserInput
    orderRevisions?: OrderRevisionUncheckedCreateNestedManyWithoutUserInput
    orderCommunications?: OrderCommunicationUncheckedCreateNestedManyWithoutUserInput
    bettingPositions?: BettingPositionUncheckedCreateNestedManyWithoutUserInput
    bettingPayouts?: BettingPayoutUncheckedCreateNestedManyWithoutUserInput
    ownedAuctions?: CardAuctionUncheckedCreateNestedManyWithoutOwnerInput
    wonAuctions?: CardAuctionUncheckedCreateNestedManyWithoutWinnerInput
    placedAuctionBids?: AuctionBidUncheckedCreateNestedManyWithoutBidderInput
    watchedAuctions?: AuctionWatcherUncheckedCreateNestedManyWithoutUserInput
    initiatedMABattles?: MABattleUncheckedCreateNestedManyWithoutInitiatorInput
    targetedMABattles?: MABattleUncheckedCreateNestedManyWithoutTargetInput
    battleProposals?: BattleProposalUncheckedCreateNestedManyWithoutProposerInput
    battleVotes?: BattleVotingUncheckedCreateNestedManyWithoutVoterInput
    stakingPositions?: StakingPositionUncheckedCreateNestedManyWithoutUserInput
    governanceProposals?: GovernanceProposalUncheckedCreateNestedManyWithoutProposerInput
    governanceVotes?: GovernanceVoteUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    socialFeeds?: SocialFeedUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutStakingRewardsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStakingRewardsInput, UserUncheckedCreateWithoutStakingRewardsInput>
  }

  export type StakingPoolCreateWithoutRewardsInput = {
    id?: string
    name: string
    description?: string | null
    poolType: $Enums.StakingPoolType
    totalStaked?: number
    totalRewards?: number
    apy?: number
    minStakeAmount?: number
    lockupPeriod?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stakes?: StakingPositionCreateNestedManyWithoutPoolInput
  }

  export type StakingPoolUncheckedCreateWithoutRewardsInput = {
    id?: string
    name: string
    description?: string | null
    poolType: $Enums.StakingPoolType
    totalStaked?: number
    totalRewards?: number
    apy?: number
    minStakeAmount?: number
    lockupPeriod?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stakes?: StakingPositionUncheckedCreateNestedManyWithoutPoolInput
  }

  export type StakingPoolCreateOrConnectWithoutRewardsInput = {
    where: StakingPoolWhereUniqueInput
    create: XOR<StakingPoolCreateWithoutRewardsInput, StakingPoolUncheckedCreateWithoutRewardsInput>
  }

  export type StakingPositionCreateWithoutRewardsInput = {
    id?: string
    amount: number
    stakedAt?: Date | string
    unstakedAt?: Date | string | null
    lockupEndsAt?: Date | string | null
    isActive?: boolean
    user: UserCreateNestedOneWithoutStakingPositionsInput
    pool: StakingPoolCreateNestedOneWithoutStakesInput
  }

  export type StakingPositionUncheckedCreateWithoutRewardsInput = {
    id?: string
    userId: string
    poolId: string
    amount: number
    stakedAt?: Date | string
    unstakedAt?: Date | string | null
    lockupEndsAt?: Date | string | null
    isActive?: boolean
  }

  export type StakingPositionCreateOrConnectWithoutRewardsInput = {
    where: StakingPositionWhereUniqueInput
    create: XOR<StakingPositionCreateWithoutRewardsInput, StakingPositionUncheckedCreateWithoutRewardsInput>
  }

  export type UserUpsertWithoutStakingRewardsInput = {
    update: XOR<UserUpdateWithoutStakingRewardsInput, UserUncheckedUpdateWithoutStakingRewardsInput>
    create: XOR<UserCreateWithoutStakingRewardsInput, UserUncheckedCreateWithoutStakingRewardsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStakingRewardsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStakingRewardsInput, UserUncheckedUpdateWithoutStakingRewardsInput>
  }

  export type UserUpdateWithoutStakingRewardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eceBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: UserSubscriptionUpdateOneWithoutUserNestedInput
    cryptoWallets?: CryptoWalletUpdateManyWithoutUserNestedInput
    physicalCard?: PhysicalCardUpdateOneWithoutUserNestedInput
    ownedCards?: CardUpdateManyWithoutOwnerNestedInput
    tradingHistory?: TransactionUpdateManyWithoutUserNestedInput
    bids?: BidUpdateManyWithoutBidderNestedInput
    listings?: MarketplaceListingUpdateManyWithoutSellerNestedInput
    appOrders?: AppOrderUpdateManyWithoutUserNestedInput
    orderRevisions?: OrderRevisionUpdateManyWithoutUserNestedInput
    orderCommunications?: OrderCommunicationUpdateManyWithoutUserNestedInput
    bettingPositions?: BettingPositionUpdateManyWithoutUserNestedInput
    bettingPayouts?: BettingPayoutUpdateManyWithoutUserNestedInput
    ownedAuctions?: CardAuctionUpdateManyWithoutOwnerNestedInput
    wonAuctions?: CardAuctionUpdateManyWithoutWinnerNestedInput
    placedAuctionBids?: AuctionBidUpdateManyWithoutBidderNestedInput
    watchedAuctions?: AuctionWatcherUpdateManyWithoutUserNestedInput
    initiatedMABattles?: MABattleUpdateManyWithoutInitiatorNestedInput
    targetedMABattles?: MABattleUpdateManyWithoutTargetNestedInput
    battleProposals?: BattleProposalUpdateManyWithoutProposerNestedInput
    battleVotes?: BattleVotingUpdateManyWithoutVoterNestedInput
    stakingPositions?: StakingPositionUpdateManyWithoutUserNestedInput
    governanceProposals?: GovernanceProposalUpdateManyWithoutProposerNestedInput
    governanceVotes?: GovernanceVoteUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    socialFeeds?: SocialFeedUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutStakingRewardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eceBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: UserSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    cryptoWallets?: CryptoWalletUncheckedUpdateManyWithoutUserNestedInput
    physicalCard?: PhysicalCardUncheckedUpdateOneWithoutUserNestedInput
    ownedCards?: CardUncheckedUpdateManyWithoutOwnerNestedInput
    tradingHistory?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderNestedInput
    listings?: MarketplaceListingUncheckedUpdateManyWithoutSellerNestedInput
    appOrders?: AppOrderUncheckedUpdateManyWithoutUserNestedInput
    orderRevisions?: OrderRevisionUncheckedUpdateManyWithoutUserNestedInput
    orderCommunications?: OrderCommunicationUncheckedUpdateManyWithoutUserNestedInput
    bettingPositions?: BettingPositionUncheckedUpdateManyWithoutUserNestedInput
    bettingPayouts?: BettingPayoutUncheckedUpdateManyWithoutUserNestedInput
    ownedAuctions?: CardAuctionUncheckedUpdateManyWithoutOwnerNestedInput
    wonAuctions?: CardAuctionUncheckedUpdateManyWithoutWinnerNestedInput
    placedAuctionBids?: AuctionBidUncheckedUpdateManyWithoutBidderNestedInput
    watchedAuctions?: AuctionWatcherUncheckedUpdateManyWithoutUserNestedInput
    initiatedMABattles?: MABattleUncheckedUpdateManyWithoutInitiatorNestedInput
    targetedMABattles?: MABattleUncheckedUpdateManyWithoutTargetNestedInput
    battleProposals?: BattleProposalUncheckedUpdateManyWithoutProposerNestedInput
    battleVotes?: BattleVotingUncheckedUpdateManyWithoutVoterNestedInput
    stakingPositions?: StakingPositionUncheckedUpdateManyWithoutUserNestedInput
    governanceProposals?: GovernanceProposalUncheckedUpdateManyWithoutProposerNestedInput
    governanceVotes?: GovernanceVoteUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    socialFeeds?: SocialFeedUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type StakingPoolUpsertWithoutRewardsInput = {
    update: XOR<StakingPoolUpdateWithoutRewardsInput, StakingPoolUncheckedUpdateWithoutRewardsInput>
    create: XOR<StakingPoolCreateWithoutRewardsInput, StakingPoolUncheckedCreateWithoutRewardsInput>
    where?: StakingPoolWhereInput
  }

  export type StakingPoolUpdateToOneWithWhereWithoutRewardsInput = {
    where?: StakingPoolWhereInput
    data: XOR<StakingPoolUpdateWithoutRewardsInput, StakingPoolUncheckedUpdateWithoutRewardsInput>
  }

  export type StakingPoolUpdateWithoutRewardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    poolType?: EnumStakingPoolTypeFieldUpdateOperationsInput | $Enums.StakingPoolType
    totalStaked?: FloatFieldUpdateOperationsInput | number
    totalRewards?: FloatFieldUpdateOperationsInput | number
    apy?: FloatFieldUpdateOperationsInput | number
    minStakeAmount?: FloatFieldUpdateOperationsInput | number
    lockupPeriod?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stakes?: StakingPositionUpdateManyWithoutPoolNestedInput
  }

  export type StakingPoolUncheckedUpdateWithoutRewardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    poolType?: EnumStakingPoolTypeFieldUpdateOperationsInput | $Enums.StakingPoolType
    totalStaked?: FloatFieldUpdateOperationsInput | number
    totalRewards?: FloatFieldUpdateOperationsInput | number
    apy?: FloatFieldUpdateOperationsInput | number
    minStakeAmount?: FloatFieldUpdateOperationsInput | number
    lockupPeriod?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stakes?: StakingPositionUncheckedUpdateManyWithoutPoolNestedInput
  }

  export type StakingPositionUpsertWithoutRewardsInput = {
    update: XOR<StakingPositionUpdateWithoutRewardsInput, StakingPositionUncheckedUpdateWithoutRewardsInput>
    create: XOR<StakingPositionCreateWithoutRewardsInput, StakingPositionUncheckedCreateWithoutRewardsInput>
    where?: StakingPositionWhereInput
  }

  export type StakingPositionUpdateToOneWithWhereWithoutRewardsInput = {
    where?: StakingPositionWhereInput
    data: XOR<StakingPositionUpdateWithoutRewardsInput, StakingPositionUncheckedUpdateWithoutRewardsInput>
  }

  export type StakingPositionUpdateWithoutRewardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    stakedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unstakedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockupEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutStakingPositionsNestedInput
    pool?: StakingPoolUpdateOneRequiredWithoutStakesNestedInput
  }

  export type StakingPositionUncheckedUpdateWithoutRewardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    poolId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    stakedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unstakedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockupEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserCreateWithoutGovernanceProposalsInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    passwordHash?: string | null
    emailVerified?: Date | string | null
    eceBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string
    subscription?: UserSubscriptionCreateNestedOneWithoutUserInput
    cryptoWallets?: CryptoWalletCreateNestedManyWithoutUserInput
    physicalCard?: PhysicalCardCreateNestedOneWithoutUserInput
    ownedCards?: CardCreateNestedManyWithoutOwnerInput
    tradingHistory?: TransactionCreateNestedManyWithoutUserInput
    bids?: BidCreateNestedManyWithoutBidderInput
    listings?: MarketplaceListingCreateNestedManyWithoutSellerInput
    appOrders?: AppOrderCreateNestedManyWithoutUserInput
    orderRevisions?: OrderRevisionCreateNestedManyWithoutUserInput
    orderCommunications?: OrderCommunicationCreateNestedManyWithoutUserInput
    bettingPositions?: BettingPositionCreateNestedManyWithoutUserInput
    bettingPayouts?: BettingPayoutCreateNestedManyWithoutUserInput
    ownedAuctions?: CardAuctionCreateNestedManyWithoutOwnerInput
    wonAuctions?: CardAuctionCreateNestedManyWithoutWinnerInput
    placedAuctionBids?: AuctionBidCreateNestedManyWithoutBidderInput
    watchedAuctions?: AuctionWatcherCreateNestedManyWithoutUserInput
    initiatedMABattles?: MABattleCreateNestedManyWithoutInitiatorInput
    targetedMABattles?: MABattleCreateNestedManyWithoutTargetInput
    battleProposals?: BattleProposalCreateNestedManyWithoutProposerInput
    battleVotes?: BattleVotingCreateNestedManyWithoutVoterInput
    stakingPositions?: StakingPositionCreateNestedManyWithoutUserInput
    stakingRewards?: StakingRewardCreateNestedManyWithoutUserInput
    governanceVotes?: GovernanceVoteCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    socialFeeds?: SocialFeedCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutGovernanceProposalsInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    passwordHash?: string | null
    emailVerified?: Date | string | null
    eceBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string
    subscription?: UserSubscriptionUncheckedCreateNestedOneWithoutUserInput
    cryptoWallets?: CryptoWalletUncheckedCreateNestedManyWithoutUserInput
    physicalCard?: PhysicalCardUncheckedCreateNestedOneWithoutUserInput
    ownedCards?: CardUncheckedCreateNestedManyWithoutOwnerInput
    tradingHistory?: TransactionUncheckedCreateNestedManyWithoutUserInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderInput
    listings?: MarketplaceListingUncheckedCreateNestedManyWithoutSellerInput
    appOrders?: AppOrderUncheckedCreateNestedManyWithoutUserInput
    orderRevisions?: OrderRevisionUncheckedCreateNestedManyWithoutUserInput
    orderCommunications?: OrderCommunicationUncheckedCreateNestedManyWithoutUserInput
    bettingPositions?: BettingPositionUncheckedCreateNestedManyWithoutUserInput
    bettingPayouts?: BettingPayoutUncheckedCreateNestedManyWithoutUserInput
    ownedAuctions?: CardAuctionUncheckedCreateNestedManyWithoutOwnerInput
    wonAuctions?: CardAuctionUncheckedCreateNestedManyWithoutWinnerInput
    placedAuctionBids?: AuctionBidUncheckedCreateNestedManyWithoutBidderInput
    watchedAuctions?: AuctionWatcherUncheckedCreateNestedManyWithoutUserInput
    initiatedMABattles?: MABattleUncheckedCreateNestedManyWithoutInitiatorInput
    targetedMABattles?: MABattleUncheckedCreateNestedManyWithoutTargetInput
    battleProposals?: BattleProposalUncheckedCreateNestedManyWithoutProposerInput
    battleVotes?: BattleVotingUncheckedCreateNestedManyWithoutVoterInput
    stakingPositions?: StakingPositionUncheckedCreateNestedManyWithoutUserInput
    stakingRewards?: StakingRewardUncheckedCreateNestedManyWithoutUserInput
    governanceVotes?: GovernanceVoteUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    socialFeeds?: SocialFeedUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutGovernanceProposalsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGovernanceProposalsInput, UserUncheckedCreateWithoutGovernanceProposalsInput>
  }

  export type GovernanceVoteCreateWithoutProposalInput = {
    id?: string
    voteChoice: $Enums.VoteChoice
    votingPower: number
    reason?: string | null
    votedAt?: Date | string
    user: UserCreateNestedOneWithoutGovernanceVotesInput
  }

  export type GovernanceVoteUncheckedCreateWithoutProposalInput = {
    id?: string
    userId: string
    voteChoice: $Enums.VoteChoice
    votingPower: number
    reason?: string | null
    votedAt?: Date | string
  }

  export type GovernanceVoteCreateOrConnectWithoutProposalInput = {
    where: GovernanceVoteWhereUniqueInput
    create: XOR<GovernanceVoteCreateWithoutProposalInput, GovernanceVoteUncheckedCreateWithoutProposalInput>
  }

  export type GovernanceVoteCreateManyProposalInputEnvelope = {
    data: GovernanceVoteCreateManyProposalInput | GovernanceVoteCreateManyProposalInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutGovernanceProposalsInput = {
    update: XOR<UserUpdateWithoutGovernanceProposalsInput, UserUncheckedUpdateWithoutGovernanceProposalsInput>
    create: XOR<UserCreateWithoutGovernanceProposalsInput, UserUncheckedCreateWithoutGovernanceProposalsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGovernanceProposalsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGovernanceProposalsInput, UserUncheckedUpdateWithoutGovernanceProposalsInput>
  }

  export type UserUpdateWithoutGovernanceProposalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eceBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: UserSubscriptionUpdateOneWithoutUserNestedInput
    cryptoWallets?: CryptoWalletUpdateManyWithoutUserNestedInput
    physicalCard?: PhysicalCardUpdateOneWithoutUserNestedInput
    ownedCards?: CardUpdateManyWithoutOwnerNestedInput
    tradingHistory?: TransactionUpdateManyWithoutUserNestedInput
    bids?: BidUpdateManyWithoutBidderNestedInput
    listings?: MarketplaceListingUpdateManyWithoutSellerNestedInput
    appOrders?: AppOrderUpdateManyWithoutUserNestedInput
    orderRevisions?: OrderRevisionUpdateManyWithoutUserNestedInput
    orderCommunications?: OrderCommunicationUpdateManyWithoutUserNestedInput
    bettingPositions?: BettingPositionUpdateManyWithoutUserNestedInput
    bettingPayouts?: BettingPayoutUpdateManyWithoutUserNestedInput
    ownedAuctions?: CardAuctionUpdateManyWithoutOwnerNestedInput
    wonAuctions?: CardAuctionUpdateManyWithoutWinnerNestedInput
    placedAuctionBids?: AuctionBidUpdateManyWithoutBidderNestedInput
    watchedAuctions?: AuctionWatcherUpdateManyWithoutUserNestedInput
    initiatedMABattles?: MABattleUpdateManyWithoutInitiatorNestedInput
    targetedMABattles?: MABattleUpdateManyWithoutTargetNestedInput
    battleProposals?: BattleProposalUpdateManyWithoutProposerNestedInput
    battleVotes?: BattleVotingUpdateManyWithoutVoterNestedInput
    stakingPositions?: StakingPositionUpdateManyWithoutUserNestedInput
    stakingRewards?: StakingRewardUpdateManyWithoutUserNestedInput
    governanceVotes?: GovernanceVoteUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    socialFeeds?: SocialFeedUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutGovernanceProposalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eceBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: UserSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    cryptoWallets?: CryptoWalletUncheckedUpdateManyWithoutUserNestedInput
    physicalCard?: PhysicalCardUncheckedUpdateOneWithoutUserNestedInput
    ownedCards?: CardUncheckedUpdateManyWithoutOwnerNestedInput
    tradingHistory?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderNestedInput
    listings?: MarketplaceListingUncheckedUpdateManyWithoutSellerNestedInput
    appOrders?: AppOrderUncheckedUpdateManyWithoutUserNestedInput
    orderRevisions?: OrderRevisionUncheckedUpdateManyWithoutUserNestedInput
    orderCommunications?: OrderCommunicationUncheckedUpdateManyWithoutUserNestedInput
    bettingPositions?: BettingPositionUncheckedUpdateManyWithoutUserNestedInput
    bettingPayouts?: BettingPayoutUncheckedUpdateManyWithoutUserNestedInput
    ownedAuctions?: CardAuctionUncheckedUpdateManyWithoutOwnerNestedInput
    wonAuctions?: CardAuctionUncheckedUpdateManyWithoutWinnerNestedInput
    placedAuctionBids?: AuctionBidUncheckedUpdateManyWithoutBidderNestedInput
    watchedAuctions?: AuctionWatcherUncheckedUpdateManyWithoutUserNestedInput
    initiatedMABattles?: MABattleUncheckedUpdateManyWithoutInitiatorNestedInput
    targetedMABattles?: MABattleUncheckedUpdateManyWithoutTargetNestedInput
    battleProposals?: BattleProposalUncheckedUpdateManyWithoutProposerNestedInput
    battleVotes?: BattleVotingUncheckedUpdateManyWithoutVoterNestedInput
    stakingPositions?: StakingPositionUncheckedUpdateManyWithoutUserNestedInput
    stakingRewards?: StakingRewardUncheckedUpdateManyWithoutUserNestedInput
    governanceVotes?: GovernanceVoteUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    socialFeeds?: SocialFeedUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type GovernanceVoteUpsertWithWhereUniqueWithoutProposalInput = {
    where: GovernanceVoteWhereUniqueInput
    update: XOR<GovernanceVoteUpdateWithoutProposalInput, GovernanceVoteUncheckedUpdateWithoutProposalInput>
    create: XOR<GovernanceVoteCreateWithoutProposalInput, GovernanceVoteUncheckedCreateWithoutProposalInput>
  }

  export type GovernanceVoteUpdateWithWhereUniqueWithoutProposalInput = {
    where: GovernanceVoteWhereUniqueInput
    data: XOR<GovernanceVoteUpdateWithoutProposalInput, GovernanceVoteUncheckedUpdateWithoutProposalInput>
  }

  export type GovernanceVoteUpdateManyWithWhereWithoutProposalInput = {
    where: GovernanceVoteScalarWhereInput
    data: XOR<GovernanceVoteUpdateManyMutationInput, GovernanceVoteUncheckedUpdateManyWithoutProposalInput>
  }

  export type GovernanceProposalCreateWithoutVotesInput = {
    id?: string
    title: string
    description: string
    proposalType: $Enums.ProposalType
    status?: $Enums.GovernanceStatus
    votingStartsAt: Date | string
    votingEndsAt: Date | string
    executionDate?: Date | string | null
    minQuorum?: number
    minApproval?: number
    totalVotes?: number
    yesVotes?: number
    noVotes?: number
    abstainVotes?: number
    isExecuted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    proposer: UserCreateNestedOneWithoutGovernanceProposalsInput
  }

  export type GovernanceProposalUncheckedCreateWithoutVotesInput = {
    id?: string
    title: string
    description: string
    proposalType: $Enums.ProposalType
    proposerId: string
    status?: $Enums.GovernanceStatus
    votingStartsAt: Date | string
    votingEndsAt: Date | string
    executionDate?: Date | string | null
    minQuorum?: number
    minApproval?: number
    totalVotes?: number
    yesVotes?: number
    noVotes?: number
    abstainVotes?: number
    isExecuted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
  }

  export type GovernanceProposalCreateOrConnectWithoutVotesInput = {
    where: GovernanceProposalWhereUniqueInput
    create: XOR<GovernanceProposalCreateWithoutVotesInput, GovernanceProposalUncheckedCreateWithoutVotesInput>
  }

  export type UserCreateWithoutGovernanceVotesInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    passwordHash?: string | null
    emailVerified?: Date | string | null
    eceBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string
    subscription?: UserSubscriptionCreateNestedOneWithoutUserInput
    cryptoWallets?: CryptoWalletCreateNestedManyWithoutUserInput
    physicalCard?: PhysicalCardCreateNestedOneWithoutUserInput
    ownedCards?: CardCreateNestedManyWithoutOwnerInput
    tradingHistory?: TransactionCreateNestedManyWithoutUserInput
    bids?: BidCreateNestedManyWithoutBidderInput
    listings?: MarketplaceListingCreateNestedManyWithoutSellerInput
    appOrders?: AppOrderCreateNestedManyWithoutUserInput
    orderRevisions?: OrderRevisionCreateNestedManyWithoutUserInput
    orderCommunications?: OrderCommunicationCreateNestedManyWithoutUserInput
    bettingPositions?: BettingPositionCreateNestedManyWithoutUserInput
    bettingPayouts?: BettingPayoutCreateNestedManyWithoutUserInput
    ownedAuctions?: CardAuctionCreateNestedManyWithoutOwnerInput
    wonAuctions?: CardAuctionCreateNestedManyWithoutWinnerInput
    placedAuctionBids?: AuctionBidCreateNestedManyWithoutBidderInput
    watchedAuctions?: AuctionWatcherCreateNestedManyWithoutUserInput
    initiatedMABattles?: MABattleCreateNestedManyWithoutInitiatorInput
    targetedMABattles?: MABattleCreateNestedManyWithoutTargetInput
    battleProposals?: BattleProposalCreateNestedManyWithoutProposerInput
    battleVotes?: BattleVotingCreateNestedManyWithoutVoterInput
    stakingPositions?: StakingPositionCreateNestedManyWithoutUserInput
    stakingRewards?: StakingRewardCreateNestedManyWithoutUserInput
    governanceProposals?: GovernanceProposalCreateNestedManyWithoutProposerInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    socialFeeds?: SocialFeedCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutGovernanceVotesInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    passwordHash?: string | null
    emailVerified?: Date | string | null
    eceBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string
    subscription?: UserSubscriptionUncheckedCreateNestedOneWithoutUserInput
    cryptoWallets?: CryptoWalletUncheckedCreateNestedManyWithoutUserInput
    physicalCard?: PhysicalCardUncheckedCreateNestedOneWithoutUserInput
    ownedCards?: CardUncheckedCreateNestedManyWithoutOwnerInput
    tradingHistory?: TransactionUncheckedCreateNestedManyWithoutUserInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderInput
    listings?: MarketplaceListingUncheckedCreateNestedManyWithoutSellerInput
    appOrders?: AppOrderUncheckedCreateNestedManyWithoutUserInput
    orderRevisions?: OrderRevisionUncheckedCreateNestedManyWithoutUserInput
    orderCommunications?: OrderCommunicationUncheckedCreateNestedManyWithoutUserInput
    bettingPositions?: BettingPositionUncheckedCreateNestedManyWithoutUserInput
    bettingPayouts?: BettingPayoutUncheckedCreateNestedManyWithoutUserInput
    ownedAuctions?: CardAuctionUncheckedCreateNestedManyWithoutOwnerInput
    wonAuctions?: CardAuctionUncheckedCreateNestedManyWithoutWinnerInput
    placedAuctionBids?: AuctionBidUncheckedCreateNestedManyWithoutBidderInput
    watchedAuctions?: AuctionWatcherUncheckedCreateNestedManyWithoutUserInput
    initiatedMABattles?: MABattleUncheckedCreateNestedManyWithoutInitiatorInput
    targetedMABattles?: MABattleUncheckedCreateNestedManyWithoutTargetInput
    battleProposals?: BattleProposalUncheckedCreateNestedManyWithoutProposerInput
    battleVotes?: BattleVotingUncheckedCreateNestedManyWithoutVoterInput
    stakingPositions?: StakingPositionUncheckedCreateNestedManyWithoutUserInput
    stakingRewards?: StakingRewardUncheckedCreateNestedManyWithoutUserInput
    governanceProposals?: GovernanceProposalUncheckedCreateNestedManyWithoutProposerInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    socialFeeds?: SocialFeedUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutGovernanceVotesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGovernanceVotesInput, UserUncheckedCreateWithoutGovernanceVotesInput>
  }

  export type GovernanceProposalUpsertWithoutVotesInput = {
    update: XOR<GovernanceProposalUpdateWithoutVotesInput, GovernanceProposalUncheckedUpdateWithoutVotesInput>
    create: XOR<GovernanceProposalCreateWithoutVotesInput, GovernanceProposalUncheckedCreateWithoutVotesInput>
    where?: GovernanceProposalWhereInput
  }

  export type GovernanceProposalUpdateToOneWithWhereWithoutVotesInput = {
    where?: GovernanceProposalWhereInput
    data: XOR<GovernanceProposalUpdateWithoutVotesInput, GovernanceProposalUncheckedUpdateWithoutVotesInput>
  }

  export type GovernanceProposalUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    proposalType?: EnumProposalTypeFieldUpdateOperationsInput | $Enums.ProposalType
    status?: EnumGovernanceStatusFieldUpdateOperationsInput | $Enums.GovernanceStatus
    votingStartsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votingEndsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    minQuorum?: FloatFieldUpdateOperationsInput | number
    minApproval?: FloatFieldUpdateOperationsInput | number
    totalVotes?: FloatFieldUpdateOperationsInput | number
    yesVotes?: FloatFieldUpdateOperationsInput | number
    noVotes?: FloatFieldUpdateOperationsInput | number
    abstainVotes?: FloatFieldUpdateOperationsInput | number
    isExecuted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    proposer?: UserUpdateOneRequiredWithoutGovernanceProposalsNestedInput
  }

  export type GovernanceProposalUncheckedUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    proposalType?: EnumProposalTypeFieldUpdateOperationsInput | $Enums.ProposalType
    proposerId?: StringFieldUpdateOperationsInput | string
    status?: EnumGovernanceStatusFieldUpdateOperationsInput | $Enums.GovernanceStatus
    votingStartsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votingEndsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    minQuorum?: FloatFieldUpdateOperationsInput | number
    minApproval?: FloatFieldUpdateOperationsInput | number
    totalVotes?: FloatFieldUpdateOperationsInput | number
    yesVotes?: FloatFieldUpdateOperationsInput | number
    noVotes?: FloatFieldUpdateOperationsInput | number
    abstainVotes?: FloatFieldUpdateOperationsInput | number
    isExecuted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserUpsertWithoutGovernanceVotesInput = {
    update: XOR<UserUpdateWithoutGovernanceVotesInput, UserUncheckedUpdateWithoutGovernanceVotesInput>
    create: XOR<UserCreateWithoutGovernanceVotesInput, UserUncheckedCreateWithoutGovernanceVotesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGovernanceVotesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGovernanceVotesInput, UserUncheckedUpdateWithoutGovernanceVotesInput>
  }

  export type UserUpdateWithoutGovernanceVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eceBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: UserSubscriptionUpdateOneWithoutUserNestedInput
    cryptoWallets?: CryptoWalletUpdateManyWithoutUserNestedInput
    physicalCard?: PhysicalCardUpdateOneWithoutUserNestedInput
    ownedCards?: CardUpdateManyWithoutOwnerNestedInput
    tradingHistory?: TransactionUpdateManyWithoutUserNestedInput
    bids?: BidUpdateManyWithoutBidderNestedInput
    listings?: MarketplaceListingUpdateManyWithoutSellerNestedInput
    appOrders?: AppOrderUpdateManyWithoutUserNestedInput
    orderRevisions?: OrderRevisionUpdateManyWithoutUserNestedInput
    orderCommunications?: OrderCommunicationUpdateManyWithoutUserNestedInput
    bettingPositions?: BettingPositionUpdateManyWithoutUserNestedInput
    bettingPayouts?: BettingPayoutUpdateManyWithoutUserNestedInput
    ownedAuctions?: CardAuctionUpdateManyWithoutOwnerNestedInput
    wonAuctions?: CardAuctionUpdateManyWithoutWinnerNestedInput
    placedAuctionBids?: AuctionBidUpdateManyWithoutBidderNestedInput
    watchedAuctions?: AuctionWatcherUpdateManyWithoutUserNestedInput
    initiatedMABattles?: MABattleUpdateManyWithoutInitiatorNestedInput
    targetedMABattles?: MABattleUpdateManyWithoutTargetNestedInput
    battleProposals?: BattleProposalUpdateManyWithoutProposerNestedInput
    battleVotes?: BattleVotingUpdateManyWithoutVoterNestedInput
    stakingPositions?: StakingPositionUpdateManyWithoutUserNestedInput
    stakingRewards?: StakingRewardUpdateManyWithoutUserNestedInput
    governanceProposals?: GovernanceProposalUpdateManyWithoutProposerNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    socialFeeds?: SocialFeedUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutGovernanceVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eceBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: UserSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    cryptoWallets?: CryptoWalletUncheckedUpdateManyWithoutUserNestedInput
    physicalCard?: PhysicalCardUncheckedUpdateOneWithoutUserNestedInput
    ownedCards?: CardUncheckedUpdateManyWithoutOwnerNestedInput
    tradingHistory?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderNestedInput
    listings?: MarketplaceListingUncheckedUpdateManyWithoutSellerNestedInput
    appOrders?: AppOrderUncheckedUpdateManyWithoutUserNestedInput
    orderRevisions?: OrderRevisionUncheckedUpdateManyWithoutUserNestedInput
    orderCommunications?: OrderCommunicationUncheckedUpdateManyWithoutUserNestedInput
    bettingPositions?: BettingPositionUncheckedUpdateManyWithoutUserNestedInput
    bettingPayouts?: BettingPayoutUncheckedUpdateManyWithoutUserNestedInput
    ownedAuctions?: CardAuctionUncheckedUpdateManyWithoutOwnerNestedInput
    wonAuctions?: CardAuctionUncheckedUpdateManyWithoutWinnerNestedInput
    placedAuctionBids?: AuctionBidUncheckedUpdateManyWithoutBidderNestedInput
    watchedAuctions?: AuctionWatcherUncheckedUpdateManyWithoutUserNestedInput
    initiatedMABattles?: MABattleUncheckedUpdateManyWithoutInitiatorNestedInput
    targetedMABattles?: MABattleUncheckedUpdateManyWithoutTargetNestedInput
    battleProposals?: BattleProposalUncheckedUpdateManyWithoutProposerNestedInput
    battleVotes?: BattleVotingUncheckedUpdateManyWithoutVoterNestedInput
    stakingPositions?: StakingPositionUncheckedUpdateManyWithoutUserNestedInput
    stakingRewards?: StakingRewardUncheckedUpdateManyWithoutUserNestedInput
    governanceProposals?: GovernanceProposalUncheckedUpdateManyWithoutProposerNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    socialFeeds?: SocialFeedUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type CryptoWalletCreateManyUserInput = {
    id?: string
    currency: string
    address: string
    balance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CardCreateManyOwnerInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.CardCategory
    rarity: $Enums.CardRarity
    company?: string | null
    currentPrice: number
    historicalPrices?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    stats?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateManyUserInput = {
    id?: string
    cardId?: string | null
    type: $Enums.TransactionType
    amount: number
    currency?: string
    status?: $Enums.TransactionStatus
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: string | null
    paymentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BidCreateManyBidderInput = {
    id?: string
    listingId: string
    cardId: string
    amount: number
    status?: $Enums.BidStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketplaceListingCreateManySellerInput = {
    id?: string
    cardId: string
    price: number
    listingType?: $Enums.ListingType
    auctionEnd?: Date | string | null
    status?: $Enums.ListingStatus
    featured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppOrderCreateManyUserInput = {
    id?: string
    projectType: $Enums.ProjectType
    title: string
    description: string
    requirements?: NullableJsonNullValueInput | InputJsonValue
    timeline: $Enums.OrderTimeline
    estimatedCost: number
    actualCost?: number | null
    currency?: string
    status?: $Enums.OrderStatus
    priority?: $Enums.OrderPriority
    deliveryDate?: Date | string | null
    githubRepo?: string | null
    vercelLink?: string | null
    downloadLink?: string | null
    progressPercentage?: number
    currentMilestone?: string | null
    assignedAdminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderRevisionCreateManyUserInput = {
    id?: string
    orderId: string
    revisionNumber: number
    title: string
    description: string
    status?: $Enums.RevisionStatus
    adminResponse?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCommunicationCreateManyUserInput = {
    id?: string
    orderId: string
    messageType: $Enums.CommunicationType
    subject?: string | null
    message: string
    isFromAdmin?: boolean
    attachments?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    important?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BettingPositionCreateManyUserInput = {
    id?: string
    marketId: string
    position: $Enums.PredictionDirection
    amount: number
    odds: number
    potentialWinning: number
    pickGroupId?: string | null
    multiplier?: number
    powerPlay?: boolean
    status?: $Enums.PositionStatus
    settled?: boolean
    won?: boolean | null
    payout?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BettingPayoutCreateManyUserInput = {
    id?: string
    marketId: string
    positionId: string
    winnings: number
    originalBet: number
    multiplier: number
    status?: $Enums.PayoutStatus
    payoutDate?: Date | string | null
    transactionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CardAuctionCreateManyOwnerInput = {
    id?: string
    cardId: string
    title: string
    description?: string | null
    startPrice: number
    reservePrice?: number | null
    currentBid?: number | null
    bidIncrement?: number
    startTime?: Date | string
    endTime: Date | string
    autoExtend?: boolean
    status?: $Enums.AuctionStatus
    finalized?: boolean
    winnerId?: string | null
    viewCount?: number
    watcherCount?: number
    bidCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CardAuctionCreateManyWinnerInput = {
    id?: string
    cardId: string
    ownerId: string
    title: string
    description?: string | null
    startPrice: number
    reservePrice?: number | null
    currentBid?: number | null
    bidIncrement?: number
    startTime?: Date | string
    endTime: Date | string
    autoExtend?: boolean
    status?: $Enums.AuctionStatus
    finalized?: boolean
    viewCount?: number
    watcherCount?: number
    bidCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuctionBidCreateManyBidderInput = {
    id?: string
    auctionId: string
    bidAmount: number
    maxAutoBid?: number | null
    bidType?: $Enums.BidType
    status?: $Enums.AuctionBidStatus
    isWinning?: boolean
    outbidNotified?: boolean
    userAgent?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuctionWatcherCreateManyUserInput = {
    id?: string
    auctionId: string
    bidNotifications?: boolean
    endingNotifications?: boolean
    priceAlerts?: boolean
    alertThreshold?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MABattleCreateManyInitiatorInput = {
    id?: string
    initiatorCardId: string
    targetCardId: string
    targetUserId?: string | null
    battleType: $Enums.BattleType
    title: string
    description: string
    stakes: number
    timeline: Date | string
    votingPeriod: Date | string
    status?: $Enums.BattleStatus
    resolved?: boolean
    viewCount?: number
    participantCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MABattleCreateManyTargetInput = {
    id?: string
    initiatorCardId: string
    targetCardId: string
    initiatorUserId: string
    battleType: $Enums.BattleType
    title: string
    description: string
    stakes: number
    timeline: Date | string
    votingPeriod: Date | string
    status?: $Enums.BattleStatus
    resolved?: boolean
    viewCount?: number
    participantCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BattleProposalCreateManyProposerInput = {
    id?: string
    battleId: string
    proposalType: $Enums.ProposalType
    title: string
    description: string
    terms: JsonNullValueInput | InputJsonValue
    valuation: number
    paymentStructure: JsonNullValueInput | InputJsonValue
    timeline: JsonNullValueInput | InputJsonValue
    synergies: JsonNullValueInput | InputJsonValue
    conditions: JsonNullValueInput | InputJsonValue
    contingencies: JsonNullValueInput | InputJsonValue
    status?: $Enums.ProposalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BattleVotingCreateManyVoterInput = {
    id?: string
    battleId: string
    proposalId?: string | null
    vote: $Enums.VoteDirection
    voteWeight: number
    reasoning?: string | null
    confidence?: number | null
    eceStaked?: number | null
    expertRating?: number | null
    portfolioValue?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StakingPositionCreateManyUserInput = {
    id?: string
    poolId: string
    amount: number
    stakedAt?: Date | string
    unstakedAt?: Date | string | null
    lockupEndsAt?: Date | string | null
    isActive?: boolean
  }

  export type StakingRewardCreateManyUserInput = {
    id?: string
    poolId: string
    positionId: string
    amount: number
    rewardType: $Enums.StakingRewardType
    claimedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type GovernanceProposalCreateManyProposerInput = {
    id?: string
    title: string
    description: string
    proposalType: $Enums.ProposalType
    status?: $Enums.GovernanceStatus
    votingStartsAt: Date | string
    votingEndsAt: Date | string
    executionDate?: Date | string | null
    minQuorum?: number
    minApproval?: number
    totalVotes?: number
    yesVotes?: number
    noVotes?: number
    abstainVotes?: number
    isExecuted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
  }

  export type GovernanceVoteCreateManyUserInput = {
    id?: string
    proposalId: string
    voteChoice: $Enums.VoteChoice
    votingPower: number
    reason?: string | null
    votedAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    priority?: $Enums.NotificationPriority
    requiresSubscription?: $Enums.SubscriptionPlan | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SocialFeedCreateManyUserInput = {
    id?: string
    type: $Enums.SocialFeedType
    content: string
    data?: NullableJsonNullValueInput | InputJsonValue
    likes?: number
    comments?: number
    shares?: number
    visibility?: $Enums.SocialVisibility
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FollowCreateManyFollowerInput = {
    id?: string
    followingId: string
    createdAt?: Date | string
  }

  export type FollowCreateManyFollowingInput = {
    id?: string
    followerId: string
    createdAt?: Date | string
  }

  export type CryptoWalletUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CryptoWalletUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CryptoWalletUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CardUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCardCategoryFieldUpdateOperationsInput | $Enums.CardCategory
    rarity?: EnumCardRarityFieldUpdateOperationsInput | $Enums.CardRarity
    company?: NullableStringFieldUpdateOperationsInput | string | null
    currentPrice?: FloatFieldUpdateOperationsInput | number
    historicalPrices?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    stats?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listing?: MarketplaceListingUpdateOneWithoutCardNestedInput
    bids?: BidUpdateManyWithoutCardNestedInput
    transactions?: TransactionUpdateManyWithoutCardNestedInput
    bettingMarkets?: BettingMarketUpdateManyWithoutCardNestedInput
    marketMetrics?: MarketMetricsUpdateManyWithoutCardNestedInput
    auction?: CardAuctionUpdateOneWithoutCardNestedInput
    auctionHistory?: AuctionHistoryUpdateManyWithoutCardNestedInput
    initiatedBattles?: MABattleUpdateManyWithoutInitiatorCardNestedInput
    targetedBattles?: MABattleUpdateManyWithoutTargetCardNestedInput
  }

  export type CardUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCardCategoryFieldUpdateOperationsInput | $Enums.CardCategory
    rarity?: EnumCardRarityFieldUpdateOperationsInput | $Enums.CardRarity
    company?: NullableStringFieldUpdateOperationsInput | string | null
    currentPrice?: FloatFieldUpdateOperationsInput | number
    historicalPrices?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    stats?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listing?: MarketplaceListingUncheckedUpdateOneWithoutCardNestedInput
    bids?: BidUncheckedUpdateManyWithoutCardNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCardNestedInput
    bettingMarkets?: BettingMarketUncheckedUpdateManyWithoutCardNestedInput
    marketMetrics?: MarketMetricsUncheckedUpdateManyWithoutCardNestedInput
    auction?: CardAuctionUncheckedUpdateOneWithoutCardNestedInput
    auctionHistory?: AuctionHistoryUncheckedUpdateManyWithoutCardNestedInput
    initiatedBattles?: MABattleUncheckedUpdateManyWithoutInitiatorCardNestedInput
    targetedBattles?: MABattleUncheckedUpdateManyWithoutTargetCardNestedInput
  }

  export type CardUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCardCategoryFieldUpdateOperationsInput | $Enums.CardCategory
    rarity?: EnumCardRarityFieldUpdateOperationsInput | $Enums.CardRarity
    company?: NullableStringFieldUpdateOperationsInput | string | null
    currentPrice?: FloatFieldUpdateOperationsInput | number
    historicalPrices?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    stats?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    card?: CardUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BidUpdateWithoutBidderInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumBidStatusFieldUpdateOperationsInput | $Enums.BidStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listing?: MarketplaceListingUpdateOneRequiredWithoutBidsNestedInput
    card?: CardUpdateOneRequiredWithoutBidsNestedInput
  }

  export type BidUncheckedUpdateWithoutBidderInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    cardId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumBidStatusFieldUpdateOperationsInput | $Enums.BidStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BidUncheckedUpdateManyWithoutBidderInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    cardId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumBidStatusFieldUpdateOperationsInput | $Enums.BidStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketplaceListingUpdateWithoutSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    listingType?: EnumListingTypeFieldUpdateOperationsInput | $Enums.ListingType
    auctionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    featured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    card?: CardUpdateOneRequiredWithoutListingNestedInput
    bids?: BidUpdateManyWithoutListingNestedInput
  }

  export type MarketplaceListingUncheckedUpdateWithoutSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    listingType?: EnumListingTypeFieldUpdateOperationsInput | $Enums.ListingType
    auctionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    featured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bids?: BidUncheckedUpdateManyWithoutListingNestedInput
  }

  export type MarketplaceListingUncheckedUpdateManyWithoutSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    listingType?: EnumListingTypeFieldUpdateOperationsInput | $Enums.ListingType
    auctionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    featured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppOrderUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectType?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requirements?: NullableJsonNullValueInput | InputJsonValue
    timeline?: EnumOrderTimelineFieldUpdateOperationsInput | $Enums.OrderTimeline
    estimatedCost?: FloatFieldUpdateOperationsInput | number
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    priority?: EnumOrderPriorityFieldUpdateOperationsInput | $Enums.OrderPriority
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    githubRepo?: NullableStringFieldUpdateOperationsInput | string | null
    vercelLink?: NullableStringFieldUpdateOperationsInput | string | null
    downloadLink?: NullableStringFieldUpdateOperationsInput | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
    currentMilestone?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revisions?: OrderRevisionUpdateManyWithoutOrderNestedInput
    communications?: OrderCommunicationUpdateManyWithoutOrderNestedInput
    deliverables?: OrderDeliverableUpdateManyWithoutOrderNestedInput
  }

  export type AppOrderUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectType?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requirements?: NullableJsonNullValueInput | InputJsonValue
    timeline?: EnumOrderTimelineFieldUpdateOperationsInput | $Enums.OrderTimeline
    estimatedCost?: FloatFieldUpdateOperationsInput | number
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    priority?: EnumOrderPriorityFieldUpdateOperationsInput | $Enums.OrderPriority
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    githubRepo?: NullableStringFieldUpdateOperationsInput | string | null
    vercelLink?: NullableStringFieldUpdateOperationsInput | string | null
    downloadLink?: NullableStringFieldUpdateOperationsInput | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
    currentMilestone?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revisions?: OrderRevisionUncheckedUpdateManyWithoutOrderNestedInput
    communications?: OrderCommunicationUncheckedUpdateManyWithoutOrderNestedInput
    deliverables?: OrderDeliverableUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type AppOrderUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectType?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requirements?: NullableJsonNullValueInput | InputJsonValue
    timeline?: EnumOrderTimelineFieldUpdateOperationsInput | $Enums.OrderTimeline
    estimatedCost?: FloatFieldUpdateOperationsInput | number
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    priority?: EnumOrderPriorityFieldUpdateOperationsInput | $Enums.OrderPriority
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    githubRepo?: NullableStringFieldUpdateOperationsInput | string | null
    vercelLink?: NullableStringFieldUpdateOperationsInput | string | null
    downloadLink?: NullableStringFieldUpdateOperationsInput | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
    currentMilestone?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderRevisionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    revisionNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumRevisionStatusFieldUpdateOperationsInput | $Enums.RevisionStatus
    adminResponse?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: AppOrderUpdateOneRequiredWithoutRevisionsNestedInput
  }

  export type OrderRevisionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    revisionNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumRevisionStatusFieldUpdateOperationsInput | $Enums.RevisionStatus
    adminResponse?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderRevisionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    revisionNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumRevisionStatusFieldUpdateOperationsInput | $Enums.RevisionStatus
    adminResponse?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCommunicationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageType?: EnumCommunicationTypeFieldUpdateOperationsInput | $Enums.CommunicationType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    isFromAdmin?: BoolFieldUpdateOperationsInput | boolean
    attachments?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    important?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: AppOrderUpdateOneRequiredWithoutCommunicationsNestedInput
  }

  export type OrderCommunicationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    messageType?: EnumCommunicationTypeFieldUpdateOperationsInput | $Enums.CommunicationType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    isFromAdmin?: BoolFieldUpdateOperationsInput | boolean
    attachments?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    important?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCommunicationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    messageType?: EnumCommunicationTypeFieldUpdateOperationsInput | $Enums.CommunicationType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    isFromAdmin?: BoolFieldUpdateOperationsInput | boolean
    attachments?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    important?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BettingPositionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: EnumPredictionDirectionFieldUpdateOperationsInput | $Enums.PredictionDirection
    amount?: FloatFieldUpdateOperationsInput | number
    odds?: FloatFieldUpdateOperationsInput | number
    potentialWinning?: FloatFieldUpdateOperationsInput | number
    pickGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    multiplier?: FloatFieldUpdateOperationsInput | number
    powerPlay?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumPositionStatusFieldUpdateOperationsInput | $Enums.PositionStatus
    settled?: BoolFieldUpdateOperationsInput | boolean
    won?: NullableBoolFieldUpdateOperationsInput | boolean | null
    payout?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    market?: BettingMarketUpdateOneRequiredWithoutPositionsNestedInput
  }

  export type BettingPositionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    marketId?: StringFieldUpdateOperationsInput | string
    position?: EnumPredictionDirectionFieldUpdateOperationsInput | $Enums.PredictionDirection
    amount?: FloatFieldUpdateOperationsInput | number
    odds?: FloatFieldUpdateOperationsInput | number
    potentialWinning?: FloatFieldUpdateOperationsInput | number
    pickGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    multiplier?: FloatFieldUpdateOperationsInput | number
    powerPlay?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumPositionStatusFieldUpdateOperationsInput | $Enums.PositionStatus
    settled?: BoolFieldUpdateOperationsInput | boolean
    won?: NullableBoolFieldUpdateOperationsInput | boolean | null
    payout?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BettingPositionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    marketId?: StringFieldUpdateOperationsInput | string
    position?: EnumPredictionDirectionFieldUpdateOperationsInput | $Enums.PredictionDirection
    amount?: FloatFieldUpdateOperationsInput | number
    odds?: FloatFieldUpdateOperationsInput | number
    potentialWinning?: FloatFieldUpdateOperationsInput | number
    pickGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    multiplier?: FloatFieldUpdateOperationsInput | number
    powerPlay?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumPositionStatusFieldUpdateOperationsInput | $Enums.PositionStatus
    settled?: BoolFieldUpdateOperationsInput | boolean
    won?: NullableBoolFieldUpdateOperationsInput | boolean | null
    payout?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BettingPayoutUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    positionId?: StringFieldUpdateOperationsInput | string
    winnings?: FloatFieldUpdateOperationsInput | number
    originalBet?: FloatFieldUpdateOperationsInput | number
    multiplier?: FloatFieldUpdateOperationsInput | number
    status?: EnumPayoutStatusFieldUpdateOperationsInput | $Enums.PayoutStatus
    payoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    market?: BettingMarketUpdateOneRequiredWithoutPayoutsNestedInput
  }

  export type BettingPayoutUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    marketId?: StringFieldUpdateOperationsInput | string
    positionId?: StringFieldUpdateOperationsInput | string
    winnings?: FloatFieldUpdateOperationsInput | number
    originalBet?: FloatFieldUpdateOperationsInput | number
    multiplier?: FloatFieldUpdateOperationsInput | number
    status?: EnumPayoutStatusFieldUpdateOperationsInput | $Enums.PayoutStatus
    payoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BettingPayoutUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    marketId?: StringFieldUpdateOperationsInput | string
    positionId?: StringFieldUpdateOperationsInput | string
    winnings?: FloatFieldUpdateOperationsInput | number
    originalBet?: FloatFieldUpdateOperationsInput | number
    multiplier?: FloatFieldUpdateOperationsInput | number
    status?: EnumPayoutStatusFieldUpdateOperationsInput | $Enums.PayoutStatus
    payoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CardAuctionUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startPrice?: FloatFieldUpdateOperationsInput | number
    reservePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currentBid?: NullableFloatFieldUpdateOperationsInput | number | null
    bidIncrement?: FloatFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    autoExtend?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAuctionStatusFieldUpdateOperationsInput | $Enums.AuctionStatus
    finalized?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    watcherCount?: IntFieldUpdateOperationsInput | number
    bidCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    card?: CardUpdateOneRequiredWithoutAuctionNestedInput
    conditions?: AuctionConditionsUpdateOneWithoutAuctionNestedInput
    winner?: UserUpdateOneWithoutWonAuctionsNestedInput
    bids?: AuctionBidUpdateManyWithoutAuctionNestedInput
    watchers?: AuctionWatcherUpdateManyWithoutAuctionNestedInput
    history?: AuctionHistoryUpdateManyWithoutAuctionNestedInput
  }

  export type CardAuctionUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startPrice?: FloatFieldUpdateOperationsInput | number
    reservePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currentBid?: NullableFloatFieldUpdateOperationsInput | number | null
    bidIncrement?: FloatFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    autoExtend?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAuctionStatusFieldUpdateOperationsInput | $Enums.AuctionStatus
    finalized?: BoolFieldUpdateOperationsInput | boolean
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    watcherCount?: IntFieldUpdateOperationsInput | number
    bidCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conditions?: AuctionConditionsUncheckedUpdateOneWithoutAuctionNestedInput
    bids?: AuctionBidUncheckedUpdateManyWithoutAuctionNestedInput
    watchers?: AuctionWatcherUncheckedUpdateManyWithoutAuctionNestedInput
    history?: AuctionHistoryUncheckedUpdateManyWithoutAuctionNestedInput
  }

  export type CardAuctionUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startPrice?: FloatFieldUpdateOperationsInput | number
    reservePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currentBid?: NullableFloatFieldUpdateOperationsInput | number | null
    bidIncrement?: FloatFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    autoExtend?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAuctionStatusFieldUpdateOperationsInput | $Enums.AuctionStatus
    finalized?: BoolFieldUpdateOperationsInput | boolean
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    watcherCount?: IntFieldUpdateOperationsInput | number
    bidCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CardAuctionUpdateWithoutWinnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startPrice?: FloatFieldUpdateOperationsInput | number
    reservePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currentBid?: NullableFloatFieldUpdateOperationsInput | number | null
    bidIncrement?: FloatFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    autoExtend?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAuctionStatusFieldUpdateOperationsInput | $Enums.AuctionStatus
    finalized?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    watcherCount?: IntFieldUpdateOperationsInput | number
    bidCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    card?: CardUpdateOneRequiredWithoutAuctionNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedAuctionsNestedInput
    conditions?: AuctionConditionsUpdateOneWithoutAuctionNestedInput
    bids?: AuctionBidUpdateManyWithoutAuctionNestedInput
    watchers?: AuctionWatcherUpdateManyWithoutAuctionNestedInput
    history?: AuctionHistoryUpdateManyWithoutAuctionNestedInput
  }

  export type CardAuctionUncheckedUpdateWithoutWinnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startPrice?: FloatFieldUpdateOperationsInput | number
    reservePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currentBid?: NullableFloatFieldUpdateOperationsInput | number | null
    bidIncrement?: FloatFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    autoExtend?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAuctionStatusFieldUpdateOperationsInput | $Enums.AuctionStatus
    finalized?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    watcherCount?: IntFieldUpdateOperationsInput | number
    bidCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conditions?: AuctionConditionsUncheckedUpdateOneWithoutAuctionNestedInput
    bids?: AuctionBidUncheckedUpdateManyWithoutAuctionNestedInput
    watchers?: AuctionWatcherUncheckedUpdateManyWithoutAuctionNestedInput
    history?: AuctionHistoryUncheckedUpdateManyWithoutAuctionNestedInput
  }

  export type CardAuctionUncheckedUpdateManyWithoutWinnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startPrice?: FloatFieldUpdateOperationsInput | number
    reservePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currentBid?: NullableFloatFieldUpdateOperationsInput | number | null
    bidIncrement?: FloatFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    autoExtend?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAuctionStatusFieldUpdateOperationsInput | $Enums.AuctionStatus
    finalized?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    watcherCount?: IntFieldUpdateOperationsInput | number
    bidCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuctionBidUpdateWithoutBidderInput = {
    id?: StringFieldUpdateOperationsInput | string
    bidAmount?: FloatFieldUpdateOperationsInput | number
    maxAutoBid?: NullableFloatFieldUpdateOperationsInput | number | null
    bidType?: EnumBidTypeFieldUpdateOperationsInput | $Enums.BidType
    status?: EnumAuctionBidStatusFieldUpdateOperationsInput | $Enums.AuctionBidStatus
    isWinning?: BoolFieldUpdateOperationsInput | boolean
    outbidNotified?: BoolFieldUpdateOperationsInput | boolean
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auction?: CardAuctionUpdateOneRequiredWithoutBidsNestedInput
  }

  export type AuctionBidUncheckedUpdateWithoutBidderInput = {
    id?: StringFieldUpdateOperationsInput | string
    auctionId?: StringFieldUpdateOperationsInput | string
    bidAmount?: FloatFieldUpdateOperationsInput | number
    maxAutoBid?: NullableFloatFieldUpdateOperationsInput | number | null
    bidType?: EnumBidTypeFieldUpdateOperationsInput | $Enums.BidType
    status?: EnumAuctionBidStatusFieldUpdateOperationsInput | $Enums.AuctionBidStatus
    isWinning?: BoolFieldUpdateOperationsInput | boolean
    outbidNotified?: BoolFieldUpdateOperationsInput | boolean
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuctionBidUncheckedUpdateManyWithoutBidderInput = {
    id?: StringFieldUpdateOperationsInput | string
    auctionId?: StringFieldUpdateOperationsInput | string
    bidAmount?: FloatFieldUpdateOperationsInput | number
    maxAutoBid?: NullableFloatFieldUpdateOperationsInput | number | null
    bidType?: EnumBidTypeFieldUpdateOperationsInput | $Enums.BidType
    status?: EnumAuctionBidStatusFieldUpdateOperationsInput | $Enums.AuctionBidStatus
    isWinning?: BoolFieldUpdateOperationsInput | boolean
    outbidNotified?: BoolFieldUpdateOperationsInput | boolean
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuctionWatcherUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bidNotifications?: BoolFieldUpdateOperationsInput | boolean
    endingNotifications?: BoolFieldUpdateOperationsInput | boolean
    priceAlerts?: BoolFieldUpdateOperationsInput | boolean
    alertThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auction?: CardAuctionUpdateOneRequiredWithoutWatchersNestedInput
  }

  export type AuctionWatcherUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    auctionId?: StringFieldUpdateOperationsInput | string
    bidNotifications?: BoolFieldUpdateOperationsInput | boolean
    endingNotifications?: BoolFieldUpdateOperationsInput | boolean
    priceAlerts?: BoolFieldUpdateOperationsInput | boolean
    alertThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuctionWatcherUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    auctionId?: StringFieldUpdateOperationsInput | string
    bidNotifications?: BoolFieldUpdateOperationsInput | boolean
    endingNotifications?: BoolFieldUpdateOperationsInput | boolean
    priceAlerts?: BoolFieldUpdateOperationsInput | boolean
    alertThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MABattleUpdateWithoutInitiatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    battleType?: EnumBattleTypeFieldUpdateOperationsInput | $Enums.BattleType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    stakes?: FloatFieldUpdateOperationsInput | number
    timeline?: DateTimeFieldUpdateOperationsInput | Date | string
    votingPeriod?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBattleStatusFieldUpdateOperationsInput | $Enums.BattleStatus
    resolved?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    participantCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    initiatorCard?: CardUpdateOneRequiredWithoutInitiatedBattlesNestedInput
    targetCard?: CardUpdateOneRequiredWithoutTargetedBattlesNestedInput
    target?: UserUpdateOneWithoutTargetedMABattlesNestedInput
    winner?: BattleOutcomeUpdateOneWithoutWinningBattleNestedInput
    proposals?: BattleProposalUpdateManyWithoutBattleNestedInput
    votes?: BattleVotingUpdateManyWithoutBattleNestedInput
    outcomes?: BattleOutcomeUpdateManyWithoutBattleNestedInput
  }

  export type MABattleUncheckedUpdateWithoutInitiatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    initiatorCardId?: StringFieldUpdateOperationsInput | string
    targetCardId?: StringFieldUpdateOperationsInput | string
    targetUserId?: NullableStringFieldUpdateOperationsInput | string | null
    battleType?: EnumBattleTypeFieldUpdateOperationsInput | $Enums.BattleType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    stakes?: FloatFieldUpdateOperationsInput | number
    timeline?: DateTimeFieldUpdateOperationsInput | Date | string
    votingPeriod?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBattleStatusFieldUpdateOperationsInput | $Enums.BattleStatus
    resolved?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    participantCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    winner?: BattleOutcomeUncheckedUpdateOneWithoutWinningBattleNestedInput
    proposals?: BattleProposalUncheckedUpdateManyWithoutBattleNestedInput
    votes?: BattleVotingUncheckedUpdateManyWithoutBattleNestedInput
    outcomes?: BattleOutcomeUncheckedUpdateManyWithoutBattleNestedInput
  }

  export type MABattleUncheckedUpdateManyWithoutInitiatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    initiatorCardId?: StringFieldUpdateOperationsInput | string
    targetCardId?: StringFieldUpdateOperationsInput | string
    targetUserId?: NullableStringFieldUpdateOperationsInput | string | null
    battleType?: EnumBattleTypeFieldUpdateOperationsInput | $Enums.BattleType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    stakes?: FloatFieldUpdateOperationsInput | number
    timeline?: DateTimeFieldUpdateOperationsInput | Date | string
    votingPeriod?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBattleStatusFieldUpdateOperationsInput | $Enums.BattleStatus
    resolved?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    participantCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MABattleUpdateWithoutTargetInput = {
    id?: StringFieldUpdateOperationsInput | string
    battleType?: EnumBattleTypeFieldUpdateOperationsInput | $Enums.BattleType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    stakes?: FloatFieldUpdateOperationsInput | number
    timeline?: DateTimeFieldUpdateOperationsInput | Date | string
    votingPeriod?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBattleStatusFieldUpdateOperationsInput | $Enums.BattleStatus
    resolved?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    participantCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    initiatorCard?: CardUpdateOneRequiredWithoutInitiatedBattlesNestedInput
    targetCard?: CardUpdateOneRequiredWithoutTargetedBattlesNestedInput
    initiator?: UserUpdateOneRequiredWithoutInitiatedMABattlesNestedInput
    winner?: BattleOutcomeUpdateOneWithoutWinningBattleNestedInput
    proposals?: BattleProposalUpdateManyWithoutBattleNestedInput
    votes?: BattleVotingUpdateManyWithoutBattleNestedInput
    outcomes?: BattleOutcomeUpdateManyWithoutBattleNestedInput
  }

  export type MABattleUncheckedUpdateWithoutTargetInput = {
    id?: StringFieldUpdateOperationsInput | string
    initiatorCardId?: StringFieldUpdateOperationsInput | string
    targetCardId?: StringFieldUpdateOperationsInput | string
    initiatorUserId?: StringFieldUpdateOperationsInput | string
    battleType?: EnumBattleTypeFieldUpdateOperationsInput | $Enums.BattleType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    stakes?: FloatFieldUpdateOperationsInput | number
    timeline?: DateTimeFieldUpdateOperationsInput | Date | string
    votingPeriod?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBattleStatusFieldUpdateOperationsInput | $Enums.BattleStatus
    resolved?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    participantCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    winner?: BattleOutcomeUncheckedUpdateOneWithoutWinningBattleNestedInput
    proposals?: BattleProposalUncheckedUpdateManyWithoutBattleNestedInput
    votes?: BattleVotingUncheckedUpdateManyWithoutBattleNestedInput
    outcomes?: BattleOutcomeUncheckedUpdateManyWithoutBattleNestedInput
  }

  export type MABattleUncheckedUpdateManyWithoutTargetInput = {
    id?: StringFieldUpdateOperationsInput | string
    initiatorCardId?: StringFieldUpdateOperationsInput | string
    targetCardId?: StringFieldUpdateOperationsInput | string
    initiatorUserId?: StringFieldUpdateOperationsInput | string
    battleType?: EnumBattleTypeFieldUpdateOperationsInput | $Enums.BattleType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    stakes?: FloatFieldUpdateOperationsInput | number
    timeline?: DateTimeFieldUpdateOperationsInput | Date | string
    votingPeriod?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBattleStatusFieldUpdateOperationsInput | $Enums.BattleStatus
    resolved?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    participantCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BattleProposalUpdateWithoutProposerInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposalType?: EnumProposalTypeFieldUpdateOperationsInput | $Enums.ProposalType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    terms?: JsonNullValueInput | InputJsonValue
    valuation?: FloatFieldUpdateOperationsInput | number
    paymentStructure?: JsonNullValueInput | InputJsonValue
    timeline?: JsonNullValueInput | InputJsonValue
    synergies?: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    contingencies?: JsonNullValueInput | InputJsonValue
    status?: EnumProposalStatusFieldUpdateOperationsInput | $Enums.ProposalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    battle?: MABattleUpdateOneRequiredWithoutProposalsNestedInput
    votes?: BattleVotingUpdateManyWithoutProposalNestedInput
  }

  export type BattleProposalUncheckedUpdateWithoutProposerInput = {
    id?: StringFieldUpdateOperationsInput | string
    battleId?: StringFieldUpdateOperationsInput | string
    proposalType?: EnumProposalTypeFieldUpdateOperationsInput | $Enums.ProposalType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    terms?: JsonNullValueInput | InputJsonValue
    valuation?: FloatFieldUpdateOperationsInput | number
    paymentStructure?: JsonNullValueInput | InputJsonValue
    timeline?: JsonNullValueInput | InputJsonValue
    synergies?: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    contingencies?: JsonNullValueInput | InputJsonValue
    status?: EnumProposalStatusFieldUpdateOperationsInput | $Enums.ProposalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: BattleVotingUncheckedUpdateManyWithoutProposalNestedInput
  }

  export type BattleProposalUncheckedUpdateManyWithoutProposerInput = {
    id?: StringFieldUpdateOperationsInput | string
    battleId?: StringFieldUpdateOperationsInput | string
    proposalType?: EnumProposalTypeFieldUpdateOperationsInput | $Enums.ProposalType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    terms?: JsonNullValueInput | InputJsonValue
    valuation?: FloatFieldUpdateOperationsInput | number
    paymentStructure?: JsonNullValueInput | InputJsonValue
    timeline?: JsonNullValueInput | InputJsonValue
    synergies?: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    contingencies?: JsonNullValueInput | InputJsonValue
    status?: EnumProposalStatusFieldUpdateOperationsInput | $Enums.ProposalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BattleVotingUpdateWithoutVoterInput = {
    id?: StringFieldUpdateOperationsInput | string
    vote?: EnumVoteDirectionFieldUpdateOperationsInput | $Enums.VoteDirection
    voteWeight?: FloatFieldUpdateOperationsInput | number
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    eceStaked?: NullableFloatFieldUpdateOperationsInput | number | null
    expertRating?: NullableFloatFieldUpdateOperationsInput | number | null
    portfolioValue?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    battle?: MABattleUpdateOneRequiredWithoutVotesNestedInput
    proposal?: BattleProposalUpdateOneWithoutVotesNestedInput
  }

  export type BattleVotingUncheckedUpdateWithoutVoterInput = {
    id?: StringFieldUpdateOperationsInput | string
    battleId?: StringFieldUpdateOperationsInput | string
    proposalId?: NullableStringFieldUpdateOperationsInput | string | null
    vote?: EnumVoteDirectionFieldUpdateOperationsInput | $Enums.VoteDirection
    voteWeight?: FloatFieldUpdateOperationsInput | number
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    eceStaked?: NullableFloatFieldUpdateOperationsInput | number | null
    expertRating?: NullableFloatFieldUpdateOperationsInput | number | null
    portfolioValue?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BattleVotingUncheckedUpdateManyWithoutVoterInput = {
    id?: StringFieldUpdateOperationsInput | string
    battleId?: StringFieldUpdateOperationsInput | string
    proposalId?: NullableStringFieldUpdateOperationsInput | string | null
    vote?: EnumVoteDirectionFieldUpdateOperationsInput | $Enums.VoteDirection
    voteWeight?: FloatFieldUpdateOperationsInput | number
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    eceStaked?: NullableFloatFieldUpdateOperationsInput | number | null
    expertRating?: NullableFloatFieldUpdateOperationsInput | number | null
    portfolioValue?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StakingPositionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    stakedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unstakedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockupEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    pool?: StakingPoolUpdateOneRequiredWithoutStakesNestedInput
    rewards?: StakingRewardUpdateManyWithoutPositionNestedInput
  }

  export type StakingPositionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    poolId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    stakedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unstakedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockupEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    rewards?: StakingRewardUncheckedUpdateManyWithoutPositionNestedInput
  }

  export type StakingPositionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    poolId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    stakedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unstakedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockupEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StakingRewardUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    rewardType?: EnumStakingRewardTypeFieldUpdateOperationsInput | $Enums.StakingRewardType
    claimedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pool?: StakingPoolUpdateOneRequiredWithoutRewardsNestedInput
    position?: StakingPositionUpdateOneRequiredWithoutRewardsNestedInput
  }

  export type StakingRewardUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    poolId?: StringFieldUpdateOperationsInput | string
    positionId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    rewardType?: EnumStakingRewardTypeFieldUpdateOperationsInput | $Enums.StakingRewardType
    claimedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StakingRewardUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    poolId?: StringFieldUpdateOperationsInput | string
    positionId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    rewardType?: EnumStakingRewardTypeFieldUpdateOperationsInput | $Enums.StakingRewardType
    claimedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GovernanceProposalUpdateWithoutProposerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    proposalType?: EnumProposalTypeFieldUpdateOperationsInput | $Enums.ProposalType
    status?: EnumGovernanceStatusFieldUpdateOperationsInput | $Enums.GovernanceStatus
    votingStartsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votingEndsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    minQuorum?: FloatFieldUpdateOperationsInput | number
    minApproval?: FloatFieldUpdateOperationsInput | number
    totalVotes?: FloatFieldUpdateOperationsInput | number
    yesVotes?: FloatFieldUpdateOperationsInput | number
    noVotes?: FloatFieldUpdateOperationsInput | number
    abstainVotes?: FloatFieldUpdateOperationsInput | number
    isExecuted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    votes?: GovernanceVoteUpdateManyWithoutProposalNestedInput
  }

  export type GovernanceProposalUncheckedUpdateWithoutProposerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    proposalType?: EnumProposalTypeFieldUpdateOperationsInput | $Enums.ProposalType
    status?: EnumGovernanceStatusFieldUpdateOperationsInput | $Enums.GovernanceStatus
    votingStartsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votingEndsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    minQuorum?: FloatFieldUpdateOperationsInput | number
    minApproval?: FloatFieldUpdateOperationsInput | number
    totalVotes?: FloatFieldUpdateOperationsInput | number
    yesVotes?: FloatFieldUpdateOperationsInput | number
    noVotes?: FloatFieldUpdateOperationsInput | number
    abstainVotes?: FloatFieldUpdateOperationsInput | number
    isExecuted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    votes?: GovernanceVoteUncheckedUpdateManyWithoutProposalNestedInput
  }

  export type GovernanceProposalUncheckedUpdateManyWithoutProposerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    proposalType?: EnumProposalTypeFieldUpdateOperationsInput | $Enums.ProposalType
    status?: EnumGovernanceStatusFieldUpdateOperationsInput | $Enums.GovernanceStatus
    votingStartsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votingEndsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    minQuorum?: FloatFieldUpdateOperationsInput | number
    minApproval?: FloatFieldUpdateOperationsInput | number
    totalVotes?: FloatFieldUpdateOperationsInput | number
    yesVotes?: FloatFieldUpdateOperationsInput | number
    noVotes?: FloatFieldUpdateOperationsInput | number
    abstainVotes?: FloatFieldUpdateOperationsInput | number
    isExecuted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
  }

  export type GovernanceVoteUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    voteChoice?: EnumVoteChoiceFieldUpdateOperationsInput | $Enums.VoteChoice
    votingPower?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    votedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proposal?: GovernanceProposalUpdateOneRequiredWithoutVotesNestedInput
  }

  export type GovernanceVoteUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposalId?: StringFieldUpdateOperationsInput | string
    voteChoice?: EnumVoteChoiceFieldUpdateOperationsInput | $Enums.VoteChoice
    votingPower?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    votedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GovernanceVoteUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposalId?: StringFieldUpdateOperationsInput | string
    voteChoice?: EnumVoteChoiceFieldUpdateOperationsInput | $Enums.VoteChoice
    votingPower?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    votedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    requiresSubscription?: NullableEnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    requiresSubscription?: NullableEnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    requiresSubscription?: NullableEnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialFeedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSocialFeedTypeFieldUpdateOperationsInput | $Enums.SocialFeedType
    content?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    likes?: IntFieldUpdateOperationsInput | number
    comments?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    visibility?: EnumSocialVisibilityFieldUpdateOperationsInput | $Enums.SocialVisibility
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialFeedUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSocialFeedTypeFieldUpdateOperationsInput | $Enums.SocialFeedType
    content?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    likes?: IntFieldUpdateOperationsInput | number
    comments?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    visibility?: EnumSocialVisibilityFieldUpdateOperationsInput | $Enums.SocialVisibility
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialFeedUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSocialFeedTypeFieldUpdateOperationsInput | $Enums.SocialFeedType
    content?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    likes?: IntFieldUpdateOperationsInput | number
    comments?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    visibility?: EnumSocialVisibilityFieldUpdateOperationsInput | $Enums.SocialVisibility
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUpdateWithoutFollowerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    following?: UserUpdateOneRequiredWithoutFollowingNestedInput
  }

  export type FollowUncheckedUpdateWithoutFollowerInput = {
    id?: StringFieldUpdateOperationsInput | string
    followingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUncheckedUpdateManyWithoutFollowerInput = {
    id?: StringFieldUpdateOperationsInput | string
    followingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUpdateWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    follower?: UserUpdateOneRequiredWithoutFollowersNestedInput
  }

  export type FollowUncheckedUpdateWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    followerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUncheckedUpdateManyWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    followerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BidCreateManyCardInput = {
    id?: string
    listingId: string
    bidderId: string
    amount: number
    status?: $Enums.BidStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateManyCardInput = {
    id?: string
    userId: string
    type: $Enums.TransactionType
    amount: number
    currency?: string
    status?: $Enums.TransactionStatus
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: string | null
    paymentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BettingMarketCreateManyCardInput = {
    id?: string
    metricType: $Enums.MarketMetricType
    title: string
    description: string
    currentValue: number
    predictionTarget: number
    targetDirection: $Enums.PredictionDirection
    odds?: number
    totalPot?: number
    minimumBet?: number
    maximumBet?: number | null
    startTime?: Date | string
    expiryDate: Date | string
    settlementDate?: Date | string | null
    status?: $Enums.MarketStatus
    settled?: boolean
    settledValue?: number | null
    winningDirection?: $Enums.PredictionDirection | null
    marketMakerFee?: number
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketMetricsCreateManyCardInput = {
    id?: string
    marketId?: string | null
    revenue?: number | null
    userGrowth?: number | null
    valuation?: number | null
    marketCap?: number | null
    quarterlyGrowth?: number | null
    userEngagement?: number | null
    productLaunches?: number | null
    competitorRank?: number | null
    sentimentScore?: number | null
    trendingScore?: number | null
    socialMentions?: number | null
    recordDate?: Date | string
    dataSource?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuctionHistoryCreateManyCardInput = {
    id?: string
    auctionId?: string | null
    salePrice: number
    sellerId: string
    buyerId: string
    saleType: $Enums.SaleType
    marketTrends?: NullableJsonNullValueInput | InputJsonValue
    priceHistory?: NullableJsonNullValueInput | InputJsonValue
    daysSinceListing?: number | null
    numberOfBids?: number | null
    highestBid?: number | null
    saleDate?: Date | string
    createdAt?: Date | string
  }

  export type MABattleCreateManyInitiatorCardInput = {
    id?: string
    targetCardId: string
    initiatorUserId: string
    targetUserId?: string | null
    battleType: $Enums.BattleType
    title: string
    description: string
    stakes: number
    timeline: Date | string
    votingPeriod: Date | string
    status?: $Enums.BattleStatus
    resolved?: boolean
    viewCount?: number
    participantCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MABattleCreateManyTargetCardInput = {
    id?: string
    initiatorCardId: string
    initiatorUserId: string
    targetUserId?: string | null
    battleType: $Enums.BattleType
    title: string
    description: string
    stakes: number
    timeline: Date | string
    votingPeriod: Date | string
    status?: $Enums.BattleStatus
    resolved?: boolean
    viewCount?: number
    participantCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BidUpdateWithoutCardInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumBidStatusFieldUpdateOperationsInput | $Enums.BidStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listing?: MarketplaceListingUpdateOneRequiredWithoutBidsNestedInput
    bidder?: UserUpdateOneRequiredWithoutBidsNestedInput
  }

  export type BidUncheckedUpdateWithoutCardInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    bidderId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumBidStatusFieldUpdateOperationsInput | $Enums.BidStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BidUncheckedUpdateManyWithoutCardInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    bidderId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumBidStatusFieldUpdateOperationsInput | $Enums.BidStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutCardInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTradingHistoryNestedInput
  }

  export type TransactionUncheckedUpdateWithoutCardInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutCardInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BettingMarketUpdateWithoutCardInput = {
    id?: StringFieldUpdateOperationsInput | string
    metricType?: EnumMarketMetricTypeFieldUpdateOperationsInput | $Enums.MarketMetricType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    currentValue?: FloatFieldUpdateOperationsInput | number
    predictionTarget?: FloatFieldUpdateOperationsInput | number
    targetDirection?: EnumPredictionDirectionFieldUpdateOperationsInput | $Enums.PredictionDirection
    odds?: FloatFieldUpdateOperationsInput | number
    totalPot?: FloatFieldUpdateOperationsInput | number
    minimumBet?: FloatFieldUpdateOperationsInput | number
    maximumBet?: NullableFloatFieldUpdateOperationsInput | number | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    settlementDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMarketStatusFieldUpdateOperationsInput | $Enums.MarketStatus
    settled?: BoolFieldUpdateOperationsInput | boolean
    settledValue?: NullableFloatFieldUpdateOperationsInput | number | null
    winningDirection?: NullableEnumPredictionDirectionFieldUpdateOperationsInput | $Enums.PredictionDirection | null
    marketMakerFee?: FloatFieldUpdateOperationsInput | number
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    positions?: BettingPositionUpdateManyWithoutMarketNestedInput
    payouts?: BettingPayoutUpdateManyWithoutMarketNestedInput
    metrics?: MarketMetricsUpdateManyWithoutMarketNestedInput
  }

  export type BettingMarketUncheckedUpdateWithoutCardInput = {
    id?: StringFieldUpdateOperationsInput | string
    metricType?: EnumMarketMetricTypeFieldUpdateOperationsInput | $Enums.MarketMetricType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    currentValue?: FloatFieldUpdateOperationsInput | number
    predictionTarget?: FloatFieldUpdateOperationsInput | number
    targetDirection?: EnumPredictionDirectionFieldUpdateOperationsInput | $Enums.PredictionDirection
    odds?: FloatFieldUpdateOperationsInput | number
    totalPot?: FloatFieldUpdateOperationsInput | number
    minimumBet?: FloatFieldUpdateOperationsInput | number
    maximumBet?: NullableFloatFieldUpdateOperationsInput | number | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    settlementDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMarketStatusFieldUpdateOperationsInput | $Enums.MarketStatus
    settled?: BoolFieldUpdateOperationsInput | boolean
    settledValue?: NullableFloatFieldUpdateOperationsInput | number | null
    winningDirection?: NullableEnumPredictionDirectionFieldUpdateOperationsInput | $Enums.PredictionDirection | null
    marketMakerFee?: FloatFieldUpdateOperationsInput | number
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    positions?: BettingPositionUncheckedUpdateManyWithoutMarketNestedInput
    payouts?: BettingPayoutUncheckedUpdateManyWithoutMarketNestedInput
    metrics?: MarketMetricsUncheckedUpdateManyWithoutMarketNestedInput
  }

  export type BettingMarketUncheckedUpdateManyWithoutCardInput = {
    id?: StringFieldUpdateOperationsInput | string
    metricType?: EnumMarketMetricTypeFieldUpdateOperationsInput | $Enums.MarketMetricType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    currentValue?: FloatFieldUpdateOperationsInput | number
    predictionTarget?: FloatFieldUpdateOperationsInput | number
    targetDirection?: EnumPredictionDirectionFieldUpdateOperationsInput | $Enums.PredictionDirection
    odds?: FloatFieldUpdateOperationsInput | number
    totalPot?: FloatFieldUpdateOperationsInput | number
    minimumBet?: FloatFieldUpdateOperationsInput | number
    maximumBet?: NullableFloatFieldUpdateOperationsInput | number | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    settlementDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMarketStatusFieldUpdateOperationsInput | $Enums.MarketStatus
    settled?: BoolFieldUpdateOperationsInput | boolean
    settledValue?: NullableFloatFieldUpdateOperationsInput | number | null
    winningDirection?: NullableEnumPredictionDirectionFieldUpdateOperationsInput | $Enums.PredictionDirection | null
    marketMakerFee?: FloatFieldUpdateOperationsInput | number
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketMetricsUpdateWithoutCardInput = {
    id?: StringFieldUpdateOperationsInput | string
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    userGrowth?: NullableFloatFieldUpdateOperationsInput | number | null
    valuation?: NullableFloatFieldUpdateOperationsInput | number | null
    marketCap?: NullableFloatFieldUpdateOperationsInput | number | null
    quarterlyGrowth?: NullableFloatFieldUpdateOperationsInput | number | null
    userEngagement?: NullableFloatFieldUpdateOperationsInput | number | null
    productLaunches?: NullableIntFieldUpdateOperationsInput | number | null
    competitorRank?: NullableIntFieldUpdateOperationsInput | number | null
    sentimentScore?: NullableFloatFieldUpdateOperationsInput | number | null
    trendingScore?: NullableFloatFieldUpdateOperationsInput | number | null
    socialMentions?: NullableIntFieldUpdateOperationsInput | number | null
    recordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dataSource?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    market?: BettingMarketUpdateOneWithoutMetricsNestedInput
  }

  export type MarketMetricsUncheckedUpdateWithoutCardInput = {
    id?: StringFieldUpdateOperationsInput | string
    marketId?: NullableStringFieldUpdateOperationsInput | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    userGrowth?: NullableFloatFieldUpdateOperationsInput | number | null
    valuation?: NullableFloatFieldUpdateOperationsInput | number | null
    marketCap?: NullableFloatFieldUpdateOperationsInput | number | null
    quarterlyGrowth?: NullableFloatFieldUpdateOperationsInput | number | null
    userEngagement?: NullableFloatFieldUpdateOperationsInput | number | null
    productLaunches?: NullableIntFieldUpdateOperationsInput | number | null
    competitorRank?: NullableIntFieldUpdateOperationsInput | number | null
    sentimentScore?: NullableFloatFieldUpdateOperationsInput | number | null
    trendingScore?: NullableFloatFieldUpdateOperationsInput | number | null
    socialMentions?: NullableIntFieldUpdateOperationsInput | number | null
    recordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dataSource?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketMetricsUncheckedUpdateManyWithoutCardInput = {
    id?: StringFieldUpdateOperationsInput | string
    marketId?: NullableStringFieldUpdateOperationsInput | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    userGrowth?: NullableFloatFieldUpdateOperationsInput | number | null
    valuation?: NullableFloatFieldUpdateOperationsInput | number | null
    marketCap?: NullableFloatFieldUpdateOperationsInput | number | null
    quarterlyGrowth?: NullableFloatFieldUpdateOperationsInput | number | null
    userEngagement?: NullableFloatFieldUpdateOperationsInput | number | null
    productLaunches?: NullableIntFieldUpdateOperationsInput | number | null
    competitorRank?: NullableIntFieldUpdateOperationsInput | number | null
    sentimentScore?: NullableFloatFieldUpdateOperationsInput | number | null
    trendingScore?: NullableFloatFieldUpdateOperationsInput | number | null
    socialMentions?: NullableIntFieldUpdateOperationsInput | number | null
    recordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dataSource?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuctionHistoryUpdateWithoutCardInput = {
    id?: StringFieldUpdateOperationsInput | string
    salePrice?: FloatFieldUpdateOperationsInput | number
    sellerId?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    saleType?: EnumSaleTypeFieldUpdateOperationsInput | $Enums.SaleType
    marketTrends?: NullableJsonNullValueInput | InputJsonValue
    priceHistory?: NullableJsonNullValueInput | InputJsonValue
    daysSinceListing?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBids?: NullableIntFieldUpdateOperationsInput | number | null
    highestBid?: NullableFloatFieldUpdateOperationsInput | number | null
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auction?: CardAuctionUpdateOneWithoutHistoryNestedInput
  }

  export type AuctionHistoryUncheckedUpdateWithoutCardInput = {
    id?: StringFieldUpdateOperationsInput | string
    auctionId?: NullableStringFieldUpdateOperationsInput | string | null
    salePrice?: FloatFieldUpdateOperationsInput | number
    sellerId?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    saleType?: EnumSaleTypeFieldUpdateOperationsInput | $Enums.SaleType
    marketTrends?: NullableJsonNullValueInput | InputJsonValue
    priceHistory?: NullableJsonNullValueInput | InputJsonValue
    daysSinceListing?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBids?: NullableIntFieldUpdateOperationsInput | number | null
    highestBid?: NullableFloatFieldUpdateOperationsInput | number | null
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuctionHistoryUncheckedUpdateManyWithoutCardInput = {
    id?: StringFieldUpdateOperationsInput | string
    auctionId?: NullableStringFieldUpdateOperationsInput | string | null
    salePrice?: FloatFieldUpdateOperationsInput | number
    sellerId?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    saleType?: EnumSaleTypeFieldUpdateOperationsInput | $Enums.SaleType
    marketTrends?: NullableJsonNullValueInput | InputJsonValue
    priceHistory?: NullableJsonNullValueInput | InputJsonValue
    daysSinceListing?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBids?: NullableIntFieldUpdateOperationsInput | number | null
    highestBid?: NullableFloatFieldUpdateOperationsInput | number | null
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MABattleUpdateWithoutInitiatorCardInput = {
    id?: StringFieldUpdateOperationsInput | string
    battleType?: EnumBattleTypeFieldUpdateOperationsInput | $Enums.BattleType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    stakes?: FloatFieldUpdateOperationsInput | number
    timeline?: DateTimeFieldUpdateOperationsInput | Date | string
    votingPeriod?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBattleStatusFieldUpdateOperationsInput | $Enums.BattleStatus
    resolved?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    participantCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetCard?: CardUpdateOneRequiredWithoutTargetedBattlesNestedInput
    initiator?: UserUpdateOneRequiredWithoutInitiatedMABattlesNestedInput
    target?: UserUpdateOneWithoutTargetedMABattlesNestedInput
    winner?: BattleOutcomeUpdateOneWithoutWinningBattleNestedInput
    proposals?: BattleProposalUpdateManyWithoutBattleNestedInput
    votes?: BattleVotingUpdateManyWithoutBattleNestedInput
    outcomes?: BattleOutcomeUpdateManyWithoutBattleNestedInput
  }

  export type MABattleUncheckedUpdateWithoutInitiatorCardInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetCardId?: StringFieldUpdateOperationsInput | string
    initiatorUserId?: StringFieldUpdateOperationsInput | string
    targetUserId?: NullableStringFieldUpdateOperationsInput | string | null
    battleType?: EnumBattleTypeFieldUpdateOperationsInput | $Enums.BattleType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    stakes?: FloatFieldUpdateOperationsInput | number
    timeline?: DateTimeFieldUpdateOperationsInput | Date | string
    votingPeriod?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBattleStatusFieldUpdateOperationsInput | $Enums.BattleStatus
    resolved?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    participantCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    winner?: BattleOutcomeUncheckedUpdateOneWithoutWinningBattleNestedInput
    proposals?: BattleProposalUncheckedUpdateManyWithoutBattleNestedInput
    votes?: BattleVotingUncheckedUpdateManyWithoutBattleNestedInput
    outcomes?: BattleOutcomeUncheckedUpdateManyWithoutBattleNestedInput
  }

  export type MABattleUncheckedUpdateManyWithoutInitiatorCardInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetCardId?: StringFieldUpdateOperationsInput | string
    initiatorUserId?: StringFieldUpdateOperationsInput | string
    targetUserId?: NullableStringFieldUpdateOperationsInput | string | null
    battleType?: EnumBattleTypeFieldUpdateOperationsInput | $Enums.BattleType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    stakes?: FloatFieldUpdateOperationsInput | number
    timeline?: DateTimeFieldUpdateOperationsInput | Date | string
    votingPeriod?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBattleStatusFieldUpdateOperationsInput | $Enums.BattleStatus
    resolved?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    participantCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MABattleUpdateWithoutTargetCardInput = {
    id?: StringFieldUpdateOperationsInput | string
    battleType?: EnumBattleTypeFieldUpdateOperationsInput | $Enums.BattleType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    stakes?: FloatFieldUpdateOperationsInput | number
    timeline?: DateTimeFieldUpdateOperationsInput | Date | string
    votingPeriod?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBattleStatusFieldUpdateOperationsInput | $Enums.BattleStatus
    resolved?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    participantCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    initiatorCard?: CardUpdateOneRequiredWithoutInitiatedBattlesNestedInput
    initiator?: UserUpdateOneRequiredWithoutInitiatedMABattlesNestedInput
    target?: UserUpdateOneWithoutTargetedMABattlesNestedInput
    winner?: BattleOutcomeUpdateOneWithoutWinningBattleNestedInput
    proposals?: BattleProposalUpdateManyWithoutBattleNestedInput
    votes?: BattleVotingUpdateManyWithoutBattleNestedInput
    outcomes?: BattleOutcomeUpdateManyWithoutBattleNestedInput
  }

  export type MABattleUncheckedUpdateWithoutTargetCardInput = {
    id?: StringFieldUpdateOperationsInput | string
    initiatorCardId?: StringFieldUpdateOperationsInput | string
    initiatorUserId?: StringFieldUpdateOperationsInput | string
    targetUserId?: NullableStringFieldUpdateOperationsInput | string | null
    battleType?: EnumBattleTypeFieldUpdateOperationsInput | $Enums.BattleType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    stakes?: FloatFieldUpdateOperationsInput | number
    timeline?: DateTimeFieldUpdateOperationsInput | Date | string
    votingPeriod?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBattleStatusFieldUpdateOperationsInput | $Enums.BattleStatus
    resolved?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    participantCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    winner?: BattleOutcomeUncheckedUpdateOneWithoutWinningBattleNestedInput
    proposals?: BattleProposalUncheckedUpdateManyWithoutBattleNestedInput
    votes?: BattleVotingUncheckedUpdateManyWithoutBattleNestedInput
    outcomes?: BattleOutcomeUncheckedUpdateManyWithoutBattleNestedInput
  }

  export type MABattleUncheckedUpdateManyWithoutTargetCardInput = {
    id?: StringFieldUpdateOperationsInput | string
    initiatorCardId?: StringFieldUpdateOperationsInput | string
    initiatorUserId?: StringFieldUpdateOperationsInput | string
    targetUserId?: NullableStringFieldUpdateOperationsInput | string | null
    battleType?: EnumBattleTypeFieldUpdateOperationsInput | $Enums.BattleType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    stakes?: FloatFieldUpdateOperationsInput | number
    timeline?: DateTimeFieldUpdateOperationsInput | Date | string
    votingPeriod?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBattleStatusFieldUpdateOperationsInput | $Enums.BattleStatus
    resolved?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    participantCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BidCreateManyListingInput = {
    id?: string
    bidderId: string
    cardId: string
    amount: number
    status?: $Enums.BidStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BidUpdateWithoutListingInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumBidStatusFieldUpdateOperationsInput | $Enums.BidStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bidder?: UserUpdateOneRequiredWithoutBidsNestedInput
    card?: CardUpdateOneRequiredWithoutBidsNestedInput
  }

  export type BidUncheckedUpdateWithoutListingInput = {
    id?: StringFieldUpdateOperationsInput | string
    bidderId?: StringFieldUpdateOperationsInput | string
    cardId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumBidStatusFieldUpdateOperationsInput | $Enums.BidStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BidUncheckedUpdateManyWithoutListingInput = {
    id?: StringFieldUpdateOperationsInput | string
    bidderId?: StringFieldUpdateOperationsInput | string
    cardId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumBidStatusFieldUpdateOperationsInput | $Enums.BidStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderRevisionCreateManyOrderInput = {
    id?: string
    userId: string
    revisionNumber: number
    title: string
    description: string
    status?: $Enums.RevisionStatus
    adminResponse?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCommunicationCreateManyOrderInput = {
    id?: string
    userId: string
    messageType: $Enums.CommunicationType
    subject?: string | null
    message: string
    isFromAdmin?: boolean
    attachments?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    important?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderDeliverableCreateManyOrderInput = {
    id?: string
    type: $Enums.DeliverableType
    title: string
    description?: string | null
    url?: string | null
    filePath?: string | null
    status?: $Enums.DeliverableStatus
    delivered?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderRevisionUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    revisionNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumRevisionStatusFieldUpdateOperationsInput | $Enums.RevisionStatus
    adminResponse?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrderRevisionsNestedInput
  }

  export type OrderRevisionUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    revisionNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumRevisionStatusFieldUpdateOperationsInput | $Enums.RevisionStatus
    adminResponse?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderRevisionUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    revisionNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumRevisionStatusFieldUpdateOperationsInput | $Enums.RevisionStatus
    adminResponse?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCommunicationUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageType?: EnumCommunicationTypeFieldUpdateOperationsInput | $Enums.CommunicationType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    isFromAdmin?: BoolFieldUpdateOperationsInput | boolean
    attachments?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    important?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrderCommunicationsNestedInput
  }

  export type OrderCommunicationUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    messageType?: EnumCommunicationTypeFieldUpdateOperationsInput | $Enums.CommunicationType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    isFromAdmin?: BoolFieldUpdateOperationsInput | boolean
    attachments?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    important?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCommunicationUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    messageType?: EnumCommunicationTypeFieldUpdateOperationsInput | $Enums.CommunicationType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    isFromAdmin?: BoolFieldUpdateOperationsInput | boolean
    attachments?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    important?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderDeliverableUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDeliverableTypeFieldUpdateOperationsInput | $Enums.DeliverableType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeliverableStatusFieldUpdateOperationsInput | $Enums.DeliverableStatus
    delivered?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderDeliverableUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDeliverableTypeFieldUpdateOperationsInput | $Enums.DeliverableType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeliverableStatusFieldUpdateOperationsInput | $Enums.DeliverableStatus
    delivered?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderDeliverableUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDeliverableTypeFieldUpdateOperationsInput | $Enums.DeliverableType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeliverableStatusFieldUpdateOperationsInput | $Enums.DeliverableStatus
    delivered?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BettingPositionCreateManyMarketInput = {
    id?: string
    userId: string
    position: $Enums.PredictionDirection
    amount: number
    odds: number
    potentialWinning: number
    pickGroupId?: string | null
    multiplier?: number
    powerPlay?: boolean
    status?: $Enums.PositionStatus
    settled?: boolean
    won?: boolean | null
    payout?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BettingPayoutCreateManyMarketInput = {
    id?: string
    userId: string
    positionId: string
    winnings: number
    originalBet: number
    multiplier: number
    status?: $Enums.PayoutStatus
    payoutDate?: Date | string | null
    transactionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketMetricsCreateManyMarketInput = {
    id?: string
    cardId: string
    revenue?: number | null
    userGrowth?: number | null
    valuation?: number | null
    marketCap?: number | null
    quarterlyGrowth?: number | null
    userEngagement?: number | null
    productLaunches?: number | null
    competitorRank?: number | null
    sentimentScore?: number | null
    trendingScore?: number | null
    socialMentions?: number | null
    recordDate?: Date | string
    dataSource?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BettingPositionUpdateWithoutMarketInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: EnumPredictionDirectionFieldUpdateOperationsInput | $Enums.PredictionDirection
    amount?: FloatFieldUpdateOperationsInput | number
    odds?: FloatFieldUpdateOperationsInput | number
    potentialWinning?: FloatFieldUpdateOperationsInput | number
    pickGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    multiplier?: FloatFieldUpdateOperationsInput | number
    powerPlay?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumPositionStatusFieldUpdateOperationsInput | $Enums.PositionStatus
    settled?: BoolFieldUpdateOperationsInput | boolean
    won?: NullableBoolFieldUpdateOperationsInput | boolean | null
    payout?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBettingPositionsNestedInput
  }

  export type BettingPositionUncheckedUpdateWithoutMarketInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    position?: EnumPredictionDirectionFieldUpdateOperationsInput | $Enums.PredictionDirection
    amount?: FloatFieldUpdateOperationsInput | number
    odds?: FloatFieldUpdateOperationsInput | number
    potentialWinning?: FloatFieldUpdateOperationsInput | number
    pickGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    multiplier?: FloatFieldUpdateOperationsInput | number
    powerPlay?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumPositionStatusFieldUpdateOperationsInput | $Enums.PositionStatus
    settled?: BoolFieldUpdateOperationsInput | boolean
    won?: NullableBoolFieldUpdateOperationsInput | boolean | null
    payout?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BettingPositionUncheckedUpdateManyWithoutMarketInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    position?: EnumPredictionDirectionFieldUpdateOperationsInput | $Enums.PredictionDirection
    amount?: FloatFieldUpdateOperationsInput | number
    odds?: FloatFieldUpdateOperationsInput | number
    potentialWinning?: FloatFieldUpdateOperationsInput | number
    pickGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    multiplier?: FloatFieldUpdateOperationsInput | number
    powerPlay?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumPositionStatusFieldUpdateOperationsInput | $Enums.PositionStatus
    settled?: BoolFieldUpdateOperationsInput | boolean
    won?: NullableBoolFieldUpdateOperationsInput | boolean | null
    payout?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BettingPayoutUpdateWithoutMarketInput = {
    id?: StringFieldUpdateOperationsInput | string
    positionId?: StringFieldUpdateOperationsInput | string
    winnings?: FloatFieldUpdateOperationsInput | number
    originalBet?: FloatFieldUpdateOperationsInput | number
    multiplier?: FloatFieldUpdateOperationsInput | number
    status?: EnumPayoutStatusFieldUpdateOperationsInput | $Enums.PayoutStatus
    payoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBettingPayoutsNestedInput
  }

  export type BettingPayoutUncheckedUpdateWithoutMarketInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    positionId?: StringFieldUpdateOperationsInput | string
    winnings?: FloatFieldUpdateOperationsInput | number
    originalBet?: FloatFieldUpdateOperationsInput | number
    multiplier?: FloatFieldUpdateOperationsInput | number
    status?: EnumPayoutStatusFieldUpdateOperationsInput | $Enums.PayoutStatus
    payoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BettingPayoutUncheckedUpdateManyWithoutMarketInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    positionId?: StringFieldUpdateOperationsInput | string
    winnings?: FloatFieldUpdateOperationsInput | number
    originalBet?: FloatFieldUpdateOperationsInput | number
    multiplier?: FloatFieldUpdateOperationsInput | number
    status?: EnumPayoutStatusFieldUpdateOperationsInput | $Enums.PayoutStatus
    payoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketMetricsUpdateWithoutMarketInput = {
    id?: StringFieldUpdateOperationsInput | string
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    userGrowth?: NullableFloatFieldUpdateOperationsInput | number | null
    valuation?: NullableFloatFieldUpdateOperationsInput | number | null
    marketCap?: NullableFloatFieldUpdateOperationsInput | number | null
    quarterlyGrowth?: NullableFloatFieldUpdateOperationsInput | number | null
    userEngagement?: NullableFloatFieldUpdateOperationsInput | number | null
    productLaunches?: NullableIntFieldUpdateOperationsInput | number | null
    competitorRank?: NullableIntFieldUpdateOperationsInput | number | null
    sentimentScore?: NullableFloatFieldUpdateOperationsInput | number | null
    trendingScore?: NullableFloatFieldUpdateOperationsInput | number | null
    socialMentions?: NullableIntFieldUpdateOperationsInput | number | null
    recordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dataSource?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    card?: CardUpdateOneRequiredWithoutMarketMetricsNestedInput
  }

  export type MarketMetricsUncheckedUpdateWithoutMarketInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardId?: StringFieldUpdateOperationsInput | string
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    userGrowth?: NullableFloatFieldUpdateOperationsInput | number | null
    valuation?: NullableFloatFieldUpdateOperationsInput | number | null
    marketCap?: NullableFloatFieldUpdateOperationsInput | number | null
    quarterlyGrowth?: NullableFloatFieldUpdateOperationsInput | number | null
    userEngagement?: NullableFloatFieldUpdateOperationsInput | number | null
    productLaunches?: NullableIntFieldUpdateOperationsInput | number | null
    competitorRank?: NullableIntFieldUpdateOperationsInput | number | null
    sentimentScore?: NullableFloatFieldUpdateOperationsInput | number | null
    trendingScore?: NullableFloatFieldUpdateOperationsInput | number | null
    socialMentions?: NullableIntFieldUpdateOperationsInput | number | null
    recordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dataSource?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketMetricsUncheckedUpdateManyWithoutMarketInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardId?: StringFieldUpdateOperationsInput | string
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    userGrowth?: NullableFloatFieldUpdateOperationsInput | number | null
    valuation?: NullableFloatFieldUpdateOperationsInput | number | null
    marketCap?: NullableFloatFieldUpdateOperationsInput | number | null
    quarterlyGrowth?: NullableFloatFieldUpdateOperationsInput | number | null
    userEngagement?: NullableFloatFieldUpdateOperationsInput | number | null
    productLaunches?: NullableIntFieldUpdateOperationsInput | number | null
    competitorRank?: NullableIntFieldUpdateOperationsInput | number | null
    sentimentScore?: NullableFloatFieldUpdateOperationsInput | number | null
    trendingScore?: NullableFloatFieldUpdateOperationsInput | number | null
    socialMentions?: NullableIntFieldUpdateOperationsInput | number | null
    recordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dataSource?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuctionBidCreateManyAuctionInput = {
    id?: string
    bidderId: string
    bidAmount: number
    maxAutoBid?: number | null
    bidType?: $Enums.BidType
    status?: $Enums.AuctionBidStatus
    isWinning?: boolean
    outbidNotified?: boolean
    userAgent?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuctionWatcherCreateManyAuctionInput = {
    id?: string
    userId: string
    bidNotifications?: boolean
    endingNotifications?: boolean
    priceAlerts?: boolean
    alertThreshold?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuctionHistoryCreateManyAuctionInput = {
    id?: string
    cardId: string
    salePrice: number
    sellerId: string
    buyerId: string
    saleType: $Enums.SaleType
    marketTrends?: NullableJsonNullValueInput | InputJsonValue
    priceHistory?: NullableJsonNullValueInput | InputJsonValue
    daysSinceListing?: number | null
    numberOfBids?: number | null
    highestBid?: number | null
    saleDate?: Date | string
    createdAt?: Date | string
  }

  export type AuctionBidUpdateWithoutAuctionInput = {
    id?: StringFieldUpdateOperationsInput | string
    bidAmount?: FloatFieldUpdateOperationsInput | number
    maxAutoBid?: NullableFloatFieldUpdateOperationsInput | number | null
    bidType?: EnumBidTypeFieldUpdateOperationsInput | $Enums.BidType
    status?: EnumAuctionBidStatusFieldUpdateOperationsInput | $Enums.AuctionBidStatus
    isWinning?: BoolFieldUpdateOperationsInput | boolean
    outbidNotified?: BoolFieldUpdateOperationsInput | boolean
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bidder?: UserUpdateOneRequiredWithoutPlacedAuctionBidsNestedInput
  }

  export type AuctionBidUncheckedUpdateWithoutAuctionInput = {
    id?: StringFieldUpdateOperationsInput | string
    bidderId?: StringFieldUpdateOperationsInput | string
    bidAmount?: FloatFieldUpdateOperationsInput | number
    maxAutoBid?: NullableFloatFieldUpdateOperationsInput | number | null
    bidType?: EnumBidTypeFieldUpdateOperationsInput | $Enums.BidType
    status?: EnumAuctionBidStatusFieldUpdateOperationsInput | $Enums.AuctionBidStatus
    isWinning?: BoolFieldUpdateOperationsInput | boolean
    outbidNotified?: BoolFieldUpdateOperationsInput | boolean
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuctionBidUncheckedUpdateManyWithoutAuctionInput = {
    id?: StringFieldUpdateOperationsInput | string
    bidderId?: StringFieldUpdateOperationsInput | string
    bidAmount?: FloatFieldUpdateOperationsInput | number
    maxAutoBid?: NullableFloatFieldUpdateOperationsInput | number | null
    bidType?: EnumBidTypeFieldUpdateOperationsInput | $Enums.BidType
    status?: EnumAuctionBidStatusFieldUpdateOperationsInput | $Enums.AuctionBidStatus
    isWinning?: BoolFieldUpdateOperationsInput | boolean
    outbidNotified?: BoolFieldUpdateOperationsInput | boolean
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuctionWatcherUpdateWithoutAuctionInput = {
    id?: StringFieldUpdateOperationsInput | string
    bidNotifications?: BoolFieldUpdateOperationsInput | boolean
    endingNotifications?: BoolFieldUpdateOperationsInput | boolean
    priceAlerts?: BoolFieldUpdateOperationsInput | boolean
    alertThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWatchedAuctionsNestedInput
  }

  export type AuctionWatcherUncheckedUpdateWithoutAuctionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bidNotifications?: BoolFieldUpdateOperationsInput | boolean
    endingNotifications?: BoolFieldUpdateOperationsInput | boolean
    priceAlerts?: BoolFieldUpdateOperationsInput | boolean
    alertThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuctionWatcherUncheckedUpdateManyWithoutAuctionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bidNotifications?: BoolFieldUpdateOperationsInput | boolean
    endingNotifications?: BoolFieldUpdateOperationsInput | boolean
    priceAlerts?: BoolFieldUpdateOperationsInput | boolean
    alertThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuctionHistoryUpdateWithoutAuctionInput = {
    id?: StringFieldUpdateOperationsInput | string
    salePrice?: FloatFieldUpdateOperationsInput | number
    sellerId?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    saleType?: EnumSaleTypeFieldUpdateOperationsInput | $Enums.SaleType
    marketTrends?: NullableJsonNullValueInput | InputJsonValue
    priceHistory?: NullableJsonNullValueInput | InputJsonValue
    daysSinceListing?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBids?: NullableIntFieldUpdateOperationsInput | number | null
    highestBid?: NullableFloatFieldUpdateOperationsInput | number | null
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    card?: CardUpdateOneRequiredWithoutAuctionHistoryNestedInput
  }

  export type AuctionHistoryUncheckedUpdateWithoutAuctionInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardId?: StringFieldUpdateOperationsInput | string
    salePrice?: FloatFieldUpdateOperationsInput | number
    sellerId?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    saleType?: EnumSaleTypeFieldUpdateOperationsInput | $Enums.SaleType
    marketTrends?: NullableJsonNullValueInput | InputJsonValue
    priceHistory?: NullableJsonNullValueInput | InputJsonValue
    daysSinceListing?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBids?: NullableIntFieldUpdateOperationsInput | number | null
    highestBid?: NullableFloatFieldUpdateOperationsInput | number | null
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuctionHistoryUncheckedUpdateManyWithoutAuctionInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardId?: StringFieldUpdateOperationsInput | string
    salePrice?: FloatFieldUpdateOperationsInput | number
    sellerId?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    saleType?: EnumSaleTypeFieldUpdateOperationsInput | $Enums.SaleType
    marketTrends?: NullableJsonNullValueInput | InputJsonValue
    priceHistory?: NullableJsonNullValueInput | InputJsonValue
    daysSinceListing?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBids?: NullableIntFieldUpdateOperationsInput | number | null
    highestBid?: NullableFloatFieldUpdateOperationsInput | number | null
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BattleProposalCreateManyBattleInput = {
    id?: string
    proposerId: string
    proposalType: $Enums.ProposalType
    title: string
    description: string
    terms: JsonNullValueInput | InputJsonValue
    valuation: number
    paymentStructure: JsonNullValueInput | InputJsonValue
    timeline: JsonNullValueInput | InputJsonValue
    synergies: JsonNullValueInput | InputJsonValue
    conditions: JsonNullValueInput | InputJsonValue
    contingencies: JsonNullValueInput | InputJsonValue
    status?: $Enums.ProposalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BattleVotingCreateManyBattleInput = {
    id?: string
    proposalId?: string | null
    voterId: string
    vote: $Enums.VoteDirection
    voteWeight: number
    reasoning?: string | null
    confidence?: number | null
    eceStaked?: number | null
    expertRating?: number | null
    portfolioValue?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BattleOutcomeCreateManyBattleInput = {
    id?: string
    winningBattleId?: string | null
    winner: $Enums.BattleWinner
    winningProposalId?: string | null
    finalTerms: JsonNullValueInput | InputJsonValue
    finalValuation: number
    implementation: JsonNullValueInput | InputJsonValue
    stakeholdersPayouts: JsonNullValueInput | InputJsonValue
    tokenRewards: JsonNullValueInput | InputJsonValue
    completionDate?: Date | string | null
    realWorldImpact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BattleProposalUpdateWithoutBattleInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposalType?: EnumProposalTypeFieldUpdateOperationsInput | $Enums.ProposalType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    terms?: JsonNullValueInput | InputJsonValue
    valuation?: FloatFieldUpdateOperationsInput | number
    paymentStructure?: JsonNullValueInput | InputJsonValue
    timeline?: JsonNullValueInput | InputJsonValue
    synergies?: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    contingencies?: JsonNullValueInput | InputJsonValue
    status?: EnumProposalStatusFieldUpdateOperationsInput | $Enums.ProposalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proposer?: UserUpdateOneRequiredWithoutBattleProposalsNestedInput
    votes?: BattleVotingUpdateManyWithoutProposalNestedInput
  }

  export type BattleProposalUncheckedUpdateWithoutBattleInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposerId?: StringFieldUpdateOperationsInput | string
    proposalType?: EnumProposalTypeFieldUpdateOperationsInput | $Enums.ProposalType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    terms?: JsonNullValueInput | InputJsonValue
    valuation?: FloatFieldUpdateOperationsInput | number
    paymentStructure?: JsonNullValueInput | InputJsonValue
    timeline?: JsonNullValueInput | InputJsonValue
    synergies?: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    contingencies?: JsonNullValueInput | InputJsonValue
    status?: EnumProposalStatusFieldUpdateOperationsInput | $Enums.ProposalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: BattleVotingUncheckedUpdateManyWithoutProposalNestedInput
  }

  export type BattleProposalUncheckedUpdateManyWithoutBattleInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposerId?: StringFieldUpdateOperationsInput | string
    proposalType?: EnumProposalTypeFieldUpdateOperationsInput | $Enums.ProposalType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    terms?: JsonNullValueInput | InputJsonValue
    valuation?: FloatFieldUpdateOperationsInput | number
    paymentStructure?: JsonNullValueInput | InputJsonValue
    timeline?: JsonNullValueInput | InputJsonValue
    synergies?: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    contingencies?: JsonNullValueInput | InputJsonValue
    status?: EnumProposalStatusFieldUpdateOperationsInput | $Enums.ProposalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BattleVotingUpdateWithoutBattleInput = {
    id?: StringFieldUpdateOperationsInput | string
    vote?: EnumVoteDirectionFieldUpdateOperationsInput | $Enums.VoteDirection
    voteWeight?: FloatFieldUpdateOperationsInput | number
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    eceStaked?: NullableFloatFieldUpdateOperationsInput | number | null
    expertRating?: NullableFloatFieldUpdateOperationsInput | number | null
    portfolioValue?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proposal?: BattleProposalUpdateOneWithoutVotesNestedInput
    voter?: UserUpdateOneRequiredWithoutBattleVotesNestedInput
  }

  export type BattleVotingUncheckedUpdateWithoutBattleInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposalId?: NullableStringFieldUpdateOperationsInput | string | null
    voterId?: StringFieldUpdateOperationsInput | string
    vote?: EnumVoteDirectionFieldUpdateOperationsInput | $Enums.VoteDirection
    voteWeight?: FloatFieldUpdateOperationsInput | number
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    eceStaked?: NullableFloatFieldUpdateOperationsInput | number | null
    expertRating?: NullableFloatFieldUpdateOperationsInput | number | null
    portfolioValue?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BattleVotingUncheckedUpdateManyWithoutBattleInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposalId?: NullableStringFieldUpdateOperationsInput | string | null
    voterId?: StringFieldUpdateOperationsInput | string
    vote?: EnumVoteDirectionFieldUpdateOperationsInput | $Enums.VoteDirection
    voteWeight?: FloatFieldUpdateOperationsInput | number
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    eceStaked?: NullableFloatFieldUpdateOperationsInput | number | null
    expertRating?: NullableFloatFieldUpdateOperationsInput | number | null
    portfolioValue?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BattleOutcomeUpdateWithoutBattleInput = {
    id?: StringFieldUpdateOperationsInput | string
    winner?: EnumBattleWinnerFieldUpdateOperationsInput | $Enums.BattleWinner
    winningProposalId?: NullableStringFieldUpdateOperationsInput | string | null
    finalTerms?: JsonNullValueInput | InputJsonValue
    finalValuation?: FloatFieldUpdateOperationsInput | number
    implementation?: JsonNullValueInput | InputJsonValue
    stakeholdersPayouts?: JsonNullValueInput | InputJsonValue
    tokenRewards?: JsonNullValueInput | InputJsonValue
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    realWorldImpact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    winningBattle?: MABattleUpdateOneWithoutWinnerNestedInput
  }

  export type BattleOutcomeUncheckedUpdateWithoutBattleInput = {
    id?: StringFieldUpdateOperationsInput | string
    winningBattleId?: NullableStringFieldUpdateOperationsInput | string | null
    winner?: EnumBattleWinnerFieldUpdateOperationsInput | $Enums.BattleWinner
    winningProposalId?: NullableStringFieldUpdateOperationsInput | string | null
    finalTerms?: JsonNullValueInput | InputJsonValue
    finalValuation?: FloatFieldUpdateOperationsInput | number
    implementation?: JsonNullValueInput | InputJsonValue
    stakeholdersPayouts?: JsonNullValueInput | InputJsonValue
    tokenRewards?: JsonNullValueInput | InputJsonValue
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    realWorldImpact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BattleOutcomeUncheckedUpdateManyWithoutBattleInput = {
    id?: StringFieldUpdateOperationsInput | string
    winningBattleId?: NullableStringFieldUpdateOperationsInput | string | null
    winner?: EnumBattleWinnerFieldUpdateOperationsInput | $Enums.BattleWinner
    winningProposalId?: NullableStringFieldUpdateOperationsInput | string | null
    finalTerms?: JsonNullValueInput | InputJsonValue
    finalValuation?: FloatFieldUpdateOperationsInput | number
    implementation?: JsonNullValueInput | InputJsonValue
    stakeholdersPayouts?: JsonNullValueInput | InputJsonValue
    tokenRewards?: JsonNullValueInput | InputJsonValue
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    realWorldImpact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BattleVotingCreateManyProposalInput = {
    id?: string
    battleId: string
    voterId: string
    vote: $Enums.VoteDirection
    voteWeight: number
    reasoning?: string | null
    confidence?: number | null
    eceStaked?: number | null
    expertRating?: number | null
    portfolioValue?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BattleVotingUpdateWithoutProposalInput = {
    id?: StringFieldUpdateOperationsInput | string
    vote?: EnumVoteDirectionFieldUpdateOperationsInput | $Enums.VoteDirection
    voteWeight?: FloatFieldUpdateOperationsInput | number
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    eceStaked?: NullableFloatFieldUpdateOperationsInput | number | null
    expertRating?: NullableFloatFieldUpdateOperationsInput | number | null
    portfolioValue?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    battle?: MABattleUpdateOneRequiredWithoutVotesNestedInput
    voter?: UserUpdateOneRequiredWithoutBattleVotesNestedInput
  }

  export type BattleVotingUncheckedUpdateWithoutProposalInput = {
    id?: StringFieldUpdateOperationsInput | string
    battleId?: StringFieldUpdateOperationsInput | string
    voterId?: StringFieldUpdateOperationsInput | string
    vote?: EnumVoteDirectionFieldUpdateOperationsInput | $Enums.VoteDirection
    voteWeight?: FloatFieldUpdateOperationsInput | number
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    eceStaked?: NullableFloatFieldUpdateOperationsInput | number | null
    expertRating?: NullableFloatFieldUpdateOperationsInput | number | null
    portfolioValue?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BattleVotingUncheckedUpdateManyWithoutProposalInput = {
    id?: StringFieldUpdateOperationsInput | string
    battleId?: StringFieldUpdateOperationsInput | string
    voterId?: StringFieldUpdateOperationsInput | string
    vote?: EnumVoteDirectionFieldUpdateOperationsInput | $Enums.VoteDirection
    voteWeight?: FloatFieldUpdateOperationsInput | number
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    eceStaked?: NullableFloatFieldUpdateOperationsInput | number | null
    expertRating?: NullableFloatFieldUpdateOperationsInput | number | null
    portfolioValue?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StakingPositionCreateManyPoolInput = {
    id?: string
    userId: string
    amount: number
    stakedAt?: Date | string
    unstakedAt?: Date | string | null
    lockupEndsAt?: Date | string | null
    isActive?: boolean
  }

  export type StakingRewardCreateManyPoolInput = {
    id?: string
    userId: string
    positionId: string
    amount: number
    rewardType: $Enums.StakingRewardType
    claimedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type StakingPositionUpdateWithoutPoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    stakedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unstakedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockupEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutStakingPositionsNestedInput
    rewards?: StakingRewardUpdateManyWithoutPositionNestedInput
  }

  export type StakingPositionUncheckedUpdateWithoutPoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    stakedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unstakedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockupEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    rewards?: StakingRewardUncheckedUpdateManyWithoutPositionNestedInput
  }

  export type StakingPositionUncheckedUpdateManyWithoutPoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    stakedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unstakedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockupEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StakingRewardUpdateWithoutPoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    rewardType?: EnumStakingRewardTypeFieldUpdateOperationsInput | $Enums.StakingRewardType
    claimedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStakingRewardsNestedInput
    position?: StakingPositionUpdateOneRequiredWithoutRewardsNestedInput
  }

  export type StakingRewardUncheckedUpdateWithoutPoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    positionId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    rewardType?: EnumStakingRewardTypeFieldUpdateOperationsInput | $Enums.StakingRewardType
    claimedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StakingRewardUncheckedUpdateManyWithoutPoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    positionId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    rewardType?: EnumStakingRewardTypeFieldUpdateOperationsInput | $Enums.StakingRewardType
    claimedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StakingRewardCreateManyPositionInput = {
    id?: string
    userId: string
    poolId: string
    amount: number
    rewardType: $Enums.StakingRewardType
    claimedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type StakingRewardUpdateWithoutPositionInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    rewardType?: EnumStakingRewardTypeFieldUpdateOperationsInput | $Enums.StakingRewardType
    claimedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStakingRewardsNestedInput
    pool?: StakingPoolUpdateOneRequiredWithoutRewardsNestedInput
  }

  export type StakingRewardUncheckedUpdateWithoutPositionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    poolId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    rewardType?: EnumStakingRewardTypeFieldUpdateOperationsInput | $Enums.StakingRewardType
    claimedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StakingRewardUncheckedUpdateManyWithoutPositionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    poolId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    rewardType?: EnumStakingRewardTypeFieldUpdateOperationsInput | $Enums.StakingRewardType
    claimedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GovernanceVoteCreateManyProposalInput = {
    id?: string
    userId: string
    voteChoice: $Enums.VoteChoice
    votingPower: number
    reason?: string | null
    votedAt?: Date | string
  }

  export type GovernanceVoteUpdateWithoutProposalInput = {
    id?: StringFieldUpdateOperationsInput | string
    voteChoice?: EnumVoteChoiceFieldUpdateOperationsInput | $Enums.VoteChoice
    votingPower?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    votedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutGovernanceVotesNestedInput
  }

  export type GovernanceVoteUncheckedUpdateWithoutProposalInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    voteChoice?: EnumVoteChoiceFieldUpdateOperationsInput | $Enums.VoteChoice
    votingPower?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    votedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GovernanceVoteUncheckedUpdateManyWithoutProposalInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    voteChoice?: EnumVoteChoiceFieldUpdateOperationsInput | $Enums.VoteChoice
    votingPower?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    votedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}